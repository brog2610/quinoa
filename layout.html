<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Quinoa: Particle data layout</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Quinoa
   
   </div>
   <div id="projectbrief">Adaptive computational fluid dynamics</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Documents</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('layout.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Particle data layout </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="layout_req"></a>
Data layout requirements and design</h2>
<p>How should the particle properties should be stored in memory? This is the single largest chunk of data in a particle-based code. The layout determines how the data is accessed and potentially has a first-degree effect on overall efficiency.</p>
<h2><a class="anchor" id="layout_possibilities"></a>
Possibilities</h2>
<p>1. __Particle-major__, in which various physical properties, e.g., position, velocity, energy, etc., of a single particle are close to each other in memory. For example: [ x1, y1, z1, ..., x2, y2, z2, ..., x3, y3, z3, ... ] where the x* are governed by one equation (e.g., position), the y* are governed by another equation (e.g., velocity), and the z* are governed by a third equation (e.g., energy), etc. Here the first letter denotes a physical quantity, while the second is the particle number. If the algorithm that advances the properties in time applies one equation at a time, the equations will access data by having to jump a distance that corresponds to the number of scalar physical variables per particle. In the example, the update will have to jump as x1, x2, x3, ... are updated.</p>
<p>2. __Property-major__, in which the same type of physical properties are close to each other in memory. For example, [ x1, x2, x3, ..., y1, y2, y3, ..., z1, z2, z3, ... ]. The legend here is the same as in particle-major: the first letter denotes a physical quantity, while the second is the particle number. If the algorithm that advances the properties in time applies one equation at a time, the equations will access data contiguously in memory as the properties are contiguously stored.</p>
<h2><a class="anchor" id="layout_discussion"></a>
Discussion</h2>
<p>A property-major storage, case 2 above, seems to be the most efficient at first sight, as it stores data, as it is read and written by the equation algorithms, contiguously. However, data access is contiguous only if the particle properties are independent, i.e., if there is no coupling among the equations. Unfortunately, this is rarely the case, at least not for fluid dynamics. For example, position is used by the velocity update, and velocity is required by the energy update. Depending on the physical approximation, density (or mass) may be required for all equations. The stronger the equations are coupled the more very-far-reads are required for a given update. These far-reads are potentially almost always cache misses, as the property-major storage stores the physical variables for the same particle very far in memory, e.g., the distance between x1 and y1 is the number of particles. While the particle-major storage, case 1 above, inherently stores data non-contiguously, the distance between properties of a single particle is relatively small, i.e., the number of properties, which may incure less cache misses as several particles with all of their properties could fit into cache.</p>
<p>Assuming strong coupling among the variables, the particle-major storage will be favored, but it would be nice if the design allowed for both layouts, so depending on the type of equations the most appropriate layout could be selected. If such a design is maintanable, there is still a question wether the data layout selection should be done at compile-, or run-time.</p>
<h2><a class="anchor" id="layout_blaze"></a>
Assessment of the Blaze library that offers a similar choice</h2>
<p>Have looked at <a href="https://code.google.com/p/blaze-lib">https://code.google.com/p/blaze-lib</a> which implements row-, and column-major matrix classes based on a template argument. See, e.g., blaze-1.5/blaze/math/dense/StaticMatrix.h, which reveals that the template argument (bool) SO selects between row-, or column-major internal storage. Then SO is used at both compile-time (e.g., by the class-user, when instantiating the type of the matrix), as well as run-time (e.g., the implementation of isDefault()). Both compile-time and run-time usage of the SO template arguments are problematic:</p>
<ul>
<li>The compile-time usage duplicates a lot of code by having to provide similar implementations for the element-access operator() of StaticMatrix specialized to column-major. There is a generic implementation for SO for everthing that is agnostic of SO, and there is a specialization when SO is column-major.</li>
</ul>
<ul>
<li>The run-time usage also duplicates code by doing an if-test on SO in, e.g., isDefault(). Is there a better way of doing this? If there are only two types of data layout (particle-, and property-major), code duplication should not be too much of an issue. However, the implementation of particle-property data access must be absolutely zero run-time cost. This means the selection must be at compile-time and the element access must be absolutely invisible to the derived equation classes. In other words, there must be no re-implementation of a time-integrator for an equation just because the data access is different.</li>
</ul>
<h2><a class="anchor" id="layout_requirements"></a>
Requirements</h2>
<p>Is it possible to implement a compile-time configurable data-access policy via a thin data-access interface with zero run-time cost, no code-duplication, and in a way that is invisible to derived equation classes? <em>Yes</em>.</p>
<p>Zero-cost is achieved via type-based compile-time polymorphism. This is controlled via the cmake variable LAYOUT.</p>
<p>The particle data is a logically 3-dimensional array that stores the particle properties. In principle there are a total of 6 permutations:</p>
<p>1. ParEqComp: [ particle ] [ equation ] [ component ] 2. ParCompEq: [ particle ] [ component ] [ equation ] 3. EqCompPar: [ equation ] [ component ] [ particle ] 4. EqParComp: [ equation ] [ particle ] [ component ] 5. CompEqPar: [ component ] [ equation ] [ particle ] 6. CompParEq: [ component ] [ particle ] [ equation ]</p>
<p>Of these 6 we only consider those where component follows equation. (For those layouts where equation follows component the access would be unnecessarily complicated by the potentially unequal number of components for different equations which is not known at compile-time and thus does not allow some optimizations.) This decision leaves us with the following choices:</p>
<p>1. ParEqComp: [ particle ] [ equation ] [ component ] 3. EqCompPar: [ equation ] [ component ] [ particle ] 4. EqParComp: [ equation ] [ particle ] [ component ]</p>
<p>Access is based on the 3 coordinates: particle, component, and offset. Particle is the particle ID, component denotes the given component of a vector equation, e.g., velocity has 3 components, a multi-material turbulent mix model governed by the Dirichlet SDE has K=N-1 scalars (components), and offset is determined by the relative position of the given equation compared to the other equations. Using these 3 coordinates the index calculations for the above 3 cases are:</p>
<p>1. ParEqComp: [ particle ] [ equation ] [ component ]</p>
<p>baseptr + particle*nprop + offset + component,</p>
<p>where nprop is the total number of particle properties, e.g., 3 positions, 3 velocities, 5 scalars -&gt; nprop = 11.</p>
<p>3. EqCompPar: [ equation ] [ component ] [ particle ]</p>
<p>baseptr + (offset+component)*npar + particle,</p>
<p>where npar is the total number of particles.</p>
<p>4. EqParComp: [ equation ] [ particle ] [ component ]</p>
<p>baseptr + offset*npar + nce*particle + component,</p>
<p>where nce is the number of components for the given equation. Since this would require another function argument (besides particle, component, and offset), and it costs an integer-multiply more than the other two layouts, we dismiss this layout, and only implement the following two:</p>
<p>1. ParEqComp - Particle-major 3. EqCompPar - Equation-major</p>
<p>These options are exposed via the cmake variable LAYOUT and can be switched before a build by setting LAYOUT to either 'LAYOUT_PARTICLE_MAJOR' or 'LAYOUT_EQUATION_MAJOR'.</p>
<p>Data layout assembly -------------------- This section documents the assembly, produced by the compilers, of the implementation of the compile-time configurable particle-data-access policy discussed above. The implementation is via a thin data-access interface with zero run-time cost, no code-duplication, and in a way that is invisible to derived equation classes.</p>
<h2><a class="anchor" id="layout_zerocost"></a>
Zero-runtime-cost data-layout wrappers with type-based compile-time dispatch</h2>
<p>Tags for selecting particle-, or property-major data layout policies:</p>
<p>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.C} const bool ParticleMajor = true; const bool PropertyMajor = false; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</p>
<p>Implementation of data-layout wrappers:</p>
<p>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.C} template&lt; bool Major &gt; class Data {</p>
<p>private: Transform a compile-time bool into a type template&lt; bool m &gt; struct int2type { enum { value = m }; };</p>
<p>Overloads for particle-, and property-major accesses inline tk::real&amp; access( int particle, int property, int2type&lt;ParticleMajor&gt; ) { return *(m_ptr + particle*m_nprop + m_offset + property); } inline tk::real&amp; access( int particle, int property, int2type&lt;PropertyMajor&gt; ) { This is the same for now, not callsed, irrelevant in zero-cost-test return *(m_ptr + particle*m_nprop + m_offset + property); }</p>
<p>tk::real* const m_ptr; const int m_nprop; const int m_offset;</p>
<p>public: Constructor Data( tk::real* const ptr, int nprop, int offset ) : m_ptr(ptr), m_nprop(nprop), m_offset(offset) {}</p>
<p>Access dispatch inline tk::real&amp; operator()( int particle, int property ) { return access( particle, property, int2type&lt;Major&gt;() ); } }; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</p>
<h2><a class="anchor" id="layout_test"></a>
Test of zero-cost</h2>
<p>Add to Dirichlet constructor:</p>
<p>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.C} ParticleProperties&lt; Layout &gt; d( particles, m_nprop, m_offset ); Model::aa = d( 34, 3 ); Model::bb = *(m_particles + 34*m_nprop + m_offset + 3); ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</p>
<p>Add to Model:</p>
<p>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.C} Model { ... public: tk::real aa; tk::real bb; ... } ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</p>
<p>Add to Physics constructor after m_mix is instantiated:</p>
<p>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.C} std::cout &lt;&lt; m_mix-&gt;aa &lt;&lt; m_mix-&gt;bb; ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</p>
<p>All the above so the optimizing compiler cannot entirely optimize the assignments of <em>aa</em> and <em>bb</em> away.</p>
<h2><a class="anchor" id="layout_debugasm"></a>
Debug assembly</h2>
<p>Generated DEBUG assembly code of the assignments of <em>aa</em> (line 42) and <em>bb</em> (line 43) in Dirichlet's constructor, with clang -g -S -mllvm --x86-asm-syntax=intel, gnu and intel generate very similar code:</p>
<p>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ... .loc 143 42 20 # /home/jbakosi/code/quinoa/src/SDE/Dirichlet.h:42:20 .Ltmp27038: lea RDI, QWORD PTR [RBP - 56] mov ESI, 34 mov EDX, 3 call _ZN6quinoa4DataILb1EEclEii .Ltmp27039: mov QWORD PTR [RBP - 176], RAX # 8-byte Spill jmp .LBB2550_7 .LBB2550_7: mov RAX, QWORD PTR [RBP - 176] # 8-byte Reload movsd XMM0, QWORD PTR [RAX] mov RCX, QWORD PTR [RBP - 64] # 8-byte Reload movsd QWORD PTR [RCX + 8], XMM0 .loc 143 43 0 # /home/jbakosi/code/quinoa/src/SDE/Dirichlet.h:43:0 mov RDX, QWORD PTR [RCX + 32] imul ESI, DWORD PTR [RCX + 48], 34 movsxd RDI, ESI shl RDI, 3 add RDX, RDI movsxd RDI, DWORD PTR [RCX + 52] movsd XMM0, QWORD PTR [RDX + 8*RDI + 24] movsd QWORD PTR [RCX + 16], XMM0 ... ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</p>
<p>Line 42 translates to register loads and a function call into <a class="el" href="classtk_1_1_particle_properties.html">tk::ParticleProperties</a>, while line 43 translates to some integer arithmetic of the address and loads.</p>
<h2><a class="anchor" id="layout_excerpt1"></a>
Excerpt from the Intel® 64 and IA-32 Architectures Software Developer Manual</h2>
<p>&gt; The LEA (load effective address) instruction computes the effective address in &gt; memory (offset within a segment) of a source operand and places it in a &gt; general-purpose register. This instruction can interpret any of the &gt; processor’s addressing modes and can perform any indexing or scaling that may &gt; be needed. It is especially useful for initializing the ESI or EDI registers &gt; before the execution of string instructions or for initializing the EBX &gt; register before an XLAT instruction. &gt; &gt; The MOVSXD instruction operates on 64-bit data. It sign-extends a 32-bit value &gt; to 64 bits. This instruction is not encodable in non-64-bit modes. &gt; &gt; A common type of operation on packed integers is the conversion by zero- or &gt; sign-extension of packed integers into wider data types. SSE4.1 adds 12 &gt; instructions that convert from a smaller packed integer type to a larger &gt; integer type (PMOVSXBW, PMOVZXBW, PMOVSXBD, PMOVZXBD, PMOVSXWD, PMOVZXWD, &gt; PMOVSXBQ, PMOVZXBQ, PMOVSXWQ, PMOVZXWQ, PMOVSXDQ, PMOVZXDQ). The source &gt; operand is from either an XMM register or memory; the destination is an XMM &gt; register. &gt; &gt; IMUL Signed multiply. The IMUL instruction multiplies two signed integer &gt; operands. The result is computed to twice the size of the source operands; &gt; however, in some cases the result is truncated to the size of the source &gt; operands. &gt; &gt; SAL/SHL Shift arithmetic left/Shift logical left. The SAL (shift arithmetic &gt; left), SHL (shift logical left), SAR (shift arithmetic right), SHR (shift &gt; logical right) instructions perform an arithmetic or logical shift of the bits &gt; in a byte, word, or doubleword. The SAL and SHL instructions perform the same &gt; operation. They shift the source operand left by from 1 to 31 bit positions. &gt; Empty bit positions are cleared. The CF flag is loaded with the last bit &gt; shifted out of the operand.</p>
<h2><a class="anchor" id="layout_optasm"></a>
Optimized assembly</h2>
<p>Generated RELWITHDEBINFO assembly code of the assignments of <em>aa</em> (line 42) and <em>bb</em> (line 43) in Dirichlet's constructor, with clang -O2 -g DNDEBUG -S -mllvm --x86-asm-syntax=intel, gnu and intel generate very similar optimized code:</p>
<p>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ... .loc 144 42 20 # /home/jbakosi/code/quinoa/src/SDE/Dirichlet.h:42:20 movsd XMM0, QWORD PTR [R14 + 8*RAX + 24] movsd QWORD PTR [R13 + 8], XMM0 .loc 144 43 0 # /home/jbakosi/code/quinoa/src/SDE/Dirichlet.h:43:0 mov RCX, QWORD PTR [R13 + 32] movsd XMM0, QWORD PTR [RCX + 8*RAX + 24] movsd QWORD PTR [R13 + 16], XMM0 ... ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</p>
<p>Both lines 42 and 43 translate to very similar SSE loads with pointer arithmetic, i.e., line 42 costs the same as line 43.</p>
<h2><a class="anchor" id="layout_excerpt2"></a>
Excerpt from the Intel® 64 and IA-32 Architectures Software Developer Manual</h2>
<p>&gt; The MOVS instruction moves the string element addressed by the ESI register to &gt; the location addressed by the EDI register. The assembler recognizes three &gt; “short forms” of this instruction, which specify the size of the string to be &gt; moved: MOVSB (move byte string), MOVSW (move word string), and MOVSD (move &gt; doubleword string). &gt; &gt; The MOVSD (move scalar double-precision floating-point) instruction transfers &gt; a 64-bit double-precision floating- point operand from memory to the low &gt; quadword of an XMM register or vice versa, or between XMM registers. &gt; Alignment of the memory address is not required, unless alignment checking is &gt; enabled.</p>
<p>Data layout benchmark --------------------- This section documents the benchmark of the implementation of the compile-time configurable particle-data-access policy discussed above. The implementation is via a thin data-access interface with zero run-time cost, no code-duplication, and in a way that is invisible to derived equation classes.</p>
<h2><a class="anchor" id="layout_input"></a>
Control file used for benchmark</h2>
<p>We will integrate for the duration of a 100,000 time steps a system of 100 coupled non-linear stochastic differential equations (SDEs) whose statistically stationary solution convergese to the Dirichlet distribution and measure the wall-clock time. For more on the Dirichlet SDE, see <a class="el" href="_dirichlet_8h.html" title="Dirichlet SDE.">src/DiffEq/Dirichlet.h</a>.</p>
<p>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ walker</p>
<p>nstep 100000 # Max number of time steps term 140.0 # Max time dt 0.05 # Time step size npar 40000 # Number of particles</p>
<p>ttyi 100 # TTY output interval</p>
<p>rngs mkl_mrg32k3a seed 0 end end</p>
<p>dirichlet ncomp 100 # = K = N-1 b 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 end S 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 end kappa 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 end rng mkl_mrg32k3a end</p>
<p>statistics # Estimate statistics &lt;Y1&gt; # mean of Y1 &lt;Y2&gt; &lt;y1y1&gt; # variance of Y1 = &lt;(Y1-&lt;Y1&gt;)^2&gt; = &lt;y1^2&gt; &lt;y2y2&gt; &lt;y1y2&gt; end</p>
<p>end ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</p>
<h2><a class="anchor" id="layout_ptr"></a>
Ptr - Working with raw pointers</h2>
<p>This algorithm gets the starting raw pointer from which the given particle data is (contiguously) accessible in memory and simply adds integers to the address to access and update the 100 components specified above. The algorithm assumes a particular data layout - it only works with the particle-major storage - a logically 3-dimensional array with [ particle ] [ sde ] [ component ].</p>
<p>__Layout-dependent algorithm:__</p>
<p>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ! Advance particles void advance(int p, int tid, tk::real dt) override { Get access to particle scalars tk::real* y = m_particles.ptr() + p*m_nprop + m_offset;</p>
<p>Compute Nth scalar tk::real yn = 1.0 - y[0]; for (int i=1; i&lt;m_ncomp; ++i) yn -= y[i];</p>
<p>Generate Gaussian random numbers with zero mean and unit variance tk::real dW[m_ncomp]; m_rng-&gt;gaussian( tid, m_ncomp, dW );</p>
<p>Advance first m_ncomp (K=N-1) scalars for (int i=0; i&lt;m_ncomp; ++i) { tk::real d = m_k[i]*y[i]*yn*dt; if (d &gt; 0.0) d = sqrt(d); else d = 0.0; y[i] += 0.5*m_b[i]*(m_S[i]*yn - (1.0-m_S[i])*y[i])*dt + d*dW[i]; } } ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</p>
<h2><a class="anchor" id="layout_par"></a>
Par - Access via particle-major layout policy</h2>
<p>This algorithm accesses particle data via the wrapper class, <a class="el" href="classtk_1_1_particle_properties.html">tk::ParticleProperties</a>, in a data-layout-agnostic fashion. Access itself via this class is demonstrably "zero-cost", i.e., an optmizing compiler completely optimizes the abstraction away: see [assembly](layout_assembly.html) for the assembly generated by 3 compilers. However, writing an SDE-advance algorithm in a data-layout-agnostic manner, requires index calculations at every particle-access compared to working with raw pointers, as described above. Thus the following tests are designed to measure only the additional index calculations that the layout-agnostic access entails.</p>
<p>__Layout-independent algorithm:__</p>
<p>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ! Advance particles void advance(int p, int tid, tk::real dt) override { Compute Nth scalar tk::real yn = 1.0 - m_particles(p, 0, m_offset); for (int i=1; i&lt;m_ncomp; ++i) yn -= m_particles(p, i, m_offset);</p>
<p>Generate Gaussian random numbers with zero mean and unit variance tk::real dW[m_ncomp]; m_rng-&gt;gaussian( tid, m_ncomp, dW );</p>
<p>Advance first m_ncomp (K=N-1) scalars for (int i=0; i&lt;m_ncomp; ++i) { tk::real d = m_k[i] * m_particles(p, i, m_offset) * yn * dt; if (d &gt; 0.0) d = sqrt(d); else d = 0.0; m_particles(p, i, m_offset) += 0.5*m_b[i]*(m_S[i]*yn - (1.0-m_S[i]) * m_particles(p, i, m_offset) )*dt + d*dW[i]; } } ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</p>
<h2><a class="anchor" id="layout_comparison"></a>
Comparison of the algorithms</h2>
<p>DEBUG mode is -O0 and does not optimize function calls away for all of three compilers tested. RELEASE modes is -O3 and the abstraction is completely optimized away. However, index calculations still remain compared to a layout-dependent advance algorithm.</p>
<p>Total time measured in micro-seconds, run on a Lenovo laptop with Intel Core i7, 8 compute cores: Run | Ptr | Par | Par/Ptr :------------ | ---------------: | ---------------: | ----------------: clang/DEBUG | 150350236 | 338851735 | 2.2537 x slowdown clang/RELEASE | 98157742 | 104077139 | 1.0603 x slowdown DEBUG/RELEASE | 1.5317 x speedup | 3.2558 x speedup | n/a</p>
<p>Run | Ptr | Par | Par/Ptr :------------ | ---------------: | ---------------: | ----------------: gnu/DEBUG | 161603164 | 386646353 | 2.3926 x slowdown gnu/RELEASE | 94747953 | 98187568 | 1.0363 x slowdown DEBUG/RELEASE | 1.7056 x speedup | 3.9378 x speedup | n/a</p>
<p>Run | Ptr | Par | Par/Ptr :------------ | ---------------: | ---------------: | ----------------: intel/DEBUG | 171691440 | 608407412 | 3.5436 x slowdown intel/RELEASE | 90059133 | 89892665 | 0.99815 x speedup DEBUG/RELEASE | 1.9064 x speedup | 6.7682 x speedup | n/a</p>
<h2><a class="anchor" id="layout_discussion"></a>
Discussion</h2>
<ul>
<li>As expected, inlining has a significant effect on performance: going from DEBUG to RELEASE mode yields a significant speedup with all three compilers, see last, DEBUG/RELEASE, rows.</li>
</ul>
<ul>
<li>As expected, the additional index calculations required by layout-agnostic access do take a performance hit: though only 6% with clang, and 3% with gnu, see last, Par/Ptr, columns.</li>
</ul>
<ul>
<li>Surprisingly, the layout-agnostic access is even a tiny bit faster than the layout-dependent algorithm with the intel compiler with -O3.</li>
</ul>
<h2><a class="anchor" id="layout_conclusion"></a>
Conclusion</h2>
<p>As this is not a significant performance hit, the equation advancement algorithms and general particle data access are implemented in a data-layout-independent fashion. The data layout can be changed at compile time. Access will be abstracted (and optimized) away.</p>
<p>For the implementation see the <a class="el" href="classtk_1_1_particle_properties.html">tk::ParticleProperties</a>.</p>
<hr/>
 <div><small> <em>Page last updated:</em> Tue 09 Jun 2015 08:33:55 AM MDT <em>Copyright 2012-2015, Jozsef Bakosi.</em> </small></div> </div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div>
  <div id="nav-path" class="navpath">
    <ul>

    <li class="footer">Generated on Tue Jul 7 2015 03:25:02 for Quinoa by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
