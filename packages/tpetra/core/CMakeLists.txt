INCLUDE(CombinedOption)
INCLUDE(TribitsETISupport)

#
# Declare the subpackage
#
TRIBITS_SUBPACKAGE(Core)

TRIBITS_ADD_EXPLICIT_INSTANTIATION_OPTION()

# Enable Explicit Template Instantiation (ETI) support for Tpetra.
TRIBITS_ADD_ETI_SUPPORT()

ASSERT_DEFINED(${PACKAGE_NAME}_ENABLE_EXPLICIT_INSTANTIATION)
# FIXME (mfh 17 Dec 2014) We really just want a macro, not a CMake option.
# This is mainly just for backwards compatibility.
TRIBITS_ADD_OPTION_AND_DEFINE(
  Tpetra_ENABLE_EXPLICIT_INSTANTIATION
  HAVE_TPETRA_EXPLICIT_INSTANTIATION
  "Enable explicit template instantiation (ETI) in Tpetra"
  ${${PACKAGE_NAME}_ENABLE_EXPLICIT_INSTANTIATION}
  )

ASSERT_DEFINED(Kokkos_ENABLE_Cuda)
ASSERT_DEFINED(Kokkos_ENABLE_Cuda_UVM)
IF (Kokkos_ENABLE_Cuda AND NOT Kokkos_ENABLE_Cuda_UVM)
  MESSAGE (FATAL_ERROR "If CUDA is enabled in Kokkos, Tpetra requires that Kokkos' UVM support be enabled.  You may do this by setting the CMake option Kokkos_ENABLE_Cuda_UVM:BOOL=ON (WARNING: IT IS CASE SENSITIVE!) and running CMake again.\n\nDetails for developers: UVM stands for \"Unified Virtual Memory\".  It lets code running on the host processor access GPU memory.  There is a difference between CUDA's support for UVM, and Kokkos' support for UVM.  Versions of CUDA >= 6 have UVM support built in by default.  Kokkos always supports this.  In particular, Kokkos always has a memory space for UVM allocations, called Kokkos::CudaUVMSpace.  \"Turning on UVM support in Kokkos\" means two things:\n\n1. Kokkos::Cuda::memory_space (the CUDA execution space's default memory space) is Kokkos::CudaUVMSpace, rather than Kokkos::CudaSpace.\n\n2. Kokkos::DualView<T, Kokkos::Cuda> only uses a single allocation, in the Kokkos::CudaUVMSpace memory space.")
ENDIF ()

SET(Tpetra_MACHINE_XML_FILE_DIR 
    ${CMAKE_CURRENT_SOURCE_DIR}/machine_files
    CACHE INTERNAL "")

ASSERT_DEFINED(KokkosClassic_DefaultNode)
ASSERT_DEFINED(KokkosClassic_ENABLED_NODES)

# Set variables which were implicitly set when the Kokkos packages were optional dependencies
IF(Tpetra_ENABLE_Kokkos_Refactor)
  GLOBAL_SET(HAVE_TPETRACORE_TEUCHOSKOKKOSCOMPAT ON)
  GLOBAL_SET(HAVE_TPETRACORE_TEUCHOSKOKKOSCOMM ON)
  GLOBAL_SET(HAVE_TPETRACORE_KOKKOSCORE ON)
  GLOBAL_SET(HAVE_TPETRACORE_KOKKOSALGORITHMS ON)
  GLOBAL_SET(HAVE_TPETRACORE_KOKKOSCONTAINERS ON)
ENDIF()

TRIBITS_ADD_OPTION_AND_DEFINE(
  ${PACKAGE_NAME}_ENABLE_SS_TESTING
  HAVE_TPETRA_ENABLE_SS_TESTING
  "Enabling testing of Secondary Stable Code."
  ${${PROJECT_NAME}_ENABLE_SECONDARY_STABLE_CODE}
  )

# If this variable isn't defined, then the TpetraTSQR subpackage of
# Tpetra isn't where it should be.
ASSERT_DEFINED(${PROJECT_NAME}_ENABLE_TpetraTSQR)
IF (${PROJECT_NAME}_ENABLE_TpetraTSQR)
  SET(${PACKAGE_NAME}_ENABLE_TSQR_DEFAULT ON)
ELSE ()
  SET(${PACKAGE_NAME}_ENABLE_TSQR_DEFAULT OFF)
ENDIF ()

# TpetraCore_ENABLE_TSQR says whether TpetraCore should build its TSQR
# interface.  You may turn this interface off if you like, even if the
# TpetraTSQR subpackage of Tpetra is enabled.
TRIBITS_ADD_OPTION_AND_DEFINE(
  ${PACKAGE_NAME}_ENABLE_TSQR
  HAVE_TPETRA_TSQR
  "Whether to build Tpetra with TSQR support.  This is enabled by default if the KokkosTSQR subpackage is enabled.  You may turn off TSQR support if you like, but leaving it enabled is fine.  Please note that Epetra's TSQR adapter lives in the Tpetra package, for various historical reasons.  Therefore, in order to use TSQR with Epetra, you must enable Tpetra as well."
  ${${PACKAGE_NAME}_ENABLE_TSQR_DEFAULT}
  )

TRIBITS_ADD_OPTION_AND_DEFINE(
  ${PACKAGE_NAME}_ENABLE_BUGTESTS
  HAVE_TPETRA_BUGTESTS
  "Enabling testing of previous Tpetra bugs."
  ${${PROJECT_NAME}_ENABLE_SECONDARY_STABLE_CODE}
  )

######################################################################
# Explicit template instantiation (ETI) and test instantiation logic
######################################################################
#
#
#
# For Scalar types, Node types, and (LocalOrdinal, GlobalOrdinal) type
# pairs, Tpetra defines macros which say
#
#   1. whether Tpetra instantiates (if ETI is enabled) and/or tests
#      its objects for that type (or type pair), and
#   2. whether the type (or type pair) is available.
#
# If ETI is enabled, both are identical.  If not, the settings of the
# latter depend on both Kokkos settings and Trilinos' settings.
#
# The availability macros have the following pattern: HAVE_TPETRA_[TYPE]
# The instantiation macros have the pattern:          HAVE_TPETRA_INST_[TYPE]
# The CMake options have the pattern:                 Tpetra_INST_[TYPE]
#
# The ordinal types are: INT_INT, INT_UNSIGNED, INT_LONG, INT_LONG_LONG
# The node types are:    SERIALCLASSIC, SERIAL, OPENMP, PTHREAD, CUDA
# The scalar types are:  DOUBLE, FLOAT, COMPLEX_DOUBLE, COMPLEX_FLOAT
#
# A downstream package or application should use the availability macros to check
# whether something can be used/instantiated. 
#
# Note on (1) above: Tpetra also adds enabled GlobalOrdinal types
# internally to the Scalar types for instantiation of MultiVector.
#
# Note on (2) above: some of the types can only be enabled if certain
# requirements are fulfilled.

SET(TpetraCore_ETI_SCALARS "")
SET(TpetraCore_ETI_GORDS   "")
SET(TpetraCore_ETI_LORDS   "int")
SET(TpetraCore_ETI_NODES   "")

# ============================================================
# Nodes
# ============================================================

# Decide what Node types to enable.  If ETI is ON, "enabling a Node
# type" means that Tpetra objects with Node as a template parameter
# will
# 
#   1. get instantiated explicitly for that Node type, and
#   2. get tested for that Node type, if their test is also
#      templated on Node type.
#
# If ETI is OFF, #1 no longer holds, but #2 still holds.
IF (Tpetra_ENABLE_Kokkos_Refactor)

  IF (${${PACKAGE_NAME}_ENABLE_EXPLICIT_INSTANTIATION})
    #
    # If ETI is ON, then we only enable ONE Node type by default.
    #
    IF (Kokkos_ENABLE_Cuda) 
      GLOBAL_SET(HAVE_TPETRA_INST_SERIAL_DEFAULT OFF)
      GLOBAL_SET(HAVE_TPETRA_INST_PTHREAD_DEFAULT OFF)
      GLOBAL_SET(HAVE_TPETRA_INST_OPENMP_DEFAULT OFF)  
      GLOBAL_SET(HAVE_TPETRA_INST_CUDA_DEFAULT ON)  
    ELSE()
      IF (Kokkos_ENABLE_OpenMP) 
        GLOBAL_SET(HAVE_TPETRA_INST_SERIAL_DEFAULT OFF)
        GLOBAL_SET(HAVE_TPETRA_INST_PTHREAD_DEFAULT OFF)
        GLOBAL_SET(HAVE_TPETRA_INST_OPENMP_DEFAULT ON)  
        GLOBAL_SET(HAVE_TPETRA_INST_CUDA_DEFAULT OFF)  
      ELSE()
        IF (Kokkos_ENABLE_Serial)
          GLOBAL_SET(HAVE_TPETRA_INST_SERIAL_DEFAULT ON)
          GLOBAL_SET(HAVE_TPETRA_INST_PTHREAD_DEFAULT OFF)
          GLOBAL_SET(HAVE_TPETRA_INST_OPENMP_DEFAULT OFF)  
          GLOBAL_SET(HAVE_TPETRA_INST_CUDA_DEFAULT OFF)  
        ELSE()
          IF (Kokkos_ENABLE_Pthread)
            # Treat Pthreads differently than other Node types: Turn
            # it OFF as a Node type by default, since the Pthreads TPL
            # is on by default.
            GLOBAL_SET(HAVE_TPETRA_INST_SERIAL_DEFAULT OFF)
            GLOBAL_SET(HAVE_TPETRA_INST_PTHREAD_DEFAULT ON)
            GLOBAL_SET(HAVE_TPETRA_INST_OPENMP_DEFAULT OFF)  
            GLOBAL_SET(HAVE_TPETRA_INST_CUDA_DEFAULT OFF)
          ELSE()
            MESSAGE(FATAL_ERROR "No Kokkos execution space is enabled.")
          ENDIF()  # Kokkos_ENABLE_Pthread
        ENDIF() # Kokkos_ENABLE_Serial
      ENDIF() # Kokkos_ENABLE_OpenMP
    ENDIF() # Kokkos_ENABLE_Cuda

    TRIBITS_ADD_OPTION_AND_DEFINE(
      Tpetra_INST_SERIAL
      HAVE_TPETRA_INST_SERIAL
      "If explicit template instantiation (ETI) is enabled, instantiate Tpetra classes over Node = Kokkos::Compat::KokkosSerialWrapperNode.  This option is ${HAVE_TPETRA_INST_SERIAL_DEFAULT} by default."
      ${HAVE_TPETRA_INST_SERIAL_DEFAULT}
      )

    TRIBITS_ADD_OPTION_AND_DEFINE(
      Tpetra_INST_PTHREAD
      HAVE_TPETRA_INST_PTHREAD
      "If explicit template instantiation (ETI) is enabled, instantiate Tpetra classes over Node = Kokkos::Compat::KokkosThreadsWrapperNode.  This option is ${HAVE_TPETRA_INST_PTHREAD_DEFAULT} by default."
      ${HAVE_TPETRA_INST_PTHREAD_DEFAULT}
      )

    TRIBITS_ADD_OPTION_AND_DEFINE(
      Tpetra_INST_OPENMP
      HAVE_TPETRA_INST_OPENMP
      "If explicit template instantiation (ETI) is enabled, instantiate Tpetra classes over Node = Kokkos::Compat::KokkosOpenMPWrapperNode.  This option is ${HAVE_TPETRA_INST_OPENMP_DEFAULT} by default."
      ${HAVE_TPETRA_INST_OPENMP_DEFAULT}
      )

    TRIBITS_ADD_OPTION_AND_DEFINE(
      Tpetra_INST_CUDA
      HAVE_TPETRA_INST_CUDA
      "If explicit template instantiation (ETI) is enabled, instantiate Tpetra classes over Node = Kokkos::Compat::KokkosCudaWrapperNode.  This option is ${HAVE_TPETRA_INST_CUDA_DEFAULT} by default."
      ${HAVE_TPETRA_INST_CUDA_DEFAULT}
      )

    TRIBITS_ADD_OPTION_AND_DEFINE(
      Tpetra_INST_SERIALCLASSIC
      HAVE_TPETRA_INST_SERIALCLASSIC
      "If explicit template instantiation (ETI) is enabled, instantiate Tpetra classes over Node = KokkosClassic::DoNotUse::SerialNode.  This option is OFF by default."
      OFF
      )

    # Make sure that the default Node type is actually enabled,
    # and set the macro saying which Node type is the default.
    #
    # While doing so, print out a helpful STATUS message if a Kokkos
    # execution space is ON, but ETI for its corresponding Node type
    # is OFF.  This may help users diagnose link errors.
    
    # KokkosClassic::DoNotUse::SerialNode
    IF(Tpetra_INST_SERIALCLASSIC)
      GLOBAL_SET(HAVE_TPETRA_SERIALCLASSIC ON)
    ELSE()
      GLOBAL_SET(HAVE_TPETRA_SERIALCLASSIC OFF)
      IF (HAVE_KOKKOSCLASSIC_DEFAULTNODE_SERIALNODE) 
        MESSAGE(FATAL_ERROR "Tpetra: You set KokkosClassic::DoNotUse::SerialNode as the default Node type, but ETI (explicit template instantiation) is OFF for that Node type.  Try setting the CMake option Tpetra_INST_SERIALCLASSIC:BOOL=ON.")
      ENDIF()
    ENDIF()

    # Kokkos::Serial (Kokkos::Compat::KokkosSerialWrapperNode)
    IF(Tpetra_INST_SERIAL)
      GLOBAL_SET(HAVE_TPETRA_SERIAL ON)
    ELSE()
      GLOBAL_SET(HAVE_TPETRA_SERIAL OFF)
      IF (HAVE_KOKKOSCLASSIC_DEFAULTNODE_SERIALWRAPPERNODE) 
        MESSAGE(FATAL_ERROR "Tpetra: You set Kokkos::Compat::KokkosSerialWrapperNode as the default Node type, but ETI (explicit template instantiation) is OFF for that Node type.  Try setting the CMake options Kokkos_ENABLE_Serial:BOOL=ON and Tpetra_INST_SERIAL:BOOL=ON.")
      ENDIF()
      IF (Kokkos_ENABLE_Serial)
        MESSAGE(STATUS "NOTE: Kokkos::Serial is ON (the CMake option Kokkos_ENABLE_Serial is ON), but explicit instantiation for Kokkos::Serial in Tpetra is OFF.  If you want to enable instantiation and use of Kokkos::Serial in Tpetra, please also set the CMake option Tpetra_INST_SERIAL:BOOL=ON.  If you use the Kokkos::Serial version of Tpetra without doing this, you will get link errors!")
      ENDIF ()
    ENDIF()

    # Kokkos::OpenMP (Kokkos::Compat::KokkosOpenMPWrapperNode)
    IF(Tpetra_INST_OPENMP)
      GLOBAL_SET(HAVE_TPETRA_OPENMP ON)
    ELSE()
      GLOBAL_SET(HAVE_TPETRA_OPENMP OFF)
      IF (HAVE_KOKKOSCLASSIC_DEFAULTNODE_OPENMPWRAPPERNODE) 
        MESSAGE(FATAL_ERROR "Tpetra: You set Kokkos::Compat::KokkosOpenMPWrapperNode as the default Node type, but ETI (explicit template instantiation) is OFF for that Node type.  Try setting the CMake option Tpetra_INST_OPENMP:BOOL=ON.  If that does not work, also add Trilinos_ENABLE_OpenMP:BOOL=ON and possibly also Kokkos_ENABLE_OpenMP:BOOL=ON.")
      ENDIF()
      IF (Kokkos_ENABLE_OpenMP)
        MESSAGE(STATUS "NOTE: Kokkos::OpenMP is ON (the CMake option Kokkos_ENABLE_OpenMP is ON), but explicit instantiation for Kokkos::OpenMP in Tpetra is OFF.  If you want to enable instantiation and use of Kokkos::OpenMP in Tpetra, please also set the CMake option Tpetra_INST_OPENMP:BOOL=ON.  If you use the Kokkos::OpenMP version of Tpetra without doing this, you will get link errors!")
      ENDIF ()
    ENDIF()

    # Kokkos::Threads (Kokkos::Compat::KokkosThreadsWrapperNode)
    IF(Tpetra_INST_PTHREAD)
      GLOBAL_SET(HAVE_TPETRA_PTHREAD ON)
      IF (Tpetra_INST_OPENMP)
        MESSAGE(WARNING "We do NOT recommend enabling both the Kokkos::Serial and Kokkos::Threads versions of Tpetra in the same build!  The threads that the Kokkos::Threads execution space creates will interfere with OpenMP's threads, causing performance problems.  You are seeing this warning because both CMake options Tpetra_INST_OPENMP and Tpetra_INST_PTHREAD are ON, which is not the default.")
      ENDIF ()
    ELSE()
      GLOBAL_SET(HAVE_TPETRA_PTHREAD OFF)
      IF (HAVE_KOKKOSCLASSIC_DEFAULTNODE_THREADSWRAPPERNODE) 
        MESSAGE(FATAL_ERROR "Tpetra: You set Kokkos::Compat::KokkosThreadsWrapperNode as the default Node type, but ETI (explicit template instantiation) is OFF for that Node type.  Try setting the CMake options Kokkos_ENABLE_Pthread:BOOL=ON and Tpetra_INST_PTHREAD:BOOL=ON.  (Yes, it is 'Pthread', not 'Pthreads'.  Sorry, that wasn't my idea.)")
      ENDIF()
      IF (Kokkos_ENABLE_Pthread)
        MESSAGE(STATUS "NOTE: Kokkos::Threads is ON (the CMake option Kokkos_ENABLE_Pthread is ON), but explicit instantiation (ETI) for Kokkos::Threads in Tpetra is OFF.  Note that unlike with other Kokkos execution spaces, Tpetra disables ETI for Kokkos::Threads by default.  If you want to enable instantiation and use of Kokkos::Threads in Tpetra, please also set the CMake option Tpetra_INST_PTHREAD:BOOL=ON.  If you use the Kokkos::Threads version of Tpetra without doing this, you will get link errors!  We do NOT recommend using Kokkos::Threads if Kokkos::OpenMP is enabled.")
      ENDIF ()
    ENDIF()

    # Kokkos::Cuda (Kokkos::Compat::KokkosCudaWrapperNode)
    IF(Tpetra_INST_CUDA)
      GLOBAL_SET(HAVE_TPETRA_CUDA ON)
    ELSE()
      GLOBAL_SET(HAVE_TPETRA_CUDA OFF)
      IF (HAVE_KOKKOSCLASSIC_DEFAULTNODE_CUDAWRAPPERNODE) 
        MESSAGE(FATAL_ERROR "Tpetra: You set Kokkos::Compat::KokkosCudaWrapperNode as the default Node type, but ETI (explicit template instantiation) is OFF for that Node type.  Try setting the CMake options Kokkos_ENABLE_Cuda:BOOL=ON and Tpetra_INST_CUDA:BOOL=ON.  If you are building with a CUDA-capable compiler and Kokkos can detect that, then you are unlikely to see this message, since both Kokkos and Tpetra enable CUDA support by default in that case.")
      ENDIF()
      IF (Kokkos_ENABLE_Cuda)
        MESSAGE(STATUS "NOTE: Kokkos::Cuda is ON (the CMake option Kokkos_ENABLE_Cuda is ON), but explicit instantiation for Kokkos::Cuda in Tpetra is OFF.  If you want to enable instantiation and use of Kokkos::Cuda in Tpetra, please also set the CMake option Tpetra_INST_CUDA:BOOL=ON.  If you use the Kokkos::Cuda version of Tpetra without doing this, you will get link errors!")
      ENDIF ()
    ENDIF()
    
    # Append the instantiation list

    IF(Tpetra_INST_SERIALCLASSIC) 
      LIST(APPEND TpetraCore_ETI_NODES "KokkosClassic::DoNotUse::SerialNode")
      MESSAGE(STATUS "Enabling Node: KokkosClassic::DoNotUse::SerialNode")
    ENDIF()
    IF(Tpetra_INST_SERIAL) 
      LIST(APPEND TpetraCore_ETI_NODES "Kokkos::Compat::KokkosSerialWrapperNode")
      MESSAGE(STATUS "Enabling Node: Kokkos::Compat::KokkosSerialWrapperNode")
    ENDIF()
    IF(Tpetra_INST_PTHREAD) 
      LIST(APPEND TpetraCore_ETI_NODES "Kokkos::Compat::KokkosThreadsWrapperNode")
      MESSAGE(STATUS "Enabling Node: Kokkos::Compat::KokkosThreadsWrapperNode")
    ENDIF()
    IF(Tpetra_INST_OPENMP) 
      LIST(APPEND TpetraCore_ETI_NODES "Kokkos::Compat::KokkosOpenMPWrapperNode")
      MESSAGE(STATUS "Enabling Node: Kokkos::Compat::KokkosOpenMPWrapperNode")
    ENDIF()
    IF(Tpetra_INST_CUDA) 
      LIST(APPEND TpetraCore_ETI_NODES "Kokkos::Compat::KokkosCudaWrapperNode")
      MESSAGE(STATUS "Enabling Node: Kokkos::Compat::KokkosCudaWrapperNode")
    ENDIF()

  ELSE() # ETI is OFF

    GLOBAL_SET(HAVE_TPETRA_INST_SERIAL_DEFAULT OFF)
    GLOBAL_SET(HAVE_TPETRA_INST_PTHREAD_DEFAULT OFF)
    GLOBAL_SET(HAVE_TPETRA_INST_OPENMP_DEFAULT OFF)
    GLOBAL_SET(HAVE_TPETRA_INST_CUDA_DEFAULT OFF)

    # If ETI is OFF, then all Node types whose execution spaces are
    # enabled in Kokkos are available to packages downstream of Tpetra.

    GLOBAL_SET(HAVE_TPETRA_SERIALCLASSIC ON)
    IF(Kokkos_ENABLE_Serial)
      GLOBAL_SET(HAVE_TPETRA_SERIAL ON)
    ELSE()
      GLOBAL_SET(HAVE_TPETRA_SERIAL OFF)
      IF (HAVE_KOKKOSCLASSIC_DEFAULTNODE_SERIALWRAPPERNODE) 
        MESSAGE(FATAL_ERROR "Tpetra: set KokkosSerialWrapperNode as default node type but its not enabled.")   
      ENDIF()
    ENDIF()
    IF(Kokkos_ENABLE_Pthread)
      GLOBAL_SET(HAVE_TPETRA_PTHREAD ON)
    ELSE()
      GLOBAL_SET(HAVE_TPETRA_PTHREAD OFF)
      IF (HAVE_KOKKOSCLASSIC_DEFAULTNODE_THREADSWRAPPERNODE) 
        MESSAGE(FATAL_ERROR "Tpetra: set KokkosThreadsWrapperNode as default node type but its not enabled.")   
      ENDIF()
    ENDIF()
    IF(Kokkos_ENABLE_OpenMP)
      GLOBAL_SET(HAVE_TPETRA_OPENMP ON)
    ELSE()
      GLOBAL_SET(HAVE_TPETRA_OPENMP OFF)
      IF (HAVE_KOKKOSCLASSIC_DEFAULTNODE_OPENMPWRAPPERNODE) 
        MESSAGE(FATAL_ERROR "Tpetra: set KokkosOpenMPWrapperNode as default node type but its not enabled.")   
      ENDIF()
    ENDIF()
    IF(Kokkos_ENABLE_Cuda)
      GLOBAL_SET(HAVE_TPETRA_CUDA ON)
    ELSE()
      GLOBAL_SET(HAVE_TPETRA_CUDA OFF)
      IF (HAVE_KOKKOSCLASSIC_DEFAULTNODE_CUDAWRAPPERNODE) 
        MESSAGE(FATAL_ERROR "Tpetra: set KokkosCudaWrapperNode as default node type but its not enabled.")   
      ENDIF()
    ENDIF()
  ENDIF()

ELSE() # NOT Tpetra_ENABLE_Kokkos_Refactor (DEPRECATED)

  MESSAGE(WARNING "The 'classic' version of Tpetra has been DEPRECATED and will go away before the 12.0 release of Trilinos.")

  SET(TpetraCore_ETI_NODES   "${KokkosClassic_ENABLED_NODES}")
  GLOBAL_SET(HAVE_TPETRA_SERIALCLASSIC ON)
  GLOBAL_SET(HAVE_TPETRA_SERIAL OFF)
  GLOBAL_SET(HAVE_TPETRA_PTHREAD OFF)
  GLOBAL_SET(HAVE_TPETRA_OPENMP OFF)
  GLOBAL_SET(HAVE_TPETRA_CUDA OFF)

ENDIF() # Tpetra_ENABLE_Kokkos_Refactor


MESSAGE(STATUS "Tpetra Node availability: ")
MESSAGE(STATUS "   KokkosSerialWrapperNode:      ${HAVE_TPETRA_SERIAL}")
MESSAGE(STATUS "   KokkosThreadsWrapperNode:     ${HAVE_TPETRA_PTHREAD}")
MESSAGE(STATUS "   KokkosOpenMPWrapperNode:      ${HAVE_TPETRA_OPENMP}")
MESSAGE(STATUS "   KokkosCudaWrapperNode:        ${HAVE_TPETRA_CUDA}")
MESSAGE(STATUS "   SerialNode (classic):         ${HAVE_TPETRA_SERIALCLASSIC}")


#-----------------------------------------------------------------------
#---------------------Global Ordinals-----------------------------------
#-----------------------------------------------------------------------
#The user gets what he asks for, and if nothing is asked for enable "int"
 
# Default logic
# Note that long is 64 bits on some platforms, and 32 bits on other
# platforms.  On the latter, you may use long long instead, which
# C++11 / C99 guarantees to be at least 64 bits long.

# NOTE: The unsigned int is used because they help catch errors with caused
# when GlobalOrdinal is unsigned and GlobalOrdinal is smaller than
# global_size_t (using wrong Teuchos::OrdinalTraits<>::invald(). 

IF (${${PACKAGE_NAME}_ENABLE_EXPLICIT_INSTANTIATION})
  IF (Tpetra_INST_INT_LONG_LONG OR HAVE_TEUCHOS_LONG_LONG_INT) 
    GLOBAL_SET(HAVE_TPETRA_INST_INT_LONG_LONG_DEFAULT ON)
    GLOBAL_SET(HAVE_TPETRA_INST_INT_LONG_DEFAULT OFF)
    GLOBAL_SET(HAVE_TPETRA_INST_INT_UNSIGNED_DEFAULT OFF)  
    GLOBAL_SET(HAVE_TPETRA_INST_INT_INT_DEFAULT ON)  
  ELSE()
    IF (Tpetra_INST_INT_LONG) 
      GLOBAL_SET(HAVE_TPETRA_INST_INT_LONG_LONG_DEFAULT OFF)
      GLOBAL_SET(HAVE_TPETRA_INST_INT_LONG_DEFAULT ON)
      GLOBAL_SET(HAVE_TPETRA_INST_INT_UNSIGNED_DEFAULT OFF)  
      GLOBAL_SET(HAVE_TPETRA_INST_INT_INT_DEFAULT ON)  
    ELSE()
      IF (Tpetra_INST_INT_UNSIGNED)
        GLOBAL_SET(HAVE_TPETRA_INST_INT_LONG_LONG_DEFAULT OFF)
        GLOBAL_SET(HAVE_TPETRA_INST_INT_LONG_DEFAULT OFF)
        GLOBAL_SET(HAVE_TPETRA_INST_INT_UNSIGNED_DEFAULT ON)  
        GLOBAL_SET(HAVE_TPETRA_INST_INT_INT_DEFAULT ON)  
      ELSE()
        GLOBAL_SET(HAVE_TPETRA_INST_INT_LONG_LONG_DEFAULT OFF)
        GLOBAL_SET(HAVE_TPETRA_INST_INT_LONG_DEFAULT OFF)
        GLOBAL_SET(HAVE_TPETRA_INST_INT_UNSIGNED_DEFAULT OFF)  
        GLOBAL_SET(HAVE_TPETRA_INST_INT_INT_DEFAULT ON)  
      ENDIF()
    ENDIF()
  ENDIF() # Tpetra_INST_INT_LONG_LONG OR HAVE_TEUCHOS_LONG_LONG_INT

  # Decide whether to enable various GlobalOrdinal types

  TRIBITS_ADD_OPTION_AND_DEFINE(  
    Tpetra_INST_INT_INT
    HAVE_TPETRA_INST_INT_INT
    "If explicit template instantiation (ETI) is enabled, instantiate Tpetra classes over GlobalOrdinal = int.  This option is ${HAVE_TPETRA_INST_INT_INT_DEFAULT} by default."
    ${HAVE_TPETRA_INST_INT_INT_DEFAULT}
    )

  TRIBITS_ADD_OPTION_AND_DEFINE(
    Tpetra_INST_INT_UNSIGNED
    HAVE_TPETRA_INST_INT_UNSIGNED
    "If explicit template instantiation (ETI) is enabled, instantiate Tpetra classes over GlobalOrdinal = unsigned.  This option is ${HAVE_TPETRA_INST_INT_UNSIGNED_DEFAULT} by default."
    ${HAVE_TPETRA_INST_INT_UNSIGNED_DEFAULT}
    )
  
  TRIBITS_ADD_OPTION_AND_DEFINE(
    Tpetra_INST_INT_LONG
    HAVE_TPETRA_INST_INT_LONG
    "If explicit template instantiation (ETI) is enabled, instantiate Tpetra classes over GlobalOrdinal = long.  This option is ${HAVE_TPETRA_INST_INT_LONG_DEFAULT} by default."
    ${HAVE_TPETRA_INST_INT_LONG_DEFAULT}
    )

  TRIBITS_ADD_OPTION_AND_DEFINE(
    Tpetra_INST_INT_LONG_LONG
    HAVE_TPETRA_INST_INT_LONG_LONG
    "If explicit template instantiation (ETI) is enabled, instantiate Tpetra classes over GlobalOrdinal = long long.  This option is ${HAVE_TPETRA_INST_INT_LONG_LONG_DEFAULT} by default."
    ${HAVE_TPETRA_INST_INT_LONG_LONG_DEFAULT}
    ) 

  # Set availability macros for various GlobalOrdinal types

  IF(Tpetra_INST_INT_INT) 
    GLOBAL_SET(HAVE_TPETRA_INT_INT ON)
  ELSE()
    GLOBAL_SET(HAVE_TPETRA_INT_INT OFF)
  ENDIF()
  IF(Tpetra_INST_INT_UNSIGNED) 
    GLOBAL_SET(HAVE_TPETRA_INT_UNSIGNED ON)
  ELSE()
    GLOBAL_SET(HAVE_TPETRA_INT_UNSIGNED OFF)
  ENDIF()
  IF(Tpetra_INST_INT_LONG) 
    GLOBAL_SET(HAVE_TPETRA_INT_LONG ON)
  ELSE()
    GLOBAL_SET(HAVE_TPETRA_INT_LONG OFF)
  ENDIF()
  IF(Tpetra_INST_INT_LONG_LONG) 
    GLOBAL_SET(HAVE_TPETRA_INT_LONG_LONG ON)
  ELSE()
    GLOBAL_SET(HAVE_TPETRA_INT_LONG_LONG OFF)
  ENDIF()
  
  # Append GlobalOrdinal types to instantiation list.  Add them to
  # Scalar types as well, since Tpetra needs Scalar=GlobalOrdinal for
  # some communication routines.

  IF(Tpetra_INST_INT_INT) 
    LIST(APPEND TpetraCore_ETI_SCALARS "int")
    LIST(APPEND TpetraCore_ETI_GORDS "int")
  ENDIF()
  IF(Tpetra_INST_INT_UNSIGNED) 
    LIST(APPEND TpetraCore_ETI_SCALARS "unsigned")
    LIST(APPEND TpetraCore_ETI_GORDS "unsigned")
  ENDIF()
  IF(Tpetra_INST_INT_LONG) 
    LIST(APPEND TpetraCore_ETI_SCALARS "long")
    LIST(APPEND TpetraCore_ETI_GORDS "long")
  ENDIF()
  IF(Tpetra_INST_INT_LONG_LONG) 
    LIST(APPEND TpetraCore_ETI_SCALARS "long long")
    LIST(APPEND TpetraCore_ETI_GORDS "long long")
  ENDIF()

  # Make sure that at least one GlobalOrdinal type got activated
  
  IF(Tpetra_INST_INT_INT OR Tpetra_INST_INT_UNSIGNED OR Tpetra_INST_INT_LONG OR Tpetra_INST_INT_LONG_LONG)
    GLOBAL_SET(HAVE_TPETRA_GLOBALORDINAL ON)
  ELSE()
    MESSAGE(FATAL_ERROR "Tpetra: No GlobalOrdinal type is enabled. One GlobalOrdinal type needs to be enabled to use ETI.")   
  ENDIF()  
  IF(Tpetra_INST_INT_LONG_LONG AND NOT Teuchos_ENABLE_LONG_LONG_INT)
    MESSAGE(FATAL_ERROR "Tpetra: Long long enabled in Tpetra but not enabled in Teuchos. Set Teuchos_ENABLE_LONG_LONG_INT to ON or set Tpetra_INST_INT_LONG_LONG to OFF.")
  ENDIF()

ELSE() # ETI is OF

  # If ETI is OFF, all GlobalOrdinal types are available but none get instantiated. 

  GLOBAL_SET(HAVE_TPETRA_INST_INT_LONG_LONG_DEFAULT OFF)
  GLOBAL_SET(HAVE_TPETRA_INST_INT_LONG_DEFAULT OFF)
  GLOBAL_SET(HAVE_TPETRA_INST_INT_UNSIGNED_DEFAULT OFF)
  GLOBAL_SET(HAVE_TPETRA_INST_INT_INT_DEFAULT OFF)
  
  GLOBAL_SET(HAVE_TPETRA_INT_LONG_LONG ${Teuchos_ENABLE_LONG_LONG_INT})
  GLOBAL_SET(HAVE_TPETRA_INT_LONG ON)
  GLOBAL_SET(HAVE_TPETRA_INT_UNSIGNED ON)
  GLOBAL_SET(HAVE_TPETRA_INT_INT ON)
  
  GLOBAL_SET(HAVE_TPETRA_GLOBALORDINAL ON)
ENDIF()

######################################################################
# Scalars
######################################################################
#
# Users always get what they ask for.  If they don't ask for anything,
# they get Scalar = double by default.  Scalar = dobule is always
# enabled, since tests explicitly depend on it.

# The warning makes sense whether or not ETI is enabled.
IF (${PACKAGE_NAME}_ENABLE_quadmath AND ${PACKAGE_NAME}_ENABLE_CUDA)
  MESSAGE(WARNING "You have enabled the 'quadmath' TPL for __float128 support, but have also enabled CUDA.  __float128 does not work in CUDA code.  To simplify Tpetra's CMake logic, we have thus turned off Tpetra's ETI (explicit template instantiation) and tests for Scalar = __float128.  If you really want to use __float128 in Tpetra, AND really want to enable CUDA, please talk to the Tpetra developers.")
ENDIF ()


IF (${${PACKAGE_NAME}_ENABLE_EXPLICIT_INSTANTIATION})

  # Instantiate Scalar=double by default.
  # Users may shut this off explicitly by setting Tpetra_INST_DOUBLE=OFF.
  GLOBAL_SET(HAVE_TPETRA_INST_DOUBLE_DEFAULT ON)

  TRIBITS_ADD_OPTION_AND_DEFINE(
    Tpetra_INST_DOUBLE
    HAVE_TPETRA_INST_DOUBLE
    "If explicit template instantiation (ETI) is enabled, instantiate Tpetra classes over Scalar = double.  This option is ${HAVE_TPETRA_INST_DOUBLE_DEFAULT} by default."
    ${HAVE_TPETRA_INST_DOUBLE_DEFAULT}
    )
  ASSERT_DEFINED (Tpetra_INST_DOUBLE)

  # Decide whether to instantiate Scalar=float.

  # FIXME (mfh 19 Mar 2015) It doesn't make sense to refer to
  # Tpetra_INST_FLOAT before the TRIBITS_ADD_OPTION_AND_DEFINE call
  # that supposedly defines it.

  IF (Tpetra_INST_FLOAT) 
    GLOBAL_SET(HAVE_TPETRA_INST_FLOAT_DEFAULT ON)
  ELSE()
    GLOBAL_SET(HAVE_TPETRA_INST_FLOAT_DEFAULT OFF)
  ENDIF()  

  TRIBITS_ADD_OPTION_AND_DEFINE(
    Tpetra_INST_FLOAT
    HAVE_TPETRA_INST_FLOAT
    "If explicit template instantiation (ETI) is enabled, instantiate Tpetra classes over Scalar = float.  This option is ${HAVE_TPETRA_INST_FLOAT_DEFAULT} by default."
    ${HAVE_TPETRA_INST_FLOAT_DEFAULT}
    )
  ASSERT_DEFINED (Tpetra_INST_FLOAT)

  # Decide whether to instantiate Scalar = std::complex<float> and
  # std::complex<double>.  Both require a complex-arithmetic BLAS, and
  # std::complex<T> requires the corresponding Scalar=T instantiation.
  
  IF (HAVE_COMPLEX_BLAS)
    IF (Tpetra_INST_DOUBLE)
      GLOBAL_SET(HAVE_Tpetra_INST_COMPLEX_DOUBLE_DEFAULT ON)
    ELSE()
      GLOBAL_SET(HAVE_Tpetra_INST_COMPLEX_DOUBLE_DEFAULT OFF)
    ENDIF()
    IF (Tpetra_INST_FLOAT)
      GLOBAL_SET(HAVE_Tpetra_INST_COMPLEX_FLOAT_DEFAULT ON)
    ELSE()
      GLOBAL_SET(HAVE_Tpetra_INST_COMPLEX_FLOAT_DEFAULT OFF)
    ENDIF()
  ELSE()
    GLOBAL_SET(HAVE_Tpetra_INST_COMPLEX_DOUBLE_DEFAULT OFF)
    GLOBAL_SET(HAVE_Tpetra_INST_COMPLEX_FLOAT_DEFAULT OFF)
  ENDIF() # HAVE_COMPLEX_BLAS

  TRIBITS_ADD_OPTION_AND_DEFINE(
    Tpetra_INST_COMPLEX_FLOAT
    HAVE_TPETRA_INST_COMPLEX_FLOAT
    "If explicit template instantiation (ETI) is enabled, instantiate Tpetra classes with Scalar = std::complex<float>.  This option is ${HAVE_TPETRA_INST_COMPLEX_FLOAT_DEFAULT} by default."
    ${HAVE_Tpetra_INST_COMPLEX_FLOAT_DEFAULT}
    )
  ASSERT_DEFINED (Tpetra_INST_COMPLEX_FLOAT)

  TRIBITS_ADD_OPTION_AND_DEFINE(
    Tpetra_INST_COMPLEX_DOUBLE
    HAVE_TPETRA_INST_COMPLEX_DOUBLE
    "If explicit template instantiation (ETI) is enabled, instantiate Tpetra classes with Scalar = std::complex<double>.  This option is ${HAVE_TPETRA_INST_COMPLEX_DOUBLE_DEFAULT} by default."
    ${HAVE_Tpetra_INST_COMPLEX_DOUBLE_DEFAULT}
    )
  ASSERT_DEFINED (Tpetra_INST_COMPLEX_DOUBLE)

  # Optionally enable explicit template instantiation (ETI) and tests
  # for Scalar = __float128.  __float128 is a GCC-specific C++ language
  # extension.  It requires building with GCC, enabling the 'quadmath'
  # TPL, and setting build flags -std=gnu+11 (not c++11, else warnings)
  # and -fext-numeric-literals (else build errors).  Be sure also to
  # turn off -ansi -pedantic; __float128 is a language extension, so it
  # is NOT ANSI C++.
  #
  # __float128 won't work with Kokkos::Cuda.  We could try to be clever
  # about turning off Tpetra's ETI and tests for __float128 with the
  # Kokkos::Cuda execution space, but instead, we simply disable
  # __float128 ETI and tests if CUDA is enabled.

  ASSERT_DEFINED (${PACKAGE_NAME}_ENABLE_quadmath)
  IF (${PACKAGE_NAME}_ENABLE_quadmath AND NOT ${PACKAGE_NAME}_ENABLE_CUDA)
    # FIXME (mfh 19 Mar 2015) It doesn't currently build.
    # Once it does, set this to ON.
    SET (HAVE_Tpetra_INST_FLOAT128_DEFAULT OFF)
  ELSE ()
    SET (HAVE_Tpetra_INST_FLOAT128_DEFAULT OFF)
  ENDIF ()

  TRIBITS_ADD_OPTION_AND_DEFINE(
    Tpetra_INST_FLOAT128
    HAVE_TPETRA_INST_FLOAT128
    "If explicit template instantiation (ETI) is enabled, instantiate Tpetra classes with Scalar = __float128.  This option is ${HAVE_TPETRA_INST_FLOAT128_DEFAULT} by default.  __float128 is a GCC-specific C++ language extension.  It requires building with GCC, enabling the 'quadmath' TPL, and setting build flags -std=gnu+11 (not c++11, else warnings) and -fext-numeric-literals (else build errors).  Be sure also to turn off -ansi -pedantic; __float128 is a language extension, so it is NOT ANSI C++."
    ${HAVE_Tpetra_INST_FLOAT128_DEFAULT}
    )
  ASSERT_DEFINED (Tpetra_INST_FLOAT128)

  IF (Tpetra_INST_FLOAT128 AND NOT ${PACKAGE_NAME}_ENABLE_quadmath)
    MESSAGE (FATAL_ERROR "You may not enable ETI (explicit template instantiation) or tests in Tpetra for Scalar = __float128, unless you enable the 'quadmath' TPL.  Please also note that __float128 is a GCC-specific C++ language extension.  It requires building with GCC, enabling the 'quadmath' TPL, and setting build flags -std=gnu+11 (not c++11, else warnings) and -fext-numeric-literals (else build errors).  Be sure also to turn off -ansi -pedantic; __float128 is a language extension, so it is NOT ANSI C++.")
  ENDIF ()

  # Enable explicit template instantiation (ETI) and tests for Scalar =
  # qd_real ("quad-double," provided by the QD TPL).
  #
  # ST_FOR_DEV_PT_FOR_RELEASE means something like, "in a debug build."
  # In a debug build, we do ETI for Scalar=std::complex<float>, in order
  # that this capability be tested.  In a release build, we turn off ETI
  # for Scalar=std::complex<float>, to reduce build time.
  IF (ST_FOR_DEV_PT_FOR_RELEASE AND ${PACKAGE_NAME}_ENABLE_QD AND NOT Tpetra_ENABLE_Kokkos_Refactor)
    # mfh 09 Jan 2015: qd_real does NOT currently work with the Kokkos
    # refactor version of Tpetra, due to a missing Kokkos::atomic_*
    # implementation for this class.  Feel free to remove "AND NOT
    # Tpetra_ENABLE_Kokkos_Refactor" from the above test once that gets
    # fixed.
    GLOBAL_SET(HAVE_TPETRA_INST_QD_REAL_DEFAULT ON)
  ELSE()
    GLOBAL_SET(HAVE_TPETRA_INST_QD_REAL_DEFAULT OFF)
  ENDIF()

  TRIBITS_ADD_OPTION_AND_DEFINE(
    Tpetra_INST_QD_REAL
    HAVE_TPETRA_INST_QD_REAL
    "If explicit template instantiation (ETI) is enabled, instantiate Tpetra classes over Scalar = qd_real (requries TPL QD).  This option is ${HAVE_TPETRA_INST_QD_REAL_DEFAULT} by default."
    ${HAVE_TPETRA_INST_QD_REAL_DEFAULT}  
    )
  ASSERT_DEFINED (Tpetra_INST_QD_REAL)
  
  # Enable explicit template instantiation (ETI) and tests for Scalar =
  # qd_real ("double-double," provided by the QD TPL).
  #
  # ST_FOR_DEV_PT_FOR_RELEASE means something like, "in a debug build."
  # In a debug build, we do ETI for Scalar=std::complex<float>, in order
  # that this capability be tested.  In a release build, we turn off ETI
  # for Scalar=std::complex<float>, to reduce build time.
  IF (ST_FOR_DEV_PT_FOR_RELEASE AND ${PACKAGE_NAME}_ENABLE_QD AND NOT Tpetra_ENABLE_Kokkos_Refactor)
    # mfh 09 Jan 2015: dd_real does NOT currently work with the Kokkos
    # refactor version of Tpetra, due to a missing Kokkos::atomic_*
    # implementation for this class.  Feel free to remove "AND NOT
    # Tpetra_ENABLE_Kokkos_Refactor" from the above test once that gets
    # fixed.
    GLOBAL_SET(HAVE_TPETRA_INST_DD_REAL_DEFAULT ON)
  ELSE()
    GLOBAL_SET(HAVE_TPETRA_INST_DD_REAL_DEFAULT OFF)
  ENDIF()
  TRIBITS_ADD_OPTION_AND_DEFINE(
    Tpetra_INST_DD_REAL
    HAVE_TPETRA_INST_DD_REAL
    "If explicit template instantiation (ETI) is enabled, instantiate Tpetra classes over Scalar = dd_real (requries TPL QD).  This option is ${HAVE_TPETRA_INST_DD_REAL_DEFAULT} by default."
    ${HAVE_TPETRA_INST_DD_REAL_DEFAULT}  
    ) 
  ASSERT_DEFINED (Tpetra_INST_DD_REAL)
  
  # Check for support in BLAS
  
  IF(Tpetra_INST_FLOAT AND NOT HAVE_TEUCHOS_BLASFLOAT)
    MESSAGE(SEND_ERROR "You may not instantiate Tpetra classes with Scalar = float, if the BLAS library you are using does not support float (S) arithmetic.")
  ENDIF()
  IF(Tpetra_INST_COMPLEX_FLOAT AND (NOT HAVE_COMPLEX_BLAS OR NOT HAVE_TEUCHOS_BLASFLOAT))
    MESSAGE(SEND_ERROR "You may not instantiate Tpetra classes with Scalar = std::complex<float>, if the BLAS library you are using does not support complex (C) or float (S) arithmetic.")
  ENDIF()
  IF(Tpetra_INST_COMPLEX_DOUBLE AND NOT HAVE_COMPLEX_BLAS)
    MESSAGE(SEND_ERROR "You may not instantiate Tpetra classes with Scalar = std::complex<double>, if the BLAS library you are using does not support double-complex (Z) arithmetic.")
  ENDIF()
  IF(Tpetra_INST_QD_REAL AND Tpetra_ENABLE_Kokkos_Refactor)
    MESSAGE(SEND_ERROR "Scalar = qd_real does not currently work with the Kokkos refactor version of Tpetra.  We will fix this at some point.  Please let us know if you need this capability urgently.")
  ENDIF()
  IF(Tpetra_INST_DD_REAL AND Tpetra_ENABLE_Kokkos_Refactor)
    MESSAGE(SEND_ERROR "Scalar = dd_real does not currently work with the Kokkos refactor version of Tpetra.  We will fix this at some point.  Please let us know if you need this capability urgently.")
  ENDIF()

  # Set availability macros for Scalar types

  IF(Tpetra_INST_FLOAT) 
    GLOBAL_SET(HAVE_TPETRA_FLOAT ON)
  ELSE()
    GLOBAL_SET(HAVE_TPETRA_FLOAT OFF)
  ENDIF()
  IF(Tpetra_INST_DOUBLE) 
    GLOBAL_SET(HAVE_TPETRA_DOUBLE ON)
  ELSE()
    GLOBAL_SET(HAVE_TPETRA_DOUBLE OFF)
  ENDIF()
  IF(Tpetra_INST_COMPLEX_FLOAT) 
    GLOBAL_SET(HAVE_TPETRA_COMPLEX_FLOAT ON)
  ELSE()
    GLOBAL_SET(HAVE_TPETRA_COMPLEX_FLOAT OFF)
  ENDIF()
  IF(Tpetra_INST_COMPLEX_DOUBLE) 
    GLOBAL_SET(HAVE_TPETRA_COMPLEX_DOUBLE ON)
  ELSE()
    GLOBAL_SET(HAVE_TPETRA_COMPLEX_DOUBLE OFF)
  ENDIF()
  IF(Tpetra_INST_FLOAT128) 
    GLOBAL_SET(HAVE_TPETRA_FLOAT128 ON)
  ELSE()
    GLOBAL_SET(HAVE_TPETRA_FLOAT128 OFF)
  ENDIF()
  IF(Tpetra_INST_QD_REAL) 
    GLOBAL_SET(HAVE_TPETRA_QD_REAL ON)
  ELSE()
    GLOBAL_SET(HAVE_TPETRA_QD_REAL OFF)
  ENDIF()
  IF(Tpetra_INST_DD_REAL) 
    GLOBAL_SET(HAVE_TPETRA_DD_REAL ON)
  ELSE()
    GLOBAL_SET(HAVE_TPETRA_DD_REAL OFF)
  ENDIF()

  # Build list of ETI Scalar types

  IF(Tpetra_INST_FLOAT) 
    LIST(APPEND TpetraCore_ETI_SCALARS "float")
  ENDIF()
  IF(Tpetra_INST_DOUBLE) 
    LIST(APPEND TpetraCore_ETI_SCALARS "double")
  ENDIF()
  IF(Tpetra_INST_COMPLEX_FLOAT) 
    LIST(APPEND TpetraCore_ETI_SCALARS "std::complex<float>")
  ENDIF()
  IF(Tpetra_INST_COMPLEX_DOUBLE) 
    LIST(APPEND TpetraCore_ETI_SCALARS "std::complex<double>")
  ENDIF()
  IF(Tpetra_INST_FLOAT128) 
    LIST(APPEND TpetraCore_ETI_SCALARS "__float128")
  ENDIF()
  IF(Tpetra_INST_QD_REAL) 
    LIST(APPEND TpetraCore_ETI_SCALARS "qd_real")
  ENDIF()
  IF(Tpetra_INST_DD_REAL) 
    LIST(APPEND TpetraCore_ETI_SCALARS "dd_real")
  ENDIF()

  # Make sure that at one Scalar type got activated
  
  IF(Tpetra_INST_FLOAT OR Tpetra_INST_DOUBLE OR Tpetra_INST_COMPLEX_FLOAT OR Tpetra_INST_COMPLEX_DOUBLE OR Tpetra_INST_FLOAT128 OR Tpetra_INST_QD_REAL OR Tpetra_INST_DD_REAL)
    GLOBAL_SET(HAVE_TPETRA_SCALAR ON)
  ELSE()
    MESSAGE(FATAL_ERROR "You must enable at least one Scalar type in Tpetra in order to enable ETI (explicit template instantiation).  If you see this message, you probably set nondefault CMake options to disable all of Tpetra's Scalar types.  Please don't do that.")
  ENDIF()

ELSE() # ETI NOT enabled

  GLOBAL_SET(HAVE_TPETRA_SCALAR ON)

  # Always test with Scalar=double.
  GLOBAL_SET(HAVE_TPETRA_DOUBLE ON)

  # Only test Scalar=float if the BLAS supports it.
  IF (HAVE_TEUCHOS_BLASFLOAT)
    GLOBAL_SET(HAVE_TPETRA_FLOAT ON)
  ELSE ()
    GLOBAL_SET(HAVE_TPETRA_FLOAT OFF)
  ENDIF ()

  # Only test Scalar=std::complex<T> (for T in {float, double}) if the
  # BLAS supports them, and if the corresponding Scalar=T is enabled.
  IF (HAVE_COMPLEX_BLAS)
    IF (HAVE_TPETRA_FLOAT)
      GLOBAL_SET(HAVE_TPETRA_COMPLEX_FLOAT ON)
    ENDIF ()
    IF (HAVE_TPETRA_DOUBLE)
      GLOBAL_SET(HAVE_TPETRA_COMPLEX_DOUBLE ON)
    ENDIF ()
  ELSE()
    GLOBAL_SET(HAVE_TPETRA_COMPLEX_FLOAT OFF)
    GLOBAL_SET(HAVE_TPETRA_COMPLEX_DOUBLE OFF)
  ENDIF() # HAVE_COMPLEX_BLAS

  # Only test Scalar=__float128 if 'quadmath' TPL is enabled and CUDA
  # is disabled.  (See discussion above about why the two don't work
  # together.)
  ASSERT_DEFINED (${PACKAGE_NAME}_ENABLE_quadmath)
  IF (${PACKAGE_NAME}_ENABLE_quadmath AND NOT ${PACKAGE_NAME}_ENABLE_CUDA)
    # FIXME (mfh 19 Mar 2015) It doesn't currently build.
    # Once it does, set this to ON.
    GLOBAL_SET (HAVE_TPETRA_FLOAT128 OFF)
  ELSE ()
    GLOBAL_SET (HAVE_TPETRA_FLOAT128 OFF)
  ENDIF ()

  # Both dd_real and qd_real live in the QD TPL.
  IF (${PACKAGE_NAME}_ENABLE_QD)
    GLOBAL_SET(HAVE_TPETRA_DD_REAL ON)
    GLOBAL_SET(HAVE_TPETRA_QD_REAL ON)
  ELSE()
    GLOBAL_SET(HAVE_TPETRA_DD_REAL OFF)
    GLOBAL_SET(HAVE_TPETRA_QD_REAL OFF)
  ENDIF()

ENDIF() # whether ETI is enabled

ASSERT_DEFINED(HAVE_TPETRA_SCALAR)
ASSERT_DEFINED(HAVE_TPETRA_GLOBALORDINAL)

#
# Other Tpetra options
#

TRIBITS_ADD_OPTION_AND_DEFINE(
  ${PACKAGE_NAME}_Threaded_MKL
  HAVE_TPETRA_THREADED_MKL
  "Indicates that the linked BLAS is a threaded version of the MKL."
  OFF
  )

TRIBITS_ADD_OPTION_AND_DEFINE(
  Tpetra_THROW_Warnings
  HAVE_TPETRA_THROW_WARNINGS
  "Enable exception throwing for a number of warnings in Tpetra."
  OFF
  )

TRIBITS_ADD_OPTION_AND_DEFINE(
  Tpetra_PRINT_Warnings
  HAVE_TPETRA_PRINT_WARNINGS
  "Enable printing of a number of warnings in Tpetra."
  OFF
  )

TRIBITS_ADD_OPTION_AND_DEFINE(
  Tpetra_THROW_Efficiency_Warnings
  HAVE_TPETRA_THROW_EFFICIENCY_WARNINGS
  "Enable exception throwing for Tpetra efficiency warnings."
  ${Tpetra_THROW_Warnings}
  )

TRIBITS_ADD_OPTION_AND_DEFINE(
  Tpetra_PRINT_Efficiency_Warnings
  HAVE_TPETRA_PRINT_EFFICIENCY_WARNINGS
  "Enable printing of Tpetra efficiency warnings."
  ${Tpetra_PRINT_Warnings}
  )

TRIBITS_ADD_OPTION_AND_DEFINE(
  Tpetra_THROW_Abuse_Warnings
  HAVE_TPETRA_THROW_ABUSE_WARNINGS
  "Enable exception throwing for potential Tpetra abuse warnings."
  ${Tpetra_THROW_Warnings}
  )

TRIBITS_ADD_OPTION_AND_DEFINE(
  Tpetra_PRINT_Abuse_Warnings
  HAVE_TPETRA_PRINT_ABUSE_WARNINGS
  "Enable printing of potential Tpetra abuse warnings."
  ${Tpetra_PRINT_Warnings}
  )

#
# FIXME (mfh 09 Jan 2015) This shouldn't even be an option.  We should
# examine the Map at run time to determine the best hash function to
# use.
#
TRIBITS_ADD_OPTION_AND_DEFINE(
  Tpetra_USE_MURMUR_HASH
  TPETRA_USE_MURMUR_HASH
  "Use the Murmur hash function in Tpetra::Map for global-to-local index lookups, rather than the default hash function.  Murmur hash is more expensive to evaluate, but does a better job of avoiding hash table collisions for Maps that do not look like local permutations of contiguous Maps."
  OFF
  )

TRIBITS_ADD_OPTION_AND_DEFINE(
  Tpetra_ENABLE_Kokkos_DistObject
  TPETRA_ENABLE_KOKKOS_DISTOBJECT
  "Use experimental Kokkos::View for DistObject methods, enabling efficient communication for GPU node types."
  OFF
  )

TRIBITS_ADD_OPTION_AND_DEFINE(
  Tpetra_ENABLE_MPI_CUDA_RDMA
  TPETRA_ENABLE_MPI_CUDA_RDMA
  "Enable RDMA support for MPI communication between CUDA GPUs.  Only turn this on if you know for sure your MPI library supports it.  Requires also enabling Tpetra_ENABLE_Kokkos_DistObject."
  OFF
  )

TRIBITS_ADD_OPTION_AND_DEFINE(
  Tpetra_ENABLE_MMM_Timings
  HAVE_TPETRA_MMM_TIMINGS
  "Enable the timings for the MMM kernels"
  OFF
)

# The "Kokkos refactor" version of Tpetra currently requires that
# several Kokkos subpackages be enabled.  These subpackages should be
# enabled by default (as of 08 Jan 2015).  The following test checks
# that the subpackages have been enabled.

ASSERT_DEFINED(Tpetra_ENABLE_Kokkos_Refactor)
IF (Tpetra_ENABLE_Kokkos_Refactor)
  SET(Tpetra_Have_Kokkos_Refactor ON CACHE INTERNAL "")
ELSE()
  SET(Tpetra_Have_Kokkos_Refactor OFF CACHE INTERNAL "")
ENDIF()
# Set corresponding value of CPP macro
GLOBAL_SET(TPETRA_HAVE_KOKKOS_REFACTOR ${Tpetra_Have_Kokkos_Refactor})


TRIBITS_ADD_OPTION_AND_DEFINE(
  Tpetra_ENABLE_Kokkos_Refactor_Map
  TPETRA_USE_KOKKOS_REFACTOR_MAP
  "Enable Tpetra::Map specialization for refactor to new Kokkos interface.  If this option is OFF, you may still use the other Kokkos refactor classes with the old Map implementation."
  OFF
  )

IF (Tpetra_ENABLE_Kokkos_Refactor_Map AND NOT Tpetra_Have_Kokkos_Refactor)
  MESSAGE( FATAL_ERROR "If Tpetra_ENABLE_Kokkos_Refactor_Map is ON, then Tpetra's Kokkos refactor code must be enabled as well.  This requires Tpetra_ENABLE_Kokkos_Refactor to be ON, and the following subpackages to be enabled: KokkosCore, KokkosContainers, KokkosAlgorithms, TeuchosKokkosCompat, TeuchosKokkosComm, and TpetraKernels." )
ENDIF ()

TRIBITS_ADD_OPTION_AND_DEFINE(
  ${PACKAGE_NAME}_ENABLE_RTI
  HAVE_TPETRACORE_RTI
  "Enable Tpetra's Reduction/Transformation Interface (RTI).  It is OFF by default.  Note that RTI is currently incompatible with the new Kokkos wrapper Nodes."
  OFF
  )
IF (${PACKAGE_NAME}_ENABLE_RTI)
  MESSAGE(STATUS "Enabling Tpetra/RTI")
ELSE()
  MESSAGE(STATUS "Not enabling Tpetra/RTI")
ENDIF()

IF (Tpetra_ENABLE_Kokkos_Refactor AND ${PACKAGE_NAME}_ENABLE_RTI)
  MESSAGE(FATAL_ERROR "You enabled the Reduction/Transformation Interface (RTI) in Tpetra by setting ${PACKAGE_NAME}_ENABLE_RTI, yet the Kokkos refactor (new) version of Tpetra is enabled.  We have not yet certified RTI for use with the new version of Tpetra.  If you really need RTI right now, you may bring back the old version of Tpetra temporarily by setting Tpetra_ENABLE_Kokkos_Refactor:BOOL=OFF.  Please note that the old version of Tpetra will go away completely with the 12.0 release of Trilinos.")
ENDIF ()

#
# Add libraries, tests, and examples
#

ADD_SUBDIRECTORY(src)
ADD_SUBDIRECTORY(inout)
ADD_SUBDIRECTORY(ext)
IF (${PACKAGE_NAME}_ENABLE_RTI)
  ADD_SUBDIRECTORY(rti)
ENDIF()
 
TRIBITS_ADD_TEST_DIRECTORIES(test)
TRIBITS_ADD_EXAMPLE_DIRECTORIES(example)

GLOBAL_SET(TpetraCore_ETI_SCALARS ${TpetraCore_ETI_SCALARS})
GLOBAL_SET(TpetraCore_ETI_GORDS   ${TpetraCore_ETI_GORDS})
GLOBAL_SET(TpetraCore_ETI_LORDS   ${TpetraCore_ETI_LORDS})
GLOBAL_SET(TpetraCore_ETI_NODES   ${TpetraCore_ETI_NODES})

#
# Do standard subpackage postprocessing
#
TRIBITS_SUBPACKAGE_POSTPROCESS()
