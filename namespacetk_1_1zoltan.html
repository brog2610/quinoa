<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Quinoa: tk::zoltan Namespace Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Quinoa
   
   </div>
   <div id="projectbrief">Adaptive computational fluid dynamics</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Documents</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('namespacetk_1_1zoltan.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">tk::zoltan Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Interoperation with the Zoltan library, used for static mesh partitioning.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1zoltan_1_1_h_g_r_a_p_h___d_a_t_a.html">HGRAPH_DATA</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk_1_1zoltan.html#a42758b1f8fa18345ca7713dd10a25a55">get_number_of_vertices</a> (void *data, int *ierr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Zoltan query function returning the number of objects assigned to an MPI rank.  <a href="#a42758b1f8fa18345ca7713dd10a25a55"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk_1_1zoltan.html#ac644154a08e30f49ad24f7aa7cf42084">get_vertex_list</a> (void *data, int sizeGID, int sizeLID, ZOLTAN_ID_PTR globalID, ZOLTAN_ID_PTR localID, int wgt_dim, float *obj_wgts, int *ierr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Zoltan query function query function to fill two (three if weights are used) arrays with information about the objects assigned to an MPI rank.  <a href="#ac644154a08e30f49ad24f7aa7cf42084"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk_1_1zoltan.html#a3ff02ce57d2e9652de6133d73841bda4">get_hypergraph_size</a> (void *data, int *num_lists, int *num_nonzeros, int *format, int *ierr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Zoltan query function query function which format we will supply the hypergraph.  <a href="#a3ff02ce57d2e9652de6133d73841bda4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk_1_1zoltan.html#a893ff0b3ba9b6ca7e258c270f16a7df3">get_hypergraph</a> (void *data, int sizeGID, int num_edges, int num_nonzeros, int format, ZOLTAN_ID_PTR edgeGID, int *vtxPtr, ZOLTAN_ID_PTR vtxGID, int *ierr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Zoltan query function that returns a hypergraph in a compressed storage (CS) format.  <a href="#a893ff0b3ba9b6ca7e258c270f16a7df3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static std::pair&lt; std::size_t, <br class="typebreak"/>
std::vector&lt; std::size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk_1_1zoltan.html#a294b6e52c7c2630206edf02786baa63f">createHyperGraph</a> (<a class="el" href="classtk_1_1_uns_mesh.html">tk::UnsMesh</a> &amp;graph, <a class="el" href="structtk_1_1zoltan_1_1_h_g_r_a_p_h___d_a_t_a.html">HGRAPH_DATA</a> &amp;hg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk_1_1zoltan.html#a62249062ce66c0a53ecb146cac6779d7">emptyHyperGraph</a> (<a class="el" href="structtk_1_1zoltan_1_1_h_g_r_a_p_h___d_a_t_a.html">HGRAPH_DATA</a> &amp;hg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk_1_1zoltan.html#acebe5c87ef3485f63cec1eea7b5f3c57">destroyHyperGraph</a> (<a class="el" href="structtk_1_1zoltan_1_1_h_g_r_a_p_h___d_a_t_a.html">HGRAPH_DATA</a> &amp;hg, std::size_t nhedge)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector<br class="typebreak"/>
&lt; std::size_t &gt;, std::vector<br class="typebreak"/>
&lt; std::size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk_1_1zoltan.html#a8612e56aedd6fbaf760c5c0a756306ab">partitionMesh</a> (<a class="el" href="classtk_1_1_uns_mesh.html">tk::UnsMesh</a> &amp;graph, uint64_t npart, const <a class="el" href="classtk_1_1_print.html">tk::Print</a> &amp;print)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Partition mesh using Zoltan's hypergraph algorithm in serial.  <a href="#a8612e56aedd6fbaf760c5c0a756306ab"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Interoperation with the Zoltan library, used for static mesh partitioning. </p>
</div><hr/><h2>Function Documentation</h2>
<a class="anchor" id="a294b6e52c7c2630206edf02786baa63f"></a><!-- doxytag: member="tk::zoltan::createHyperGraph" ref="a294b6e52c7c2630206edf02786baa63f" args="(tk::UnsMesh &amp;graph, HGRAPH_DATA &amp;hg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static std::pair&lt; std::size_t, std::vector&lt; std::size_t &gt; &gt; <a class="el" href="namespacetk_1_1zoltan.html#a294b6e52c7c2630206edf02786baa63f">tk::zoltan::createHyperGraph</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtk_1_1_uns_mesh.html">tk::UnsMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HGRAPH_DATA &amp;&#160;</td>
          <td class="paramname"><em>hg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>Unstructured mesh graph object reference </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">inout]</td><td>hg Hypergraph data structure to fill </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of hyperedges in graph, the new-&gt;old mesh point map </dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>This function must not be called on MPI ranks other than zero. </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_zoltan_inter_op_8_c_source.html#l00262">262</a> of file <a class="el" href="_zoltan_inter_op_8_c_source.html">ZoltanInterOp.C</a>.</p>

<p>References <a class="el" href="_zoltan_inter_op_8_c_source.html#l00049">tk::zoltan::HGRAPH_DATA::edgeGID</a>, <a class="el" href="_derived_data_8_c_source.html#l00026">tk::genEsup()</a>, <a class="el" href="_derived_data_8_c_source.html#l00110">tk::genPsup()</a>, <a class="el" href="_zoltan_inter_op_8_c_source.html#l00051">tk::zoltan::HGRAPH_DATA::nborGID</a>, <a class="el" href="_zoltan_inter_op_8_c_source.html#l00050">tk::zoltan::HGRAPH_DATA::nborIndex</a>, <a class="el" href="_zoltan_inter_op_8_c_source.html#l00048">tk::zoltan::HGRAPH_DATA::numAllNbors</a>, <a class="el" href="_zoltan_inter_op_8_c_source.html#l00047">tk::zoltan::HGRAPH_DATA::numMyHEdges</a>, <a class="el" href="_zoltan_inter_op_8_c_source.html#l00045">tk::zoltan::HGRAPH_DATA::numMyVertices</a>, <a class="el" href="_reorder_8_c_source.html#l00044">tk::remap()</a>, <a class="el" href="_reorder_8_c_source.html#l00068">tk::renumber()</a>, <a class="el" href="_uns_mesh_8h_source.html#l00129">tk::UnsMesh::size()</a>, <a class="el" href="_uns_mesh_8h_source.html#l00173">tk::UnsMesh::tetinpoel()</a>, and <a class="el" href="_zoltan_inter_op_8_c_source.html#l00046">tk::zoltan::HGRAPH_DATA::vtxGID</a>.</p>

<p>Referenced by <a class="el" href="_zoltan_inter_op_8_c_source.html#l00366">partitionMesh()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">// Get number of points from graph.</span>
  <span class="keyword">const</span> <span class="keyword">auto</span> npoin = graph.<a class="code" href="classtk_1_1_uns_mesh.html#aa271a359fbefbf064b0df8fdfed43f6e">size</a>();

  <span class="comment">// Create hypergraph data structure based on mesh graph</span>
  hg.numMyVertices = <span class="keyword">static_cast&lt;</span> <span class="keywordtype">int</span> <span class="keyword">&gt;</span>( npoin );
  hg.numMyHEdges = hg.numMyVertices;
  hg.vtxGID = (ZOLTAN_ID_PTR)
    malloc(<span class="keyword">sizeof</span>(ZOLTAN_ID_TYPE) * <span class="keyword">static_cast&lt;</span>std::size_t<span class="keyword">&gt;</span>(hg.numMyVertices));
  hg.edgeGID = (ZOLTAN_ID_PTR)
    malloc(<span class="keyword">sizeof</span>(ZOLTAN_ID_TYPE) * <span class="keyword">static_cast&lt;</span>std::size_t<span class="keyword">&gt;</span>(hg.numMyHEdges));
  hg.nborIndex = (<span class="keywordtype">int</span>*)
    malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>) * <span class="keyword">static_cast&lt;</span>std::size_t<span class="keyword">&gt;</span>(hg.numMyHEdges + 1));

  <span class="comment">// Assign global point ids</span>
  <span class="keywordflow">for</span> (std::size_t i=0; i&lt;static_cast&lt;std::size_t&gt;(hg.numMyVertices); ++i)
    hg.vtxGID[i] = static_cast&lt; ZOLTAN_ID_TYPE &gt;( i );

  <span class="comment">// Get tetrahedron mesh graph connectivity</span>
  <span class="keyword">auto</span>&amp; inpoel = graph.<a class="code" href="classtk_1_1_uns_mesh.html#add64317e28f878c1c7c7ac18aebf1d20">tetinpoel</a>();

  <span class="comment">// Generate (connectivity graph) points surrounding points of graph</span>
  <span class="keyword">auto</span> psup = <a class="code" href="namespacetk.html#ad2a88a65102c17149b44660db15d445b" title="Generate derived data structure, points surrounding points.">tk::genPsup</a>( inpoel, 4, <a class="code" href="namespacetk.html#a66a2889d5d8aeb4a836842c6a1010463" title="Generate derived data structure, elements surrounding points.">tk::genEsup</a>( inpoel, 4 ) );

  <span class="comment">// Renumber mesh points for better data locality</span>
  std::vector&lt; std::size_t &gt; map, invmap;
  std::tie( map, invmap ) = <a class="code" href="namespacetk.html#a1d0312d71017d8ffd9f11811a46e5a16" title="Reorder mesh points with the advancing front technique.">tk::renumber</a>( psup );
  <span class="comment">// Remap element connectivity</span>
  <a class="code" href="namespacetk.html#a5ac2475f6c08b5fcb81392b14aad73a4" title="Reorder mesh point ids in a vector given a new order, i.e., index map.">tk::remap</a>( inpoel, map );
  <span class="comment">// Re-generate points surrounding points</span>
  psup = <a class="code" href="namespacetk.html#ad2a88a65102c17149b44660db15d445b" title="Generate derived data structure, points surrounding points.">tk::genPsup</a>( inpoel, 4, <a class="code" href="namespacetk.html#a66a2889d5d8aeb4a836842c6a1010463" title="Generate derived data structure, elements surrounding points.">tk::genEsup</a>( inpoel, 4 ) );

  <span class="comment">// Allocate data to store the hypergraph ids. The total number of vertices or</span>
  <span class="comment">// neighbors in all the hyperedges of the hypergraph, nhedge = all points</span>
  <span class="comment">// surrounding points + number of points, since psup does not store the</span>
  <span class="comment">// connection to the own point, i.e., in matrix parlance, the main-diagonal.</span>
  <span class="comment">// In other words, here we need the number of edges in the graph, independent</span>
  <span class="comment">// of direction.</span>
  <span class="keyword">auto</span> nhedge = psup.first.size() - 1 + npoin;
  hg.numAllNbors = <span class="keyword">static_cast&lt;</span> <span class="keywordtype">int</span> <span class="keyword">&gt;</span>( nhedge );
  hg.nborGID = (ZOLTAN_ID_PTR)malloc(<span class="keyword">sizeof</span>(ZOLTAN_ID_TYPE) * nhedge);

  <span class="comment">// Fill up hypergraph edge ids and their indices</span>
  hg.nborIndex[0] = 0;
  <span class="keywordflow">for</span> (std::size_t p=0; p&lt;npoin; ++p) {
    hg.edgeGID[p] = <span class="keyword">static_cast&lt;</span> ZOLTAN_ID_TYPE <span class="keyword">&gt;</span>( p+1 );
    <span class="comment">// put in own point id, i.e., main diagonal</span>
    hg.nborGID[ hg.nborIndex[p] ] = <span class="keyword">static_cast&lt;</span> ZOLTAN_ID_TYPE <span class="keyword">&gt;</span>( p );
    <span class="keywordtype">int</span> j = 1;
    <span class="comment">// put in neighbor point ids, i.e., off-diagonals</span>
    <span class="keywordflow">for</span> (<span class="keyword">auto</span> i=psup.second[p]+1; i&lt;=psup.second[p+1]; ++i, ++j) {
      hg.nborGID[ hg.nborIndex[p] + j ] =
        <span class="keyword">static_cast&lt;</span> ZOLTAN_ID_TYPE <span class="keyword">&gt;</span>( psup.first[i] );
    }
    hg.nborIndex[p+1] = hg.nborIndex[p] + j;
  }

  <span class="keywordflow">return</span> { nhedge, invmap };
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_1_1zoltan_a294b6e52c7c2630206edf02786baa63f_cgraph.svg" width="424" height="291"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="acebe5c87ef3485f63cec1eea7b5f3c57"></a><!-- doxytag: member="tk::zoltan::destroyHyperGraph" ref="acebe5c87ef3485f63cec1eea7b5f3c57" args="(HGRAPH_DATA &amp;hg, std::size_t nhedge)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="namespacetk_1_1zoltan.html#acebe5c87ef3485f63cec1eea7b5f3c57">tk::zoltan::destroyHyperGraph</a> </td>
          <td>(</td>
          <td class="paramtype">HGRAPH_DATA &amp;&#160;</td>
          <td class="paramname"><em>hg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>nhedge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">inout]</td><td>hg Hypergraph data structure to destroy </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nhedge</td><td>Number of hyperedges in graph </td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_zoltan_inter_op_8_c_source.html#l00351">351</a> of file <a class="el" href="_zoltan_inter_op_8_c_source.html">ZoltanInterOp.C</a>.</p>

<p>References <a class="el" href="_zoltan_inter_op_8_c_source.html#l00049">tk::zoltan::HGRAPH_DATA::edgeGID</a>, <a class="el" href="_zoltan_inter_op_8_c_source.html#l00051">tk::zoltan::HGRAPH_DATA::nborGID</a>, <a class="el" href="_zoltan_inter_op_8_c_source.html#l00050">tk::zoltan::HGRAPH_DATA::nborIndex</a>, <a class="el" href="_zoltan_inter_op_8_c_source.html#l00047">tk::zoltan::HGRAPH_DATA::numMyHEdges</a>, <a class="el" href="_zoltan_inter_op_8_c_source.html#l00045">tk::zoltan::HGRAPH_DATA::numMyVertices</a>, and <a class="el" href="_zoltan_inter_op_8_c_source.html#l00046">tk::zoltan::HGRAPH_DATA::vtxGID</a>.</p>

<p>Referenced by <a class="el" href="_zoltan_inter_op_8_c_source.html#l00366">partitionMesh()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (hg.numMyVertices &gt; 0) free( hg.vtxGID );
  <span class="keywordflow">if</span> (hg.numMyHEdges &gt; 0) free( hg.edgeGID );
  <span class="keywordflow">if</span> (hg.numMyHEdges &gt;= 0) free( hg.nborIndex );
  <span class="keywordflow">if</span> (nhedge &gt; 0) free( hg.nborGID );
}
</pre></div>
</div>
</div>
<a class="anchor" id="a62249062ce66c0a53ecb146cac6779d7"></a><!-- doxytag: member="tk::zoltan::emptyHyperGraph" ref="a62249062ce66c0a53ecb146cac6779d7" args="(HGRAPH_DATA &amp;hg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static std::size_t <a class="el" href="namespacetk_1_1zoltan.html#a62249062ce66c0a53ecb146cac6779d7">tk::zoltan::emptyHyperGraph</a> </td>
          <td>(</td>
          <td class="paramtype">HGRAPH_DATA &amp;&#160;</td>
          <td class="paramname"><em>hg</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">inout]</td><td>hg Hypergraph data structure to fill </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of hyperedges in graph </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_zoltan_inter_op_8_c_source.html#l00332">332</a> of file <a class="el" href="_zoltan_inter_op_8_c_source.html">ZoltanInterOp.C</a>.</p>

<p>References <a class="el" href="_zoltan_inter_op_8_c_source.html#l00050">tk::zoltan::HGRAPH_DATA::nborIndex</a>, <a class="el" href="_zoltan_inter_op_8_c_source.html#l00048">tk::zoltan::HGRAPH_DATA::numAllNbors</a>, <a class="el" href="_zoltan_inter_op_8_c_source.html#l00047">tk::zoltan::HGRAPH_DATA::numMyHEdges</a>, and <a class="el" href="_zoltan_inter_op_8_c_source.html#l00045">tk::zoltan::HGRAPH_DATA::numMyVertices</a>.</p>

<p>Referenced by <a class="el" href="_zoltan_inter_op_8_c_source.html#l00366">partitionMesh()</a>.</p>
<div class="fragment"><pre class="fragment">{
  hg.numMyVertices = 0;
  hg.numMyHEdges = hg.numMyVertices;
  hg.numAllNbors = 0;
  hg.nborIndex = (<span class="keywordtype">int</span>*)
    malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>) * <span class="keyword">static_cast&lt;</span>std::size_t<span class="keyword">&gt;</span>(hg.numMyHEdges + 1));
  hg.nborIndex[0] = 0;

  <span class="keywordflow">return</span> 0;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a893ff0b3ba9b6ca7e258c270f16a7df3"></a><!-- doxytag: member="tk::zoltan::get_hypergraph" ref="a893ff0b3ba9b6ca7e258c270f16a7df3" args="(void *data, int sizeGID, int num_edges, int num_nonzeros, int format, ZOLTAN_ID_PTR edgeGID, int *vtxPtr, ZOLTAN_ID_PTR vtxGID, int *ierr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="namespacetk_1_1zoltan.html#a893ff0b3ba9b6ca7e258c270f16a7df3">tk::zoltan::get_hypergraph</a> </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeGID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_nonzeros</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ZOLTAN_ID_PTR&#160;</td>
          <td class="paramname"><em>edgeGID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>vtxPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ZOLTAN_ID_PTR&#160;</td>
          <td class="paramname"><em>vtxGID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ierr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Zoltan query function that returns a hypergraph in a compressed storage (CS) format. </p>
<p>The size and format of the data to be returned must have been supplied to Zoltan using a ZOLTAN_HG_SIZE_CS_FN_TYPE function.</p>
<p>When a hypergraph is distributed across multiple MPI ranks, Zoltan expects that all ranks share a consistent global numbering scheme for hyperedges and vertices. Also, no two ranks should return the same pin (matrix non-zero) in this query function. (Pin ownership is unique.)</p>
<p>This query function is required by all applications using the hypergraph methods of Zoltan (unless they are using the graph-based functions with hypergraph code instead).</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">inout]</td><td>data Pointer to user-defined data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sizeGID</td><td>The number of array entries used to describe a single global ID. This value is the maximum value over all ranks of the parameter NUM_GID_ENTRIES. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_edges</td><td>The number of global IDs that is expected to appear on return in edgeGID. This may correspond to either vertices or (hyper-)edges. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_nonzeros</td><td>The number of pins that is expected to appear on return in vtxGID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>If format is ZOLTAN_COMPRESSED_EDGE, Zoltan expects that hyperedge global IDs will be returned in edgeGID, and that vertex global IDs will be returned in vtxGID. If it is ZOLTAN_COMPRESSED_VERTEX, then vertex global IDs are expected to be returned in edgeGID and hyperedge global IDs are expected to be returned in vtxGID. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">inout]</td><td>edgeGID Upon return, a list of num_edges global IDs. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">inout]</td><td>vtxPtr Upon return, this array contains num_edges integers such that the number of pins specified for hyperedge j (if format is ZOLTAN_COMPRESSED_EDGE) or vertex j (if format is ZOLTAN_COMPRESSED_VERTEX) is vtxPtr[j+1]-vtxPtr[j]. If the format is ZOLTAN_COMPRESSED_EDGE, vtxPtr[j]*sizeGID is the index into the array vtxGID where edge j's pins (vertices belonging to edge j) begin; if the format is ZOLTAN_COMPRESSED_VERTEX, vtxPtr[j]*sizeGID is the index into the array vtxGID where vertex j's pins (edges to which vertex j belongs) begin. Array indices begin at zero. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">inout]</td><td>vtxGID Upon return, a list of num_pins global IDs. This is the list of the pins contained in the hyperedges or vertices listed in vtxGID. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">inout]</td><td>ierr Error code </td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_zoltan_inter_op_8_c_source.html#l00188">188</a> of file <a class="el" href="_zoltan_inter_op_8_c_source.html">ZoltanInterOp.C</a>.</p>

<p>References <a class="el" href="_zoltan_inter_op_8_c_source.html#l00049">tk::zoltan::HGRAPH_DATA::edgeGID</a>, <a class="el" href="_zoltan_inter_op_8_c_source.html#l00051">tk::zoltan::HGRAPH_DATA::nborGID</a>, <a class="el" href="_zoltan_inter_op_8_c_source.html#l00050">tk::zoltan::HGRAPH_DATA::nborIndex</a>, <a class="el" href="_zoltan_inter_op_8_c_source.html#l00048">tk::zoltan::HGRAPH_DATA::numAllNbors</a>, and <a class="el" href="_zoltan_inter_op_8_c_source.html#l00047">tk::zoltan::HGRAPH_DATA::numMyHEdges</a>.</p>

<p>Referenced by <a class="el" href="_zoltan_inter_op_8_c_source.html#l00366">partitionMesh()</a>.</p>
<div class="fragment"><pre class="fragment">{
  HGRAPH_DATA *hg = (HGRAPH_DATA *)data;
  *ierr = ZOLTAN_OK;

  <span class="keywordflow">if</span> ( (num_edges != hg-&gt;numMyHEdges) ||
       (num_nonzeros != hg-&gt;numAllNbors) ||
       (format != ZOLTAN_COMPRESSED_EDGE) )
  {
    *ierr = ZOLTAN_FATAL;
    <span class="keywordflow">return</span>;
  }

  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;num_edges; ++i) {
    edgeGID[i] = hg-&gt;edgeGID[i];
    vtxPtr[i] = hg-&gt;nborIndex[i];
  }

  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;num_nonzeros; ++i) vtxGID[i] = hg-&gt;nborGID[i];
}
</pre></div>
</div>
</div>
<a class="anchor" id="a3ff02ce57d2e9652de6133d73841bda4"></a><!-- doxytag: member="tk::zoltan::get_hypergraph_size" ref="a3ff02ce57d2e9652de6133d73841bda4" args="(void *data, int *num_lists, int *num_nonzeros, int *format, int *ierr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="namespacetk_1_1zoltan.html#a3ff02ce57d2e9652de6133d73841bda4">tk::zoltan::get_hypergraph_size</a> </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>num_lists</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>num_nonzeros</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ierr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Zoltan query function query function which format we will supply the hypergraph. </p>
<p>A hypergraph can be supplied to the Zoltan library in one of two compressed storage formats. Although hypergraphs are often used to represent the structure of sparse matrices, the Zoltan/PHG terminology is purely in terms of vertices and hyperedges (not rows or columns). The two compressed formats are analogous to CRS and CCS for matrices.</p>
<p>In compressed hyperedge format (ZOLTAN_COMPRESSED_EDGE) a list of global hyperedge IDs is provided. Then a single list of the hypergraph pins, is provided. A pin is the connection between a vertex and a hyperedge (corresponds to a nonzero in a sparse matrix). Pins do not have separate IDs but are rather identified by the global ID of the vertex containing the pin, and implicitly also by the hyperedge ID.</p>
<p>The other format is compressed vertex (ZOLTAN_COMPRESSED_VERTEX). In this format a list of vertex global IDs is provided. Then a list of pins ordered by vertex and then by hyperedge is provided. The pin ID in this case is the global ID of the hyperedge in which the pin appears. In both formats, an array must be provided pointing to the start in the list of pins where each hyperedge or vertex begins.</p>
<p>The purpose of this query function is to tell Zoltan in which format we will supply the hypergraph, how many vertices and hyperedges there will be, and how many pins. The actual hypergraph is supplied with a query function of the type ZOLTAN_HG_CS_FN_TYPE.</p>
<p>This query function is required by all applications using the hypergraph methods of Zoltan (unless they are using the graph-based functions with hypergraph code instead). </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">inout]</td><td>data Pointer to user-defined data </td></tr>
    <tr><td class="paramname">inout]</td><td>num_lists Upon return, the number of vertices (if using compressed vertex storage) or hyperedges (if using compressed hyperedge storage) that will be supplied to Zoltan by the MPI rank. </td></tr>
    <tr><td class="paramname">inout]</td><td>num_nonzeros Upon return, the number of pins (connections between vertices and hyperedges) that will be supplied to Zoltan by the MPI rank. </td></tr>
    <tr><td class="paramname">inout]</td><td>format Upon return, the format in which we will provide the hypergraph to Zoltan. The options are ZOLTAN_COMPRESSED_EDGE and ZOLTAN_COMPRESSED_VERTEX. </td></tr>
    <tr><td class="paramname">inout]</td><td>ierr Error code </td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_zoltan_inter_op_8_c_source.html#l00126">126</a> of file <a class="el" href="_zoltan_inter_op_8_c_source.html">ZoltanInterOp.C</a>.</p>

<p>References <a class="el" href="_zoltan_inter_op_8_c_source.html#l00048">tk::zoltan::HGRAPH_DATA::numAllNbors</a>, and <a class="el" href="_zoltan_inter_op_8_c_source.html#l00047">tk::zoltan::HGRAPH_DATA::numMyHEdges</a>.</p>

<p>Referenced by <a class="el" href="_zoltan_inter_op_8_c_source.html#l00366">partitionMesh()</a>.</p>
<div class="fragment"><pre class="fragment">{
  HGRAPH_DATA *hg = (HGRAPH_DATA *)data;
  *ierr = ZOLTAN_OK;

  *num_lists = hg-&gt;numMyHEdges;
  *num_nonzeros = hg-&gt;numAllNbors;

  <span class="comment">// We will provide a compressed hyperedge (row) format. The alternative is</span>
  <span class="comment">// compressed vertex (column) format: ZOLTAN_COMPRESSED_VERTEX.</span>
  *format = ZOLTAN_COMPRESSED_EDGE;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a42758b1f8fa18345ca7713dd10a25a55"></a><!-- doxytag: member="tk::zoltan::get_number_of_vertices" ref="a42758b1f8fa18345ca7713dd10a25a55" args="(void *data, int *ierr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int <a class="el" href="namespacetk_1_1zoltan.html#a42758b1f8fa18345ca7713dd10a25a55">tk::zoltan::get_number_of_vertices</a> </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ierr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Zoltan query function returning the number of objects assigned to an MPI rank. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">inout]</td><td>data Pointer to user-defined data </td></tr>
    <tr><td class="paramname">inout]</td><td>ierr Error code </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of objects that are assigned to the MPI rank </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_zoltan_inter_op_8_c_source.html#l00055">55</a> of file <a class="el" href="_zoltan_inter_op_8_c_source.html">ZoltanInterOp.C</a>.</p>

<p>References <a class="el" href="_zoltan_inter_op_8_c_source.html#l00045">tk::zoltan::HGRAPH_DATA::numMyVertices</a>.</p>

<p>Referenced by <a class="el" href="_zoltan_inter_op_8_c_source.html#l00366">partitionMesh()</a>.</p>
<div class="fragment"><pre class="fragment">{
  HGRAPH_DATA *hg = (HGRAPH_DATA*)data;
  *ierr = ZOLTAN_OK;
  <span class="keywordflow">return</span> hg-&gt;numMyVertices;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac644154a08e30f49ad24f7aa7cf42084"></a><!-- doxytag: member="tk::zoltan::get_vertex_list" ref="ac644154a08e30f49ad24f7aa7cf42084" args="(void *data, int sizeGID, int sizeLID, ZOLTAN_ID_PTR globalID, ZOLTAN_ID_PTR localID, int wgt_dim, float *obj_wgts, int *ierr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="namespacetk_1_1zoltan.html#ac644154a08e30f49ad24f7aa7cf42084">tk::zoltan::get_vertex_list</a> </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeGID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeLID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ZOLTAN_ID_PTR&#160;</td>
          <td class="paramname"><em>globalID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ZOLTAN_ID_PTR&#160;</td>
          <td class="paramname"><em>localID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>wgt_dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>obj_wgts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>ierr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Zoltan query function query function to fill two (three if weights are used) arrays with information about the objects assigned to an MPI rank. </p>
<p>This Zoltan query function fills two (three if weights are used) arrays with information about the objects assigned to an MPI rank. Both arrays are allocated (and subsequently freed) by Zoltan; their size is determined by a call to a ZOLTAN_NUM_OBJ_FN query function (get_number_of_vertices) to get the array size. For many algorithms, either a ZOLTAN_OBJ_LIST_FN query function or a ZOLTAN_FIRST_OBJ_FN/ZOLTAN_NEXT_OBJ_FN query-function pair must be registered; however, both query options need not be provided. The ZOLTAN_OBJ_LIST_FN is preferred for efficiency. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">inout]</td><td>data Pointer to user-defined data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sizeGID</td><td>The number of array entries used to describe a single global ID. This value is the maximum value over all MPI ranks of the parameter NUM_GID_ENTRIES. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sizeLID</td><td>The number of array entries used to describe a single local ID. This value is the maximum value over all MPI ranks of the parameter NUM_LID_ENTRIES. (It should be zero if local ids are not used.) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">inout]</td><td>globalID Upon return, an array of unique global IDs for all objects assigned to the MPI rank. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">inout]</td><td>localID Upon return, an array of local IDs, the meaning of which can be determined by the application, for all objects assigned to the MPI rank (optional). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wgt_dim</td><td>The number of weights associated with an object (typically 1), or 0 if weights are not requested. This value is set through the parameter OBJ_WEIGHT_DIM. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">inout]</td><td>obj_wgts Upon return, an array of object weights. Weights for object i are stored in obj_wgts[(i-1)*wgt_dim:i*wgt_dim-1]. If wgt_dim=0, the return value of obj_wgts is undefined and may be NULL. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">inout]</td><td>ierr Error code </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of objects that are assigned to the MPI rank </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_zoltan_inter_op_8_c_source.html#l00070">70</a> of file <a class="el" href="_zoltan_inter_op_8_c_source.html">ZoltanInterOp.C</a>.</p>

<p>References <a class="el" href="_zoltan_inter_op_8_c_source.html#l00045">tk::zoltan::HGRAPH_DATA::numMyVertices</a>, and <a class="el" href="_zoltan_inter_op_8_c_source.html#l00046">tk::zoltan::HGRAPH_DATA::vtxGID</a>.</p>

<p>Referenced by <a class="el" href="_zoltan_inter_op_8_c_source.html#l00366">partitionMesh()</a>.</p>
<div class="fragment"><pre class="fragment">{
  HGRAPH_DATA *hg = (HGRAPH_DATA*)data;
  *ierr = ZOLTAN_OK;

  <span class="comment">// Return the IDs of our vertices, but no weights. Zoltan will assume equally</span>
  <span class="comment">// weighted vertices.</span>
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;hg-&gt;numMyVertices; ++i) {
    globalID[i] = hg-&gt;vtxGID[i];
    localID[i] = <span class="keyword">static_cast&lt;</span> ZOLTAN_ID_TYPE <span class="keyword">&gt;</span>( i );
  }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a8612e56aedd6fbaf760c5c0a756306ab"></a><!-- doxytag: member="tk::zoltan::partitionMesh" ref="a8612e56aedd6fbaf760c5c0a756306ab" args="(tk::UnsMesh &amp;graph, uint64_t npart, const tk::Print &amp;print)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; <a class="el" href="namespacetk_1_1zoltan.html#a8612e56aedd6fbaf760c5c0a756306ab">tk::zoltan::partitionMesh</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtk_1_1_uns_mesh.html">tk::UnsMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>npart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtk_1_1_print.html">tk::Print</a> &amp;&#160;</td>
          <td class="paramname"><em>print</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Partition mesh using Zoltan's hypergraph algorithm in serial. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>Unstructured mesh graph object reference </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">npart</td><td>Number of desired graph partitions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">print</td><td>Pretty printer </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Array of chare ownership IDs mapping graph points to concurrent async chares, and new-&gt;old mesh point id map (new: renumbered, old: as in mesh file)</dd></dl>
<p>This function uses Zoltan to partition the mesh graph in serial. It assumes the mesh graph only exists on MPI rank 0. </p>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_zoltan_inter_op_8_c_source.html#l00366">366</a> of file <a class="el" href="_zoltan_inter_op_8_c_source.html">ZoltanInterOp.C</a>.</p>

<p>References <a class="el" href="_exception_m_p_i_8h_source.html#l00041">AssertMPI</a>, <a class="el" href="_zoltan_inter_op_8_c_source.html#l00262">createHyperGraph()</a>, <a class="el" href="_zoltan_inter_op_8_c_source.html#l00351">destroyHyperGraph()</a>, <a class="el" href="_zoltan_inter_op_8_c_source.html#l00332">emptyHyperGraph()</a>, <a class="el" href="_exception_8h_source.html#l00059">ErrChk</a>, <a class="el" href="_exception_m_p_i_8h_source.html#l00059">ErrChkMPI</a>, <a class="el" href="_zoltan_inter_op_8_c_source.html#l00188">get_hypergraph()</a>, <a class="el" href="_zoltan_inter_op_8_c_source.html#l00126">get_hypergraph_size()</a>, <a class="el" href="_zoltan_inter_op_8_c_source.html#l00055">get_number_of_vertices()</a>, <a class="el" href="_zoltan_inter_op_8_c_source.html#l00070">get_vertex_list()</a>, and <a class="el" href="_exception_8h_source.html#l00034">Throw</a>.</p>

<p>Referenced by <a class="el" href="_inciter_setup_8_c_source.html#l00455">inciter::prepareMesh()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">// Initialize the Zoltan library</span>
  <span class="keywordtype">float</span> ver = 0.0;
  <a class="code" href="_exception_m_p_i_8h.html#a3afa50d45842d4814d89150d9518d9db" title="ErrChkMPI macro that only throws an exception if expr fails.">ErrChkMPI</a>( Zoltan_Initialize( 0, <span class="keyword">nullptr</span>, &amp;ver ) == ZOLTAN_OK,
             <span class="stringliteral">&quot;Zoltan could not be initialized&quot;</span> );

  <span class="comment">// Create Zoltan data structure</span>
  <span class="keyword">struct </span>Zoltan_Struct *zz;
  zz = Zoltan_Create( MPI_COMM_WORLD );
  <a class="code" href="_exception_m_p_i_8h.html#ad1c0e4f6ba0562153542fc4232518cfd" title="Assert macro that only throws an exception if expr fails.">AssertMPI</a>( zz != <span class="keyword">nullptr</span>, <span class="stringliteral">&quot;Failed to create Zoltan data structure&quot;</span> );

  <span class="keywordtype">int</span> peid;
  MPI_Comm_rank( MPI_COMM_WORLD, &amp;peid );

  <span class="comment">// Set Zoltan parameters</span>
  Zoltan_Set_Param( zz, <span class="stringliteral">&quot;DEBUG_LEVEL&quot;</span>, <span class="stringliteral">&quot;0&quot;</span> );
  Zoltan_Set_Param( zz, <span class="stringliteral">&quot;LB_METHOD&quot;</span>, <span class="stringliteral">&quot;HYPERGRAPH&quot;</span> );
  Zoltan_Set_Param( zz, <span class="stringliteral">&quot;LB_APPROACH&quot;</span>, <span class="stringliteral">&quot;PARTITION&quot;</span> );
  Zoltan_Set_Param( zz, <span class="stringliteral">&quot;HYPERGRAPH_PACKAGE&quot;</span>, <span class="stringliteral">&quot;PHG&quot;</span> );
  Zoltan_Set_Param( zz, <span class="stringliteral">&quot;NUM_GID_ENTRIES&quot;</span>, <span class="stringliteral">&quot;1&quot;</span> );
  Zoltan_Set_Param( zz, <span class="stringliteral">&quot;NUM_LID_ENTRIES&quot;</span>, <span class="stringliteral">&quot;1&quot;</span> );
  Zoltan_Set_Param( zz, <span class="stringliteral">&quot;OBJ_WEIGHT_DIM&quot;</span>, <span class="stringliteral">&quot;0&quot;</span> );
  Zoltan_Set_Param( zz, <span class="stringliteral">&quot;EDGE_WEIGHT_DIM&quot;</span>, <span class="stringliteral">&quot;0&quot;</span> );
  Zoltan_Set_Param( zz, <span class="stringliteral">&quot;RETURN_LISTS&quot;</span>, <span class="stringliteral">&quot;PART&quot;</span> );
  <span class="comment">//Zoltan_Set_Param( zz, &quot;PHG_EDGE_SIZE_THRESHOLD&quot;, &quot;1.0&quot; );</span>
  <span class="comment">//Zoltan_Set_Param( zz, &quot;REMAP&quot;, &quot;0&quot; );</span>
  Zoltan_Set_Param( zz, <span class="stringliteral">&quot;NUM_GLOBAL_PARTS&quot;</span>, std::to_string(npart).c_str() );

  HGRAPH_DATA hg;
  std::size_t nhedge = 0;
  std::vector&lt; std::size_t &gt; invmap;
  <span class="keywordflow">if</span> (peid == 0)  
    std::tie( nhedge, invmap ) = <a class="code" href="namespacetk_1_1zoltan.html#a294b6e52c7c2630206edf02786baa63f">createHyperGraph</a>( graph, hg );
  <span class="keywordflow">else</span>
    nhedge = <a class="code" href="namespacetk_1_1zoltan.html#a62249062ce66c0a53ecb146cac6779d7">emptyHyperGraph</a>( hg );

  <span class="comment">// Set Zoltan query functions</span>
  Zoltan_Set_Num_Obj_Fn( zz, <a class="code" href="namespacetk_1_1zoltan.html#a42758b1f8fa18345ca7713dd10a25a55" title="Zoltan query function returning the number of objects assigned to an MPI rank.">get_number_of_vertices</a>, &amp;hg );
  Zoltan_Set_Obj_List_Fn( zz, <a class="code" href="namespacetk_1_1zoltan.html#ac644154a08e30f49ad24f7aa7cf42084" title="Zoltan query function query function to fill two (three if weights are used) arrays with information ...">get_vertex_list</a>, &amp;hg );
  Zoltan_Set_HG_Size_CS_Fn( zz, <a class="code" href="namespacetk_1_1zoltan.html#a3ff02ce57d2e9652de6133d73841bda4" title="Zoltan query function query function which format we will supply the hypergraph.">get_hypergraph_size</a>, &amp;hg );
  Zoltan_Set_HG_CS_Fn( zz, <a class="code" href="namespacetk_1_1zoltan.html#a893ff0b3ba9b6ca7e258c270f16a7df3" title="Zoltan query function that returns a hypergraph in a compressed storage (CS) format.">get_hypergraph</a>, &amp;hg );

  <span class="comment">// Perform partitioning using Zoltan</span>
  <span class="keywordtype">int</span> changes, numGidEntries, numLidEntries, numImport, numExport;
  ZOLTAN_ID_PTR importGlobalGids, importLocalGids, exportGlobalGids,
                exportLocalGids;
  <span class="keywordtype">int</span> *importProcs, *importToPart, *exportProcs, *exportToPart;
  <span class="keywordtype">int</span> rc =
    Zoltan_LB_Partition(
      zz,                <span class="comment">// Input hypergraph data structure (remaining: output)</span>
      &amp;changes,          <span class="comment">// 1 if partitioning was changed, 0 otherwise</span>
      &amp;numGidEntries,    <span class="comment">// Number of integers used for a global ID</span>
      &amp;numLidEntries,    <span class="comment">// Number of integers used for a local ID</span>
      &amp;numImport,        <span class="comment">// Number of vertices to be sent to me</span>
      &amp;importGlobalGids, <span class="comment">// Global IDs of vertices to be sent to me</span>
      &amp;importLocalGids,  <span class="comment">// Local IDs of vertices to be sent to me</span>
      &amp;importProcs,      <span class="comment">// Process rank for source of each incoming vertex</span>
      &amp;importToPart,     <span class="comment">// New partition for each incoming vertex</span>
      &amp;numExport,        <span class="comment">// Number of vertices I must send to other processes</span>
      &amp;exportGlobalGids, <span class="comment">// Global IDs of the vertices I must send</span>
      &amp;exportLocalGids,  <span class="comment">// Local IDs of the vertices I must send</span>
      &amp;exportProcs,      <span class="comment">// Process to which I send each of the vertices</span>
      &amp;exportToPart );   <span class="comment">// Partition to which each vertex will belong</span>

  <span class="comment">// Destructor lambda</span>
  <span class="keyword">auto</span> destruct = [&amp;]() {
    <a class="code" href="namespacetk_1_1zoltan.html#acebe5c87ef3485f63cec1eea7b5f3c57">destroyHyperGraph</a>( hg, nhedge );    <span class="comment">// destroy hypergraph data structure</span>
    Zoltan_Destroy( &amp;zz );              <span class="comment">// destroy Zoltan data structure</span>
  };

  <span class="keywordflow">if</span> (rc != ZOLTAN_OK) {
    destruct();
    <a class="code" href="_exception_8h.html#a0412f798470c18f503a2c2f63c970ba8" title="Throw macro that always throws an exception.">Throw</a>( <span class="stringliteral">&quot;Zoltan_LB_Partition failed&quot;</span> );
  }

  <span class="comment">// Copy over array of chare IDs corresponding to the ownership of all points</span>
  <span class="comment">// in the mesh graph, i.e., the coloring or chare ids for all mesh nodes</span>
  std::vector&lt; std::size_t &gt; chare;
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> p=0; p&lt;numExport; ++p )
    chare.push_back( static_cast&lt; std::size_t &gt;( exportToPart[p] ) );

  std::size_t nchare = 1;
  <span class="keywordflow">if</span> (peid == 0) {
    <span class="comment">// Find out the number of partitions created by Zoltan</span>
    <span class="keyword">auto</span> minmax = std::minmax_element( begin(chare), end(chare) );
    nchare = *minmax.second - *minmax.first + 1; 

    <a class="code" href="_exception_8h.html#ac75cd6578896829d2bfbccf5de71de4f" title="ErrChk macro that only throws an exception if expr fails.">ErrChk</a>( npart == nchare,
      <span class="stringliteral">&quot;The number of parts returned from the graph partitioner (&quot;</span> +
      std::to_string(nchare) + <span class="stringliteral">&quot;) does not equal the number of work units &quot;</span>
      <span class="stringliteral">&quot;computed (&quot;</span> + std::to_string(npart) + <span class="stringliteral">&quot;) based on the degree of &quot;</span>
      <span class="stringliteral">&quot;virtualization desired. This is an indication of a too large &quot;</span>
      <span class="stringliteral">&quot;overdecomposition. Solution 1: decrease the virtualization to a lower &quot;</span>
      <span class="stringliteral">&quot;value using the command-line arrgument &#39;-u&#39;. Solution 2: decrease the &quot;</span>
      <span class="stringliteral">&quot;number processing elements (PEs) using the charmrun command-line &quot;</span>
      <span class="stringliteral">&quot;argument &#39;+pN&#39; where N is the number of PEs, which implicitly increases &quot;</span>
      <span class="stringliteral">&quot;the size (and thus decreases the number) of work units.&quot;</span> );
  }

<span class="comment">//   if (peid == 0) {</span>
<span class="comment">//     std::cout &lt;&lt; &quot;\nchp: &quot;;</span>
<span class="comment">//     for (auto i : chare) std::cout &lt;&lt; i &lt;&lt; &quot; &quot;;</span>
<span class="comment">//     std::cout &lt;&lt; &#39;\n&#39;;</span>
<span class="comment">//   }</span>

  <span class="comment">// Free the arrays allocated by Zoltan_LB_Partition</span>
  Zoltan_LB_Free_Part( &amp;importGlobalGids, &amp;importLocalGids, &amp;importProcs,
                       &amp;importToPart );
  Zoltan_LB_Free_Part( &amp;exportGlobalGids, &amp;exportLocalGids, &amp;exportProcs,
                       &amp;exportToPart);

  <span class="comment">// Free hypergraph and Zoltan data structure</span>
  destruct();

  <span class="keywordflow">return</span> { chare, invmap };
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="namespacetk_1_1zoltan_a8612e56aedd6fbaf760c5c0a756306ab_cgraph.svg" width="100%" height="391"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
</p>

</div>
</div>
</div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespacetk.html">tk</a>      </li>
      <li class="navelem"><a class="el" href="namespacetk_1_1zoltan.html">zoltan</a>      </li>

    <li class="footer">Generated on Tue Jul 7 2015 00:09:51 for Quinoa by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
