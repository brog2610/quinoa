//******************************************************************************
/*!
  \file      src/LinSys/linsysmerger.ci
  \author    J. Bakosi
  \date      Thu 11 Feb 2016 02:06:03 PM MST
  \copyright 2012-2015, Jozsef Bakosi, 2016, Los Alamos National Security, LLC.
  \brief     Charm++ module interface file for merging a linear system
  \details   Charm++ module interface file for merging a linear system
*/
//******************************************************************************

module linsysmerger {

  extern module conductor;

  namespace tk {

    // List all possible specializations of templated chare to instantiate
    // registration and delivery of code for the individual specializations

    // Will specialize linear system merger for inciter's Conductor & Performer
    chare LinSysMerger< inciter::CProxy_Conductor, inciter::CProxy_Performer >;

    // LinSysMerger is templated so that the same code (parameterized by the
    // type given by the template arguments, HostProxy and WorkerProxy) can be
    // generated for different types of proxies. Howver, all possible
    // specializations must be listed above to ensure that Charm++ generates
    // correct code.
    template< class HostProxy, class WorkerProxy >
    group LinSysMerger {
      entry LinSysMerger( const HostProxy& host,
                          const WorkerProxy& worker,
                          std::size_t ncomp );
      entry void bounds( int pe, std::size_t lower, std::size_t upper );
      entry void enable_wait4rhs();
      entry void addrow( int fromch,
                         int frompe,
                         const std::set< std::size_t >& row );
      entry void recrow();
      entry void addsol( int fromch,
                         const std::map< std::size_t,
                                         std::vector< tk::real > >& sol );
      entry void addlhs( int fromch,
        const std::map< std::size_t,
                        std::map< std::size_t,
                                  std::vector< tk::real > > >& lhs );
      entry void addrhs( int fromch,
                         const std::map< std::size_t,
                                         std::vector< tk::real > >& rhs );
      entry void rowsreceived();

      // SDAG code follows. See http://charm.cs.illinois.edu/manuals/html/
      // charm++/manual.html, Sec. "Structured Control Flow: Structured Dagger".

      // High-level overview of the dependency and asynchronous call structure
      // ---------------------------------------------------------------------
      //
      // Directed Acyclic Graph (DAG):        DAG legend:
      // -----------------------------          WPe  - Query worker PEs
      //                                        Sys  - Create linear system
      // WPe -- Pts                             Pts  - Export mesh points
      //           \                            Init - Initialized
      // Sys ------ Init
      //
      // Interpretation of the above DAG
      // -------------------------------
      // Control flow is from left to right and top to bottom.
      //

      entry void wait4sol()
      { when trigger_sol_complete() serial "hypresol" { hypresol(); } };
      entry void wait4lhs()
      { when trigger_lhs_complete() serial "hyprelhs" { hyprelhs(); } };
      entry void wait4rhs()
      { when trigger_rhs_complete() serial "hyprerhs" { hyprerhs(); } };

      entry void wait4hypresol()
      { when trigger_hypresol_complete() serial "sol" { sol(); } };
      entry void wait4hyprelhs()
      { when trigger_hyprelhs_complete() serial "lhs" { lhs(); } };
      entry void wait4hyprerhs()
      { when trigger_hyprerhs_complete() serial "rhs" { rhs(); } };

      entry void wait4fillsol()
      { when trigger_fillsol_complete() serial "asmsol" { assemblesol(); } };
      entry void wait4filllhs()
      { when trigger_filllhs_complete() serial "asmlhs" { assemblelhs(); } };
      entry void wait4fillrhs()
      { when trigger_fillrhs_complete() serial "asmrhs" { assemblerhs(); } };

      entry void wait4asm() {
        when trigger_asmsol_complete(),
             trigger_asmlhs_complete(),
             trigger_asmrhs_complete()
        serial "solve" { solve(); }
      };

      entry void trigger_lhs_complete();
      entry void trigger_rhs_complete();
      entry void trigger_sol_complete();
      entry void trigger_hyprelhs_complete();
      entry void trigger_hyprerhs_complete();
      entry void trigger_hypresol_complete();
      entry void trigger_filllhs_complete();
      entry void trigger_fillrhs_complete();
      entry void trigger_fillsol_complete();
      entry void trigger_asmlhs_complete();
      entry void trigger_asmrhs_complete();
      entry void trigger_asmsol_complete();
    };

  } // tk::

}
