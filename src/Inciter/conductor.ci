//******************************************************************************
/*!
  \file      src/Inciter/conductor.ci
  \author    J. Bakosi
  \date      Tue 22 Dec 2015 10:08:33 PM MST
  \copyright 2012-2015, Jozsef Bakosi.
  \brief     Charm++ module interface file for Conductor
  \details   Charm++ module interface file for Conductor
*/
//******************************************************************************

module conductor {

  // List Charm++ modules conductor depends on
  //extern module linearmap;
  //extern module unsmeshmap;
  extern module partitioner;
  extern module spawner;

  include "Types.h";

  namespace inciter {

    chare Conductor {
      entry Conductor();
      entry [reductiontarget] void load( uint64_t nelem );
      entry void addNodes( int pe, const std::vector< std::size_t >& gid );
      entry [reductiontarget] void partition();
      entry [reductiontarget] void flatten();
      entry [reductiontarget] void flattened();
      entry void prepared(
              int pe,
              const std::unordered_map< int, std::vector< std::size_t > >& conn,
              const std::unordered_map< int,
                      std::unordered_map< std::size_t, std::size_t > >& chcid );
      entry void costed( int pe, tk::real c );
      entry [reductiontarget] void created();
      entry [reductiontarget] void rowcomplete();
      entry [reductiontarget] void initcomplete();
      entry [reductiontarget] void evaluateTime();
      entry [reductiontarget] void advance();
      entry [reductiontarget] void finish();
      entry void arrTimestamp(
        const std::vector< std::pair< std::string, tk::real > >& stamp );
      entry void grpTimestamp(
        const std::vector< std::pair< std::string, tk::real > >& stamp );
      entry void arrPerfstat(
        const std::vector< std::pair< std::string, tk::real > >& p );
      entry void grpPerfstat(
        const std::vector< std::pair< std::string, tk::real > >& p );


      // SDAG code follows. See http://charm.cs.illinois.edu/manuals/html/
      // charm++/manual.html, Sec. "Structured Control Flow: Structured Dagger".

      // High-level overview of the dependency and asynchronous call structure
      // ---------------------------------------------------------------------
      //
      // Directed Acyclic Graph (DAG):        DAG legend:
      // -----------------------------          Fla - Node ID flattening
      //                                        Com - Communication map complete
      // Fla --  Re                             Re  - Reorder
      //       /
      // Com --
      //
      // Interpretation of the above DAG
      // -------------------------------
      // Control flow is from left to right and top to bottom. As the above
      // graph shows, we wait for both Fla and Com conditions to be complete
      // before we can start reordering of the nodes.
      //
      // Fla is triggered when all Partitioner chare groups (one on each PE)
      // have access to their part of the unique node IDs, i.e., their chares
      // will contribute to (in the linear system assembly later). This happens
      // when the the unique mesh node IDs, connecting those elements of the
      // mesh graph that have been assigned to the chares assigned to a PE, are
      // ready on a PE, needed for reordering.
      //
      // Com is ready when the communication map, needed for mesh node
      // reordering, is fully built for all PEs. This is done by member
      // functions addNodes() and buildComm(), the former receiveing the unique
      // node IDs, the latter attempting to build the communication map for each
      // PE. While there is only Conductor object, receiving and building the
      // maps are asynchronous and overlap communication and computation. Also
      // all this happens unordered as the IDs from PEs arrive in an unordered
      // fashion.

      entry void wait4setup() {
        when trigger_flatten_complete(),
             trigger_commmap_complete()
        serial {
          reorder();
        }
      };

      entry void trigger_flatten_complete();
      entry void trigger_commmap_complete();
    }

  } // inciter::

}
