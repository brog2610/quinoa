<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Quinoa: tk Namespace Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Quinoa
   
   </div>
   <div id="projectbrief">Adaptive computational fluid dynamics</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Documents</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('namespacetk.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">tk Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Toolkit declarations and definitions for general purpose utilities.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk_1_1ctr.html">ctr</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Toolkit control, general purpose user input to internal data transfer. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk_1_1grm.html">grm</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Toolkit general purpose grammar definition. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk_1_1hypre.html">hypre</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk_1_1mkl.html">mkl</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Toolkit, grammar definition for Intel's Math Kernel Library. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk_1_1rngsse.html">rngsse</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Toolkit, grammar definition for the <a class="el" href="classtk_1_1_r_n_g_s_s_e.html" title="RNGSSE-based random number generator used polymorphically with tk::RNG.">RNGSSE</a> library. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk_1_1tuple.html">tuple</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Tagged tuple allowing tag-based access to tuple members. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk_1_1zoltan.html">zoltan</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Interoperation with the Zoltan library, used for static mesh partitioning. </p>
<br/></td></tr>
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_exception.html">Exception</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic exception class for producing <a href="file:func:line">file:func:line</a> info + call trace.  <a href="classtk_1_1_exception.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1_has_typedef_proxy.html">HasTypedefProxy</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect if T defines type "Proxy".  <a href="structtk_1_1_has_typedef_proxy.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1_has_typedef_alias.html">HasTypedefAlias</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect if T defines type "alias".  <a href="structtk_1_1_has_typedef_alias.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1_has_typedef_expect_type.html">HasTypedefExpectType</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect if T defines type "expect::type".  <a href="structtk_1_1_has_typedef_expect_type.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1_has_function_expect_description.html">HasFunctionExpectDescription</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect if T defines function "expect::description".  <a href="structtk_1_1_has_function_expect_description.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1_has_function_expect_choices.html">HasFunctionExpectChoices</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect if T defines function "expect::choices".  <a href="structtk_1_1_has_function_expect_choices.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1if__.html">if_</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type selection: if_&lt; Condition, Then, Else &gt;::type.  <a href="structtk_1_1if__.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1if___3_01false_00_01_then_00_01_else_01_4.html">if_&lt; false, Then, Else &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1make__list_3_01_t_00_01_args_8_8_8_01_4.html">make_list&lt; T, Args... &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1make__list_3_01_t_01_4.html">make_list&lt; T &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1make__list_3_4.html">make_list&lt;&gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1___make_uniq.html">_MakeUniq</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1___make_uniq_3_01___tp[]_4.html">_MakeUniq&lt; _Tp[]&gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1___make_uniq_3_01___tp[___bound]_4.html">_MakeUniq&lt; _Tp[_Bound]&gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1_msg.html">Msg</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1_strings_msg.html">StringsMsg</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtk_1_1_vec_strs_msg.html">VecStrsMsg</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_particle_properties.html">ParticleProperties</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_print.html">Print</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_reader.html">Reader</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1str__const.html">str_const</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">constexpr string  <a href="classtk_1_1str__const.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_timer.html">Timer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_writer.html">Writer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_control.html">Control</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_file_parser.html">FileParser</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtk_1_1_file_parser.html" title="FileParser.">FileParser</a>.  <a href="classtk_1_1_file_parser.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_string_parser.html">StringParser</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtk_1_1_string_parser.html" title="StringParser.">StringParser</a>.  <a href="classtk_1_1_string_parser.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_toggle.html">Toggle</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtk_1_1_toggle.html" title="Toggle is the base for an Option, doing generic searches.">Toggle</a> is the base for an Option, doing generic searches.  <a href="classtk_1_1_toggle.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_exodus_i_i_mesh_reader.html">ExodusIIMeshReader</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_exodus_i_i_mesh_writer.html">ExodusIIMeshWriter</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_gmsh_mesh_reader.html">GmshMeshReader</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_gmsh_mesh_writer.html">GmshMeshWriter</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_netgen_mesh_reader.html">NetgenMeshReader</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtk_1_1_netgen_mesh_reader.html" title="NetgenMeshReader : tk::Reader.">NetgenMeshReader</a> : <a class="el" href="classtk_1_1_reader.html">tk::Reader</a>.  <a href="classtk_1_1_netgen_mesh_reader.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_netgen_mesh_writer.html">NetgenMeshWriter</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_p_d_f_writer.html">PDFWriter</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtk_1_1_p_d_f_writer.html" title="PDFWriter : Writer.">PDFWriter</a> : <a class="el" href="classtk_1_1_writer.html">Writer</a>.  <a href="classtk_1_1_p_d_f_writer.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_silo_writer.html">SiloWriter</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtk_1_1_silo_writer.html" title="SiloWriter.">SiloWriter</a>.  <a href="classtk_1_1_silo_writer.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_s_t_l_txt_mesh_reader.html">STLTxtMeshReader</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtk_1_1_s_t_l_txt_mesh_reader.html" title="STLTxtMeshReader : tk::Reader.">STLTxtMeshReader</a> : <a class="el" href="classtk_1_1_reader.html">tk::Reader</a>.  <a href="classtk_1_1_s_t_l_txt_mesh_reader.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_txt_stat_writer.html">TxtStatWriter</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtk_1_1_txt_stat_writer.html" title="TxtStatWriter : tk::Writer.">TxtStatWriter</a> : <a class="el" href="classtk_1_1_writer.html">tk::Writer</a>.  <a href="classtk_1_1_txt_stat_writer.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_lin_sys_merger.html">LinSysMerger</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_linear_map.html">LinearMap</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_uns_mesh_map.html">UnsMeshMap</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Charm++ array map for initial placement of array elements using an unstructured grid.  <a href="classtk_1_1_uns_mesh_map.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_driver.html">Driver</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_r_n_g_print.html">RNGPrint</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtk_1_1_r_n_g_print.html" title="RNGPrint : Print.">RNGPrint</a> : <a class="el" href="classtk_1_1_print.html">Print</a>.  <a href="classtk_1_1_r_n_g_print.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_s_t_l_mesh.html">STLMesh</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtk_1_1_s_t_l_mesh.html" title="STLMesh.">STLMesh</a>.  <a href="classtk_1_1_s_t_l_mesh.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_uns_mesh.html">UnsMesh</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">3D unstructured mesh class  <a href="classtk_1_1_uns_mesh.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_m_k_l_r_n_g.html">MKLRNG</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">MKL-based random number generator used polymorphically with <a class="el" href="classtk_1_1_r_n_g.html" title="Random number generator.">tk::RNG</a>.  <a href="classtk_1_1_m_k_l_r_n_g.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_r_n_g.html">RNG</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Random number generator.  <a href="classtk_1_1_r_n_g.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_r_n_g_s_s_e.html">RNGSSE</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">RNGSSE-based random number generator used polymorphically with <a class="el" href="classtk_1_1_r_n_g.html" title="Random number generator.">tk::RNG</a>.  <a href="classtk_1_1_r_n_g_s_s_e.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_r_n_g_stack.html">RNGStack</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Random number generator stack.  <a href="classtk_1_1_r_n_g_stack.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_bi_p_d_f.html">BiPDF</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Joint bivariate PDF estimator.  <a href="classtk_1_1_bi_p_d_f.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_statistics.html">Statistics</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtk_1_1_statistics.html" title="Statistics estimator.">Statistics</a> estimator.  <a href="classtk_1_1_statistics.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_tri_p_d_f.html">TriPDF</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Joint trivariate PDF estimator.  <a href="classtk_1_1_tri_p_d_f.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_uni_p_d_f.html">UniPDF</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Univariate PDF estimator.  <a href="classtk_1_1_uni_p_d_f.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a9cf01baf933877754757512f92cbf819">SiloErrorHandler</a> )(char *)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Silo error handler function type.  <a href="#a9cf01baf933877754757512f92cbf819"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#afcc275d91d4368505f221061b9ba822a">ErrCode</a> { <br/>
&#160;&#160;<a class="el" href="namespacetk.html#afcc275d91d4368505f221061b9ba822aa44683a43d6d73a54b10158203fe65ae3">SUCCESS</a> =  EXIT_SUCCESS, 
<br/>
&#160;&#160;<a class="el" href="namespacetk.html#afcc275d91d4368505f221061b9ba822aac0d05ac793a72e012dcf46dd3d08e6a1">FAILURE</a> =  EXIT_FAILURE
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Error codes for the OS (or whatever calls us)  <a href="namespacetk.html#afcc275d91d4368505f221061b9ba822a">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a1d172b64b84ff0554f0e87475f4541b4">Style</a> { <br/>
&#160;&#160;<a class="el" href="namespacetk.html#a1d172b64b84ff0554f0e87475f4541b4a0d8a63db0fd2f16c716359376f6ef43e">QUIET</a> = 0, 
<br/>
&#160;&#160;<a class="el" href="namespacetk.html#a1d172b64b84ff0554f0e87475f4541b4a4b5fcf1f7bc8b2efb469c3d2374057a2">VERBOSE</a> = 1
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Output verbosity. C-style enum as this is used for template argument.  <a href="namespacetk.html#a1d172b64b84ff0554f0e87475f4541b4">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#aea4fb4c5b5f9f99675ec2f39d25a3482">ExoWriter</a> { <br/>
&#160;&#160;<a class="el" href="namespacetk.html#aea4fb4c5b5f9f99675ec2f39d25a3482a32944105664ee0152ea1c2973449ac92">CREATE</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacetk.html#aea4fb4c5b5f9f99675ec2f39d25a3482a1af0ce1eb2f2fa08a60e6e276faeb720">OPEN</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">ExodusII writer constructor modes.  <a href="namespacetk.html#aea4fb4c5b5f9f99675ec2f39d25a3482">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a85016961456a798f65e4e5a451e44242">GmshElemType</a> { <br/>
&#160;&#160;<a class="el" href="namespacetk.html#a85016961456a798f65e4e5a451e44242a59c586aa6ae7233e39e6b9c67c5d363d">LIN</a> =  1, 
<br/>
&#160;&#160;<a class="el" href="namespacetk.html#a85016961456a798f65e4e5a451e44242a07c22c1f72029ed5466bbb5093f87674">TRI</a> =  2, 
<br/>
&#160;&#160;<a class="el" href="namespacetk.html#a85016961456a798f65e4e5a451e44242a07275767cefe376134a81905435410c1">TET</a> =  4, 
<br/>
&#160;&#160;<a class="el" href="namespacetk.html#a85016961456a798f65e4e5a451e44242aead712f351b8889c92348ee3d7a58125">PNT</a> =  15
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifiers of supported Gmsh elements.  <a href="namespacetk.html#a85016961456a798f65e4e5a451e44242">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#af910e1a2aff3119022dea29cf3d898c1">GmshFileType</a> { <br/>
&#160;&#160;<a class="el" href="namespacetk.html#af910e1a2aff3119022dea29cf3d898c1a3721d646ca908a7affe869dc27727206">UNDEFINED</a> =  -1, 
<br/>
&#160;&#160;<a class="el" href="namespacetk.html#af910e1a2aff3119022dea29cf3d898c1a4829d14bd9b5fd06ebbb1de3371432bc">ASCII</a> =  0, 
<br/>
&#160;&#160;<a class="el" href="namespacetk.html#af910e1a2aff3119022dea29cf3d898c1a1e523c615b893c3f0bab44149d15d3ce">BINARY</a> =  1
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported Gmsh mesh file types.  <a href="namespacetk.html#af910e1a2aff3119022dea29cf3d898c1">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a0661f98cba9daba610596ff8548b9153">MeshReader</a> { <br/>
&#160;&#160;<a class="el" href="namespacetk.html#af939b5fb62841ad69ce26159d7703cc5a455f9201094ecb9c7e6307eeea5ce25c">GMSH</a> = 0, 
<br/>
&#160;&#160;<a class="el" href="namespacetk.html#af939b5fb62841ad69ce26159d7703cc5a1e61700dafa65b3b779b95c5c1c780d3">NETGEN</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacetk.html#af939b5fb62841ad69ce26159d7703cc5aebc46e429998577b749267cf19b0c2d9">EXODUSII</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported mesh readers.  <a href="namespacetk.html#a0661f98cba9daba610596ff8548b9153">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#af939b5fb62841ad69ce26159d7703cc5">MeshWriter</a> { <br/>
&#160;&#160;<a class="el" href="namespacetk.html#af939b5fb62841ad69ce26159d7703cc5a455f9201094ecb9c7e6307eeea5ce25c">GMSH</a> = 0, 
<br/>
&#160;&#160;<a class="el" href="namespacetk.html#af939b5fb62841ad69ce26159d7703cc5a1e61700dafa65b3b779b95c5c1c780d3">NETGEN</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacetk.html#af939b5fb62841ad69ce26159d7703cc5aebc46e429998577b749267cf19b0c2d9">EXODUSII</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported mesh writers.  <a href="namespacetk.html#af939b5fb62841ad69ce26159d7703cc5">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a38b86e8177464be2166539994cac6336">HeaderType</a> { <br/>
&#160;&#160;<a class="el" href="namespacetk.html#a38b86e8177464be2166539994cac6336a360d2bd5dd4a55dddcc5827647e7b3c4">INCITER</a> = 0, 
<br/>
&#160;&#160;<a class="el" href="namespacetk.html#a38b86e8177464be2166539994cac6336a12a2d15c1e06b867909c498ab86f2427">RNGTEST</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacetk.html#a38b86e8177464be2166539994cac6336acab6a685a69507a1a7c531259b1e5c5e">REGTEST</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacetk.html#a38b86e8177464be2166539994cac6336a19206e9715cf12bca9c6986dd6c64720">UNITTEST</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacetk.html#a38b86e8177464be2166539994cac6336ae55ef4c5035bcd7c2bdb76ba7f1cd21a">MESHCONV</a>, 
<br/>
&#160;&#160;<a class="el" href="namespacetk.html#a38b86e8177464be2166539994cac6336a9997076bb092e2fad82749161bf4cda8">WALKER</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Executable types for which an ascii logo is available in <a class="el" href="classtk_1_1_print.html">tk::Print</a>.  <a href="namespacetk.html#a38b86e8177464be2166539994cac6336">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Container &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#a87af1b002bc711716bd170a714bda211">unique</a> (Container &amp;c)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair<br class="typebreak"/>
&lt; std::string, T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#ad3bb9163d83946edc30eb450deb3b7c7">average</a> (const std::map&lt; std::string, std::vector&lt; T &gt; &gt; &amp;mapvec, const std::string &amp;addendum=&quot;&quot;)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair<br class="typebreak"/>
&lt; std::string, T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#a56ab5269f94bf65a0efcb6be3347325a">variance</a> (const std::map&lt; std::string, std::vector&lt; T &gt; &gt; &amp;mapvec, const std::vector&lt; std::pair&lt; std::string, T &gt; &gt; &amp;avg, const std::string &amp;addendum=&quot;&quot;)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Key , typename Value &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::map&lt; Key, Value &gt;::size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#a6c68c42b8cf1dd91142411308913a13e">lid</a> (const std::map&lt; Key, Value &gt; &amp;map, Key key)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class C , class Key , class Factory , typename... ConstructorArgs&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#a5eccb941ad0c5499c356c717000f1842">record</a> (Factory &amp;f, const Key &amp;key, ConstructorArgs &amp;&amp;...args)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Factory , class Key , class Obj  = typename std::remove_pointer&lt;                        typename Factory::mapped_type::result_type &gt;::type&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; Obj &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#aeb9673379e599043b13fff369dce1402">instantiate</a> (const Factory &amp;f, const Key &amp;key)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Host , class ModelConstructor , class Factory , class Key , typename... ModelConstrArgs&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#a4930b9ae2466cefbb1001f9f055bb177">recordModel</a> (Factory &amp;f, const Key &amp;key, ModelConstrArgs &amp;&amp;...args)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Host , class ModelConstructor , class Factory , class Key , typename ModelConstrArg &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#ae98b4e55f14339c707622a8da43d8ce9">recordModelLate</a> (Factory &amp;f, const Key &amp;key, ModelConstrArg)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Host , class ModelConstructor , class Factory , class Key , typename... ModelConstrArgs&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#a9121bd0e85e99f3eb79010513e9e1760">recordCharmModel</a> (Factory &amp;f, const Key &amp;key, ModelConstrArgs &amp;&amp;...args)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; B, A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#ac2323b3c43edbcc32d55d91100ffc3a6">flip_pair</a> (const std::pair&lt; A, B &gt; &amp;p)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::multimap&lt; B, A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#a42982d289f8edfffa60fa4da8b7b9fdf">flip_map</a> (const std::map&lt; A, B &gt; &amp;src)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp , typename... _Args&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtk_1_1___make_uniq.html">_MakeUniq</a>&lt; _Tp &gt;::__single_object&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#a7d4b15650c1811f0e22a149c4000835e">make_unique</a> (_Args &amp;&amp;...__args)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">std::make_unique for single objects  <a href="#a7d4b15650c1811f0e22a149c4000835e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtk_1_1___make_uniq.html">_MakeUniq</a>&lt; _Tp &gt;::__array&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#a9673c73139b1b3cfb2115976c8d4bda0">make_unique</a> (size_t __num)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">std::make_unique for arrays of unknown bound  <a href="#a9673c73139b1b3cfb2115976c8d4bda0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename _Tp , typename... _Args&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtk_1_1___make_uniq.html">_MakeUniq</a>&lt; _Tp &gt;::__invalid_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#a8f05614e8d8ba124ebe2cec8c19e985c">make_unique</a> (_Args &amp;&amp;...)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable std::make_unique for arrays of known bound.  <a href="#a8f05614e8d8ba124ebe2cec8c19e985c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename Ch , typename Tr &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::basic_ostream&lt; Ch, Tr &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#a1bbb9b08d37f6f5f3bed45effc8fc64e">operator&lt;&lt;</a> (std::basic_ostream&lt; Ch, Tr &gt; &amp;os, const std::vector&lt; T &gt; &amp;t)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Msg &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Msg::value_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#a5d61711de49d010da4785f7cb6ad2d9b">waitfor</a> (const CkFuture &amp;f)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a4d5bfee8e8bdea2bc60e5d725672af09">rm</a> (const std::string &amp;file)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove file from file system.  <a href="#a4d5bfee8e8bdea2bc60e5d725672af09"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#af04df49334286e653e440035c499a8d1">processExceptionCharm</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Process an exception from the Charm++ runtime system.  <a href="#af04df49334286e653e440035c499a8d1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a2a62b5b6880fbd0a011cedf8896b19dc">processExceptionMPI</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Process an exception from the MPI runtime system.  <a href="#a2a62b5b6880fbd0a011cedf8896b19dc"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename Ch , typename Tr , typename std::enable_if&lt; std::is_enum&lt; T &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::basic_ostream&lt; Ch, Tr &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#aabd06aee13370660ff0109b8f8b1958e">operator&lt;&lt;</a> (std::basic_ostream&lt; Ch, Tr &gt; &amp;os, const T &amp;e)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename Ch , typename Tr &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::basic_string&lt; Ch, Tr &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#aa160d13ea2e4a3498916472c3b6cdbb0">operator&lt;&lt;</a> (std::basic_string&lt; Ch, Tr &gt; &amp;lhs, const T &amp;e)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T , typename Ch , typename Tr &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::basic_string&lt; Ch, Tr &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#a7adfa2dfb8b3a38f60ac0edf5666b6c4">operator&lt;&lt;</a> (std::basic_string&lt; Ch, Tr &gt; &amp;&amp;lhs, const T &amp;e)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtk_1_1_timer_1_1_watch.html">Timer::Watch</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#ad6260a3dcdcb9a995a4886e566b665c4">hms</a> (tk::real stamp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert existing time stamp as a real to Watch (global scope)  <a href="#ad6260a3dcdcb9a995a4886e566b665c4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Tag &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">tk::real&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#ab964262adcc6f9ebdf8545891d9b4725">query</a> (const std::map&lt; Tag, <a class="el" href="classtk_1_1_timer.html">Timer</a> &gt; &amp;timers, Tag t)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#ab602857e33f89cab4cc3788576ab1519">cross</a> (const std::array&lt; T, 3 &gt; &amp;v1, const std::array&lt; T, 3 &gt; &amp;v2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#a77ef9600b5075a8bbee89b6e4991fd69">crossdiv</a> (const std::array&lt; T, 3 &gt; &amp;v1, const std::array&lt; T, 3 &gt; &amp;v2, T j)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#aeaca2df70ee950c576f6d74e1eb42caa">dot</a> (const std::array&lt; T, 3 &gt; &amp;v1, const std::array&lt; T, 3 &gt; &amp;v2)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#ae5b04b00aa51667b944b7188545ec5ae">triple</a> (const std::array&lt; T, 3 &gt; &amp;v1, const std::array&lt; T, 3 &gt; &amp;v2, const std::array&lt; T, 3 &gt; &amp;v3)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetk.html#a0661f98cba9daba610596ff8548b9153">MeshReader</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a08e7ddf794b944c7d2095c1222f4244a">detectInput</a> (const std::string &amp;filename)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect input mesh file type.  <a href="#a08e7ddf794b944c7d2095c1222f4244a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetk.html#af939b5fb62841ad69ce26159d7703cc5">MeshWriter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a64b09f52ea3b4314e449e70255837836">pickOutput</a> (const std::string &amp;filename)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine output mesh file type.  <a href="#a64b09f52ea3b4314e449e70255837836"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtk_1_1_uns_mesh.html">UnsMesh</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#aed9a0acd7495c7400aa3d167715ba3be">readUnsMesh</a> (const std::string &amp;filename, std::pair&lt; std::string, tk::real &gt; &amp;timestamp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read unstructured mesh from file.  <a href="#aed9a0acd7495c7400aa3d167715ba3be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a69a706a859b7a7c33973877b65de42ed">writeUnsMesh</a> (const std::string &amp;filename, const <a class="el" href="classtk_1_1_uns_mesh.html">UnsMesh</a> &amp;mesh, std::pair&lt; std::string, tk::real &gt; &amp;timestamp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write unstructured mesh to file.  <a href="#a69a706a859b7a7c33973877b65de42ed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a20ee8c554da198c14efbb80a0b623a4a">SiloError</a> (char *msg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Silo error handler.  <a href="#a20ee8c554da198c14efbb80a0b623a4a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::map<br class="typebreak"/>
&lt; std::size_t, std::vector<br class="typebreak"/>
&lt; std::size_t &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a9e673ba34e4398c95190bfa42391d101">poinCommMaps</a> (const <a class="el" href="classtk_1_1_uns_mesh.html">tk::UnsMesh</a> &amp;graph, const std::vector&lt; std::size_t &gt; &amp;chp, const std::vector&lt; std::size_t &gt; &amp;tetinpoel, std::size_t nchare, std::string &amp;&amp;toofine)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute point-based communication maps.  <a href="#a9e673ba34e4398c95190bfa42391d101"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::map<br class="typebreak"/>
&lt; std::size_t, std::vector<br class="typebreak"/>
&lt; std::size_t &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#ac0fc2ea438d61a85d64157bc20efdb7c">elemCommMaps</a> (const std::vector&lt; std::size_t &gt; &amp;chp, const std::vector&lt; std::size_t &gt; &amp;tetinpoel, const std::vector&lt; std::vector&lt; std::size_t &gt; &gt; &amp;element, std::size_t nchare)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute element-based communication maps.  <a href="#ac0fc2ea438d61a85d64157bc20efdb7c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#ae484074849c5c9532282fc9fa4e19467">linearLoadDistributor</a> (tk::real virtualization, uint64_t load, int npe, uint64_t &amp;chunksize, uint64_t &amp;remainder)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute linear load distribution for given total work and virtualization.  <a href="#ae484074849c5c9532282fc9fa4e19467"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a8e567fa9a72a1d5d02cea9eb020b192a">workdir</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for POSIX API's getcwd() from unistd.h.  <a href="#a8e567fa9a72a1d5d02cea9eb020b192a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a69ebefad09fa900014b6271b30e8bd5f">curtime</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for the standard C library's gettimeofday() from.  <a href="#a69ebefad09fa900014b6271b30e8bd5f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#afbbf10b984ba3f66b55cc8363c6a2341">echoHeader</a> (const <a class="el" href="classtk_1_1_print.html">Print</a> &amp;print, <a class="el" href="namespacetk.html#a38b86e8177464be2166539994cac6336">HeaderType</a> header)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Echo program header.  <a href="#afbbf10b984ba3f66b55cc8363c6a2341"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#ab72923dba604ccbf4233af3ccafc70b3">echoBuildEnv</a> (const <a class="el" href="classtk_1_1_print.html">Print</a> &amp;print, const std::string &amp;executable)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Echo build environment.  <a href="#ab72923dba604ccbf4233af3ccafc70b3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a991ea7a4015fef3262bdb056f840bf82">echoRunEnv</a> (const <a class="el" href="classtk_1_1_print.html">Print</a> &amp;print, int argc, char **argv, bool verbose)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Echo runtime environment.  <a href="#a991ea7a4015fef3262bdb056f840bf82"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Driver , class Printer , class CmdLine &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtk_1_1_driver.html">Driver</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetk.html#af9d21933fc9e1a656db37419b2173f5f">Main</a> (int argc, char *argv[], const CmdLine &amp;cmdline, <a class="el" href="namespacetk.html#a38b86e8177464be2166539994cac6336">HeaderType</a> header, const std::string &amp;executable, const Printer &amp;print)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic <a class="el" href="namespacetk.html#af9d21933fc9e1a656db37419b2173f5f" title="Generic Main() used for all executables for code-reuse and a uniform output.">Main()</a> used for all executables for code-reuse and a uniform output.  <a href="#af9d21933fc9e1a656db37419b2173f5f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector<br class="typebreak"/>
&lt; std::size_t &gt;, std::vector<br class="typebreak"/>
&lt; std::size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a66a2889d5d8aeb4a836842c6a1010463">genEsup</a> (const std::vector&lt; std::size_t &gt; &amp;inpoel, std::size_t nnpe)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate derived data structure, elements surrounding points.  <a href="#a66a2889d5d8aeb4a836842c6a1010463"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector<br class="typebreak"/>
&lt; std::size_t &gt;, std::vector<br class="typebreak"/>
&lt; std::size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#ad2a88a65102c17149b44660db15d445b">genPsup</a> (const std::vector&lt; std::size_t &gt; &amp;inpoel, std::size_t nnpe, const std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; &amp;esup)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate derived data structure, points surrounding points.  <a href="#ad2a88a65102c17149b44660db15d445b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector<br class="typebreak"/>
&lt; std::size_t &gt;, std::vector<br class="typebreak"/>
&lt; std::size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#adb7a88611b67f7c809f2bba5c794df0b">genEdsup</a> (const std::vector&lt; std::size_t &gt; &amp;inpoel, std::size_t nnpe, const std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; &amp;esup)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate derived data structure, edges surrounding points.  <a href="#adb7a88611b67f7c809f2bba5c794df0b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a559eb56e40ec844767bd2a55da55bda0">genInpoed</a> (const std::vector&lt; std::size_t &gt; &amp;inpoel, std::size_t nnpe, const std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; &amp;esup)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate derived data structure, edge connectivity.  <a href="#a559eb56e40ec844767bd2a55da55bda0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector<br class="typebreak"/>
&lt; std::size_t &gt;, std::vector<br class="typebreak"/>
&lt; std::size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a9d835a7a93970d17a66356b64f3291af">genEsupel</a> (const std::vector&lt; std::size_t &gt; &amp;inpoel, std::size_t nnpe, const std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; &amp;esup)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate derived data structure, elements surrounding points of elements.  <a href="#a9d835a7a93970d17a66356b64f3291af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector<br class="typebreak"/>
&lt; std::size_t &gt;, std::vector<br class="typebreak"/>
&lt; std::size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a7b12aff8f884c70e45c6037b4f37e662">genEsuel</a> (const std::vector&lt; std::size_t &gt; &amp;inpoel, std::size_t nnpe, const std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; &amp;esup)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate derived data structure, elements surrounding elements.  <a href="#a7b12aff8f884c70e45c6037b4f37e662"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a7c8a720dd257388a44d5ca7af7aaec8f">genInedel</a> (const std::vector&lt; std::size_t &gt; &amp;inpoel, std::size_t nnpe, const std::vector&lt; std::size_t &gt; &amp;inpoed)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate derived data structure, edges of elements.  <a href="#a7c8a720dd257388a44d5ca7af7aaec8f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector<br class="typebreak"/>
&lt; std::size_t &gt;, std::vector<br class="typebreak"/>
&lt; std::size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#abff39252e99681eebb5ccf0078b7b924">genEsued</a> (const std::vector&lt; std::size_t &gt; &amp;inpoel, std::size_t nnpe, const std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; &amp;esup)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate derived data structure, elements surrounding edges.  <a href="#abff39252e99681eebb5ccf0078b7b924"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a22d7126404fbcf649fef98a747264305">shiftToZero</a> (std::vector&lt; std::size_t &gt; &amp;inpoel)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift node IDs to start with zero in element connectivity.  <a href="#a22d7126404fbcf649fef98a747264305"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a5ac2475f6c08b5fcb81392b14aad73a4">remap</a> (std::vector&lt; std::size_t &gt; &amp;id, const std::vector&lt; std::size_t &gt; &amp;newid)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder mesh point ids in a vector given a new order, i.e., index map.  <a href="#a5ac2475f6c08b5fcb81392b14aad73a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector<br class="typebreak"/>
&lt; std::size_t &gt;, std::vector<br class="typebreak"/>
&lt; std::size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a1d0312d71017d8ffd9f11811a46e5a16">renumber</a> (const std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; &amp;psup)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder mesh points with the advancing front technique.  <a href="#a1d0312d71017d8ffd9f11811a46e5a16"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#af9ca17aedbef10f63fdfdee06f57e29c">CSTYLE_STRLEN</a> = 1024</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a077f896b0c19528996cde33d4052eddc">ParEqComp</a> = 0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Tags for selecting data layout policies.  <a href="#a077f896b0c19528996cde33d4052eddc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetk.html#a146fc5751a35f82672bf193ee6048719">EqCompPar</a> = 1</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Toolkit declarations and definitions for general purpose utilities. </p>
</div><hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a9cf01baf933877754757512f92cbf819"></a><!-- doxytag: member="tk::SiloErrorHandler" ref="a9cf01baf933877754757512f92cbf819" args=")(char *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="namespacetk.html#a9cf01baf933877754757512f92cbf819">tk::SiloErrorHandler</a>)(char *)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Silo error handler function type. </p>

<p>Definition at line <a class="el" href="_silo_writer_8h_source.html#l00023">23</a> of file <a class="el" href="_silo_writer_8h_source.html">SiloWriter.h</a>.</p>

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="afcc275d91d4368505f221061b9ba822a"></a><!-- doxytag: member="tk::ErrCode" ref="afcc275d91d4368505f221061b9ba822a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetk.html#afcc275d91d4368505f221061b9ba822a">tk::ErrCode</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Error codes for the OS (or whatever calls us) </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="afcc275d91d4368505f221061b9ba822aa44683a43d6d73a54b10158203fe65ae3"></a><!-- doxytag: member="SUCCESS" ref="afcc275d91d4368505f221061b9ba822aa44683a43d6d73a54b10158203fe65ae3" args="" -->SUCCESS</em>&nbsp;</td><td>
<p>Everything went fine. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="afcc275d91d4368505f221061b9ba822aac0d05ac793a72e012dcf46dd3d08e6a1"></a><!-- doxytag: member="FAILURE" ref="afcc275d91d4368505f221061b9ba822aac0d05ac793a72e012dcf46dd3d08e6a1" args="" -->FAILURE</em>&nbsp;</td><td>
<p>Exceptions occurred. </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="_exception_8h_source.html#l00063">63</a> of file <a class="el" href="_exception_8h_source.html">Exception.h</a>.</p>
<div class="fragment"><pre class="fragment">             { <a class="code" href="namespacetk.html#afcc275d91d4368505f221061b9ba822aa44683a43d6d73a54b10158203fe65ae3" title="Everything went fine.">SUCCESS</a> = EXIT_SUCCESS, <span class="comment">//!&lt; Everything went fine</span>
<span class="comment"></span>               <a class="code" href="namespacetk.html#afcc275d91d4368505f221061b9ba822aac0d05ac793a72e012dcf46dd3d08e6a1" title="Exceptions occurred.">FAILURE</a> = EXIT_FAILURE  <span class="comment">//!&lt; Exceptions occurred</span>
<span class="comment"></span>};
</pre></div>
</div>
</div>
<a class="anchor" id="aea4fb4c5b5f9f99675ec2f39d25a3482"></a><!-- doxytag: member="tk::ExoWriter" ref="aea4fb4c5b5f9f99675ec2f39d25a3482" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetk.html#aea4fb4c5b5f9f99675ec2f39d25a3482">tk::ExoWriter</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>ExodusII writer constructor modes. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="aea4fb4c5b5f9f99675ec2f39d25a3482a32944105664ee0152ea1c2973449ac92"></a><!-- doxytag: member="CREATE" ref="aea4fb4c5b5f9f99675ec2f39d25a3482a32944105664ee0152ea1c2973449ac92" args="" -->CREATE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aea4fb4c5b5f9f99675ec2f39d25a3482a1af0ce1eb2f2fa08a60e6e276faeb720"></a><!-- doxytag: member="OPEN" ref="aea4fb4c5b5f9f99675ec2f39d25a3482a1af0ce1eb2f2fa08a60e6e276faeb720" args="" -->OPEN</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="_exodus_i_i_mesh_writer_8h_source.html#l00025">25</a> of file <a class="el" href="_exodus_i_i_mesh_writer_8h_source.html">ExodusIIMeshWriter.h</a>.</p>
<div class="fragment"><pre class="fragment">{ <a class="code" href="namespacetk.html#aea4fb4c5b5f9f99675ec2f39d25a3482a32944105664ee0152ea1c2973449ac92">CREATE</a>, <a class="code" href="namespacetk.html#aea4fb4c5b5f9f99675ec2f39d25a3482a1af0ce1eb2f2fa08a60e6e276faeb720">OPEN</a> };
</pre></div>
</div>
</div>
<a class="anchor" id="a85016961456a798f65e4e5a451e44242"></a><!-- doxytag: member="tk::GmshElemType" ref="a85016961456a798f65e4e5a451e44242" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetk.html#a85016961456a798f65e4e5a451e44242">tk::GmshElemType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Identifiers of supported Gmsh elements. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a85016961456a798f65e4e5a451e44242a59c586aa6ae7233e39e6b9c67c5d363d"></a><!-- doxytag: member="LIN" ref="a85016961456a798f65e4e5a451e44242a59c586aa6ae7233e39e6b9c67c5d363d" args="" -->LIN</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a85016961456a798f65e4e5a451e44242a07c22c1f72029ed5466bbb5093f87674"></a><!-- doxytag: member="TRI" ref="a85016961456a798f65e4e5a451e44242a07c22c1f72029ed5466bbb5093f87674" args="" -->TRI</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a85016961456a798f65e4e5a451e44242a07275767cefe376134a81905435410c1"></a><!-- doxytag: member="TET" ref="a85016961456a798f65e4e5a451e44242a07275767cefe376134a81905435410c1" args="" -->TET</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a85016961456a798f65e4e5a451e44242aead712f351b8889c92348ee3d7a58125"></a><!-- doxytag: member="PNT" ref="a85016961456a798f65e4e5a451e44242aead712f351b8889c92348ee3d7a58125" args="" -->PNT</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="_gmsh_mesh_i_o_8h_source.html#l00017">17</a> of file <a class="el" href="_gmsh_mesh_i_o_8h_source.html">GmshMeshIO.h</a>.</p>
<div class="fragment"><pre class="fragment">                  { <a class="code" href="namespacetk.html#a85016961456a798f65e4e5a451e44242a59c586aa6ae7233e39e6b9c67c5d363d">LIN</a> = 1,
                    <a class="code" href="namespacetk.html#a85016961456a798f65e4e5a451e44242a07c22c1f72029ed5466bbb5093f87674">TRI</a> = 2,
                    <a class="code" href="namespacetk.html#a85016961456a798f65e4e5a451e44242a07275767cefe376134a81905435410c1">TET</a> = 4,
                    <a class="code" href="namespacetk.html#a85016961456a798f65e4e5a451e44242aead712f351b8889c92348ee3d7a58125">PNT</a> = 15 };
</pre></div>
</div>
</div>
<a class="anchor" id="af910e1a2aff3119022dea29cf3d898c1"></a><!-- doxytag: member="tk::GmshFileType" ref="af910e1a2aff3119022dea29cf3d898c1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetk.html#af910e1a2aff3119022dea29cf3d898c1">tk::GmshFileType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Supported Gmsh mesh file types. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="af910e1a2aff3119022dea29cf3d898c1a3721d646ca908a7affe869dc27727206"></a><!-- doxytag: member="UNDEFINED" ref="af910e1a2aff3119022dea29cf3d898c1a3721d646ca908a7affe869dc27727206" args="" -->UNDEFINED</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="af910e1a2aff3119022dea29cf3d898c1a4829d14bd9b5fd06ebbb1de3371432bc"></a><!-- doxytag: member="ASCII" ref="af910e1a2aff3119022dea29cf3d898c1a4829d14bd9b5fd06ebbb1de3371432bc" args="" -->ASCII</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="af910e1a2aff3119022dea29cf3d898c1a1e523c615b893c3f0bab44149d15d3ce"></a><!-- doxytag: member="BINARY" ref="af910e1a2aff3119022dea29cf3d898c1a1e523c615b893c3f0bab44149d15d3ce" args="" -->BINARY</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="_gmsh_mesh_i_o_8h_source.html#l00023">23</a> of file <a class="el" href="_gmsh_mesh_i_o_8h_source.html">GmshMeshIO.h</a>.</p>
<div class="fragment"><pre class="fragment">                        { <a class="code" href="namespacetk.html#af910e1a2aff3119022dea29cf3d898c1a3721d646ca908a7affe869dc27727206">UNDEFINED</a> = -1,
                          <a class="code" href="namespacetk.html#af910e1a2aff3119022dea29cf3d898c1a4829d14bd9b5fd06ebbb1de3371432bc">ASCII</a> = 0,
                          <a class="code" href="namespacetk.html#af910e1a2aff3119022dea29cf3d898c1a1e523c615b893c3f0bab44149d15d3ce">BINARY</a> = 1 };
</pre></div>
</div>
</div>
<a class="anchor" id="a38b86e8177464be2166539994cac6336"></a><!-- doxytag: member="tk::HeaderType" ref="a38b86e8177464be2166539994cac6336" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetk.html#a38b86e8177464be2166539994cac6336">tk::HeaderType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Executable types for which an ascii logo is available in <a class="el" href="classtk_1_1_print.html">tk::Print</a>. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a38b86e8177464be2166539994cac6336a360d2bd5dd4a55dddcc5827647e7b3c4"></a><!-- doxytag: member="INCITER" ref="a38b86e8177464be2166539994cac6336a360d2bd5dd4a55dddcc5827647e7b3c4" args="" -->INCITER</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a38b86e8177464be2166539994cac6336a12a2d15c1e06b867909c498ab86f2427"></a><!-- doxytag: member="RNGTEST" ref="a38b86e8177464be2166539994cac6336a12a2d15c1e06b867909c498ab86f2427" args="" -->RNGTEST</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a38b86e8177464be2166539994cac6336acab6a685a69507a1a7c531259b1e5c5e"></a><!-- doxytag: member="REGTEST" ref="a38b86e8177464be2166539994cac6336acab6a685a69507a1a7c531259b1e5c5e" args="" -->REGTEST</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a38b86e8177464be2166539994cac6336a19206e9715cf12bca9c6986dd6c64720"></a><!-- doxytag: member="UNITTEST" ref="a38b86e8177464be2166539994cac6336a19206e9715cf12bca9c6986dd6c64720" args="" -->UNITTEST</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a38b86e8177464be2166539994cac6336ae55ef4c5035bcd7c2bdb76ba7f1cd21a"></a><!-- doxytag: member="MESHCONV" ref="a38b86e8177464be2166539994cac6336ae55ef4c5035bcd7c2bdb76ba7f1cd21a" args="" -->MESHCONV</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a38b86e8177464be2166539994cac6336a9997076bb092e2fad82749161bf4cda8"></a><!-- doxytag: member="WALKER" ref="a38b86e8177464be2166539994cac6336a9997076bb092e2fad82749161bf4cda8" args="" -->WALKER</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="_init_8h_source.html#l00030">30</a> of file <a class="el" href="_init_8h_source.html">Init.h</a>.</p>
<div class="fragment"><pre class="fragment">                      : uint8_t { <a class="code" href="namespacetk.html#a38b86e8177464be2166539994cac6336a360d2bd5dd4a55dddcc5827647e7b3c4">INCITER</a>=0,
                                  <a class="code" href="namespacetk.html#a38b86e8177464be2166539994cac6336a12a2d15c1e06b867909c498ab86f2427">RNGTEST</a>,
                                  <a class="code" href="namespacetk.html#a38b86e8177464be2166539994cac6336acab6a685a69507a1a7c531259b1e5c5e">REGTEST</a>,
                                  <a class="code" href="namespacetk.html#a38b86e8177464be2166539994cac6336a19206e9715cf12bca9c6986dd6c64720">UNITTEST</a>,
                                  <a class="code" href="namespacetk.html#a38b86e8177464be2166539994cac6336ae55ef4c5035bcd7c2bdb76ba7f1cd21a">MESHCONV</a>,
                                  <a class="code" href="namespacetk.html#a38b86e8177464be2166539994cac6336a9997076bb092e2fad82749161bf4cda8">WALKER</a> };
</pre></div>
</div>
</div>
<a class="anchor" id="a0661f98cba9daba610596ff8548b9153"></a><!-- doxytag: member="tk::MeshReader" ref="a0661f98cba9daba610596ff8548b9153" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetk.html#a0661f98cba9daba610596ff8548b9153">tk::MeshReader</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Supported mesh readers. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="af939b5fb62841ad69ce26159d7703cc5a455f9201094ecb9c7e6307eeea5ce25c"></a><!-- doxytag: member="GMSH" ref="af939b5fb62841ad69ce26159d7703cc5a455f9201094ecb9c7e6307eeea5ce25c" args="" -->GMSH</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="af939b5fb62841ad69ce26159d7703cc5a1e61700dafa65b3b779b95c5c1c780d3"></a><!-- doxytag: member="NETGEN" ref="af939b5fb62841ad69ce26159d7703cc5a1e61700dafa65b3b779b95c5c1c780d3" args="" -->NETGEN</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="af939b5fb62841ad69ce26159d7703cc5aebc46e429998577b749267cf19b0c2d9"></a><!-- doxytag: member="EXODUSII" ref="af939b5fb62841ad69ce26159d7703cc5aebc46e429998577b749267cf19b0c2d9" args="" -->EXODUSII</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="_mesh_factory_8h_source.html#l00023">23</a> of file <a class="el" href="_mesh_factory_8h_source.html">MeshFactory.h</a>.</p>
<div class="fragment"><pre class="fragment">                      : uint8_t { <a class="code" href="namespacetk.html#af939b5fb62841ad69ce26159d7703cc5a455f9201094ecb9c7e6307eeea5ce25c">GMSH</a>=0,
                                  <a class="code" href="namespacetk.html#af939b5fb62841ad69ce26159d7703cc5a1e61700dafa65b3b779b95c5c1c780d3">NETGEN</a>,
                                  <a class="code" href="namespacetk_1_1ctr.html#abdf7f48d3f0b49c9493d75f59c0d6218a130b728ec985a6380ea06a1bf2f20aec">EXODUSII</a> };
</pre></div>
</div>
</div>
<a class="anchor" id="af939b5fb62841ad69ce26159d7703cc5"></a><!-- doxytag: member="tk::MeshWriter" ref="af939b5fb62841ad69ce26159d7703cc5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetk.html#af939b5fb62841ad69ce26159d7703cc5">tk::MeshWriter</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Supported mesh writers. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="af939b5fb62841ad69ce26159d7703cc5a455f9201094ecb9c7e6307eeea5ce25c"></a><!-- doxytag: member="GMSH" ref="af939b5fb62841ad69ce26159d7703cc5a455f9201094ecb9c7e6307eeea5ce25c" args="" -->GMSH</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="af939b5fb62841ad69ce26159d7703cc5a1e61700dafa65b3b779b95c5c1c780d3"></a><!-- doxytag: member="NETGEN" ref="af939b5fb62841ad69ce26159d7703cc5a1e61700dafa65b3b779b95c5c1c780d3" args="" -->NETGEN</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="af939b5fb62841ad69ce26159d7703cc5aebc46e429998577b749267cf19b0c2d9"></a><!-- doxytag: member="EXODUSII" ref="af939b5fb62841ad69ce26159d7703cc5aebc46e429998577b749267cf19b0c2d9" args="" -->EXODUSII</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="_mesh_factory_8h_source.html#l00028">28</a> of file <a class="el" href="_mesh_factory_8h_source.html">MeshFactory.h</a>.</p>
<div class="fragment"><pre class="fragment">                      : uint8_t { <a class="code" href="namespacetk.html#af939b5fb62841ad69ce26159d7703cc5a455f9201094ecb9c7e6307eeea5ce25c">GMSH</a>=0,
                                  <a class="code" href="namespacetk.html#af939b5fb62841ad69ce26159d7703cc5a1e61700dafa65b3b779b95c5c1c780d3">NETGEN</a>,
                                  <a class="code" href="namespacetk_1_1ctr.html#abdf7f48d3f0b49c9493d75f59c0d6218a130b728ec985a6380ea06a1bf2f20aec">EXODUSII</a> };
</pre></div>
</div>
</div>
<a class="anchor" id="a1d172b64b84ff0554f0e87475f4541b4"></a><!-- doxytag: member="tk::Style" ref="a1d172b64b84ff0554f0e87475f4541b4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetk.html#a1d172b64b84ff0554f0e87475f4541b4">tk::Style</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Output verbosity. C-style enum as this is used for template argument. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a1d172b64b84ff0554f0e87475f4541b4a0d8a63db0fd2f16c716359376f6ef43e"></a><!-- doxytag: member="QUIET" ref="a1d172b64b84ff0554f0e87475f4541b4a0d8a63db0fd2f16c716359376f6ef43e" args="" -->QUIET</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a1d172b64b84ff0554f0e87475f4541b4a4b5fcf1f7bc8b2efb469c3d2374057a2"></a><!-- doxytag: member="VERBOSE" ref="a1d172b64b84ff0554f0e87475f4541b4a4b5fcf1f7bc8b2efb469c3d2374057a2" args="" -->VERBOSE</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="_print_8h_source.html#l00030">30</a> of file <a class="el" href="_print_8h_source.html">Print.h</a>.</p>
<div class="fragment"><pre class="fragment">{ <a class="code" href="namespacetk.html#a1d172b64b84ff0554f0e87475f4541b4a0d8a63db0fd2f16c716359376f6ef43e">QUIET</a>=0, <a class="code" href="namespacetk.html#a1d172b64b84ff0554f0e87475f4541b4a4b5fcf1f7bc8b2efb469c3d2374057a2">VERBOSE</a>=1 };
</pre></div>
</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ad3bb9163d83946edc30eb450deb3b7c7"></a><!-- doxytag: member="tk::average" ref="ad3bb9163d83946edc30eb450deb3b7c7" args="(const std::map&lt; std::string, std::vector&lt; T &gt; &gt; &amp;mapvec, const std::string &amp;addendum=&quot;&quot;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::string, T &gt; &gt; <a class="el" href="namespacetk.html#ad3bb9163d83946edc30eb450deb3b7c7">tk::average</a> </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; std::string, std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>addendum</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapvec</td><td>Map of vectors associated to labels </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addendum</td><td>Optional string to add to the label </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Vector of pairs of label and average </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_container_util_8h_source.html#l00040">40</a> of file <a class="el" href="_container_util_8h_source.html">ContainerUtil.h</a>.</p>

<p>Referenced by <a class="el" href="_conductor_8_c_source.html#l00166">inciter::Conductor::perfstat()</a>, and <a class="el" href="_conductor_8_c_source.html#l00135">inciter::Conductor::timestamp()</a>.</p>
<div class="fragment"><pre class="fragment">{
  std::vector&lt; std::pair&lt; std::string, T &gt; &gt; s;
  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; t : mapvec) {
    T sum = 0.0;
    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v : t.second) sum += v;
    s.emplace_back( t.first + addendum, sum/static_cast&lt;T&gt;(t.second.size()) );
  }
  <span class="keywordflow">return</span> s;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab602857e33f89cab4cc3788576ab1519"></a><!-- doxytag: member="tk::cross" ref="ab602857e33f89cab4cc3788576ab1519" args="(const std::array&lt; T, 3 &gt; &amp;v1, const std::array&lt; T, 3 &gt; &amp;v2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, 3 &gt; <a class="el" href="namespacetk.html#ab602857e33f89cab4cc3788576ab1519">tk::cross</a> </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compute the cross-product of two vectors </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v1</td><td>1st vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v2</td><td>2nd vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Cross-product </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_vector_8h_source.html#l00020">20</a> of file <a class="el" href="_vector_8h_source.html">Vector.h</a>.</p>

<p>Referenced by <a class="el" href="_vector_8h_source.html#l00067">triple()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> {{ v1[1]*v2[2] - v2[1]*v1[2],
            v1[2]*v2[0] - v2[2]*v1[0],
            v1[0]*v2[1] - v2[0]*v1[1] }};
}
</pre></div>
</div>
</div>
<a class="anchor" id="a77ef9600b5075a8bbee89b6e4991fd69"></a><!-- doxytag: member="tk::crossdiv" ref="a77ef9600b5075a8bbee89b6e4991fd69" args="(const std::array&lt; T, 3 &gt; &amp;v1, const std::array&lt; T, 3 &gt; &amp;v2, T j)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, 3 &gt; <a class="el" href="namespacetk.html#a77ef9600b5075a8bbee89b6e4991fd69">tk::crossdiv</a> </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compute the cross-product of two vectors divided by a scalar </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v1</td><td>1st vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v2</td><td>2nd vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">j</td><td>Scalar to divide each component by </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Cross-product divided by scalar </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_vector_8h_source.html#l00036">36</a> of file <a class="el" href="_vector_8h_source.html">Vector.h</a>.</p>

<p>Referenced by <a class="el" href="_performer_8_c_source.html#l00190">inciter::Performer::rhs()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> {{ (v1[1]*v2[2] - v2[1]*v1[2]) / j,
            (v1[2]*v2[0] - v2[2]*v1[0]) / j,
            (v1[0]*v2[1] - v2[0]*v1[1]) / j }};
}
</pre></div>
</div>
</div>
<a class="anchor" id="a69ebefad09fa900014b6271b30e8bd5f"></a><!-- doxytag: member="tk::curtime" ref="a69ebefad09fa900014b6271b30e8bd5f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static std::string <a class="el" href="namespacetk.html#a69ebefad09fa900014b6271b30e8bd5f">tk::curtime</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wrapper for the standard C library's gettimeofday() from. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A stirng containing the current date and time </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_init_8h_source.html#l00053">53</a> of file <a class="el" href="_init_8h_source.html">Init.h</a>.</p>

<p>References <a class="el" href="_exception_8h_source.html#l00034">Throw</a>.</p>

<p>Referenced by <a class="el" href="_init_8h_source.html#l00137">echoRunEnv()</a>.</p>
<div class="fragment"><pre class="fragment">{
  time_t current_time;
  <span class="keywordtype">char</span>* c_time_string;

  <span class="comment">// Obtain current time as seconds elapsed since the Epoch</span>
  current_time = time( NULL );

  <span class="keywordflow">if</span> (current_time == ((time_t)-1))
    <a class="code" href="_exception_8h.html#a0412f798470c18f503a2c2f63c970ba8" title="Throw macro that always throws an exception.">Throw</a>( <span class="stringliteral">&quot;Failure to compute the current time&quot;</span> );

  <span class="comment">// Convert to local time format</span>
  c_time_string = ctime(&amp;current_time);

  <span class="keywordflow">if</span> (c_time_string == NULL)
    <a class="code" href="_exception_8h.html#a0412f798470c18f503a2c2f63c970ba8" title="Throw macro that always throws an exception.">Throw</a>( <span class="stringliteral">&quot;Failure to convert the current time&quot;</span> );

  <span class="comment">// Convert to std::string and remove trailing newline</span>
  std::string str( c_time_string );
  str.erase( std::remove(str.begin(), str.end(), <span class="charliteral">&#39;\n&#39;</span>), str.end() );

  <span class="keywordflow">return</span> str;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a08e7ddf794b944c7d2095c1222f4244a"></a><!-- doxytag: member="tk::detectInput" ref="a08e7ddf794b944c7d2095c1222f4244a" args="(const std::string &amp;filename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetk.html#a0661f98cba9daba610596ff8548b9153">MeshReader</a> <a class="el" href="namespacetk.html#a08e7ddf794b944c7d2095c1222f4244a">tk::detectInput</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Detect input mesh file type. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>File to open and detect its type </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>enum specifying the mesh reader type </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_mesh_factory_8_c_source.html#l00029">29</a> of file <a class="el" href="_mesh_factory_8_c_source.html">MeshFactory.C</a>.</p>

<p>References <a class="el" href="_mesh_factory_8h_source.html#l00025">EXODUSII</a>, <a class="el" href="_mesh_factory_8h_source.html#l00023">GMSH</a>, <a class="el" href="_mesh_factory_8h_source.html#l00024">NETGEN</a>, <a class="el" href="namespacetut.html#a954afc1dd038ad7d90c112c55218c39b">tut::Reader()</a>, and <a class="el" href="_exception_8h_source.html#l00034">Throw</a>.</p>

<p>Referenced by <a class="el" href="_mesh_factory_8_c_source.html#l00087">readUnsMesh()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">// Get first three letters from input file</span>
  std::string s( <a class="code" href="namespacetut.html#a954afc1dd038ad7d90c112c55218c39b" title="Define test group.">Reader</a>( filename ).firstline().substr(0,3) );

  <span class="keywordflow">if</span> ( s == <span class="stringliteral">&quot;$Me&quot;</span> ) {
    <span class="keywordflow">return</span> <a class="code" href="namespacetk.html#af939b5fb62841ad69ce26159d7703cc5a455f9201094ecb9c7e6307eeea5ce25c">MeshReader::GMSH</a>;
  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( s == <span class="stringliteral">&quot;CDF&quot;</span> || s == <span class="stringliteral">&quot;HDF&quot;</span> ) {
    <span class="keywordflow">return</span> <a class="code" href="namespacetk_1_1ctr.html#abdf7f48d3f0b49c9493d75f59c0d6218a130b728ec985a6380ea06a1bf2f20aec">MeshReader::EXODUSII</a>;
  } <span class="keywordflow">else</span> {
    <span class="keywordflow">try</span> {
      std::stoi(s);    <span class="comment">// try to convert to an integer</span>
    } <span class="keywordflow">catch</span> ( std::invalid_argument ) {
      <a class="code" href="_exception_8h.html#a0412f798470c18f503a2c2f63c970ba8" title="Throw macro that always throws an exception.">Throw</a>( <span class="stringliteral">&quot;Input mesh file type could not be determined from header: &quot;</span> +
             filename );
    }
    <span class="comment">// could also catch std::out_of_range, the other exception potentially</span>
    <span class="comment">// thrown by std::stoi(), but a three-digit integer will always fit into int</span>

    <span class="comment">// if we got here, the above string-to-integer conversion succeeded</span>
    <span class="keywordflow">return</span> <a class="code" href="namespacetk.html#af939b5fb62841ad69ce26159d7703cc5a1e61700dafa65b3b779b95c5c1c780d3">MeshReader::NETGEN</a>;
  }
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_a08e7ddf794b944c7d2095c1222f4244a_cgraph.svg" width="267" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="aeaca2df70ee950c576f6d74e1eb42caa"></a><!-- doxytag: member="tk::dot" ref="aeaca2df70ee950c576f6d74e1eb42caa" args="(const std::array&lt; T, 3 &gt; &amp;v1, const std::array&lt; T, 3 &gt; &amp;v2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="namespacetk.html#aeaca2df70ee950c576f6d74e1eb42caa">tk::dot</a> </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compute the dot-product of two vectors </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v1</td><td>1st vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v2</td><td>2nd vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Dot-product </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_vector_8h_source.html#l00053">53</a> of file <a class="el" href="_vector_8h_source.html">Vector.h</a>.</p>

<p>Referenced by <a class="el" href="_vector_8h_source.html#l00067">triple()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> v1[0]*v2[0] + v1[1]*v2[1] + v1[2]*v2[2];
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab72923dba604ccbf4233af3ccafc70b3"></a><!-- doxytag: member="tk::echoBuildEnv" ref="ab72923dba604ccbf4233af3ccafc70b3" args="(const Print &amp;print, const std::string &amp;executable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="namespacetk.html#ab72923dba604ccbf4233af3ccafc70b3">tk::echoBuildEnv</a> </td>
          <td>(</td>
          <td class="paramtype">const Print &amp;&#160;</td>
          <td class="paramname"><em>print</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>executable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Echo build environment. </p>
<p>Echo information read from &lt;build&gt;/Base/Config.h filled by CMake based on src/Main/Config.h.in. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">print</td><td>Pretty printer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">executable</td><td>Name of the executable </td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_init_8h_source.html#l00106">106</a> of file <a class="el" href="_init_8h_source.html">Init.h</a>.</p>

<p>References <a class="el" href="_print_8h_source.html#l00190">tk::Print::item()</a>, and <a class="el" href="_print_8h_source.html#l00144">tk::Print::section()</a>.</p>

<p>Referenced by <a class="el" href="_inciter_setup_8_c_source.html#l00411">inciter::init()</a>, and <a class="el" href="_init_8h_source.html#l00187">Main()</a>.</p>
<div class="fragment"><pre class="fragment">{
  print.section( <span class="stringliteral">&quot;Build environment&quot;</span> );
  print.item( <span class="stringliteral">&quot;Hostname&quot;</span>, BUILD_HOSTNAME );
  print.item( <span class="stringliteral">&quot;Executable&quot;</span>, executable );
  print.item( <span class="stringliteral">&quot;Version&quot;</span>, VERSION );
  print.item( <span class="stringliteral">&quot;Release&quot;</span>, RELEASE );
  print.item( <span class="stringliteral">&quot;Revision&quot;</span>, GIT_COMMIT );
  print.item( <span class="stringliteral">&quot;CMake build type&quot;</span>, BUILD_TYPE );

<span class="preprocessor">#ifdef NDEBUG</span>
<span class="preprocessor"></span>  print.item( <span class="stringliteral">&quot;Asserts&quot;</span>, <span class="stringliteral">&quot;off (turn on: CMAKE_BUILD_TYPE=DEBUG)&quot;</span> );
  print.item( <span class="stringliteral">&quot;Exception trace&quot;</span>, <span class="stringliteral">&quot;off (turn on: CMAKE_BUILD_TYPE=DEBUG)&quot;</span> );
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>  print.item( <span class="stringliteral">&quot;Asserts&quot;</span>, <span class="stringliteral">&quot;on (turn off: CMAKE_BUILD_TYPE=RELEASE)&quot;</span> );
  print.item( <span class="stringliteral">&quot;Exception trace&quot;</span>, <span class="stringliteral">&quot;on (turn off: CMAKE_BUILD_TYPE=RELEASE)&quot;</span> );
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
  print.item( <span class="stringliteral">&quot;MPI C++ wrapper&quot;</span>, MPI_COMPILER );
  print.item( <span class="stringliteral">&quot;Underlying C++ compiler&quot;</span>, COMPILER );
  print.item( <span class="stringliteral">&quot;Build date&quot;</span>, BUILD_DATE );
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_ab72923dba604ccbf4233af3ccafc70b3_cgraph.svg" width="310" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="afbbf10b984ba3f66b55cc8363c6a2341"></a><!-- doxytag: member="tk::echoHeader" ref="afbbf10b984ba3f66b55cc8363c6a2341" args="(const Print &amp;print, HeaderType header)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="namespacetk.html#afbbf10b984ba3f66b55cc8363c6a2341">tk::echoHeader</a> </td>
          <td>(</td>
          <td class="paramtype">const Print &amp;&#160;</td>
          <td class="paramname"><em>print</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HeaderType&#160;</td>
          <td class="paramname"><em>header</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Echo program header. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">print</td><td>Pretty printer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">header</td><td>Header type enum indicating which header to print </td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_init_8h_source.html#l00082">82</a> of file <a class="el" href="_init_8h_source.html">Init.h</a>.</p>

<p>References <a class="el" href="_print_8h_source.html#l00396">tk::Print::headerInciter()</a>, <a class="el" href="_print_8h_source.html#l00524">tk::Print::headerMeshConv()</a>, <a class="el" href="_print_8h_source.html#l00460">tk::Print::headerRegTest()</a>, <a class="el" href="_print_8h_source.html#l00428">tk::Print::headerRNGTest()</a>, <a class="el" href="_print_8h_source.html#l00492">tk::Print::headerUnitTest()</a>, <a class="el" href="_print_8h_source.html#l00556">tk::Print::headerWalker()</a>, <a class="el" href="_init_8h_source.html#l00030">INCITER</a>, <a class="el" href="_init_8h_source.html#l00034">MESHCONV</a>, <a class="el" href="_init_8h_source.html#l00032">REGTEST</a>, <a class="el" href="_init_8h_source.html#l00031">RNGTEST</a>, <a class="el" href="_exception_8h_source.html#l00034">Throw</a>, <a class="el" href="_init_8h_source.html#l00033">UNITTEST</a>, and <a class="el" href="_init_8h_source.html#l00035">WALKER</a>.</p>

<p>Referenced by <a class="el" href="_inciter_setup_8_c_source.html#l00411">inciter::init()</a>, and <a class="el" href="_init_8h_source.html#l00187">Main()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> ( header == <a class="code" href="namespacetk.html#a38b86e8177464be2166539994cac6336a360d2bd5dd4a55dddcc5827647e7b3c4">HeaderType::INCITER</a> )
    print.headerInciter();
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( header == <a class="code" href="namespacetk.html#a38b86e8177464be2166539994cac6336a12a2d15c1e06b867909c498ab86f2427">HeaderType::RNGTEST</a> )
    print.headerRNGTest();
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( header == <a class="code" href="namespacetk.html#a38b86e8177464be2166539994cac6336acab6a685a69507a1a7c531259b1e5c5e">HeaderType::REGTEST</a> )
    print.headerRegTest();
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( header == <a class="code" href="namespacetk.html#a38b86e8177464be2166539994cac6336a19206e9715cf12bca9c6986dd6c64720">HeaderType::UNITTEST</a> )
    print.headerUnitTest();
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( header == <a class="code" href="namespacetk.html#a38b86e8177464be2166539994cac6336ae55ef4c5035bcd7c2bdb76ba7f1cd21a">HeaderType::MESHCONV</a> )
    print.headerMeshConv();
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( header == <a class="code" href="namespacetk.html#a38b86e8177464be2166539994cac6336a9997076bb092e2fad82749161bf4cda8">HeaderType::WALKER</a> )
    print.headerWalker();
  <span class="keywordflow">else</span>
    <a class="code" href="_exception_8h.html#a0412f798470c18f503a2c2f63c970ba8" title="Throw macro that always throws an exception.">Throw</a>( <span class="stringliteral">&quot;Header not available&quot;</span> );
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_afbbf10b984ba3f66b55cc8363c6a2341_cgraph.svg" width="366" height="291"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a991ea7a4015fef3262bdb056f840bf82"></a><!-- doxytag: member="tk::echoRunEnv" ref="a991ea7a4015fef3262bdb056f840bf82" args="(const Print &amp;print, int argc, char **argv, bool verbose)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="namespacetk.html#a991ea7a4015fef3262bdb056f840bf82">tk::echoRunEnv</a> </td>
          <td>(</td>
          <td class="paramtype">const Print &amp;&#160;</td>
          <td class="paramname"><em>print</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Echo runtime environment. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">print</td><td>Pretty printer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">argc</td><td>Number of command-line arguments to executable </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">argv</td><td>C-style string array to command-line arguments to executable </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbose</td><td>True for verbose screen-output </td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_init_8h_source.html#l00137">137</a> of file <a class="el" href="_init_8h_source.html">Init.h</a>.</p>

<p>References <a class="el" href="_init_8h_source.html#l00053">curtime()</a>, <a class="el" href="_print_8h_source.html#l00190">tk::Print::item()</a>, <a class="el" href="_print_8h_source.html#l00144">tk::Print::section()</a>, and <a class="el" href="_init_8h_source.html#l00038">workdir()</a>.</p>

<p>Referenced by <a class="el" href="_inciter_setup_8_c_source.html#l00411">inciter::init()</a>, and <a class="el" href="_init_8h_source.html#l00187">Main()</a>.</p>
<div class="fragment"><pre class="fragment">{
  print.section( <span class="stringliteral">&quot;Run-time environment&quot;</span> );

  print.item( <span class="stringliteral">&quot;Date, time&quot;</span>, <a class="code" href="namespacetk.html#a69ebefad09fa900014b6271b30e8bd5f" title="Wrapper for the standard C library&#39;s gettimeofday() from.">curtime</a>() );
  print.item( <span class="stringliteral">&quot;Work directory&quot;</span>, <a class="code" href="namespacetk.html#a8e567fa9a72a1d5d02cea9eb020b192a" title="Wrapper for POSIX API&#39;s getcwd() from unistd.h.">workdir</a>() );
  print.item( <span class="stringliteral">&quot;Executable (rel. to work dir)&quot;</span>, argv[0] );

  print.item(<span class="stringliteral">&quot;Command line arguments&quot;</span> );
  print &lt;&lt; <span class="charliteral">&#39;\&#39;&#39;</span>;
  <span class="keywordflow">if</span> (argc&gt;1) {
    <span class="keywordflow">for</span> (<span class="keyword">auto</span> i=1; i&lt;argc-1; ++i) {
      print &lt;&lt; std::string( argv[i] ) + <span class="charliteral">&#39; &#39;</span>;
    }
    print &lt;&lt; std::string( argv[argc-1] );
  }
  print &lt;&lt; <span class="stringliteral">&quot;&#39;\n&quot;</span>;

  print.item( <span class="stringliteral">&quot;Output&quot;</span>, verbose ? <span class="stringliteral">&quot;verbose (quiet: omit -v)&quot;</span> : <span class="stringliteral">&quot;quiet&quot;</span> );
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_a991ea7a4015fef3262bdb056f840bf82_cgraph.svg" width="304" height="190"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ac0fc2ea438d61a85d64157bc20efdb7c"></a><!-- doxytag: member="tk::elemCommMaps" ref="ac0fc2ea438d61a85d64157bc20efdb7c" args="(const std::vector&lt; std::size_t &gt; &amp;chp, const std::vector&lt; std::size_t &gt; &amp;tetinpoel, const std::vector&lt; std::vector&lt; std::size_t &gt; &gt; &amp;element, std::size_t nchare)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::map&lt; std::size_t, std::vector&lt; std::size_t &gt; &gt; &gt; <a class="el" href="namespacetk.html#ac0fc2ea438d61a85d64157bc20efdb7c">tk::elemCommMaps</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>chp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>tetinpoel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; std::size_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>nchare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute element-based communication maps. </p>
<p>Compute element-based communication maps </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">chp</td><td>Array of chare ownership IDs mapping graph points to concurrent async chares </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tetinpoel</td><td>Tetrahedra element connectivity </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">element</td><td>Global mesh element ids owned by each chare </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nchare</td><td>Number of work units (Charm++ chares) </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Element-based communication map for all chares</dd></dl>
<p>This is an _element-based_ export map, because it stores the global ids of the mesh points that chares need to export to fellow chares computed based on which chare owns an element the mesh point is a vertex of. This is for algorithms that work by computing data on the mesh by looping over mesh elements, e.g., element-based algorithms. The communication map computed here is stored in a vector of maps associating a vector of global mesh point ids to chare ids that the points need to be exported to. Using the map produced here amounts to each chare taking its own map indexing the outermost vector with its chare index. The map computed here is an an export map from which the import map can be computed if needed.</p>
<p>In the MPI paradigm, these chare export maps correspond to the export lists, i.e., lists of global ids exported by a given rank to a set of receiver ranks and their associated mesh points sent at which data are to be sent (exported). This is as opposed to import maps which are lists of global ids imported by a given rank to a set of sender ranks and their associated mesh points sent at which data are to be received (imported). For example, in Zoltan, this export/import roughly corresponds to the "exported" and "imported" mesh node ids after partitioning. Actually, Zoltan_LB_Partition() already returns this information. However, if the partitioning with Zoltan is done using less MPI ranks than the number of desired mesh partitions, i.e., overdecomposition (as is the case here), there are more mesh partitions than MPI ranks and thus the arrays returned by Zoltan are not sufficient to determine the export and import maps for all the chares. Thus we compute the export mapping here. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is only supposed to operate on MPI rank 0. </dd>
<dd>
This function does not and should not modify global-scope data. </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_comm_map_8_c_source.html#l00131">131</a> of file <a class="el" href="_comm_map_8_c_source.html">CommMap.C</a>.</p>

<p>Referenced by <a class="el" href="_inciter_setup_8_c_source.html#l00303">inciter::assignMesh()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">// Map to associate a chare id to a map of receiver chare ids associated to</span>
  <span class="comment">// unique global point ids sent (export map)</span>
  std::map&lt; std::size_t,
            std::map&lt; std::size_t, std::set&lt; std::size_t &gt; &gt; &gt; comm;

  <span class="comment">// Construct element-based export maps</span>
  <span class="keywordflow">for</span> (std::size_t c=0; c&lt;element.size(); ++c)
    <span class="keywordflow">for</span> (<span class="keyword">auto</span> e : element[c])
      <span class="keywordflow">for</span> (std::size_t n=0; n&lt;4; ++n) {
        <span class="keyword">auto</span> p = tetinpoel[e*4+n];
        <span class="keywordflow">if</span> (chp[p] != c)      <span class="comment">// if the point-colors differ, store global id</span>
          comm[ c ][ chp[p] ].insert( p );
      }

<span class="comment">//   for (const auto&amp; c : comm) {</span>
<span class="comment">//     std::cout &lt;&lt; c.first &lt;&lt; &quot; -&gt; &quot;;</span>
<span class="comment">//     for (const auto&amp; t : c.second) {</span>
<span class="comment">//       std::cout &lt;&lt; t.first &lt;&lt; &quot;: &quot;;</span>
<span class="comment">//       for (auto p : t.second)</span>
<span class="comment">//         std::cout &lt;&lt; p &lt;&lt; &quot; &quot;;</span>
<span class="comment">//       std::cout &lt;&lt; &quot;, &quot;;</span>
<span class="comment">//     }</span>
<span class="comment">//   std::cout &lt;&lt; &#39;\n&#39;;</span>
<span class="comment">//   }</span>

  <span class="comment">// Construct final product: a vector of export maps associating receiver</span>
  <span class="comment">// chare ids to unique communicated global point ids for all chare ids, and</span>
  <span class="comment">// store it in global scope so that the Charm++ chares can access it</span>
  std::vector&lt; std::map&lt; std::size_t, std::vector&lt; std::size_t &gt; &gt; &gt;
    ecomm( nchare );
  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; e : comm)
    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; x : e.second)
      <span class="keywordflow">for</span> (<span class="keyword">auto</span> p : x.second)
        ecomm[ e.first ][ x.first ].push_back( p );

<span class="comment">//   std::size_t h = 0;</span>
<span class="comment">//   for (const auto&amp; m : ecomm) {</span>
<span class="comment">//     std::cout &lt;&lt; h++ &lt;&lt; &quot; e-&gt; &quot;;</span>
<span class="comment">//     for (const auto&amp; x : m) {</span>
<span class="comment">//       std::cout &lt;&lt; x.first &lt;&lt; &quot;: &quot;;</span>
<span class="comment">//       for (auto p : x.second)</span>
<span class="comment">//         std::cout &lt;&lt; p &lt;&lt; &quot; &quot;;</span>
<span class="comment">//     }</span>
<span class="comment">//     std::cout &lt;&lt; &#39;\n&#39;;</span>
<span class="comment">//   }</span>

  <span class="keywordflow">return</span> ecomm;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a42982d289f8edfffa60fa4da8b7b9fdf"></a><!-- doxytag: member="tk::flip_map" ref="a42982d289f8edfffa60fa4da8b7b9fdf" args="(const std::map&lt; A, B &gt; &amp;src)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::multimap&lt; B, A &gt; <a class="el" href="namespacetk.html#a42982d289f8edfffa60fa4da8b7b9fdf">tk::flip_map</a> </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; A, B &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Flip a std::map of arbitrary types, yielding a std::multimap sorted by std::map::value_type. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>std::map of arbitrary key and value pairs of types A and B </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>std::multimap of arbitrary key and value pairs of types B and A </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_flip__map_8h_source.html#l00031">31</a> of file <a class="el" href="_flip__map_8h_source.html">Flip_map.h</a>.</p>

<p>Referenced by <a class="el" href="_r_n_g_test_print_8h_source.html#l00213">rngtest::RNGTestPrint::cost()</a>, and <a class="el" href="_r_n_g_test_print_8h_source.html#l00235">rngtest::RNGTestPrint::rank()</a>.</p>
<div class="fragment"><pre class="fragment">                                                          {
  std::multimap&lt; B, A &gt; dst;
  std::transform( src.begin(), src.end(), std::inserter(dst, dst.begin()), 
                  flip_pair&lt; A ,B &gt; );
  <span class="keywordflow">return</span> dst;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac2323b3c43edbcc32d55d91100ffc3a6"></a><!-- doxytag: member="tk::flip_pair" ref="ac2323b3c43edbcc32d55d91100ffc3a6" args="(const std::pair&lt; A, B &gt; &amp;p)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; B, A &gt; <a class="el" href="namespacetk.html#ac2323b3c43edbcc32d55d91100ffc3a6">tk::flip_pair</a> </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; A, B &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Flip a std::pair of arbitrary types </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>std::pair of arbitrary types, A and B </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>std::pair of arbitrary types, B and A </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_flip__map_8h_source.html#l00022">22</a> of file <a class="el" href="_flip__map_8h_source.html">Flip_map.h</a>.</p>
<div class="fragment"><pre class="fragment">{ <span class="keywordflow">return</span> std::pair&lt; B, A &gt;( p.second, p.first ); }
</pre></div>
</div>
</div>
<a class="anchor" id="adb7a88611b67f7c809f2bba5c794df0b"></a><!-- doxytag: member="tk::genEdsup" ref="adb7a88611b67f7c809f2bba5c794df0b" args="(const std::vector&lt; std::size_t &gt; &amp;inpoel, std::size_t nnpe, const std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; &amp;esup)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; <a class="el" href="namespacetk.html#adb7a88611b67f7c809f2bba5c794df0b">tk::genEdsup</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>inpoel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>nnpe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>esup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generate derived data structure, edges surrounding points. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inpoel</td><td>Inteconnectivity of points and elements. These are the node ids of each element of an unstructured mesh. Example: <div class="fragment"><pre class="fragment"> {.cpp}
     std::vector&lt; std::size_t &gt; inpoel { 12, 14,  9, 11,
                                         10, 14, 13, 12 };
</pre></div> specifies two tetrahedra whose vertices (node ids) are { 12, 14, 9, 11 }, and { 10, 14, 13, 12 }. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nnpe</td><td>Number of nodes per element (3 or 4) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">esup</td><td>Elements surrounding points as linked lists, see <a class="el" href="namespacetk.html#a66a2889d5d8aeb4a836842c6a1010463" title="Generate derived data structure, elements surrounding points.">tk::genEsup</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Linked lists storing edges (point ids p &lt; q) emanating from points </dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>It is not okay to call this function with an empty container for inpoel or esup.first or esup.second or a non-positive number of nodes per element; it will throw an exception.</dd></dl>
<p>The data generated here is stored in a linked list, more precisely, two linked arrays (vectors), _edsup1_ and _edsup2_, where _edsup2_ holds the indices at which _edsup1_ holds the edge-end point ids emanating from points for all points. The generated data structure, linked lists edsup1 and edsup2, are very similar to psup1 and psup2, generated by <a class="el" href="namespacetk.html#ad2a88a65102c17149b44660db15d445b" title="Generate derived data structure, points surrounding points.">genPsup()</a>, except here only unique edges are stored, i.e., for edges with point ids p &lt; q, only ids q are stored that are still associated to point p. Looping over all unique edges can then be accomplished by the following loop: </p>
<div class="fragment"><pre class="fragment"> {.cpp}
     <span class="keywordflow">for</span> (std::size_t p=0; p&lt;npoin; ++p)
       <span class="keywordflow">for</span> (<span class="keyword">auto</span> i=edsup.second[p]+1; i&lt;=edsup.second[p+1]; ++i)
         use edge with point ids p &lt; edsup.first[i]
</pre></div><p> To find out the number of points, _npoin_, the mesh connectivity, _inpoel_, can be queried: </p>
<div class="fragment"><pre class="fragment"> {.cpp}
     <span class="keyword">auto</span> minmax = std::minmax_element( begin(inpoel), end(inpoel) );
     <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810" title="Assert macro that only throws an exception if expr fails.">Assert</a>( *minmax.first == 0, <span class="stringliteral">&quot;node ids should start from zero&quot;</span> );
     <span class="keyword">auto</span> npoin = *minmax.second + 1;
</pre></div> <dl class="note"><dt><b>Note:</b></dt><dd>At first sight, this function seems to work for elements with more vertices than that of tetrahedra. However, that is not the case since the algorithm for nnpe &gt; 4 would erronously identify any two combination of vertices as a valid edge of an element. Since only triangles and tetrahedra have no internal edges, this algorithm only works for triangle and tetrahedra element connectivity. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespacetk.html#a559eb56e40ec844767bd2a55da55bda0" title="Generate derived data structure, edge connectivity.">tk::genInpoed</a> for similar data that sometimes may be more advantageous </dd>
<dd>
Lohner, An Introduction to Applied CFD Techniques, Wiley, 2008 </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_derived_data_8_c_source.html#l00206">206</a> of file <a class="el" href="_derived_data_8_c_source.html">DerivedData.C</a>.</p>

<p>References <a class="el" href="_exception_8h_source.html#l00049">Assert</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810" title="Assert macro that only throws an exception if expr fails.">Assert</a>( !inpoel.empty(), <span class="stringliteral">&quot;Attempt to call genEdsup() on empty container&quot;</span> );
  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810" title="Assert macro that only throws an exception if expr fails.">Assert</a>( nnpe &gt; 0, <span class="stringliteral">&quot;Attempt to call genEdsup() with zero nodes per element&quot;</span> );
  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810" title="Assert macro that only throws an exception if expr fails.">Assert</a>( nnpe == 3 || nnpe == 4,
          <span class="stringliteral">&quot;Attempt to call genEdsup() with nodes per element, nnpe, that is &quot;</span>
          <span class="stringliteral">&quot;neither 4 (tetrahedra) nor 3 (triangles).&quot;</span> );
  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810" title="Assert macro that only throws an exception if expr fails.">Assert</a>( inpoel.size()%nnpe == 0, <span class="stringliteral">&quot;Size of inpoel must be divisible by nnpe&quot;</span> );
  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810" title="Assert macro that only throws an exception if expr fails.">Assert</a>( !esup.first.empty(), <span class="stringliteral">&quot;Attempt to call genEdsup() with empty esup1&quot;</span> );
  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810" title="Assert macro that only throws an exception if expr fails.">Assert</a>( !esup.second.empty(), <span class="stringliteral">&quot;Attempt to call genEdsup() with empty esup2&quot;</span> );

  <span class="comment">// find out number of points in mesh connectivity</span>
  <span class="keyword">auto</span> minmax = std::minmax_element( begin(inpoel), end(inpoel) );
  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810" title="Assert macro that only throws an exception if expr fails.">Assert</a>( *minmax.first == 0, <span class="stringliteral">&quot;node ids should start from zero&quot;</span> );
  <span class="keyword">auto</span> npoin = *minmax.second + 1;

  <span class="keyword">auto</span>&amp; esup1 = esup.first;
  <span class="keyword">auto</span>&amp; esup2 = esup.second;

  <span class="comment">// allocate and fill with zeros a temporary array, only used locally</span>
  std::vector&lt; std::size_t &gt; lpoin( npoin, 0 );

  <span class="comment">// map to contain stars, a point associated to points connected with edges</span>
  <span class="comment">// storing only the end-point id, q, of point ids p &lt; q</span>
  std::map&lt; std::size_t, std::vector&lt; std::size_t &gt; &gt; star;

  <span class="comment">// generate edge connectivity and store as stars where center id &lt; spike id</span>
  <span class="keywordflow">for</span> (std::size_t p=0; p&lt;npoin; ++p)
    <span class="keywordflow">for</span> (std::size_t i=esup2[p]+1; i&lt;=esup2[p+1]; ++i )
      <span class="keywordflow">for</span> (std::size_t n=0; n&lt;nnpe; ++n) {
        <span class="keyword">auto</span> q = inpoel[ esup1[i] * nnpe + n ];
        <span class="keywordflow">if</span> (q != p &amp;&amp; lpoin[q] != p+1) {
          <span class="keywordflow">if</span> (p &lt; q) star[p].push_back(q);
          lpoin[q] = p+1;
        }
      }

  <span class="comment">// linked lists (vectors) to store edges surrounding points and their indices</span>
  std::vector&lt; std::size_t &gt; edsup1( 1, 0 ), edsup2( 1, 0 );

  <span class="comment">// sort non-center points of each star and store nodes and indices in vectors</span>
  <span class="keywordflow">for</span> (<span class="keyword">auto</span> p : star) {
    std::sort( begin(p.second), end(p.second) );
    edsup2.push_back( edsup2.back() + p.second.size() );
    <span class="keywordflow">for</span> (<span class="keyword">auto</span> e : p.second) edsup1.push_back( e );
  }
  <span class="comment">// fill up index array with the last index for points with no new edges</span>
  <span class="keywordflow">for</span> (std::size_t i=0; i&lt;npoin-star.size(); ++i)
    edsup2.push_back( edsup2.back() );

  <span class="comment">// Return (move out) linked lists</span>
  <span class="keywordflow">return</span> std::make_pair( std::move(edsup1), std::move(edsup2) );
}
</pre></div>
</div>
</div>
<a class="anchor" id="abff39252e99681eebb5ccf0078b7b924"></a><!-- doxytag: member="tk::genEsued" ref="abff39252e99681eebb5ccf0078b7b924" args="(const std::vector&lt; std::size_t &gt; &amp;inpoel, std::size_t nnpe, const std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; &amp;esup)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; <a class="el" href="namespacetk.html#abff39252e99681eebb5ccf0078b7b924">tk::genEsued</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>inpoel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>nnpe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>esup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generate derived data structure, elements surrounding edges. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inpoel</td><td>Inteconnectivity of points and elements. These are the node ids of each element of an unstructured mesh. Example: <div class="fragment"><pre class="fragment"> {.cpp}
     std::vector&lt; std::size_t &gt; inpoel { 12, 14,  9, 11,
                                         10, 14, 13, 12 };
</pre></div> specifies two tetrahedra whose vertices (node ids) are { 12, 14, 9, 11 }, and { 10, 14, 13, 12 }. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nnpe</td><td>Number of nodes per element (3 or 4) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">esup</td><td>Elements surrounding points as linked lists, see <a class="el" href="namespacetk.html#a66a2889d5d8aeb4a836842c6a1010463" title="Generate derived data structure, elements surrounding points.">tk::genEsup</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Linked lists storing elements surrounding edges </dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>It is not okay to call this function with an empty container for inpoel or esup.first or esup.second or a non-positive number of nodes per element; it will throw an exception.</dd></dl>
<p>The data generated here is stored in a linked list, more precisely, two linked arrays (vectors), _esued1_ and _esued2_, where _esued2_ holds the indices at which _esued1_ holds the element ids surrounding edges. Looping over all elements surrounding edges can then be accomplished by the following loop: </p>
<div class="fragment"><pre class="fragment"> {.cpp}
     <span class="keywordflow">for</span> (std::size_t e=0; e&lt;nedge; ++e)
       <span class="keywordflow">for</span> (<span class="keyword">auto</span> i=esued.second[e]+1; i&lt;=esued.second[e+1]; ++i)
         use element <span class="keywordtype">id</span> esued.first[i]
</pre></div><p> To find out the number of edges, _nedge_, the edge connectivity, _inpoed_, can be queried: </p>
<div class="fragment"><pre class="fragment"> {.cpp}
     <span class="keyword">auto</span> esup = <a class="code" href="namespacetk.html#a66a2889d5d8aeb4a836842c6a1010463" title="Generate derived data structure, elements surrounding points.">tk::genEsup</a>(inpoel,nnpe);
     <span class="keyword">auto</span> nedge = <a class="code" href="namespacetk.html#a559eb56e40ec844767bd2a55da55bda0" title="Generate derived data structure, edge connectivity.">tk::genInpoed</a>(inpoel,nnpe,esup).size()/2;
</pre></div><p> where _nnpe_ is the number of nodes per element (4 for tetrahedra, 3 for triangles). </p>
<dl class="note"><dt><b>Note:</b></dt><dd>At first sight, this function seems to work for elements with more vertices than that of tetrahedra. However, that is not the case since the algorithm for nnpe &gt; 4 would erronously identify any two combination of vertices as a valid edge of an element. Since only triangles and tetrahedra have no internal edges, this algorithm only works for triangle and tetrahedra element connectivity. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>Lohner, An Introduction to Applied CFD Techniques, Wiley, 2008 </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_derived_data_8_c_source.html#l00701">701</a> of file <a class="el" href="_derived_data_8_c_source.html">DerivedData.C</a>.</p>

<p>References <a class="el" href="_exception_8h_source.html#l00049">Assert</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810" title="Assert macro that only throws an exception if expr fails.">Assert</a>( !inpoel.empty(), <span class="stringliteral">&quot;Attempt to call genEsued() on empty container&quot;</span> );
  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810" title="Assert macro that only throws an exception if expr fails.">Assert</a>( nnpe &gt; 0, <span class="stringliteral">&quot;Attempt to call genEsued() with zero nodes per element&quot;</span> );
  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810" title="Assert macro that only throws an exception if expr fails.">Assert</a>( nnpe == 3 || nnpe == 4,
          <span class="stringliteral">&quot;Attempt to call genEsued() with nodes per element, nnpe, that is &quot;</span>
          <span class="stringliteral">&quot;neither 4 (tetrahedra) nor 3 (triangles).&quot;</span> );
  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810" title="Assert macro that only throws an exception if expr fails.">Assert</a>( inpoel.size()%nnpe == 0, <span class="stringliteral">&quot;Size of inpoel must be divisible by nnpe&quot;</span> );
  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810" title="Assert macro that only throws an exception if expr fails.">Assert</a>( !esup.first.empty(), <span class="stringliteral">&quot;Attempt to call genEsued() with empty esup1&quot;</span> );
  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810" title="Assert macro that only throws an exception if expr fails.">Assert</a>( !esup.second.empty(), <span class="stringliteral">&quot;Attempt to call genEsued() with empty esup2&quot;</span> );

  <span class="comment">// find out number of points in mesh connectivity</span>
  <span class="keyword">auto</span> minmax = std::minmax_element( begin(inpoel), end(inpoel) );
  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810" title="Assert macro that only throws an exception if expr fails.">Assert</a>( *minmax.first == 0, <span class="stringliteral">&quot;node ids should start from zero&quot;</span> );
  <span class="keyword">auto</span> npoin = *minmax.second + 1;

  <span class="keyword">auto</span>&amp; esup1 = esup.first;
  <span class="keyword">auto</span>&amp; esup2 = esup.second;

  <span class="comment">// allocate and fill with zeros a temporary array, only used locally</span>
  std::vector&lt; std::size_t &gt; lpoin( npoin, 0 );

  <span class="comment">// lambda that returns true if element e contains edge (p &lt; q)</span>
  <span class="keyword">auto</span> has = [ &amp;inpoel, nnpe ]( std::size_t e, std::size_t p, std::size_t q )
  -&gt; <span class="keywordtype">bool</span> {
    std::vector&lt; bool &gt; sp;
    <span class="keywordflow">for</span> (std::size_t n=0; n&lt;nnpe; ++n)
      <span class="keywordflow">if</span> (inpoel[e*nnpe+n] == p || inpoel[e*nnpe+n] == q)
        sp.push_back( <span class="keyword">true</span> );
    <span class="keywordflow">if</span> (sp.size() == 2) <span class="keywordflow">return</span> <span class="keyword">true</span>; <span class="keywordflow">else</span> <span class="keywordflow">return</span> <span class="keyword">false</span>;
  };

  <span class="comment">// map to associate edges to unique surrounding element ids</span>
  std::map&lt; std::size_t,  std::vector&lt; std::size_t &gt; &gt; revolver;

  <span class="comment">// generate edges and associated vector of unique surrounding element ids</span>
  std::size_t ed = 0;
  <span class="keywordflow">for</span> (std::size_t p=0; p&lt;npoin; ++p)
    <span class="keywordflow">for</span> (std::size_t i=esup2[p]+1; i&lt;=esup2[p+1]; ++i )
      <span class="keywordflow">for</span> (std::size_t n=0; n&lt;nnpe; ++n) {
        <span class="keyword">auto</span> q = inpoel[ esup1[i] * nnpe + n ];
        <span class="keywordflow">if</span> (q != p &amp;&amp; lpoin[q] != p+1) {
          <span class="keywordflow">if</span> (p &lt; q) {  <span class="comment">// for edge given point ids p &lt; q</span>
            <span class="keywordflow">for</span> (std::size_t j=esup2[p]+1; j&lt;=esup2[p+1]; ++j ) {
              <span class="keyword">auto</span> e = esup1[j];
              <span class="keywordflow">if</span> (has(e,p,q)) revolver[ed].push_back(e);
            }
            ++ed;
          }
          lpoin[q] = p+1;
        }
      }

  <span class="comment">// linked lists (vectors) to store elements surrounding edges</span>
  std::vector&lt; std::size_t &gt; esued1( 1, 0 ), esued2( 1, 0 );

  <span class="comment">// sort and store elements surrounding edges and their indices in vectors</span>
  <span class="keywordflow">for</span> (<span class="keyword">auto</span> p : revolver) {
    std::sort( begin(p.second), end(p.second) );
    esued2.push_back( esued2.back() + p.second.size() );
    <span class="keywordflow">for</span> (<span class="keyword">auto</span> e : p.second) esued1.push_back( e );
  }

  <span class="comment">// Return (move out) linked lists</span>
  <span class="keywordflow">return</span> std::make_pair( std::move(esued1), std::move(esued2) );
}
</pre></div>
</div>
</div>
<a class="anchor" id="a7b12aff8f884c70e45c6037b4f37e662"></a><!-- doxytag: member="tk::genEsuel" ref="a7b12aff8f884c70e45c6037b4f37e662" args="(const std::vector&lt; std::size_t &gt; &amp;inpoel, std::size_t nnpe, const std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; &amp;esup)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; <a class="el" href="namespacetk.html#a7b12aff8f884c70e45c6037b4f37e662">tk::genEsuel</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>inpoel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>nnpe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>esup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generate derived data structure, elements surrounding elements. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inpoel</td><td>Inteconnectivity of points and elements. These are the node ids of each element of an unstructured mesh. Example: <div class="fragment"><pre class="fragment"> {.cpp}
     std::vector&lt; std::size_t &gt; inpoel { 12, 14,  9, 11,
                                         10, 14, 13, 12 };
</pre></div> specifies two tetrahedra whose vertices (node ids) are { 12, 14, 9, 11 }, and { 10, 14, 13, 12 }. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nnpe</td><td>Number of nodes per element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">esup</td><td>Elements surrounding points as linked lists, see <a class="el" href="namespacetk.html#a66a2889d5d8aeb4a836842c6a1010463" title="Generate derived data structure, elements surrounding points.">tk::genEsup</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Linked lists storing elements surrounding elements </dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>It is not okay to call this function with an empty container for inpoel or esup.first or esup.second; it will throw an exception.</dd></dl>
<p>The data generated here is stored in a linked list, more precisely, two linked arrays (vectors), _esuel1_ and _esuel2_, where _esuel2_ holds the indices at which _esuel1_ holds the element ids surrounding elements. Looping over elements surrounding elements can then be accomplished by the following loop: </p>
<div class="fragment"><pre class="fragment"> {.cpp}
     <span class="keywordflow">for</span> (std::size_t e=0; e&lt;nelem; ++e)
       <span class="keywordflow">for</span> (<span class="keyword">auto</span> i=esuel.second[e]+1; i&lt;=esuel.second[e+1]; ++i)
          use element <span class="keywordtype">id</span> esuel.first[i]
</pre></div><p> To find out the number of elements, _nelem_, the size of the mesh connectivity vector, _inpoel_, can be devided by the number of nodes per elements, _nnpe_: </p>
<div class="fragment"><pre class="fragment"> {.cpp}
     <span class="keyword">auto</span> nelem = inpoel.size()/nnpe;
</pre></div> <dl class="note"><dt><b>Note:</b></dt><dd>In principle, this function *should* work for any positive nnpe, however, only nnpe = 4 (tetrahedra) and nnpe = 3 (triangles) are tested. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>Lohner, An Introduction to Applied CFD Techniques, Wiley, 2008 </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_derived_data_8_c_source.html#l00490">490</a> of file <a class="el" href="_derived_data_8_c_source.html">DerivedData.C</a>.</p>

<p>References <a class="el" href="_exception_8h_source.html#l00049">Assert</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810" title="Assert macro that only throws an exception if expr fails.">Assert</a>( !inpoel.empty(), <span class="stringliteral">&quot;Attempt to call genEsuel() on empty container&quot;</span> );
  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810" title="Assert macro that only throws an exception if expr fails.">Assert</a>( nnpe &gt; 0, <span class="stringliteral">&quot;Attempt to call genEsuel() with zero nodes per element&quot;</span> );
  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810" title="Assert macro that only throws an exception if expr fails.">Assert</a>( inpoel.size()%nnpe == 0, <span class="stringliteral">&quot;Size of inpoel must be divisible by four&quot;</span> );
  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810" title="Assert macro that only throws an exception if expr fails.">Assert</a>( !esup.first.empty(), <span class="stringliteral">&quot;Attempt to call genEsuel() with empty esuel1&quot;</span> );
  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810" title="Assert macro that only throws an exception if expr fails.">Assert</a>( !esup.second.empty(),
          <span class="stringliteral">&quot;Attempt to call genEsuel() with empty esuel2&quot;</span> );

  <span class="keyword">auto</span>&amp; esup1 = esup.first;
  <span class="keyword">auto</span>&amp; esup2 = esup.second;

  <span class="keyword">auto</span> nelem = inpoel.size()/nnpe;

  <span class="comment">// lambda that returns true if elements hel and gel share a face</span>
  <span class="keyword">auto</span> adj = [ &amp;inpoel, nnpe ]( std::size_t hel, std::size_t gel ) -&gt; <span class="keywordtype">bool</span> {
    std::vector&lt; bool &gt; sp;
    <span class="keywordflow">for</span> (std::size_t h=0; h&lt;nnpe; ++h)
      <span class="keywordflow">for</span> (std::size_t g=0; g&lt;nnpe; ++g)
        <span class="keywordflow">if</span> (inpoel[hel*nnpe+h] == inpoel[gel*nnpe+g]) sp.push_back( <span class="keyword">true</span> );
    <span class="keywordflow">if</span> (sp.size() == nnpe-1) <span class="keywordflow">return</span> <span class="keyword">true</span>; <span class="keywordflow">else</span> <span class="keywordflow">return</span> <span class="keyword">false</span>;
  };

  <span class="comment">// map to associate unique elements and their surrounding elements</span>
  std::map&lt; std::size_t, std::vector&lt; std::size_t &gt; &gt; es;

  <span class="keywordflow">for</span> (std::size_t e=0; e&lt;nelem; ++e) {
    std::set&lt; std::size_t &gt; faces; <span class="comment">// will collect elem ids of shared faces</span>
    <span class="keywordflow">for</span> (std::size_t n=0; n&lt;nnpe; ++n) {
      <span class="keyword">auto</span> i = inpoel[ e*nnpe+n ];
      <span class="keywordflow">for</span> (<span class="keyword">auto</span> j=esup2[i]+1; j&lt;=esup2[i+1]; ++j)
        <span class="keywordflow">if</span> (adj( e, esup1[j] )) faces.insert( esup1[j] );
    }
    <span class="comment">// store element ids of shared faces</span>
    <span class="keywordflow">for</span> (<span class="keyword">auto</span> j : faces) es[e].push_back(j);
  }

  <span class="comment">// storing elements surrounding elements</span>
  std::vector&lt; std::size_t &gt; esuel1( 1, 0 ), esuel2( 1, 0 );

  <span class="comment">// store elements surrounding elements in linked lists</span>
  <span class="keywordflow">for</span> (<span class="keyword">auto</span> e : es) {
    esuel2.push_back( esuel2.back() + e.second.size() );
    <span class="keywordflow">for</span> (<span class="keyword">auto</span> s : e.second) esuel1.push_back( s );
  }

  <span class="comment">// Return (move out) linked lists</span>
  <span class="keywordflow">return</span> std::make_pair( std::move(esuel1), std::move(esuel2) );
}
</pre></div>
</div>
</div>
<a class="anchor" id="a66a2889d5d8aeb4a836842c6a1010463"></a><!-- doxytag: member="tk::genEsup" ref="a66a2889d5d8aeb4a836842c6a1010463" args="(const std::vector&lt; std::size_t &gt; &amp;inpoel, std::size_t nnpe)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; <a class="el" href="namespacetk.html#a66a2889d5d8aeb4a836842c6a1010463">tk::genEsup</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>inpoel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>nnpe</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generate derived data structure, elements surrounding points. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inpoel</td><td>Inteconnectivity of points and elements. These are the node ids of each element of an unstructured mesh. Example: <div class="fragment"><pre class="fragment"> {.cpp}
     std::vector&lt; std::size_t &gt; inpoel { 12, 14,  9, 11,
                                         10, 14, 13, 12 };
</pre></div> specifies two tetrahedra whose vertices (node ids) are { 12, 14, 9, 11 }, and { 10, 14, 13, 12 }. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nnpe</td><td>Number of nodes per element </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Linked lists storing elements surrounding points </dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>It is not okay to call this function with an empty container or a non-positive number of nodes per element; it will throw an exception.</dd></dl>
<p>The data generated here is stored in a linked list, more precisely, two linked arrays (vectors), _esup1_ and _esup2_, where _esup2_ holds the indices at which _esup1_ holds the element ids surrounding points. Looping over all elements surrounding all points can then be accomplished by the following loop: </p>
<div class="fragment"><pre class="fragment"> {.cpp}
     <span class="keywordflow">for</span> (std::size_t p=0; p&lt;npoin; ++p)
       <span class="keywordflow">for</span> (<span class="keyword">auto</span> i=esup.second[p]+1; i&lt;=esup.second[p+1]; ++i)
          use element <span class="keywordtype">id</span> esup.first[i]
</pre></div><p> To find out the number of points, _npoin_, the mesh connectivity, _inpoel_, can be queried: </p>
<div class="fragment"><pre class="fragment"> {.cpp}
     <span class="keyword">auto</span> minmax = std::minmax_element( begin(inpoel), end(inpoel) );
     <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810" title="Assert macro that only throws an exception if expr fails.">Assert</a>( *minmax.first == 0, <span class="stringliteral">&quot;node ids should start from zero&quot;</span> );
     <span class="keyword">auto</span> npoin = *minmax.second + 1;
</pre></div> <dl class="note"><dt><b>Note:</b></dt><dd>In principle, this function *should* work for any positive nnpe, however, only nnpe = 4 (tetrahedra) and nnpe = 3 (triangles) are tested. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>Lohner, An Introduction to Applied CFD Techniques, Wiley, 2008 </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_derived_data_8_c_source.html#l00026">26</a> of file <a class="el" href="_derived_data_8_c_source.html">DerivedData.C</a>.</p>

<p>References <a class="el" href="_exception_8h_source.html#l00049">Assert</a>.</p>

<p>Referenced by <a class="el" href="_inciter_setup_8_c_source.html#l00303">inciter::assignMesh()</a>, <a class="el" href="_zoltan_inter_op_8_c_source.html#l00262">tk::zoltan::createHyperGraph()</a>, and <a class="el" href="_comm_map_8_c_source.html#l00029">poinCommMaps()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810" title="Assert macro that only throws an exception if expr fails.">Assert</a>( !inpoel.empty(), <span class="stringliteral">&quot;Attempt to call genEsup() on empty container&quot;</span> );
  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810" title="Assert macro that only throws an exception if expr fails.">Assert</a>( nnpe &gt; 0, <span class="stringliteral">&quot;Attempt to call genEsup() with zero nodes per element&quot;</span> );
  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810" title="Assert macro that only throws an exception if expr fails.">Assert</a>( inpoel.size()%nnpe == 0, <span class="stringliteral">&quot;Size of inpoel must be divisible by nnpe&quot;</span> );

  <span class="comment">// find out number of points in mesh connectivity</span>
  <span class="keyword">auto</span> minmax = std::minmax_element( begin(inpoel), end(inpoel) );
  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810" title="Assert macro that only throws an exception if expr fails.">Assert</a>( *minmax.first == 0, <span class="stringliteral">&quot;node ids should start from zero&quot;</span> );
  <span class="keyword">auto</span> npoin = *minmax.second + 1;

  <span class="comment">// allocate one of the linked lists storing elements surrounding points: esup2</span>
  <span class="comment">// fill with zeros</span>
  std::vector&lt; std::size_t &gt; esup2( npoin+1, 0 );

  <span class="comment">// element pass 1: count number of elements connected to each point</span>
  <span class="keywordflow">for</span> (<span class="keyword">auto</span> n : inpoel) ++esup2[ n + 1 ];

  <span class="comment">// storage/reshuffling pass 1: update storage counter and store</span>
  <span class="comment">// also find out the maximum size of esup1 (mesup)</span>
  <span class="keyword">auto</span> mesup = esup2[0]+1;
  <span class="keywordflow">for</span> (std::size_t i=1; i&lt;npoin+1; ++i) {
    esup2[i] += esup2[i-1];
    <span class="keywordflow">if</span> (esup2[i]+1 &gt; mesup) mesup = esup2[i]+1;
  }

  <span class="comment">// now we know mesup, so allocate the other one of the linked lists storing</span>
  <span class="comment">// elements surrounding points: esup1</span>
  std::vector&lt; std::size_t &gt; esup1( mesup );

  <span class="comment">// store the elements in esup1</span>
  std::size_t e = 0;
  <span class="keywordflow">for</span> (<span class="keyword">auto</span> n : inpoel) {
    <span class="keyword">auto</span> j = esup2[n]+1;
    esup2[n] = j;
    esup1[j] = e/nnpe;
    ++e;
  }

  <span class="comment">// storage/reshuffling pass 2</span>
  <span class="keywordflow">for</span> (<span class="keyword">auto</span> i=npoin; i&gt;0; --i) esup2[i] = esup2[i-1];
  esup2[0] = 0;

  <span class="comment">// Return (move out) linked lists</span>
  <span class="keywordflow">return</span> std::make_pair( std::move(esup1), std::move(esup2) );
}
</pre></div>
</div>
</div>
<a class="anchor" id="a9d835a7a93970d17a66356b64f3291af"></a><!-- doxytag: member="tk::genEsupel" ref="a9d835a7a93970d17a66356b64f3291af" args="(const std::vector&lt; std::size_t &gt; &amp;inpoel, std::size_t nnpe, const std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; &amp;esup)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; <a class="el" href="namespacetk.html#a9d835a7a93970d17a66356b64f3291af">tk::genEsupel</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>inpoel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>nnpe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>esup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generate derived data structure, elements surrounding points of elements. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inpoel</td><td>Inteconnectivity of points and elements. These are the node ids of each element of an unstructured mesh. Example: <div class="fragment"><pre class="fragment"> {.cpp}
     std::vector&lt; std::size_t &gt; inpoel { 12, 14,  9, 11,
                                         10, 14, 13, 12 };
</pre></div> specifies two tetrahedra whose vertices (node ids) are { 12, 14, 9, 11 }, and { 10, 14, 13, 12 }. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nnpe</td><td>Number of nodes per element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">esup</td><td>Elements surrounding points as linked lists, see <a class="el" href="namespacetk.html#a66a2889d5d8aeb4a836842c6a1010463" title="Generate derived data structure, elements surrounding points.">tk::genEsup</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Linked lists storing elements surrounding points of elements </dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>It is not okay to call this function with an empty container for inpoel or esup.first or esup.second or a non-positive number of nodes per element; it will throw an exception.</dd></dl>
<p>The data generated here is stored in a linked list, more precisely, two linked arrays (vectors), _esupel1_ and _esupel2_, where _esupel2_ holds the indices at which _esupel1_ holds the element ids surrounding points of elements. Looping over all elements surrounding the points of all elements can then be accomplished by the following loop: </p>
<div class="fragment"><pre class="fragment"> {.cpp}
     <span class="keywordflow">for</span> (std::size_t e=0; e&lt;nelem; ++e)
       <span class="keywordflow">for</span> (<span class="keyword">auto</span> i=esupel.second[e]+1; i&lt;=esupel.second[e+1]; ++i)
          use element <span class="keywordtype">id</span> esupel.first[i]
</pre></div><p> To find out the number of elements, _nelem_, the size of the mesh connectivity vector, _inpoel_, can be devided by the number of nodes per elements, _nnpe_: </p>
<div class="fragment"><pre class="fragment"> {.cpp}
     <span class="keyword">auto</span> nelem = inpoel.size()/nnpe;
</pre></div> <dl class="note"><dt><b>Note:</b></dt><dd>In principle, this function *should* work for any positive nnpe, however, only nnpe = 4 (tetrahedra) and nnpe = 3 (triangles) are tested. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>Lohner, An Introduction to Applied CFD Techniques, Wiley, 2008 </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_derived_data_8_c_source.html#l00413">413</a> of file <a class="el" href="_derived_data_8_c_source.html">DerivedData.C</a>.</p>

<p>References <a class="el" href="_exception_8h_source.html#l00049">Assert</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810" title="Assert macro that only throws an exception if expr fails.">Assert</a>( !inpoel.empty(), <span class="stringliteral">&quot;Attempt to call genEsupel() on empty container&quot;</span> );
  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810" title="Assert macro that only throws an exception if expr fails.">Assert</a>( nnpe &gt; 0, <span class="stringliteral">&quot;Attempt to call genEsupel() with zero nodes per element&quot;</span> );
  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810" title="Assert macro that only throws an exception if expr fails.">Assert</a>( inpoel.size()%nnpe == 0, <span class="stringliteral">&quot;Size of inpoel must be divisible by nnpe&quot;</span> );
  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810" title="Assert macro that only throws an exception if expr fails.">Assert</a>( !esup.first.empty(), <span class="stringliteral">&quot;Attempt to call genEsupel() with empty esup1&quot;</span> );
  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810" title="Assert macro that only throws an exception if expr fails.">Assert</a>( !esup.second.empty(),
          <span class="stringliteral">&quot;Attempt to call genEsupel() with empty esup2&quot;</span> );

  <span class="keyword">auto</span>&amp; esup1 = esup.first;
  <span class="keyword">auto</span>&amp; esup2 = esup.second;

  <span class="comment">// linked lists storing elements surrounding points of elements, put in a</span>
  <span class="comment">// single zero in both</span>
  std::vector&lt; std::size_t &gt; esupel2( 1, 0 ), esupel1( 1, 0 );

  std::size_t e = 0;
  std::set&lt; std::size_t &gt; esuel;
  <span class="keywordflow">for</span> (<span class="keyword">auto</span> p : inpoel) {       <span class="comment">// loop over all points of all elements</span>
    <span class="comment">// collect unique element ids of elements surrounding points of element</span>
    <span class="keywordflow">for</span> (<span class="keyword">auto</span> i=esup2[p]+1; i&lt;=esup2[p+1]; ++i) esuel.insert( esup1[i] );
    <span class="keywordflow">if</span> (++e%nnpe == 0) {        <span class="comment">// when finished checking all nodes of element</span>
      <span class="comment">// erase element whose surrounding elements are considered</span>
      esuel.erase( e/nnpe-1 );
      <span class="comment">// store unique element ids in esupel1</span>
      <span class="keywordflow">for</span> (<span class="keyword">auto</span> i : esuel) esupel1.push_back( i );
      <span class="comment">// store end-index for element used to address into esupel1</span>
      esupel2.push_back( esupel2.back() + esuel.size() );
      esuel.clear();
    }
  }

  <span class="comment">// Return (move out) linked lists</span>
  <span class="keywordflow">return</span> std::make_pair( std::move(esupel1), std::move(esupel2) );
}
</pre></div>
</div>
</div>
<a class="anchor" id="a7c8a720dd257388a44d5ca7af7aaec8f"></a><!-- doxytag: member="tk::genInedel" ref="a7c8a720dd257388a44d5ca7af7aaec8f" args="(const std::vector&lt; std::size_t &gt; &amp;inpoel, std::size_t nnpe, const std::vector&lt; std::size_t &gt; &amp;inpoed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::size_t &gt; <a class="el" href="namespacetk.html#a7c8a720dd257388a44d5ca7af7aaec8f">tk::genInedel</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>inpoel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>nnpe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>inpoed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generate derived data structure, edges of elements. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inpoel</td><td>Inteconnectivity of points and elements. These are the node ids of each element of an unstructured mesh. Example: <div class="fragment"><pre class="fragment"> {.cpp}
     std::vector&lt; std::size_t &gt; inpoel { 12, 14,  9, 11,
                                         10, 14, 13, 12 };
</pre></div> specifies two tetrahedra whose vertices (node ids) are { 12, 14, 9, 11 }, and { 10, 14, 13, 12 }. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nnpe</td><td>Number of nodes per element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inpoed</td><td>Edge connectivity as linear vector, see <a class="el" href="namespacetk.html#a559eb56e40ec844767bd2a55da55bda0" title="Generate derived data structure, edge connectivity.">tk::genInpoed</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Linear vector storing all edge ids * 2 of all elements </dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>It is not okay to call this function with an empty container for inpoel or inpoed or a non-positive number of nodes per element; it will throw an exception.</dd></dl>
<p>The data generated here is stored in a linear vector with all edge ids (as defined by inpoed) of all elements. The edge ids stored in inedel can be directly used to index the vector inpoed. Because the derived data structure generated here, inedel, is intended to be used in conjunction with the linear vector inpoed and not with the linked lists edsup1 and edsup2, this function takes inpoed as an argument. Accessing the edges of element e using the edge of elements data structure, inedel, generated here can be accomplished by </p>
<div class="fragment"><pre class="fragment"> {.cpp}
     <span class="keywordflow">for</span> (std::size_t e=0; e&lt;nelem; ++e) {
       <span class="keywordflow">for</span> (std::size_t i=0; i&lt;nepe; ++i) {
         use edge <span class="keywordtype">id</span> inedel[e*nepe+i] of element e, or
         use point ids p &lt; q of edge <span class="keywordtype">id</span> inedel[e*nepe+i] of element e as
           p = inpoed[ inedel[e*nepe+i]*2 ]
           q = inpoed[ inedel[e*nepe+i]*2+1 ]
       }
     }
</pre></div><p> where _nepe_ denotes the number of edges per elements: 3 for triangles, 6 for tetrahedra. To find out the number of elements, _nelem_, the size of the mesh connectivity vector, _inpoel_, can be devided by the number of nodes per elements, _nnpe_: </p>
<div class="fragment"><pre class="fragment"> {.cpp}
     <span class="keyword">auto</span> nelem = inpoel.size()/nnpe;
</pre></div> <dl class="note"><dt><b>Note:</b></dt><dd>At first sight, this function seems to work for elements with more vertices than that of tetrahedra. However, that is not the case since the algorithm for nnpe &gt; 4 would erronously identify any two combination of vertices as a valid edge of an element. Since only triangles and tetrahedra have no internal edges, this algorithm only works for triangle and tetrahedra element connectivity. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>Lohner, An Introduction to Applied CFD Techniques, Wiley, 2008 </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_derived_data_8_c_source.html#l00580">580</a> of file <a class="el" href="_derived_data_8_c_source.html">DerivedData.C</a>.</p>

<p>References <a class="el" href="_exception_8h_source.html#l00049">Assert</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810" title="Assert macro that only throws an exception if expr fails.">Assert</a>( !inpoel.empty(), <span class="stringliteral">&quot;Attempt to call genInedel() on empty container&quot;</span> );
  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810" title="Assert macro that only throws an exception if expr fails.">Assert</a>( nnpe &gt; 0, <span class="stringliteral">&quot;Attempt to call genInedel() with zero nodes per element&quot;</span> );
  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810" title="Assert macro that only throws an exception if expr fails.">Assert</a>( nnpe == 3 || nnpe == 4,
          <span class="stringliteral">&quot;Attempt to call genInedel() with nodes per element, nnpe, that is &quot;</span>
          <span class="stringliteral">&quot;neither 4 (tetrahedra) nor 3 (triangles).&quot;</span> );
  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810" title="Assert macro that only throws an exception if expr fails.">Assert</a>( inpoel.size()%nnpe == 0, <span class="stringliteral">&quot;Size of inpoel must be divisible by nnpe&quot;</span> );
  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810" title="Assert macro that only throws an exception if expr fails.">Assert</a>( !inpoed.empty(), <span class="stringliteral">&quot;Attempt to call genInedel() with empty inpoed&quot;</span> );

  <span class="comment">// find out number of points in mesh connectivity</span>
  <span class="keyword">auto</span> minmax = std::minmax_element( begin(inpoel), end(inpoel) );
  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810" title="Assert macro that only throws an exception if expr fails.">Assert</a>( *minmax.first == 0, <span class="stringliteral">&quot;node ids should start from zero&quot;</span> );
  <span class="keyword">auto</span> npoin = *minmax.second + 1;

  <span class="comment">// First, generate index of star centers. This is necessary to avoid a</span>
  <span class="comment">// brute-force search for point ids of edges when searching for element edges.</span>
  <span class="comment">// Note that this is the same as edsup2, generated by genEdsup(). However,</span>
  <span class="comment">// because the derived data structure generated here, inedel, is intended to</span>
  <span class="comment">// be used in conjunction with the linear vector inpoed and not with the</span>
  <span class="comment">// linked lists edsup1 and edsup2, this function takes inpoed as an argument,</span>
  <span class="comment">// and so edsup2 is temporarily generated here to avoid a brute-force search.</span>

  <span class="comment">// map to contain stars, a point associated to points connected with edges</span>
  <span class="comment">// storing only the end-point id, q, of point ids p &lt; q</span>
  std::map&lt; std::size_t, std::vector&lt; std::size_t &gt; &gt; star;

  <span class="comment">// generate stars from inpoed; starting with zero, every even is a star</span>
  <span class="comment">// center, every odd is a spike</span>
  <span class="keywordflow">for</span> (std::size_t i=0; i&lt;inpoed.size()/2; ++i)
    star[ inpoed[i*2] ].push_back( inpoed[i*2+1] );

  <span class="comment">// store index of star centers in vector; assume non-center points of each</span>
  <span class="comment">// star have already been sorted</span>
  std::vector&lt; std::size_t &gt; edsup2( 1, 0 );
  <span class="keywordflow">for</span> (<span class="keyword">auto</span> p : star) edsup2.push_back( edsup2.back() + p.second.size() );
  <span class="comment">// fill up index array with the last index for points with no new edges</span>
  <span class="keywordflow">for</span> (std::size_t i=0; i&lt;npoin-star.size(); ++i)
    edsup2.push_back( edsup2.back() );
  star.clear();

  <span class="comment">// Second, generate edges of elements</span>

  <span class="keyword">auto</span> nelem = inpoel.size()/nnpe;

  <span class="comment">// map associating elem id with vector of edge ids</span>
  std::map&lt; std::size_t, std::vector&lt; std::size_t &gt; &gt; edges;

  <span class="comment">// generate map of elements associated to edge ids</span>
  <span class="keywordflow">for</span> (std::size_t e=0; e&lt;nelem; ++e)
    <span class="keywordflow">for</span> (std::size_t n=0; n&lt;nnpe; ++n) {
      <span class="keyword">auto</span> p = inpoel[e*nnpe+n];
      <span class="keywordflow">for</span> (<span class="keyword">auto</span> i=edsup2[p]+1; i&lt;=edsup2[p+1]; ++i)
         <span class="keywordflow">for</span> (std::size_t j=0; j&lt;nnpe; ++j)
            <span class="keywordflow">if</span> (inpoed[(i-1)*2+1] == inpoel[e*nnpe+j])
              edges[e].push_back( i-1 );
    }

  <span class="comment">// linear vector to store the edge ids of all elements</span>
  std::vector&lt; std::size_t &gt; inedel;

  <span class="comment">// store edge ids of elements in linear vector</span>
  <span class="keywordflow">for</span> (<span class="keyword">auto</span> e : edges) <span class="keywordflow">for</span> (<span class="keyword">auto</span> p : e.second) inedel.push_back( p );

  <span class="comment">// Return (move out) vector</span>
  <span class="keywordflow">return</span> inedel;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a559eb56e40ec844767bd2a55da55bda0"></a><!-- doxytag: member="tk::genInpoed" ref="a559eb56e40ec844767bd2a55da55bda0" args="(const std::vector&lt; std::size_t &gt; &amp;inpoel, std::size_t nnpe, const std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; &amp;esup)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::size_t &gt; <a class="el" href="namespacetk.html#a559eb56e40ec844767bd2a55da55bda0">tk::genInpoed</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>inpoel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>nnpe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>esup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generate derived data structure, edge connectivity. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inpoel</td><td>Inteconnectivity of points and elements. These are the node ids of each element of an unstructured mesh. Example: <div class="fragment"><pre class="fragment"> {.cpp}
     std::vector&lt; std::size_t &gt; inpoel { 12, 14,  9, 11,
                                         10, 14, 13, 12 };
</pre></div> specifies two tetrahedra whose vertices (node ids) are { 12, 14, 9, 11 }, and { 10, 14, 13, 12 }. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nnpe</td><td>Number of nodes per element (3 or 4) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">esup</td><td>Elements surrounding points as linked lists, see <a class="el" href="namespacetk.html#a66a2889d5d8aeb4a836842c6a1010463" title="Generate derived data structure, elements surrounding points.">tk::genEsup</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Linear vector storing edge connectivity (point ids p &lt; q) </dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>It is not okay to call this function with an empty container for inpoel or esup.first or esup.second or a non-positive number of nodes per element; it will throw an exception.</dd></dl>
<p>The data generated here is stored in a linear vector and is very similar to the linked lists, _edsup1_ and _edsup2, generated by <a class="el" href="namespacetk.html#adb7a88611b67f7c809f2bba5c794df0b" title="Generate derived data structure, edges surrounding points.">genEdsup()</a>. The difference is that in the linear vector, inpoed, generated here, both edge point ids are stored as a pair, p &lt; q, as opposed to the linked lists edsup1 and edsup2, in which edsup1 only stores the edge-end point ids (still associated to edge-start point ids when used together with edsup2). The rationale is that while inpoed is larger in memory, it allows direct access to edges (pair of point ids making up an edge), edsup1 and edsup2 are smaller in memory, still allow accessing the same data (edge point id pairs) but only in a linear fashion, not by direct access to particular edges. Accessing all unique edges using the edge connectivity data structure, inpoed, generated here can be accomplished by </p>
<div class="fragment"><pre class="fragment"> {.cpp}
     <span class="keywordflow">for</span> (std::size_t e=0; e&lt;inpoed.size()/2; ++e) {
       use point <span class="keywordtype">id</span> p of edge e = inpoed[e*2];
       use point <span class="keywordtype">id</span> q of edge e = inpoed[e*2+1];
     }
</pre></div> <dl class="note"><dt><b>Note:</b></dt><dd>At first sight, this function seems to work for elements with more vertices than that of tetrahedra. However, that is not the case since the algorithm for nnpe &gt; 4 would erronously identify any two combination of vertices as a valid edge of an element. Since only triangles and tetrahedra have no internal edges, this algorithm only works for triangle and tetrahedra element connectivity. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespacetk.html#adb7a88611b67f7c809f2bba5c794df0b" title="Generate derived data structure, edges surrounding points.">tk::genEdsup</a> for similar data that sometimes may be more advantageous </dd>
<dd>
Lohner, An Introduction to Applied CFD Techniques, Wiley, 2008 </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_derived_data_8_c_source.html#l00310">310</a> of file <a class="el" href="_derived_data_8_c_source.html">DerivedData.C</a>.</p>

<p>References <a class="el" href="_exception_8h_source.html#l00049">Assert</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810" title="Assert macro that only throws an exception if expr fails.">Assert</a>( !inpoel.empty(), <span class="stringliteral">&quot;Attempt to call genInpoed() on empty container&quot;</span> );
  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810" title="Assert macro that only throws an exception if expr fails.">Assert</a>( nnpe &gt; 0, <span class="stringliteral">&quot;Attempt to call genInpoed() with zero nodes per element&quot;</span> );
  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810" title="Assert macro that only throws an exception if expr fails.">Assert</a>( nnpe == 3 || nnpe == 4,
          <span class="stringliteral">&quot;Attempt to call genInpoed() with nodes per element, nnpe, that is &quot;</span>
          <span class="stringliteral">&quot;neither 4 (tetrahedra) nor 3 (triangles).&quot;</span> );
  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810" title="Assert macro that only throws an exception if expr fails.">Assert</a>( inpoel.size()%nnpe == 0, <span class="stringliteral">&quot;Size of inpoel must be divisible by nnpe&quot;</span> );
  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810" title="Assert macro that only throws an exception if expr fails.">Assert</a>( !esup.first.empty(), <span class="stringliteral">&quot;Attempt to call genInpoed() with empty esup1&quot;</span> );
  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810" title="Assert macro that only throws an exception if expr fails.">Assert</a>( !esup.second.empty(),
          <span class="stringliteral">&quot;Attempt to call genInpoed() with empty esup2&quot;</span> );

  <span class="comment">// find out number of points in mesh connectivity</span>
  <span class="keyword">auto</span> minmax = std::minmax_element( begin(inpoel), end(inpoel) );
  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810" title="Assert macro that only throws an exception if expr fails.">Assert</a>( *minmax.first == 0, <span class="stringliteral">&quot;node ids should start from zero&quot;</span> );
  <span class="keyword">auto</span> npoin = *minmax.second + 1;

  <span class="keyword">auto</span>&amp; esup1 = esup.first;
  <span class="keyword">auto</span>&amp; esup2 = esup.second;

  <span class="comment">// allocate and fill with zeros a temporary array, only used locally</span>
  std::vector&lt; std::size_t &gt; lpoin( npoin, 0 );

  <span class="comment">// map to contain stars, a point associated to points connected with edges,</span>
  <span class="comment">// storing only the end-point id, q, of point ids p &lt; q</span>
  std::map&lt; std::size_t, std::vector&lt; std::size_t &gt; &gt; star;

  <span class="comment">// generate edge connectivity and store as stars where center id &lt; spike id</span>
  <span class="keywordflow">for</span> (std::size_t p=0; p&lt;npoin; ++p)
    <span class="keywordflow">for</span> (std::size_t i=esup2[p]+1; i&lt;=esup2[p+1]; ++i )
      <span class="keywordflow">for</span> (std::size_t n=0; n&lt;nnpe; ++n) {
        <span class="keyword">auto</span> q = inpoel[ esup1[i] * nnpe + n ];
        <span class="keywordflow">if</span> (q != p &amp;&amp; lpoin[q] != p+1) {
          <span class="keywordflow">if</span> (p &lt; q) star[p].push_back( q );
          lpoin[q] = p+1;
        }
      }

  <span class="comment">// linear vector to store edge connectivity and their indices</span>
  std::vector&lt; std::size_t &gt; inpoed;

  <span class="comment">// sort non-center points of each star and store both start and end points of</span>
  <span class="comment">// each star in linear vector</span>
  <span class="keywordflow">for</span> (<span class="keyword">auto</span> p : star) {
    std::sort( begin(p.second), end(p.second) );
    <span class="keywordflow">for</span> (<span class="keyword">auto</span> e : p.second) {
      inpoed.push_back( p.first );
      inpoed.push_back( e );
    }
  }

  <span class="comment">// Return (move out) linear vector</span>
  <span class="keywordflow">return</span> inpoed;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad2a88a65102c17149b44660db15d445b"></a><!-- doxytag: member="tk::genPsup" ref="ad2a88a65102c17149b44660db15d445b" args="(const std::vector&lt; std::size_t &gt; &amp;inpoel, std::size_t nnpe, const std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; &amp;esup)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; <a class="el" href="namespacetk.html#ad2a88a65102c17149b44660db15d445b">tk::genPsup</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>inpoel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>nnpe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>esup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generate derived data structure, points surrounding points. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inpoel</td><td>Inteconnectivity of points and elements. These are the node ids of each element of an unstructured mesh. Example: <div class="fragment"><pre class="fragment"> {.cpp}
     std::vector&lt; std::size_t &gt; inpoel { 12, 14,  9, 11,
                                         10, 14, 13, 12 };
</pre></div> specifies two tetrahedra whose vertices (node ids) are { 12, 14, 9, 11 }, and { 10, 14, 13, 12 }. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nnpe</td><td>Number of nodes per element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">esup</td><td>Elements surrounding points as linked lists, see <a class="el" href="namespacetk.html#a66a2889d5d8aeb4a836842c6a1010463" title="Generate derived data structure, elements surrounding points.">tk::genEsup</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Linked lists storing points surrounding points </dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>It is not okay to call this function with an empty container for inpoel or esup.first or esup.second or a non-positive number of nodes per element; it will throw an exception.</dd></dl>
<p>The data generated here is stored in a linked list, more precisely, two linked arrays (vectors), _psup1_ and _psup2_, where _psup2_ holds the indices at which _psup1_ holds the point ids surrounding points. Looping over all points surrounding all points can then be accomplished by the following loop: </p>
<div class="fragment"><pre class="fragment"> {.cpp}
     <span class="keywordflow">for</span> (std::size_t p=0; p&lt;npoin; ++p)
       <span class="keywordflow">for</span> (<span class="keyword">auto</span> i=psup.second[p]+1; i&lt;=psup.second[p+1]; ++i)
          use point <span class="keywordtype">id</span> psup.first[i]
</pre></div><p> To find out the number of points, _npoin_, the mesh connectivity, _inpoel_, can be queried: </p>
<div class="fragment"><pre class="fragment"> {.cpp}
     <span class="keyword">auto</span> minmax = std::minmax_element( begin(inpoel), end(inpoel) );
     <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810" title="Assert macro that only throws an exception if expr fails.">Assert</a>( *minmax.first == 0, <span class="stringliteral">&quot;node ids should start from zero&quot;</span> );
     <span class="keyword">auto</span> npoin = *minmax.second + 1;
</pre></div><p> or the length-1 of the generated index list: </p>
<div class="fragment"><pre class="fragment"> {.cpp}
     autp npoin = psup.second.size()-1;
</pre></div> <dl class="note"><dt><b>Note:</b></dt><dd>In principle, this function *should* work for any positive nnpe, however, only nnpe = 4 (tetrahedra) and nnpe = 3 (triangles) are tested. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>Lohner, An Introduction to Applied CFD Techniques, Wiley, 2008 </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_derived_data_8_c_source.html#l00110">110</a> of file <a class="el" href="_derived_data_8_c_source.html">DerivedData.C</a>.</p>

<p>References <a class="el" href="_exception_8h_source.html#l00049">Assert</a>.</p>

<p>Referenced by <a class="el" href="_zoltan_inter_op_8_c_source.html#l00262">tk::zoltan::createHyperGraph()</a>, and <a class="el" href="_comm_map_8_c_source.html#l00029">poinCommMaps()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810" title="Assert macro that only throws an exception if expr fails.">Assert</a>( !inpoel.empty(), <span class="stringliteral">&quot;Attempt to call genPsup() on empty container&quot;</span> );
  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810" title="Assert macro that only throws an exception if expr fails.">Assert</a>( nnpe &gt; 0, <span class="stringliteral">&quot;Attempt to call genPsup() with zero nodes per element&quot;</span> );
  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810" title="Assert macro that only throws an exception if expr fails.">Assert</a>( inpoel.size()%nnpe == 0, <span class="stringliteral">&quot;Size of inpoel must be divisible by nnpe&quot;</span> );
  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810" title="Assert macro that only throws an exception if expr fails.">Assert</a>( !esup.first.empty(), <span class="stringliteral">&quot;Attempt to call genPsup() with empty esup1&quot;</span> );
  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810" title="Assert macro that only throws an exception if expr fails.">Assert</a>( !esup.second.empty(), <span class="stringliteral">&quot;Attempt to call genPsup() with empty esup2&quot;</span> );

  <span class="comment">// find out number of points in mesh connectivity</span>
  <span class="keyword">auto</span> minmax = std::minmax_element( begin(inpoel), end(inpoel) );
  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810" title="Assert macro that only throws an exception if expr fails.">Assert</a>( *minmax.first == 0, <span class="stringliteral">&quot;node ids should start from zero&quot;</span> );
  <span class="keyword">auto</span> npoin = *minmax.second + 1;

  <span class="keyword">auto</span>&amp; esup1 = esup.first;
  <span class="keyword">auto</span>&amp; esup2 = esup.second;

  <span class="comment">// allocate both of the linked lists storing points surrounding points, we</span>
  <span class="comment">// only know the size of psup2, put in a single zero in psup1</span>
  std::vector&lt; std::size_t &gt; psup2( npoin+1 ), psup1( 1, 0 );

  <span class="comment">// allocate and fill with zeros a temporary array, only used locally</span>
  std::vector&lt; std::size_t &gt; lpoin( npoin, 0 );

  <span class="comment">// fill both psup1 and psup2</span>
  psup2[0] = 0;
  std::size_t j = 0;
  <span class="keywordflow">for</span> (std::size_t p=0; p&lt;npoin; ++p) {
    <span class="keywordflow">for</span> (std::size_t i=esup2[p]+1; i&lt;=esup2[p+1]; ++i ) {
      <span class="keywordflow">for</span> (std::size_t n=0; n&lt;nnpe; ++n) {
        <span class="keyword">auto</span> q = inpoel[ esup1[i] * nnpe + n ];
        <span class="keywordflow">if</span> (q != p &amp;&amp; lpoin[q] != p+1) {
          ++j;
          psup1.push_back( q );
          lpoin[q] = p+1;
        }
      }
    }
    psup2[p+1] = j;
  }

  <span class="comment">// sort point ids for each point in psup1</span>
  <span class="keywordflow">for</span> (std::size_t p=0; p&lt;npoin; ++p)
    std::sort(
      std::next( begin(psup1), static_cast&lt;std::ptrdiff_t&gt;(psup2[p]+1) ),
      std::next( begin(psup1), static_cast&lt;std::ptrdiff_t&gt;(psup2[p+1]+1) ) );

  <span class="comment">// Return (move out) linked lists</span>
  <span class="keywordflow">return</span> std::make_pair( std::move(psup1), std::move(psup2) );
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad6260a3dcdcb9a995a4886e566b665c4"></a><!-- doxytag: member="tk::hms" ref="ad6260a3dcdcb9a995a4886e566b665c4" args="(tk::real stamp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtk_1_1_timer_1_1_watch.html">Timer::Watch</a> <a class="el" href="namespacetk.html#ad6260a3dcdcb9a995a4886e566b665c4">tk::hms</a> </td>
          <td>(</td>
          <td class="paramtype">tk::real&#160;</td>
          <td class="paramname"><em>stamp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert existing time stamp as a real to Watch (global scope) </p>
<p>Convert existing time stamp as a real to Watch (global-scope) </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stamp</td><td>Time stamp as a real number </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Time as hours, minutes, and seconds, as a Watch struct. </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_timer_8_c_source.html#l00094">94</a> of file <a class="el" href="_timer_8_c_source.html">Timer.C</a>.</p>

<p>Referenced by <a class="el" href="_inciter_8_c_source.html#l00165">Main::execute()</a>, <a class="el" href="_inciter_8_c_source.html#l00174">Main::finalize()</a>, and <a class="el" href="_inciter_8_c_source.html#l00191">Main::timestamp()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">using</span> std::chrono::duration_cast;
  <span class="keyword">const</span> <span class="keyword">auto</span> d = Timer::Dsec( stamp );
  <span class="keywordflow">return</span>
    Timer::Watch( duration_cast&lt; Timer::hours &gt;( d ),
                  duration_cast&lt; Timer::minutes &gt;( d ) % Timer::hours(1),
                  duration_cast&lt; Timer::seconds &gt;( d ) % Timer::minutes(1) );
}
</pre></div>
</div>
</div>
<a class="anchor" id="aeb9673379e599043b13fff369dce1402"></a><!-- doxytag: member="tk::instantiate" ref="aeb9673379e599043b13fff369dce1402" args="(const Factory &amp;f, const Key &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Factory , class Key , class Obj  = typename std::remove_pointer&lt;                        typename Factory::mapped_type::result_type &gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; Obj &gt; <a class="el" href="namespacetk.html#aeb9673379e599043b13fff369dce1402">tk::instantiate</a> </td>
          <td>(</td>
          <td class="paramtype">const Factory &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Instantiate object from factory. Factory must have a mapped_value which must have a result_type ptr, e.g., std::map&lt; Key, std::function&lt; Obj*() &gt; &gt;. This wrapper function can be used to instantiate an derived-class object from a factory, repeatedly filled with wrapper function 'record' above. The factory, as described in the documentation of 'record', stores base class pointers in an associative container, thereby facilitating runtime polymorphism and a simple lookup-and-instantiate-style object creation. The object instantiated is of type Child class. This function works in conjunction with boost::factory, i.e., uses reference semantics (works with storing pointers of objects). For a simple example on how to use this function, see UnitTest/tests/Base/Factory.h. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Factory to instantiate object from (std::map with value using reference semantics) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key used to identify the object to instantiate from factory </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>std::unique_ptr pointing to the object instantiated from factory </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespacetk.html#a5eccb941ad0c5499c356c717000f1842">record</a> </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_factory_8h_source.html#l00076">76</a> of file <a class="el" href="_factory_8h_source.html">Factory.h</a>.</p>

<p>References <a class="el" href="_exception_8h_source.html#l00049">Assert</a>.</p>
<div class="fragment"><pre class="fragment">                                                                     {
  <span class="keyword">const</span> <span class="keyword">auto</span> it = f.find( key );
  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810" title="Assert macro that only throws an exception if expr fails.">Assert</a>( it != end( f ), <span class="stringliteral">&quot;No such object registered in factory&quot;</span> );
  <span class="keywordflow">return</span> std::unique_ptr&lt; Obj &gt;( it-&gt;second() );
}
</pre></div>
</div>
</div>
<a class="anchor" id="a6c68c42b8cf1dd91142411308913a13e"></a><!-- doxytag: member="tk::lid" ref="a6c68c42b8cf1dd91142411308913a13e" args="(const std::map&lt; Key, Value &gt; &amp;map, Key key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; Key, Value &gt;::size_type <a class="el" href="namespacetk.html#a6c68c42b8cf1dd91142411308913a13e">tk::lid</a> </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; Key, Value &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find and return value for key in std::map with error handling </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>Map associating values to keys </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Value associated to key in map  This functions should not be instantiated with heavy Key types, as it is passed by value. </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_container_util_8h_source.html#l00090">90</a> of file <a class="el" href="_container_util_8h_source.html">ContainerUtil.h</a>.</p>

<p>References <a class="el" href="_exception_8h_source.html#l00034">Throw</a>.</p>

<p>Referenced by <a class="el" href="_performer_8_c_source.html#l00321">inciter::Performer::assignLid()</a>, <a class="el" href="_performer_8_c_source.html#l00284">inciter::Performer::initIds()</a>, and <a class="el" href="_lin_sys_merger_8h_source.html#l00534">tk::LinSysMerger&lt; HostProxy, WorkerProxy &gt;::updateSolution()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keyword">const</span> <span class="keyword">auto</span> it = map.find( key );

  <span class="keywordflow">if</span> (it != map.end())
    <span class="keywordflow">return</span> it-&gt;second;
  <span class="keywordflow">else</span>
    <a class="code" href="_exception_8h.html#a0412f798470c18f503a2c2f63c970ba8" title="Throw macro that always throws an exception.">Throw</a>( <span class="stringliteral">&quot;Can&#39;t find key &quot;</span> + std::to_string(key) );
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae484074849c5c9532282fc9fa4e19467"></a><!-- doxytag: member="tk::linearLoadDistributor" ref="ae484074849c5c9532282fc9fa4e19467" args="(tk::real virtualization, uint64_t load, int npe, uint64_t &amp;chunksize, uint64_t &amp;remainder)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t <a class="el" href="namespacetk.html#ae484074849c5c9532282fc9fa4e19467">tk::linearLoadDistributor</a> </td>
          <td>(</td>
          <td class="paramtype">tk::real&#160;</td>
          <td class="paramname"><em>virtualization</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>load</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>npe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t &amp;&#160;</td>
          <td class="paramname"><em>chunksize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t &amp;&#160;</td>
          <td class="paramname"><em>remainder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute linear load distribution for given total work and virtualization. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">virtualization</td><td>Degree of virtualization [0.0...1.0] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">load</td><td>Total load, e.g., number of particles, number of mesh cells </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">npe</td><td>Number of processing elements to distribute the load to </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">inout]</td><td>chunksize Chunk size, see detailed description </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">inout]</td><td>remainder Remainder, see detailed description </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of work units</dd></dl>
<p>Compute load distibution (number of chares and chunksize) based on total work (e.g., total number of particles) and virtualization</p>
<p>The virtualization parameter, specified by the user, is a real number between 0.0 and 1.0, inclusive, which controls the degree of virtualization or over-decomposition. Independent of the value of virtualization the work is approximately evenly distributed among the available processing elements, given by npe. For zero virtualization (no over-decomposition), the work is simply decomposed into total_work/numPEs, which yields the smallest number of Charm++ chares and the largest chunks of work units. The other extreme is unity virtualization, which decomposes the total work into the smallest size work units possible, yielding the largest number of Charm++ chares. Obviously, the optimum will be between 0.0 and 1.0, depending on the problem.</p>
<p>The formula implemented uses a linear relationship between the virtualization parameter and the number of work units with the extremes described above. The formula is given by</p>
<p>chunksize = (1 - n) * v + n;</p>
<p>where</p>
<ul>
<li>v = degree of virtualization</li>
<li>n = load/npes</li>
<li>load = total work, e.g., number of particles, number of mesh cells</li>
<li>npes = number of hardware processing elements <dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>
</li>
</ul>

<p>Definition at line <a class="el" href="_load_distributor_8_c_source.html#l00022">22</a> of file <a class="el" href="_load_distributor_8_c_source.html">LoadDistributor.C</a>.</p>

<p>References <a class="el" href="_exception_8h_source.html#l00049">Assert</a>.</p>

<p>Referenced by <a class="el" href="_distributor_8_c_source.html#l00063">walker::Distributor::Distributor()</a>, and <a class="el" href="_inciter_setup_8_c_source.html#l00455">inciter::prepareMesh()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810" title="Assert macro that only throws an exception if expr fails.">Assert</a>( virtualization &gt; -std::numeric_limits&lt; tk::real &gt;::epsilon() &amp;&amp;
          virtualization &lt; 1.0+std::numeric_limits&lt; tk::real &gt;::epsilon(),
          <span class="stringliteral">&quot;Virtualization parameter must be between [0.0...1.0]&quot;</span> );
  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810" title="Assert macro that only throws an exception if expr fails.">Assert</a>( npe &gt; 0, <span class="stringliteral">&quot;Number of processing elements must be larger than zero&quot;</span> );

  <span class="comment">// Compute minimum number of work units</span>
  <span class="keyword">const</span> <span class="keyword">auto</span> n = <span class="keyword">static_cast&lt;</span> tk::real <span class="keyword">&gt;</span>( load ) / npe;

  <span class="comment">// Compute work unit size based on the linear formula above</span>
  chunksize = <span class="keyword">static_cast&lt;</span> uint64_t <span class="keyword">&gt;</span>( (1.0 - n) * virtualization + n );

  <span class="comment">// Compute number of work units with size computed ignoring remainder</span>
  uint64_t nchare = load / chunksize;

  <span class="comment">// Compute remainder of work if the above number of units were to be created</span>
  remainder = load - nchare * chunksize;

  <span class="comment">// Redistribute remainder among the work units for a more equal distribution</span>
  chunksize += remainder / nchare;

  <span class="comment">// Compute new remainder (after redistribution of the previous remainder)</span>
  remainder = load - nchare * chunksize;

  <span class="comment">// Return number of work units (number of Charm++ chares)</span>
  <span class="keywordflow">return</span> nchare;
}
</pre></div>
</div>
</div>
<a class="anchor" id="af9d21933fc9e1a656db37419b2173f5f"></a><!-- doxytag: member="tk::Main" ref="af9d21933fc9e1a656db37419b2173f5f" args="(int argc, char *argv[], const CmdLine &amp;cmdline, HeaderType header, const std::string &amp;executable, const Printer &amp;print)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Driver , class Printer , class CmdLine &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtk_1_1_driver.html">Driver</a> <a class="el" href="namespacetk.html#af9d21933fc9e1a656db37419b2173f5f">tk::Main</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>argv</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CmdLine &amp;&#160;</td>
          <td class="paramname"><em>cmdline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HeaderType&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>executable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Printer &amp;&#160;</td>
          <td class="paramname"><em>print</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generic <a class="el" href="namespacetk.html#af9d21933fc9e1a656db37419b2173f5f" title="Generic Main() used for all executables for code-reuse and a uniform output.">Main()</a> used for all executables for code-reuse and a uniform output. </p>
<p>The template arguments configure this <a class="el" href="class_main.html" title="Charm++ main chare for the shock hydroddynamics executable, inciter.">Main</a> class that is practically used instead of the usual <a class="el" href="_inciter_8_c.html#a3c04138a5bfe5d72780bb7e82a18e627" title="Inciter main()">main()</a>. This allows code-reuse and a unfirom screen-output. The template arguments are:</p>
<ul>
<li><a class="el" href="classtk_1_1_driver.html">Driver</a>, specializaing the driver type to be created, see <a class="el" href="classtk_1_1_driver.html">tk::Driver</a></li>
<li>Printer, specializaing the pretty printer type to use, see <a class="el" href="classtk_1_1_print.html">tk::Print</a></li>
<li>CmdLine, specializing the command line object storing data parsed from the command line <dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">argc</td><td>Number of command-line arguments to executable </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">argv</td><td>C-style string array to command-line arguments to executable </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmdline</td><td>Command line object storing data parsed from the command line arguments </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">header</td><td>Header type enum indicating which executable header to print </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">executable</td><td>Name of the executable </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">print</td><td>Pretty printer to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Instantiated driver object which can then be used to execute() whatever it is intended to drive </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>
</li>
</ul>

<p>Definition at line <a class="el" href="_init_8h_source.html#l00187">187</a> of file <a class="el" href="_init_8h_source.html">Init.h</a>.</p>

<p>References <a class="el" href="_init_8h_source.html#l00106">echoBuildEnv()</a>, <a class="el" href="_init_8h_source.html#l00082">echoHeader()</a>, and <a class="el" href="_init_8h_source.html#l00137">echoRunEnv()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">// Echo program header</span>
  <a class="code" href="namespacetk.html#afbbf10b984ba3f66b55cc8363c6a2341" title="Echo program header.">echoHeader</a>( print, header );

  <span class="comment">// Echo environment</span>
  print.part( <span class="stringliteral">&quot;Environment&quot;</span> );
  <span class="comment">// Build environment</span>
  <a class="code" href="namespacetk.html#ab72923dba604ccbf4233af3ccafc70b3" title="Echo build environment.">echoBuildEnv</a>( print, executable );
  <span class="comment">// Runtime environment</span>
  <a class="code" href="namespacetk.html#a991ea7a4015fef3262bdb056f840bf82" title="Echo runtime environment.">echoRunEnv</a>( print, argc, argv, cmdline.template get&lt; tag::verbose &gt;() );

  <span class="comment">// Create and return driver</span>
  <span class="keywordflow">return</span> Driver( print, cmdline );
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_af9d21933fc9e1a656db37419b2173f5f_cgraph.svg" width="491" height="494"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a7d4b15650c1811f0e22a149c4000835e"></a><!-- doxytag: member="tk::make_unique" ref="a7d4b15650c1811f0e22a149c4000835e" args="(_Args &amp;&amp;...__args)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename... _Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtk_1_1___make_uniq.html">_MakeUniq</a>&lt;_Tp&gt;::__single_object <a class="el" href="namespacetk.html#a7d4b15650c1811f0e22a149c4000835e">tk::make_unique</a> </td>
          <td>(</td>
          <td class="paramtype">_Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>__args</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>std::make_unique for single objects </p>

<p>Definition at line <a class="el" href="_make__unique_8h_source.html#l00045">45</a> of file <a class="el" href="_make__unique_8h_source.html">Make_unique.h</a>.</p>
<div class="fragment"><pre class="fragment">  { <span class="keywordflow">return</span> unique_ptr&lt;_Tp&gt;(<span class="keyword">new</span> _Tp(std::forward&lt;_Args&gt;(__args)...)); }
</pre></div>
</div>
</div>
<a class="anchor" id="a9673c73139b1b3cfb2115976c8d4bda0"></a><!-- doxytag: member="tk::make_unique" ref="a9673c73139b1b3cfb2115976c8d4bda0" args="(size_t __num)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtk_1_1___make_uniq.html">_MakeUniq</a>&lt;_Tp&gt;::__array <a class="el" href="namespacetk.html#a7d4b15650c1811f0e22a149c4000835e">tk::make_unique</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>__num</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>std::make_unique for arrays of unknown bound </p>

<p>Definition at line <a class="el" href="_make__unique_8h_source.html#l00051">51</a> of file <a class="el" href="_make__unique_8h_source.html">Make_unique.h</a>.</p>
<div class="fragment"><pre class="fragment">  { <span class="keywordflow">return</span> unique_ptr&lt;_Tp&gt;(<span class="keyword">new</span> <span class="keyword">typename</span> remove_extent&lt;_Tp&gt;::type[__num]()); }
</pre></div>
</div>
</div>
<a class="anchor" id="a8f05614e8d8ba124ebe2cec8c19e985c"></a><!-- doxytag: member="tk::make_unique" ref="a8f05614e8d8ba124ebe2cec8c19e985c" args="(_Args &amp;&amp;...)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename... _Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtk_1_1___make_uniq.html">_MakeUniq</a>&lt;_Tp&gt;::__invalid_type <a class="el" href="namespacetk.html#a7d4b15650c1811f0e22a149c4000835e">tk::make_unique</a> </td>
          <td>(</td>
          <td class="paramtype">_Args &amp;&amp;&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disable std::make_unique for arrays of known bound. </p>

</div>
</div>
<a class="anchor" id="aabd06aee13370660ff0109b8f8b1958e"></a><!-- doxytag: member="tk::operator&lt;&lt;" ref="aabd06aee13370660ff0109b8f8b1958e" args="(std::basic_ostream&lt; Ch, Tr &gt; &amp;os, const T &amp;e)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Ch , typename Tr , typename std::enable_if&lt; std::is_enum&lt; T &gt;::value, int &gt;::type  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_ostream&lt; Ch, Tr &gt; &amp; tk::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; Ch, Tr &gt; &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Operator &lt;&lt; for writing enum class value to output streams. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>Output stream into which e is written </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>Value of enum class to write to stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Updated output stream for chain-use of the operator </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi</dd></dl>
<p>Delegate operator &lt;&lt; to default for writing non-enums to output streams. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>Output stream into which t is written </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>Value of arbitrary non-enum-class type to write to stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Updated output stream for chain-use of the operator </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_str_conv_util_8h_source.html#l00026">26</a> of file <a class="el" href="_str_conv_util_8h_source.html">StrConvUtil.h</a>.</p>
<div class="fragment"><pre class="fragment">                                                          {
  os &lt;&lt; static_cast&lt; unsigned int &gt;( e );
  <span class="keywordflow">return</span> os;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a1bbb9b08d37f6f5f3bed45effc8fc64e"></a><!-- doxytag: member="tk::operator&lt;&lt;" ref="a1bbb9b08d37f6f5f3bed45effc8fc64e" args="(std::basic_ostream&lt; Ch, Tr &gt; &amp;os, const std::vector&lt; T &gt; &amp;t)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Ch , typename Tr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_ostream&lt; Ch, Tr &gt;&amp; tk::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_ostream&lt; Ch, Tr &gt; &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Operator &lt;&lt; for writing std::vector&lt; T &gt; to output streams; for debugging. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>Output stream to write to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>std::vector of arbitrary type T to write to stream </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Updated output stream </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_msg_8h_source.html#l00039">39</a> of file <a class="el" href="_msg_8h_source.html">Msg.h</a>.</p>
<div class="fragment"><pre class="fragment">                                                                       {
  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v : t) os &lt;&lt; <span class="stringliteral">&quot;&#39;&quot;</span> &lt;&lt; v &lt;&lt; <span class="stringliteral">&quot;&#39; s:&quot;</span> &lt;&lt; v.size() &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;
  <span class="keywordflow">return</span> os;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa160d13ea2e4a3498916472c3b6cdbb0"></a><!-- doxytag: member="tk::operator&lt;&lt;" ref="aa160d13ea2e4a3498916472c3b6cdbb0" args="(std::basic_string&lt; Ch, Tr &gt; &amp;lhs, const T &amp;e)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Ch , typename Tr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_string&lt; Ch, Tr &gt; tk::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_string&lt; Ch, Tr &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Operator &lt;&lt; for adding (concatenating) T to a std::basic_string for lvalues. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>Output std::basic_string into which e is written </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>Value of arbitrary type to write to string </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Updated string </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_str_conv_util_8h_source.html#l00051">51</a> of file <a class="el" href="_str_conv_util_8h_source.html">StrConvUtil.h</a>.</p>
<div class="fragment"><pre class="fragment">                                                          {
  std::stringstream ss;
  ss &lt;&lt; lhs &lt;&lt; e;
  lhs = ss.str();
  <span class="keywordflow">return</span> lhs;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a7adfa2dfb8b3a38f60ac0edf5666b6c4"></a><!-- doxytag: member="tk::operator&lt;&lt;" ref="a7adfa2dfb8b3a38f60ac0edf5666b6c4" args="(std::basic_string&lt; Ch, Tr &gt; &amp;&amp;lhs, const T &amp;e)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Ch , typename Tr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::basic_string&lt; Ch, Tr &gt; tk::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::basic_string&lt; Ch, Tr &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Operator &lt;&lt; for adding (concatenating) T to a std::basic_string for rvalues. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>Output std::basic_string into which e is written </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>Value of arbitrary type to write to string </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Updated string </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_str_conv_util_8h_source.html#l00065">65</a> of file <a class="el" href="_str_conv_util_8h_source.html">StrConvUtil.h</a>.</p>
<div class="fragment"><pre class="fragment">                                                           {
  <span class="keywordflow">return</span> lhs &lt;&lt; e;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a64b09f52ea3b4314e449e70255837836"></a><!-- doxytag: member="tk::pickOutput" ref="a64b09f52ea3b4314e449e70255837836" args="(const std::string &amp;filename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetk.html#af939b5fb62841ad69ce26159d7703cc5">MeshWriter</a> <a class="el" href="namespacetk.html#a64b09f52ea3b4314e449e70255837836">tk::pickOutput</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determine output mesh file type. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>Filename to pick its type based on extension given </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>enum specifying the mesh writer type </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_mesh_factory_8_c_source.html#l00060">60</a> of file <a class="el" href="_mesh_factory_8_c_source.html">MeshFactory.C</a>.</p>

<p>References <a class="el" href="_mesh_factory_8h_source.html#l00025">EXODUSII</a>, <a class="el" href="_mesh_factory_8h_source.html#l00023">GMSH</a>, <a class="el" href="_mesh_factory_8h_source.html#l00024">NETGEN</a>, and <a class="el" href="_exception_8h_source.html#l00034">Throw</a>.</p>

<p>Referenced by <a class="el" href="_mesh_factory_8_c_source.html#l00120">writeUnsMesh()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">// Get extension of input file name</span>
  std::string fn = filename;
  std::string ext( fn.substr(fn.find_last_of(<span class="stringliteral">&quot;.&quot;</span>) + 1) );

  <span class="keywordflow">if</span> ( ext == <span class="stringliteral">&quot;msh&quot;</span> ) {
    <span class="keywordflow">return</span> <a class="code" href="namespacetk.html#af939b5fb62841ad69ce26159d7703cc5a455f9201094ecb9c7e6307eeea5ce25c">MeshWriter::GMSH</a>;
  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ext == <span class="stringliteral">&quot;exo&quot;</span> || ext == <span class="stringliteral">&quot;h5&quot;</span> ) {
    <span class="keywordflow">return</span> <a class="code" href="namespacetk_1_1ctr.html#abdf7f48d3f0b49c9493d75f59c0d6218a130b728ec985a6380ea06a1bf2f20aec">MeshWriter::EXODUSII</a>;
  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ext == <span class="stringliteral">&quot;mesh&quot;</span> ) {
    <span class="keywordflow">return</span> <a class="code" href="namespacetk.html#af939b5fb62841ad69ce26159d7703cc5a1e61700dafa65b3b779b95c5c1c780d3">MeshWriter::NETGEN</a>;
  } <span class="keywordflow">else</span> {
    <a class="code" href="_exception_8h.html#a0412f798470c18f503a2c2f63c970ba8" title="Throw macro that always throws an exception.">Throw</a>( <span class="stringliteral">&quot;Output mesh file type could not be determined from extension of &quot;</span>
           <span class="stringliteral">&quot;filename &#39;&quot;</span> + filename + <span class="stringliteral">&quot;&#39;; valid extensions are: &quot;</span>
           <span class="stringliteral">&quot;&#39;msh&#39; for Gmsh, &#39;exo&#39; or &#39;h5&#39; for ExodusII, &#39;mesh&#39; for Netgen&#39;s &quot;</span>
           <span class="stringliteral">&quot;neutral&quot;</span> );
  }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a9e673ba34e4398c95190bfa42391d101"></a><!-- doxytag: member="tk::poinCommMaps" ref="a9e673ba34e4398c95190bfa42391d101" args="(const tk::UnsMesh &amp;graph, const std::vector&lt; std::size_t &gt; &amp;chp, const std::vector&lt; std::size_t &gt; &amp;tetinpoel, std::size_t nchare, std::string &amp;&amp;toofine)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::map&lt; std::size_t, std::vector&lt; std::size_t &gt; &gt; &gt; <a class="el" href="namespacetk.html#a9e673ba34e4398c95190bfa42391d101">tk::poinCommMaps</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtk_1_1_uns_mesh.html">tk::UnsMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>chp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>tetinpoel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>nchare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&amp;&#160;</td>
          <td class="paramname"><em>toofine</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute point-based communication maps. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>Unstructured mesh graph object </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">chp</td><td>Array of chare ownership IDs mapping graph points to concurrent async chares </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tetinpoel</td><td>Tetrahedra element connectivity </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nchare</td><td>Number of work units (Charm++ chares) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">toofine</td><td>Error message to print triggered for too large overdecomposition </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Point-based communication map for all chares</dd></dl>
<p>This is a _point-based_ export map, because it stores the global ids of the mesh points that chares need to export to fellow chares computed based on which chare owns a mesh point. This is for algorithms that work by computing data on the mesh by looping over mesh points and their surrounding points, e.g., edge-based algorithms. The communication map computed here is stored in a vector of maps associating a vector of global mesh point ids to chare ids that the points need to be exported to. Using the map produced here amounts to each chare taking its own map indexing the outermost vector with its chare index. The map computed here is an an export map from which the import map can be computed if needed.</p>
<p>In the MPI paradigm, these chare export maps correspond to the export lists, i.e., lists of global ids exported by a given rank to a set of receiver ranks and their associated mesh points sent at which data are to be sent (exported). This is as opposed to import maps which are lists of global ids imported by a given rank to a set of sender ranks and their associated mesh points sent at which data are to be received (imported). For example, in Zoltan, this export/import roughly corresponds to the "exported" and "imported" mesh node ids after partitioning. Actually, Zoltan_LB_Partition() already returns this information. However, if the partitioning with Zoltan is done using less MPI ranks than the number of desired mesh partitions, i.e., overdecomposition (as is the case here), there are more mesh partitions than MPI ranks and thus the arrays returned by Zoltan are not sufficient to determine the export and import maps for all the chares. Thus we compute the export mapping here. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is only supposed to operate on MPI rank 0. </dd>
<dd>
This function does not and should not modify global-scope data. </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_comm_map_8_c_source.html#l00029">29</a> of file <a class="el" href="_comm_map_8_c_source.html">CommMap.C</a>.</p>

<p>References <a class="el" href="_exception_8h_source.html#l00049">Assert</a>, <a class="el" href="_exception_8h_source.html#l00059">ErrChk</a>, <a class="el" href="_derived_data_8_c_source.html#l00026">genEsup()</a>, <a class="el" href="_derived_data_8_c_source.html#l00110">genPsup()</a>, and <a class="el" href="_uns_mesh_8h_source.html#l00129">tk::UnsMesh::size()</a>.</p>

<p>Referenced by <a class="el" href="_inciter_setup_8_c_source.html#l00303">inciter::assignMesh()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">// Map to associate a chare id to a map of receiver chare ids associated to</span>
  <span class="comment">// unique global point ids sent (export map)</span>
  std::map&lt; std::size_t,
            std::map&lt; std::size_t, std::set&lt; std::size_t &gt; &gt; &gt; comm;

  <span class="comment">// Generate points surrounding points</span>
  <span class="keyword">auto</span> psup = <a class="code" href="namespacetk.html#ad2a88a65102c17149b44660db15d445b" title="Generate derived data structure, points surrounding points.">tk::genPsup</a>( tetinpoel, 4, <a class="code" href="namespacetk.html#a66a2889d5d8aeb4a836842c6a1010463" title="Generate derived data structure, elements surrounding points.">tk::genEsup</a>(tetinpoel,4) );

  <span class="comment">// Construct point-based export maps</span>
  <span class="keywordflow">for</span> (std::size_t p=0; p&lt;graph.<a class="code" href="classtk_1_1_uns_mesh.html#aa271a359fbefbf064b0df8fdfed43f6e">size</a>(); ++p)  <span class="comment">// for all mesh points</span>
    <span class="keywordflow">for</span> (<span class="keyword">auto</span> i=psup.second[p]+1; i&lt;=psup.second[p+1]; ++i) {
      <span class="keyword">auto</span> q = psup.first[i];
      <span class="keywordflow">if</span> (chp[p] != chp[q])   <span class="comment">// if the point-colors differ, store global id</span>
        comm[ chp[p] ][ chp[q] ].insert( p );
    }

  <span class="comment">// This check should always be done, as it can result from incorrect user</span>
  <span class="comment">// input compared to the mesh size and not due to programmer error.</span>
  <a class="code" href="_exception_8h.html#ac75cd6578896829d2bfbccf5de71de4f" title="ErrChk macro that only throws an exception if expr fails.">ErrChk</a>( comm.size() == nchare, std::move(toofine) );

<span class="preprocessor">  #ifndef NDEBUG</span>
<span class="preprocessor"></span>  std::size_t c = 0;
<span class="preprocessor">  #endif</span>
<span class="preprocessor"></span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; e : comm)
    <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810" title="Assert macro that only throws an exception if expr fails.">Assert</a>( e.first == c++,
            <span class="stringliteral">&quot;Export/import maps should not be missing for chare id &quot;</span> +
            std::to_string(c-1) );

  <span class="comment">// Construct final product: a vector of export maps associating receiver</span>
  <span class="comment">// chare ids to unique communicated global point ids for all chare ids, and</span>
  <span class="comment">// store it in global scope so that the Charm++ chares can access it</span>
  std::vector&lt; std::map&lt; std::size_t, std::vector&lt; std::size_t &gt; &gt; &gt;
    pcomm( nchare );
  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; e : comm) {
    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; x : e.second)
      <span class="keywordflow">for</span> (<span class="keyword">auto</span> p : x.second)
        pcomm[ e.first ][ x.first ].push_back( p );
  }

  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810" title="Assert macro that only throws an exception if expr fails.">Assert</a>( pcomm.size() == nchare,
          <span class="stringliteral">&quot;Number of export/import maps must equal the number of chares&quot;</span> );

<span class="comment">//   std::size_t h = 0;</span>
<span class="comment">//   for (const auto&amp; m : pcomm) {</span>
<span class="comment">//     std::cout &lt;&lt; h++ &lt;&lt; &quot; p-&gt; &quot;;</span>
<span class="comment">//     for (const auto&amp; x : m) {</span>
<span class="comment">//       std::cout &lt;&lt; x.first &lt;&lt; &quot;: &quot;;</span>
<span class="comment">//       for (auto p : x.second)</span>
<span class="comment">//         std::cout &lt;&lt; p &lt;&lt; &quot; &quot;;</span>
<span class="comment">//     }</span>
<span class="comment">//     std::cout &lt;&lt; &#39;\n&#39;;</span>
<span class="comment">//   }</span>

  <span class="keywordflow">return</span> pcomm;
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_a9e673ba34e4398c95190bfa42391d101_cgraph.svg" width="331" height="139"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="af04df49334286e653e440035c499a8d1"></a><!-- doxytag: member="tk::processExceptionCharm" ref="af04df49334286e653e440035c499a8d1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacetk.html#af04df49334286e653e440035c499a8d1">tk::processExceptionCharm</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Process an exception from the Charm++ runtime system. </p>
<p>See Josuttis, The C++ Standard Library - A Tutorial and Reference, 2nd Edition, 2012. </p>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_process_exception_8_c_source.html#l00040">40</a> of file <a class="el" href="_process_exception_8_c_source.html">ProcessException.C</a>.</p>

<p>References <a class="el" href="_exception_8_c_source.html#l00194">tk::Exception::handleException()</a>.</p>

<p>Referenced by <a class="el" href="_inciter_8_c_source.html#l00165">Main::execute()</a>, <a class="el" href="_inciter_8_c_source.html#l00174">Main::finalize()</a>, <a class="el" href="_inciter_8_c_source.html#l00201">Main::perfstat()</a>, and <a class="el" href="_inciter_8_c_source.html#l00191">Main::timestamp()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">try</span> {
    <span class="keywordflow">throw</span>;      <span class="comment">// rethrow exception to deal with it here</span>
  }
  <span class="comment">// Catch tk::Exception</span>
  <span class="keywordflow">catch</span> ( <a class="code" href="classtk_1_1_exception.html" title="Basic exception class for producing file:func:line info + call trace.">tk::Exception</a>&amp; qe ) {
    <span class="keywordflow">if</span> (!CkMyPe()) qe.<a class="code" href="classtk_1_1_exception.html#aef3989f5d076c0282329daa2a646b1c6" title="Handle Exception.">handleException</a>();
  }
  <span class="comment">// Catch std::exception and transform it into tk::Exception without</span>
  <span class="comment">// file:line:func information</span>
  <span class="keywordflow">catch</span> ( std::exception&amp; se ) {
    <a class="code" href="classtk_1_1_exception.html" title="Basic exception class for producing file:func:line info + call trace.">tk::Exception</a> qe( se.what() );
    <span class="keywordflow">if</span> (!CkMyPe()) qe.<a class="code" href="classtk_1_1_exception.html#aef3989f5d076c0282329daa2a646b1c6" title="Handle Exception.">handleException</a>();
  }
  <span class="comment">// Catch uncaught exception</span>
  <span class="keywordflow">catch</span> (...) {
    <a class="code" href="classtk_1_1_exception.html" title="Basic exception class for producing file:func:line info + call trace.">tk::Exception</a> qe( <span class="stringliteral">&quot;Non-standard exception&quot;</span> );
    <span class="keywordflow">if</span> (!CkMyPe()) qe.<a class="code" href="classtk_1_1_exception.html#aef3989f5d076c0282329daa2a646b1c6" title="Handle Exception.">handleException</a>();
  }

  <span class="comment">// Tell the runtime system to exit with a message</span>
  CkAbort( <span class="stringliteral">&quot;Exception caught&quot;</span> );
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="namespacetk_af04df49334286e653e440035c499a8d1_cgraph.svg" width="100%" height="106"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a2a62b5b6880fbd0a011cedf8896b19dc"></a><!-- doxytag: member="tk::processExceptionMPI" ref="a2a62b5b6880fbd0a011cedf8896b19dc" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacetk.html#a2a62b5b6880fbd0a011cedf8896b19dc">tk::processExceptionMPI</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Process an exception from the MPI runtime system. </p>
<p>See Josuttis, The C++ Standard Library - A Tutorial and Reference, 2nd Edition, 2012. </p>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_process_exception_8_c_source.html#l00072">72</a> of file <a class="el" href="_process_exception_8_c_source.html">ProcessException.C</a>.</p>

<p>References <a class="el" href="_exception_8h_source.html#l00064">FAILURE</a>, and <a class="el" href="_exception_8_c_source.html#l00194">tk::Exception::handleException()</a>.</p>

<p>Referenced by <a class="el" href="_inciter_8_c_source.html#l00236">main()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> peid;
  MPI_Comm_rank( MPI_COMM_WORLD, &amp;peid );  

  <span class="keywordflow">try</span> {
    <span class="keywordflow">throw</span>;      <span class="comment">// rethrow exception to deal with it here</span>
  }
  <span class="comment">// Catch tk::Exception</span>
  <span class="keywordflow">catch</span> ( <a class="code" href="classtk_1_1_exception.html" title="Basic exception class for producing file:func:line info + call trace.">tk::Exception</a>&amp; qe ) {
    <span class="keywordflow">if</span> (peid == 0) qe.<a class="code" href="classtk_1_1_exception.html#aef3989f5d076c0282329daa2a646b1c6" title="Handle Exception.">handleException</a>();
  }
  <span class="comment">// Catch std::exception and transform it into tk::Exception without</span>
  <span class="comment">// file:line:func information</span>
  <span class="keywordflow">catch</span> ( std::exception&amp; se ) {
    <a class="code" href="classtk_1_1_exception.html" title="Basic exception class for producing file:func:line info + call trace.">tk::Exception</a> qe( se.what() );
    <span class="keywordflow">if</span> (peid == 0) qe.<a class="code" href="classtk_1_1_exception.html#aef3989f5d076c0282329daa2a646b1c6" title="Handle Exception.">handleException</a>();
  }
  <span class="comment">// Catch uncaught exception</span>
  <span class="keywordflow">catch</span> (...) {
    <a class="code" href="classtk_1_1_exception.html" title="Basic exception class for producing file:func:line info + call trace.">tk::Exception</a> qe( <span class="stringliteral">&quot;Non-standard exception&quot;</span> );
    <span class="keywordflow">if</span> (peid == 0) qe.<a class="code" href="classtk_1_1_exception.html#aef3989f5d076c0282329daa2a646b1c6" title="Handle Exception.">handleException</a>();
  }

  <span class="comment">// Tell the runtime system to exit with error code</span>
  MPI_Abort( MPI_COMM_WORLD, <a class="code" href="namespacetk.html#afcc275d91d4368505f221061b9ba822aac0d05ac793a72e012dcf46dd3d08e6a1" title="Exceptions occurred.">tk::ErrCode::FAILURE</a> );
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="namespacetk_a2a62b5b6880fbd0a011cedf8896b19dc_cgraph.svg" width="100%" height="106"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="ab964262adcc6f9ebdf8545891d9b4725"></a><!-- doxytag: member="tk::query" ref="ab964262adcc6f9ebdf8545891d9b4725" args="(const std::map&lt; Tag, Timer &gt; &amp;timers, Tag t)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tag &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tk::real <a class="el" href="namespacetk.html#ab964262adcc6f9ebdf8545891d9b4725">tk::query</a> </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; Tag, Timer &gt; &amp;&#160;</td>
          <td class="paramname"><em>timers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tag&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Query timer from timer map </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timers</td><td><a class="el" href="classtk_1_1_timer.html">Timer</a> map </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>Tag to look for </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classtk_1_1_timer.html">Timer</a> clock state in seconds </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_timer_8h_source.html#l00113">113</a> of file <a class="el" href="_timer_8h_source.html">Timer.h</a>.</p>

<p>References <a class="el" href="_exception_8h_source.html#l00034">Throw</a>.</p>
<div class="fragment"><pre class="fragment">                                                   {
  <span class="keyword">const</span> <span class="keyword">auto</span> it = timers.find( t );
  <span class="keywordflow">if</span> (it != timers.end())
    <span class="keywordflow">return</span> it-&gt;second.dsec();
  <span class="keywordflow">else</span>
    <a class="code" href="_exception_8h.html#a0412f798470c18f503a2c2f63c970ba8" title="Throw macro that always throws an exception.">Throw</a>( <span class="stringliteral">&quot;Can&#39;t find timer tag&quot;</span> );
}
</pre></div>
</div>
</div>
<a class="anchor" id="aed9a0acd7495c7400aa3d167715ba3be"></a><!-- doxytag: member="tk::readUnsMesh" ref="aed9a0acd7495c7400aa3d167715ba3be" args="(const std::string &amp;filename, std::pair&lt; std::string, tk::real &gt; &amp;timestamp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtk_1_1_uns_mesh.html">UnsMesh</a> <a class="el" href="namespacetk.html#aed9a0acd7495c7400aa3d167715ba3be">tk::readUnsMesh</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; std::string, tk::real &gt; &amp;&#160;</td>
          <td class="paramname"><em>timestamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read unstructured mesh from file. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>Filename to read mesh from </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">timestamp</td><td>A time stamp consisting of a timer label (a string), and a time state (a tk::real in seconds) measuring the mesh read time </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Unstructured mesh object </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>
<p>Create unstructured mesh to store mesh </p>

<p>Definition at line <a class="el" href="_mesh_factory_8_c_source.html#l00087">87</a> of file <a class="el" href="_mesh_factory_8_c_source.html">MeshFactory.C</a>.</p>

<p>References <a class="el" href="_mesh_factory_8_c_source.html#l00029">detectInput()</a>, <a class="el" href="_timer_8h_source.html#l00071">tk::Timer::dsec()</a>, <a class="el" href="_p_d_f_file_8h_source.html#l00028">tk::ctr::EXODUSII</a>, <a class="el" href="_mesh_factory_8h_source.html#l00023">GMSH</a>, <a class="el" href="_mesh_factory_8h_source.html#l00024">NETGEN</a>, <a class="el" href="_netgen_mesh_reader_8_c_source.html#l00027">tk::NetgenMeshReader::readMesh()</a>, <a class="el" href="_exodus_i_i_mesh_reader_8_c_source.html#l00061">tk::ExodusIIMeshReader::readMesh()</a>, and <a class="el" href="_gmsh_mesh_reader_8_c_source.html#l00030">tk::GmshMeshReader::readMesh()</a>.</p>

<p>Referenced by <a class="el" href="_mesh_conv_driver_8_c_source.html#l00051">meshconv::MeshConvDriver::execute()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">// Read in mesh</span>
  <a class="code" href="classtk_1_1_timer.html">tk::Timer</a> t;
 <span class="comment"></span>
<span class="comment">  //! Create unstructured mesh to store mesh</span>
<span class="comment"></span>  UnsMesh mesh;

  <span class="keyword">const</span> <span class="keyword">auto</span> meshtype = <a class="code" href="namespacetk.html#a08e7ddf794b944c7d2095c1222f4244a" title="Detect input mesh file type.">detectInput</a>( filename );

  <span class="keywordflow">if</span> (meshtype == <a class="code" href="namespacetk.html#af939b5fb62841ad69ce26159d7703cc5a455f9201094ecb9c7e6307eeea5ce25c">MeshReader::GMSH</a>)
    GmshMeshReader( filename ).readMesh( mesh );
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (meshtype == <a class="code" href="namespacetk.html#af939b5fb62841ad69ce26159d7703cc5a1e61700dafa65b3b779b95c5c1c780d3">MeshReader::NETGEN</a>)
    NetgenMeshReader( filename ).readMesh( mesh );
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (meshtype== <a class="code" href="namespacetk_1_1ctr.html#abdf7f48d3f0b49c9493d75f59c0d6218a130b728ec985a6380ea06a1bf2f20aec">MeshReader::EXODUSII</a>)
    ExodusIIMeshReader( filename ).readMesh( mesh );

  timestamp = std::make_pair( <span class="stringliteral">&quot;Read mesh from file&quot;</span>, t.<a class="code" href="classtk_1_1_timer.html#a08304f78d80271af5adc8115d6d55a93">dsec</a>() );

  <span class="comment">// Return (move out) mesh object</span>
  <span class="keywordflow">return</span> mesh;
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="namespacetk_aed9a0acd7495c7400aa3d167715ba3be_cgraph.svg" width="100%" height="524"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a5eccb941ad0c5499c356c717000f1842"></a><!-- doxytag: member="tk::record" ref="a5eccb941ad0c5499c356c717000f1842" args="(Factory &amp;f, const Key &amp;key, ConstructorArgs &amp;&amp;...args)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , class Key , class Factory , typename... ConstructorArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacetk.html#a5eccb941ad0c5499c356c717000f1842">tk::record</a> </td>
          <td>(</td>
          <td class="paramtype">Factory &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstructorArgs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Register class into factory with given key. This is used to register a derived-class object's constructor (deriving from some base class) to a factory. The factory itself is a std::map&lt; key, std::function&lt; Child*() &gt; &gt;, i.e., an associative container, associating some key to a std::function object holding a pointer of Child's base class constructor. The constructor and its bound arguments are stored via boost::factory, which, in this use-case, yields the correct function object of type Base constructor pointer and thus facilitates runtime polymorphism. This function works in conjunction with boost::factory, i.e., uses reference semantics (works with storing pointers of objects). For a simple example on how to use this function, see UnitTest/tests/Base/Factory.h. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Factory to register to (std::map with value using reference semantics) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key used to identify the entry in the factory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Variable number of arguments to pass to the constructor being registered. Note that the constructor arguments are only bound to the constructor and stored in the factory (an std::map with value using reference semantics). The object is not instantiated here, i.e., the constructor is not called here. The object can be instantiated by function instantiate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="namespacetk.html#aeb9673379e599043b13fff369dce1402">instantiate</a> </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_factory_8h_source.html#l00050">50</a> of file <a class="el" href="_factory_8h_source.html">Factory.h</a>.</p>
<div class="fragment"><pre class="fragment">                                                                     {
  f.emplace( key,
             std::bind( boost::factory&lt; C* &gt;(),
                        std::forward&lt; ConstructorArgs &gt;( args )... ) );
}
</pre></div>
</div>
</div>
<a class="anchor" id="a9121bd0e85e99f3eb79010513e9e1760"></a><!-- doxytag: member="tk::recordCharmModel" ref="a9121bd0e85e99f3eb79010513e9e1760" args="(Factory &amp;f, const Key &amp;key, ModelConstrArgs &amp;&amp;...args)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Host , class ModelConstructor , class Factory , class Key , typename... ModelConstrArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacetk.html#a9121bd0e85e99f3eb79010513e9e1760">tk::recordCharmModel</a> </td>
          <td>(</td>
          <td class="paramtype">Factory &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ModelConstrArgs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Register Charm++ model class of host into factory with given key. We bind a host constructor to its arguments of which the first one is a std::function holding a model constructor type (modeling, i.e., used polymorhically with host), followed by an optional number of others (possibly zero) with arbitrary types. Note that the model constructor is a nullptr (default- constructed) and only used to forward its type to the call site inside std::function. The host constructor function is then placed into the factory. This is because Charm++ chares do not explicitly invoke constructors, only call ckNew() on their proxy, which requires all constructor arguments to be present and forwarded to the actual constructor that is only called at a later point in time. This can then be used by those constructors of hosts that invoke the model constructors' proxies' ckNew() and ignore the std::function. See, e.g., rngtest::Battery() and the associated unit tests in UnitTest/tests/Base/Factory.h. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Factory to register to (std::map with value using value semantics) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key used to identify the entry in the factory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Variable number of arguments to pass to the constructor being registered. </td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_factory_8h_source.html#l00183">183</a> of file <a class="el" href="_factory_8h_source.html">Factory.h</a>.</p>
<div class="fragment"><pre class="fragment">                                                                               {
  f.emplace( key, std::bind( boost::value_factory&lt; Host &gt;(),
                             std::function&lt; ModelConstructor() &gt;(), <span class="comment">// nullptr</span>
                             std::forward&lt; ModelConstrArgs &gt;( args )...) );
}
</pre></div>
</div>
</div>
<a class="anchor" id="a4930b9ae2466cefbb1001f9f055bb177"></a><!-- doxytag: member="tk::recordModel" ref="a4930b9ae2466cefbb1001f9f055bb177" args="(Factory &amp;f, const Key &amp;key, ModelConstrArgs &amp;&amp;...args)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Host , class ModelConstructor , class Factory , class Key , typename... ModelConstrArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacetk.html#a4930b9ae2466cefbb1001f9f055bb177">tk::recordModel</a> </td>
          <td>(</td>
          <td class="paramtype">Factory &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ModelConstrArgs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Register "model" class of "host" into factory with given key. This wrapper can be used to in a similar manner to 'record', but uses boost::value_factory to bind the model object constructor to its arguments and place it in the associative container storing host class objects. The container is thus of type std::map&lt; key, std::function&lt; T() &gt; &gt;, i.e., associating a key to a function holding a constructor (and not its pointer). Runtime polymorphism here is realized entirely within the "base" class. See <a class="el" href="classwalker_1_1_diff_eq.html" title="Differential equation.">walker::DiffEq</a> in <a class="el" href="_diff_eq_2_diff_eq_8h.html" title="Differential equation.">DiffEq/DiffEq.h</a> for an example and more information on runtime polymorphism without client-side inheritance. As a result, this wrapper works with factories that use value semantics, as opposed to 'record' and instantiate which work with reference semantics factories. In order to differentiate between runtime polymorphic classes using reference semantics, consistent with classes realizing runtime polymorphism without client-side inheritance, we call Host as the "Base" class and Model as the "derived" (or child) class. This wrapper function works in conjunction with boost::value_factory, i.e., uses value semantics (works with storing objects instead of object pointers). For a simple example on how to use this function, see UnitTest/tests/Base/Factory.h. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Factory to register to (std::map with value using value semantics) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key used to identify the entry in the factory </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>Variable number of arguments to pass to the constructor being registered. Note that the constructor arguments are only bound to the constructor and stored in the factory (an std::map with value using value semantics). The object is not instantiated here, i.e., the constructor is not called here. The object can be instantiated by simply calling the function call operator () on the mapped value. For an example, <a class="el" href="classtk_1_1_r_n_g_stack.html#a327916d99dc2cd331d143c20b9b37a0a" title="Instantiate selected RNGs.">RNGStack::selected()</a> in <a class="el" href="_r_n_g_stack_8_c.html" title="Stack of random number generators.">RNG/RNGStack.C</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_factory_8h_source.html#l00113">113</a> of file <a class="el" href="_factory_8h_source.html">Factory.h</a>.</p>

<p>Referenced by <a class="el" href="_r_n_g_stack_8_c_source.html#l00163">tk::RNGStack::regRNGSSE()</a>.</p>
<div class="fragment"><pre class="fragment">                                                                          {
  <span class="comment">// Bind model constructor to its arguments</span>
  std::function&lt; ModelConstructor() &gt; c =
    std::bind( boost::value_factory&lt; ModelConstructor &gt;(),
               std::forward&lt; ModelConstrArgs &gt;( args )... );
  <span class="comment">// Bind host to std::function of model constructor and place in factory</span>
  f.emplace( key, std::bind( boost::value_factory&lt; Host &gt;(), std::move(c) ) );
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae98b4e55f14339c707622a8da43d8ce9"></a><!-- doxytag: member="tk::recordModelLate" ref="ae98b4e55f14339c707622a8da43d8ce9" args="(Factory &amp;f, const Key &amp;key, ModelConstrArg)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Host , class ModelConstructor , class Factory , class Key , typename ModelConstrArg &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacetk.html#ae98b4e55f14339c707622a8da43d8ce9">tk::recordModelLate</a> </td>
          <td>(</td>
          <td class="paramtype">Factory &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ModelConstrArg&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Register model class of host into factory with given key using late binding. This variant of 'record' is very similar to 'recordModel', but registers a model class constructor to a factory with late binding of the constructor argument. Late binding allows specifying the constructor argument at the time when the object is instantiated instead of at the time when it is registered. This has all the benefits of using a factory and allows passing information into the model object only when it is available. The late bind is facilitated via boost::bind instead of std::bind) using a placeholder, _1, which stands for the first argument (bound later, i.e., not here). The value of the model constructor argument is then not used here, only its type, used to perform the late binding. The binding happens to both the model constructor via std::function (passed to the host constructor) as well as explicitly to the host constructor. Prescribing late binding to the model constructor ensures that the compiler requires the argument to the model constructor, i.e., ensures that the host constructor is required to pass the argument to the model constructor. Prescribing late binding to the host constructor puts in the actual request that an argument (with the correct type) must be passed to the host constructor at instantiate time, which then will forward it to the model constructor. See also, for example, <a class="el" href="classwalker_1_1_diff_eq.html" title="Differential equation.">walker::DiffEq</a>'s corresponding constructor. An example of client-side code is in <a class="el" href="structwalker_1_1_diff_eq_stack_1_1register_diff_eq.html" title="Function object for registering a differential equation into the differential equation factory...">walker::DiffEqStack::registerDiffEq</a> for registration into factory, and DiffEqStack::createDiffEq for instantiation late-passing the argument. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Factory to register to (std::map with value using value semantics) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key used to identify the entry in the factory </td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Only works with a single constructor argument </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_factory_8h_source.html#l00151">151</a> of file <a class="el" href="_factory_8h_source.html">Factory.h</a>.</p>
<div class="fragment"><pre class="fragment">                                                                   {
  <span class="comment">// Prescribe late binding the model constructor to its single argument</span>
  std::function&lt; ModelConstructor(ModelConstrArg) &gt; c =
    boost::bind( boost::value_factory&lt; ModelConstructor &gt;(), _1 );
  <span class="comment">// Bind host to std::function of model constructor and place in factory and</span>
  <span class="comment">// also explicitly bind single model constructor argument to host constructor</span>
  f.emplace( key,
    boost::bind( boost::value_factory&lt; Host &gt;(), std::move(c), _1 ) );
}
</pre></div>
</div>
</div>
<a class="anchor" id="a5ac2475f6c08b5fcb81392b14aad73a4"></a><!-- doxytag: member="tk::remap" ref="a5ac2475f6c08b5fcb81392b14aad73a4" args="(std::vector&lt; std::size_t &gt; &amp;id, const std::vector&lt; std::size_t &gt; &amp;newid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacetk.html#a5ac2475f6c08b5fcb81392b14aad73a4">tk::remap</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>newid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reorder mesh point ids in a vector given a new order, i.e., index map. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">inout]</td><td>id Vector of point ids </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newid</td><td>Array of indices creating a new order</td></tr>
  </table>
  </dd>
</dl>
<p>This function implements a simple reordering (or remapping) of the node ids of the vector passed in using the vector newid. Thus the vector in newid is thought of as a mapping between the array index to its value. The function overwrites every value, n, of vector id with newid[n]. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>It is okay to call this function with either of the containers empty; it will simply return without throwing an exception. </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_reorder_8_c_source.html#l00044">44</a> of file <a class="el" href="_reorder_8_c_source.html">Reorder.C</a>.</p>

<p>References <a class="el" href="_exception_8h_source.html#l00049">Assert</a>.</p>

<p>Referenced by <a class="el" href="_zoltan_inter_op_8_c_source.html#l00262">tk::zoltan::createHyperGraph()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (<span class="keywordtype">id</span>.empty() || newid.empty()) <span class="keywordflow">return</span>;

  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810" title="Assert macro that only throws an exception if expr fails.">Assert</a>( *max_element( begin(<span class="keywordtype">id</span>), end(<span class="keywordtype">id</span>) ) &lt; newid.size(),
          <span class="stringliteral">&quot;attempt to index out of node id bounds using newid&quot;</span> );

  <span class="comment">// remap node ids in vector id</span>
  <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; n : <span class="keywordtype">id</span>) n = newid[n];
}
</pre></div>
</div>
</div>
<a class="anchor" id="a1d0312d71017d8ffd9f11811a46e5a16"></a><!-- doxytag: member="tk::renumber" ref="a1d0312d71017d8ffd9f11811a46e5a16" args="(const std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; &amp;psup)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; <a class="el" href="namespacetk.html#a1d0312d71017d8ffd9f11811a46e5a16">tk::renumber</a> </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; std::vector&lt; std::size_t &gt;, std::vector&lt; std::size_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>psup</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reorder mesh points with the advancing front technique. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">psup</td><td>Points surrounding points </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pair of maps between old-&gt;new and new-&gt;old order </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_reorder_8_c_source.html#l00068">68</a> of file <a class="el" href="_reorder_8_c_source.html">Reorder.C</a>.</p>

<p>Referenced by <a class="el" href="_zoltan_inter_op_8_c_source.html#l00262">tk::zoltan::createHyperGraph()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">// Find out number of nodes in graph</span>
  <span class="keyword">auto</span> npoin = psup.second.size()-1;

  <span class="comment">// Construct mapping using advancing front</span>
  std::vector&lt; int &gt; hpoin( npoin, -1 ), lpoin( npoin, 0 );
  std::vector&lt; std::size_t &gt; mapvec( npoin, 0 );
  hpoin[0] = 0;
  lpoin[0] = 1;
  std::size_t num = 1;
  <span class="keywordflow">while</span> (num &lt; npoin) {
    std::size_t cnt = 0;
    std::size_t i = 0;
    std::vector&lt; int &gt; kpoin( npoin, -1 );
    <span class="keywordtype">int</span> p;
    <span class="keywordflow">while</span> ((p = hpoin[i]) != -1) {
      ++i;
      <span class="keyword">auto</span> P = <span class="keyword">static_cast&lt;</span> std::size_t <span class="keyword">&gt;</span>( p );
      <span class="keywordflow">for</span> (<span class="keyword">auto</span> j=psup.second[P]+1; j&lt;=psup.second[P+1]; ++j) {
        <span class="keyword">auto</span> q = psup.first[j];
        <span class="keywordflow">if</span> (lpoin[q] != 1) {    <span class="comment">// consider points not yet counted</span>
          mapvec[q] = num++;
          kpoin[cnt] = <span class="keyword">static_cast&lt;</span> <span class="keywordtype">int</span> <span class="keyword">&gt;</span>( q ); <span class="comment">// register point as counted</span>
          lpoin[q] = 1;                         <span class="comment">// register the point as counted</span>
          ++cnt;
        }
      }
    }
    hpoin = kpoin;
  }

  <span class="comment">// Construct new-&gt;old id map</span>
  std::size_t i = 0;
  std::vector&lt; std::size_t &gt; oldmap( npoin );
  <span class="keywordflow">for</span> (<span class="keyword">auto</span> n : mapvec) oldmap[n] = i++;

  <span class="comment">// Return old-&gt;new and new-&gt;old maps</span>
  <span class="keywordflow">return</span> { mapvec, oldmap };
}
</pre></div>
</div>
</div>
<a class="anchor" id="a4d5bfee8e8bdea2bc60e5d725672af09"></a><!-- doxytag: member="tk::rm" ref="a4d5bfee8e8bdea2bc60e5d725672af09" args="(const std::string &amp;file)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacetk.html#a4d5bfee8e8bdea2bc60e5d725672af09">tk::rm</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove file from file system. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>File name to delete (shell wildcards NOT expanded)</td></tr>
  </table>
  </dd>
</dl>
<p>Since we use pstream's basic_ipstream constructor with signature ( const std::string &amp; file, const argv_type &amp; argv, pmode mode = pstdout ) and the file argument doesn't contain a slash, the actions of the shell are duplicated in searching for an executable in PATH. The shell will not interpret the other arguments, so wildcard expansion will not take place. </p>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_process_control_8_c_source.html#l00043">43</a> of file <a class="el" href="_process_control_8_c_source.html">ProcessControl.C</a>.</p>

<p>References <a class="el" href="_exception_8h_source.html#l00034">Throw</a>.</p>

<p>Referenced by <a class="el" href="_test_mesh_8h_source.html#l00037">tut::Mesh_common::testPureTetMesh()</a>.</p>
<div class="fragment"><pre class="fragment">                                 {
  std::vector&lt; std::string &gt; argv;
  argv.push_back( <span class="stringliteral">&quot;rm&quot;</span> );
  argv.push_back( file );
  redi::ipstream in( <span class="stringliteral">&quot;rm&quot;</span>, argv, redi::pstreambuf::pstderr );
  std::string e;
  std::string error;
  <span class="keywordflow">while</span> ( std::getline( in, e ) ) error += e + <span class="charliteral">&#39;\n&#39;</span>;
  <span class="keywordflow">if</span> (!error.empty()) <a class="code" href="_exception_8h.html#a0412f798470c18f503a2c2f63c970ba8" title="Throw macro that always throws an exception.">Throw</a>( std::move(error) );
}
</pre></div>
</div>
</div>
<a class="anchor" id="a22d7126404fbcf649fef98a747264305"></a><!-- doxytag: member="tk::shiftToZero" ref="a22d7126404fbcf649fef98a747264305" args="(std::vector&lt; std::size_t &gt; &amp;inpoel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacetk.html#a22d7126404fbcf649fef98a747264305">tk::shiftToZero</a> </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>inpoel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Shift node IDs to start with zero in element connectivity. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">inout]</td><td>inpoel Inteconnectivity of points and elements</td></tr>
  </table>
  </dd>
</dl>
<p>This function implements a simple reordering of the node ids of the element connectivity in inpoel by shifting the node ids so that the smallest is zero. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>It is okay to call this function with an empty container; it will simply return without throwing an exception. </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_reorder_8_c_source.html#l00022">22</a> of file <a class="el" href="_reorder_8_c_source.html">Reorder.C</a>.</p>

<p>Referenced by <a class="el" href="_netgen_mesh_reader_8_c_source.html#l00070">tk::NetgenMeshReader::readElements()</a>, <a class="el" href="_gmsh_mesh_reader_8_c_source.html#l00151">tk::GmshMeshReader::readElements()</a>, <a class="el" href="_exodus_i_i_mesh_reader_8_c_source.html#l00159">tk::ExodusIIMeshReader::readElements()</a>, and <a class="el" href="_test_mesh_8h_source.html#l00037">tut::Mesh_common::testPureTetMesh()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (inpoel.empty()) <span class="keywordflow">return</span>;

  <span class="comment">// find smallest node id</span>
  <span class="keyword">auto</span> minId = *std::min_element( begin(inpoel), end(inpoel) );

  <span class="comment">// shift node ids to start from zero</span>
  <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; n : inpoel) n -= minId;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a20ee8c554da198c14efbb80a0b623a4a"></a><!-- doxytag: member="tk::SiloError" ref="a20ee8c554da198c14efbb80a0b623a4a" args="(char *msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacetk.html#a20ee8c554da198c14efbb80a0b623a4a">tk::SiloError</a> </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Silo error handler. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>Error message </td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_silo_writer_8_c_source.html#l00024">24</a> of file <a class="el" href="_silo_writer_8_c_source.html">SiloWriter.C</a>.</p>

<p>References <a class="el" href="_exception_8h_source.html#l00034">Throw</a>.</p>

<p>Referenced by <a class="el" href="_silo_writer_8_c_source.html#l00043">tk::SiloWriter::SiloWriter()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">// Take out newlines from error message coming from library</span>
  std::string str(msg);
  std::replace(str.begin(), str.end(), <span class="charliteral">&#39;\n&#39;</span>, <span class="charliteral">&#39; &#39;</span>);

  <span class="comment">// Echo and throw</span>
  std::stringstream ss;
  ss &lt;&lt; <span class="stringliteral">&quot;Silo library writer error: &quot;</span> &lt;&lt; str;
  <a class="code" href="_exception_8h.html#a0412f798470c18f503a2c2f63c970ba8" title="Throw macro that always throws an exception.">Throw</a>( ss.str() );
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae5b04b00aa51667b944b7188545ec5ae"></a><!-- doxytag: member="tk::triple" ref="ae5b04b00aa51667b944b7188545ec5ae" args="(const std::array&lt; T, 3 &gt; &amp;v1, const std::array&lt; T, 3 &gt; &amp;v2, const std::array&lt; T, 3 &gt; &amp;v3)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="namespacetk.html#ae5b04b00aa51667b944b7188545ec5ae">tk::triple</a> </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compute the triple-product of three vectors </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v1</td><td>1st vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v2</td><td>2nd vector </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v3</td><td>3rd vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Triple-product </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_vector_8h_source.html#l00067">67</a> of file <a class="el" href="_vector_8h_source.html">Vector.h</a>.</p>

<p>References <a class="el" href="_vector_8h_source.html#l00020">cross()</a>, and <a class="el" href="_vector_8h_source.html#l00053">dot()</a>.</p>

<p>Referenced by <a class="el" href="_performer_8_c_source.html#l00136">inciter::Performer::lhs()</a>, and <a class="el" href="_performer_8_c_source.html#l00190">inciter::Performer::rhs()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> <a class="code" href="namespacetk.html#aeaca2df70ee950c576f6d74e1eb42caa">dot</a>( v1, <a class="code" href="namespacetk.html#ab602857e33f89cab4cc3788576ab1519">cross</a>(v2,v3) );
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_ae5b04b00aa51667b944b7188545ec5ae_cgraph.svg" width="211" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a87af1b002bc711716bd170a714bda211"></a><!-- doxytag: member="tk::unique" ref="a87af1b002bc711716bd170a714bda211" args="(Container &amp;c)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacetk.html#a87af1b002bc711716bd170a714bda211">tk::unique</a> </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Make elements of container unique </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">inout]</td><td>c Container </td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_container_util_8h_source.html#l00024">24</a> of file <a class="el" href="_container_util_8h_source.html">ContainerUtil.h</a>.</p>

<p>References <a class="el" href="_exception_8h_source.html#l00049">Assert</a>.</p>

<p>Referenced by <a class="el" href="_performer_8_c_source.html#l00284">inciter::Performer::initIds()</a>, <a class="el" href="_walker_2_input_deck_2_parser_8_c_source.html#l00036">walker::InputDeckParser::InputDeckParser()</a>, <a class="el" href="_breeze_2_input_deck_2_parser_8_c_source.html#l00026">inciter::InputDeckParser::InputDeckParser()</a>, and <a class="el" href="_print_8h_source.html#l00633">tk::Print::splitLines()</a>.</p>
<div class="fragment"><pre class="fragment">{
  std::sort( begin(c), end(c) );
  <span class="keyword">auto</span> it = <a class="code" href="namespacetk.html#a87af1b002bc711716bd170a714bda211">std::unique</a>( begin(c), end(c) );
  <span class="keyword">auto</span> d = std::distance( begin(c), it );
  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810" title="Assert macro that only throws an exception if expr fails.">Assert</a>( d &gt;= 0, <span class="stringliteral">&quot;Distance must be non-negative in tk::unique()&quot;</span> );
  c.resize( static_cast&lt; std::size_t &gt;( d ) );
}
</pre></div>
</div>
</div>
<a class="anchor" id="a56ab5269f94bf65a0efcb6be3347325a"></a><!-- doxytag: member="tk::variance" ref="a56ab5269f94bf65a0efcb6be3347325a" args="(const std::map&lt; std::string, std::vector&lt; T &gt; &gt; &amp;mapvec, const std::vector&lt; std::pair&lt; std::string, T &gt; &gt; &amp;avg, const std::string &amp;addendum=&quot;&quot;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::string, T &gt; &gt; <a class="el" href="namespacetk.html#a56ab5269f94bf65a0efcb6be3347325a">tk::variance</a> </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; std::string, std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; std::string, T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>avg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>addendum</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapvec</td><td>Map of vectors associated to labels </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">avg</td><td>Vector of labels and averages (labels unused) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addendum</td><td>Optional string to add to the label </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Vector of pairs of label and variance </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_container_util_8h_source.html#l00061">61</a> of file <a class="el" href="_container_util_8h_source.html">ContainerUtil.h</a>.</p>

<p>References <a class="el" href="_exception_8h_source.html#l00049">Assert</a>.</p>

<p>Referenced by <a class="el" href="_conductor_8_c_source.html#l00166">inciter::Conductor::perfstat()</a>, <a class="el" href="_mix_mass_fraction_beta_coeff_policy_8h_source.html#l00222">walker::MixMassFracBetaCoeffHomDecay::update()</a>, and <a class="el" href="_mix_mass_fraction_beta_coeff_policy_8h_source.html#l00338">walker::MixMassFracBetaCoeffMonteCarloHomDecay::update()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810" title="Assert macro that only throws an exception if expr fails.">Assert</a>( mapvec.size() == avg.size(),
          <span class="stringliteral">&quot;Map and vector must be equal size for variance calculation&quot;</span> );

  std::vector&lt; std::pair&lt; std::string, T &gt; &gt; s;
  std::size_t i = 0;
  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; t : mapvec) {
    T sum = 0.0;
    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v : t.second) sum += (v-avg[i].second)*(v-avg[i].second);
    s.emplace_back( t.first + addendum, sum/static_cast&lt;T&gt;(t.second.size()) );
    ++i;
  }

  <span class="keywordflow">return</span> s;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a5d61711de49d010da4785f7cb6ad2d9b"></a><!-- doxytag: member="tk::waitfor" ref="a5d61711de49d010da4785f7cb6ad2d9b" args="(const CkFuture &amp;f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Msg &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Msg::value_type <a class="el" href="namespacetk.html#a5d61711de49d010da4785f7cb6ad2d9b">tk::waitfor</a> </td>
          <td>(</td>
          <td class="paramtype">const CkFuture &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Wait for and return future. Concept: <a class="el" href="structtk_1_1_msg.html">Msg</a> must have public function get() returning Msg::value_type. </p>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_msg_8h_source.html#l00114">114</a> of file <a class="el" href="_msg_8h_source.html">Msg.h</a>.</p>

<p>References <a class="el" href="_msg_8h_source.html#l00052">tk::Msg&lt; T &gt;::get()</a>.</p>
<div class="fragment"><pre class="fragment">                                                    {
  Msg* m = <span class="keyword">static_cast&lt;</span> Msg* <span class="keyword">&gt;</span>( CkWaitFuture( f ) );
  <span class="keyword">typename</span> Msg::value_type value( m-&gt;get() );
  <span class="keyword">delete</span> m;
  <span class="keywordflow">return</span> value;
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespacetk_a5d61711de49d010da4785f7cb6ad2d9b_cgraph.svg" width="240" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</p>

</div>
</div>
<a class="anchor" id="a8e567fa9a72a1d5d02cea9eb020b192a"></a><!-- doxytag: member="tk::workdir" ref="a8e567fa9a72a1d5d02cea9eb020b192a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static std::string <a class="el" href="namespacetk.html#a8e567fa9a72a1d5d02cea9eb020b192a">tk::workdir</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wrapper for POSIX API's getcwd() from unistd.h. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A stirng containing the current working directory </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_init_8h_source.html#l00038">38</a> of file <a class="el" href="_init_8h_source.html">Init.h</a>.</p>

<p>References <a class="el" href="_exception_8h_source.html#l00034">Throw</a>.</p>

<p>Referenced by <a class="el" href="_init_8h_source.html#l00137">echoRunEnv()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <span class="keywordtype">char</span> cwd[1024];

  <span class="keywordflow">if</span> ( getcwd(cwd, <span class="keyword">sizeof</span>(cwd)) != NULL )
    <span class="keywordflow">return</span> std::string( cwd );
  <span class="keywordflow">else</span>
    <a class="code" href="_exception_8h.html#a0412f798470c18f503a2c2f63c970ba8" title="Throw macro that always throws an exception.">Throw</a>( <span class="stringliteral">&quot;Error from POSIX API&#39;s getcwd()&quot;</span> );
}
</pre></div>
</div>
</div>
<a class="anchor" id="a69a706a859b7a7c33973877b65de42ed"></a><!-- doxytag: member="tk::writeUnsMesh" ref="a69a706a859b7a7c33973877b65de42ed" args="(const std::string &amp;filename, const UnsMesh &amp;mesh, std::pair&lt; std::string, tk::real &gt; &amp;timestamp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespacetk.html#a69a706a859b7a7c33973877b65de42ed">tk::writeUnsMesh</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UnsMesh &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::pair&lt; std::string, tk::real &gt; &amp;&#160;</td>
          <td class="paramname"><em>timestamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write unstructured mesh to file. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>Filename to write mesh to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>Unstructured mesh object to write from </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">timestamp</td><td>A time stamp consisting of a timer label (a string), and a time state (a tk::real in seconds) measuring the mesh write time </td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_mesh_factory_8_c_source.html#l00120">120</a> of file <a class="el" href="_mesh_factory_8_c_source.html">MeshFactory.C</a>.</p>

<p>References <a class="el" href="_exodus_i_i_mesh_writer_8h_source.html#l00025">CREATE</a>, <a class="el" href="_timer_8h_source.html#l00071">tk::Timer::dsec()</a>, <a class="el" href="_p_d_f_file_8h_source.html#l00028">tk::ctr::EXODUSII</a>, <a class="el" href="_mesh_factory_8h_source.html#l00023">GMSH</a>, <a class="el" href="_mesh_factory_8h_source.html#l00024">NETGEN</a>, <a class="el" href="_mesh_factory_8_c_source.html#l00060">pickOutput()</a>, <a class="el" href="_netgen_mesh_writer_8_c_source.html#l00029">tk::NetgenMeshWriter::writeMesh()</a>, <a class="el" href="_gmsh_mesh_writer_8_c_source.html#l00064">tk::GmshMeshWriter::writeMesh()</a>, and <a class="el" href="_exodus_i_i_mesh_writer_8_c_source.html#l00077">tk::ExodusIIMeshWriter::writeMesh()</a>.</p>

<p>Referenced by <a class="el" href="_mesh_conv_driver_8_c_source.html#l00051">meshconv::MeshConvDriver::execute()</a>.</p>
<div class="fragment"><pre class="fragment">{
  <a class="code" href="classtk_1_1_timer.html">tk::Timer</a> t;

  <span class="keyword">const</span> <span class="keyword">auto</span> meshtype = <a class="code" href="namespacetk.html#a64b09f52ea3b4314e449e70255837836" title="Determine output mesh file type.">pickOutput</a>( filename );

  <span class="keywordflow">if</span> (meshtype == <a class="code" href="namespacetk.html#af939b5fb62841ad69ce26159d7703cc5a455f9201094ecb9c7e6307eeea5ce25c">MeshWriter::GMSH</a>)
    GmshMeshWriter( filename ).writeMesh( mesh );
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (meshtype == <a class="code" href="namespacetk.html#af939b5fb62841ad69ce26159d7703cc5a1e61700dafa65b3b779b95c5c1c780d3">MeshWriter::NETGEN</a>)
    NetgenMeshWriter( filename ).writeMesh( mesh );
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (meshtype== <a class="code" href="namespacetk_1_1ctr.html#abdf7f48d3f0b49c9493d75f59c0d6218a130b728ec985a6380ea06a1bf2f20aec">MeshWriter::EXODUSII</a>)
    ExodusIIMeshWriter( filename, <a class="code" href="namespacetk.html#aea4fb4c5b5f9f99675ec2f39d25a3482a32944105664ee0152ea1c2973449ac92">ExoWriter::CREATE</a> ).writeMesh( mesh );

  timestamp = std::make_pair( <span class="stringliteral">&quot;Write mesh to file&quot;</span>, t.<a class="code" href="classtk_1_1_timer.html#a08304f78d80271af5adc8115d6d55a93">dsec</a>() );
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><div class="zoom"><iframe scrolling="no" frameborder="0" src="namespacetk_a69a706a859b7a7c33973877b65de42ed_cgraph.svg" width="100%" height="511"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
</div>
</p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="af9ca17aedbef10f63fdfdee06f57e29c"></a><!-- doxytag: member="tk::CSTYLE_STRLEN" ref="af9ca17aedbef10f63fdfdee06f57e29c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="namespacetk.html#af9ca17aedbef10f63fdfdee06f57e29c">tk::CSTYLE_STRLEN</a> = 1024<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_msg_8h_source.html#l00030">30</a> of file <a class="el" href="_msg_8h_source.html">Msg.h</a>.</p>

<p>Referenced by <a class="el" href="_msg_8h_source.html#l00062">tk::StringsMsg::StringsMsg()</a>, and <a class="el" href="_msg_8h_source.html#l00089">tk::VecStrsMsg&lt; Size &gt;::VecStrsMsg()</a>.</p>

</div>
</div>
<a class="anchor" id="a146fc5751a35f82672bf193ee6048719"></a><!-- doxytag: member="tk::EqCompPar" ref="a146fc5751a35f82672bf193ee6048719" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t <a class="el" href="namespacetk.html#a146fc5751a35f82672bf193ee6048719">tk::EqCompPar</a> = 1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_particle_properties_8h_source.html#l00025">25</a> of file <a class="el" href="_particle_properties_8h_source.html">ParticleProperties.h</a>.</p>

</div>
</div>
<a class="anchor" id="a077f896b0c19528996cde33d4052eddc"></a><!-- doxytag: member="tk::ParEqComp" ref="a077f896b0c19528996cde33d4052eddc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t <a class="el" href="namespacetk.html#a077f896b0c19528996cde33d4052eddc">tk::ParEqComp</a> = 0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tags for selecting data layout policies. </p>

<p>Definition at line <a class="el" href="_particle_properties_8h_source.html#l00024">24</a> of file <a class="el" href="_particle_properties_8h_source.html">ParticleProperties.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespacetk.html">tk</a>      </li>

    <li class="footer">Generated on Tue Jul 7 2015 03:25:05 for Quinoa by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
