/*!
  \page      layout_benchmark Layout benchmark

Particle data layout performance tests -- input file and algorithms
===================================================================

See also [layout assembly](layout_assembly.html).

Control file used for benchmark
-------------------------------

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
hommix          # Select physics: Homogeneous mixing

  nstep 100000  # Max number of time steps
  term  140.0   # Max time
  dt    0.05    # Time step size
  npar  40000   # Number of particles

  ttyi  100     # TTY output interval
  dmpi  100     # Restart dump interval (not yet implemented)
  stai  1       # Statistics output interval
  pdfi  1000    # PDF output interval
  glbi  1       # Glob output interval

  rngs
    rngsse_gm55
      seed 0
      seqlen long
    end

    mkl_mrg32k3a seed 0 end
  end

  statistics    # Estimate statistics
    <Y1>        # mean of Y1
    <Y2>
    <y1y1>      # variance of Y1 = <(Y1-<Y1>)^2> = <y1^2>
    <y2y2>
    <y1y2>
  end

  mix_dir
    nscalar 100  # = K = N-1
    b     0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5
          0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5
          0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5
          0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5
          0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5
          0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5
          0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5
          0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5
          0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5
          0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5 0.1 1.5
    end
    S     0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4
          0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4
          0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4
          0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4
          0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4
          0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4
          0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4
          0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4
          0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4
          0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4 0.625 0.4
    end
    kappa 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3
          0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3
          0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3
          0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3
          0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3
          0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3
          0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3
          0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3
          0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3
          0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3 0.0125 0.3
    end
    rng mkl_mrg32k3a
  end
end
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Ptr - Working with raw pointers
-------------------------------

This algorithm gets the starting raw pointer from which the given particle data
is (contiguously) accessible in memory and simply adds integers to the address
to access and update the 100 components specified above. The algorithm assumes a
particular data layout - it only works with the particle-major storage - a
logically 3-dimensional array with [ particle ] [ sde ] [ component ].

__Layout-dependent algorithm:__

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//! Advance particles
void advance(int p, int tid, tk::real dt) override {
  // Get access to particle scalars
  tk::real* y = m_particles.ptr() + p*m_nprop + m_offset;
  
  // Compute Nth scalar
  tk::real yn = 1.0 - y[0];
  for (int i=1; i<m_ncomp; ++i) yn -= y[i];
  
  // Generate Gaussian random numbers with zero mean and unit variance
  tk::real dW[m_ncomp];
  m_rng->gaussian( tid, m_ncomp, dW );
  
  // Advance first m_ncomp (K=N-1) scalars
  for (int i=0; i<m_ncomp; ++i) {
    tk::real d = m_k[i]*y[i]*yn*dt;
    if (d > 0.0) d = sqrt(d); else d = 0.0;
    y[i] += 0.5*m_b[i]*(m_S[i]*yn - (1.0-m_S[i])*y[i])*dt + d*dW[i];
  }
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Par - Access via particle-major layout policy
---------------------------------------------

This algorithm accesses particle data via the wrapper class, ParticleProperties,
in a data-layout-agnostic fashion. Access itself via this  class is demonstrably
"zero-cost", i.e., an optmizing compiler completely optimizes the abstraction
away - looked at assembly generated by 3 compilers. However, writing an
SDE-advance algorithm in a data-layout-agnostic manner, requires index
calculations at every particle-access compared to working with raw pointers, as
described above. Thus the following tests are designed to measure only the
additional index calculations that the layout-agnostic access entails.

__Layout-independent algorithm:__

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//! Advance particles
void advance(int p, int tid, tk::real dt) override {
  // Compute Nth scalar
  tk::real yn = 1.0 - m_particles(p, 0, m_offset);
  for (int i=1; i<m_ncomp; ++i) yn -= m_particles(p, i, m_offset);

  // Generate Gaussian random numbers with zero mean and unit variance
  tk::real dW[m_ncomp];
  m_rng->gaussian( tid, m_ncomp, dW );

  // Advance first m_ncomp (K=N-1) scalars
  for (int i=0; i<m_ncomp; ++i) {
    tk::real d = m_k[i] * m_particles(p, i, m_offset) * yn * dt;
    if (d > 0.0) d = sqrt(d); else d = 0.0;
    m_particles(p, i, m_offset) +=
      0.5*m_b[i]*(m_S[i]*yn - (1.0-m_S[i]) * m_particles(p, i, m_offset) )*dt
    + d*dW[i];
  }
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Comparison of algorithms
------------------------

DEBUG mode is -O0 and does not optimize function calls away for all of three
compilers tested. RELEASE modes is -O3 and the abstraction is completely
optimized away. However, index calculations still remain compared to a
layout-dependent advance algorithm.

Total time measured in micro-seconds, run on machine ito (Intel Core i7, laptop)
with 8 cores:
       Run           | Ptr              | Par              | Par/Ptr
       :------------ | ---------------: | ---------------: | ----------------:
       clang/DEBUG   | 150350236        | 338851735        | 2.2537 x slowdown
       clang/RELEASE |  98157742        | 104077139        | 1.0603 x slowdown
       DEBUG/RELEASE | 1.5317 x speedup | 3.2558 x speedup | n/a

       Run           | Ptr              | Par              | Par/Ptr
       :------------ | ---------------: | ---------------: | ----------------:
       gnu/DEBUG     | 161603164        | 386646353        | 2.3926 x slowdown
       gnu/RELEASE   |  94747953        |  98187568        | 1.0363 x slowdown
       DEBUG/RELEASE | 1.7056 x speedup | 3.9378 x speedup | n/a

       Run           | Ptr              | Par              | Par/Ptr
       :------------ | ---------------: | ---------------: | ----------------:
       intel/DEBUG   | 171691440        | 608407412        | 3.5436 x slowdown
       intel/RELEASE |  90059133        |  89892665        | 0.99815 x speedup
       DEBUG/RELEASE | 1.9064 x speedup | 6.7682 x speedup | n/a

Discussion
----------
- As expected, inlining has a significant effect on performance: going from
  DEBUG to RELEASE mode yields a significant speedup with all three compilers,
  see last, DEBUG/RELEASE, rows.

- As expected, the additional index calculations required by layout-agnostic
  access do take a performance hit: though only 6% with clang, and 3% with gnu,
  see last, Par/Ptr, columns.

- Surprisingly, the layout-agnostic access is even a tiny bit faster than the
  layout-dependent algorithm with the intel compiler with -O3.

Conclusion
----------
As this is not a significant performance hit, the SDE advance algorithms will be
implemented in a data-layout-independent fashion. The data layout can be changed
at compile time. Access will be abstracted (and optimized) away.

For the implementation see the [layout policy](_layout_policy_8h_source.html).

<hr>
<div><small>
<em>Page last updated:</em> Tue 08 Jul 2014 03:27:01 PM MDT
<em>Copyright &copy; 2005-2012, Jozsef Bakosi, All rights reserved.</em>
</small></div>
*/
