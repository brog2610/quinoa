* Control: Control::Bundle would be nicer with a hierarchical structure.

* Alternative RND library: Need a quick switchable way of building without MKL
  as it is practically impossible to distinguish between memory leaks (hopefully
  false positives) in MKL and non-MKL code. May need to implement another random
  number library.

* Testing: Don't know how long I can keep going without some sort of unit and/or
  regression testing infrastructure.

* test suite for exceptions: automatically switch each potential throw location
  into a throw and test for clean exit (e.g. with valgrind)

* Unit tests: GoogleTest, QuickTest, Template Unit Test

* Faster build: explore dynamic libs, less and larger libs, precompiled headers,
  reduce build  deps with ninja build dependency map

* Setup precompiled headers?

* Less libraries?

* Define own error handler for the new operator via set_new_handler(), and
  also customize set_unexpected(), set_terminate().

* Fix up MemoryEntry with smart pointer features: construction, assignment,
  automatic destruction as leaving scope, dereferencing, testing nullness. See
  Item 2/28.

* auto_ptr to avoid having to explicitly free pointers in destructors. See Item
  2/9.

* Are cout warnings in destructors' catch blocks exception-safe?

* Automatically turn list of keywords into Keywords.h, could use constexpr
  functions and/or classes and variadic templates? See Appendix in
  ConcurrencyInAction.

* valarrays eligible for more aggressive optimizations, especially on multicore?

* Use noexcept and conditional noexcept. See STL 3.1.7.

* Reuse exception handling code. See STL 4.3.2.

* Add operator << for tuple. See STL 5.1.3.

* Fix Timer. See STL 5.7. Also add clocks info. See STL 5.7.3.

* Use exit codes EXIT_SUCCESS and EXIT_FAILURE at exit from main(). See STL
  5.8.2.

* Any libs for concurrent containers? Do we need any?
