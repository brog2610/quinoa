<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Quinoa: tk::Control&lt; Ts &gt; Class Template Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Quinoa
   
   </div>
   <div id="projectbrief">Adaptive computational fluid dynamics</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Documents</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classtk_1_1_control.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">tk::Control&lt; Ts &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="tk::Control" --><!-- doxytag: inherits="tagged_tuple&lt; Ts...&gt;" -->
<p><code>#include &lt;<a class="el" href="_control_8h_source.html">Control.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for tk::Control&lt; Ts &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classtk_1_1_control__inherit__graph.svg" width="358" height="195"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtk_1_1_control.html#ab808941c33e950bf6272cde25d5c8528">convert</a> (const std::string &amp;str)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert string to a type given by the template argument using std::stringstream.  <a href="#ab808941c33e950bf6272cde25d5c8528"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename type &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtk_1_1_control.html#a6f38bfb5aee1c6b9b0ecf5ef4dec6fbc">convert</a> (const type &amp;val)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert value of type given by the template argument to std::string using std::stringstream.  <a href="#a6f38bfb5aee1c6b9b0ecf5ef4dec6fbc"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Const-ref accessors at three different depths</div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename tag &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">constexpr const <br class="typebreak"/>
Tuple::template nT&lt; tag &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtk_1_1_control.html#a85c14acef1b9de96946fcf2ab7c08721">get</a> () const noexcept</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Const-ref accessor to single element at 1st level.  <a href="#a85c14acef1b9de96946fcf2ab7c08721"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename tag , typename subtag &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">constexpr const <br class="typebreak"/>
Tuple::template nT&lt; tag &gt;<br class="typebreak"/>
::template nT&lt; subtag &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtk_1_1_control.html#a667f8a630c8d08c2a29254395aecc86d">get</a> () const noexcept</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Const-ref accessor to single element at 2nd level.  <a href="#a667f8a630c8d08c2a29254395aecc86d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename tag , typename subtag , typename subsubtag &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">constexpr const <br class="typebreak"/>
Tuple::template nT&lt; tag &gt;<br class="typebreak"/>
::template nT&lt; subtag &gt;<br class="typebreak"/>
::template nT&lt; subsubtag &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtk_1_1_control.html#aca9009d4b003a57a145cd45eaf698bc7">get</a> () const noexcept</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Const-ref accessor to single element at 3rd level.  <a href="#aca9009d4b003a57a145cd45eaf698bc7"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Rvalue accessors at three different depths</div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename tag &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Tuple::template nT&lt; tag &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtk_1_1_control.html#a8fdfaa86da44a4e90c6cca5bc57c4cd0">get</a> () noexcept</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Rvalue accessor to single element at 1st level.  <a href="#a8fdfaa86da44a4e90c6cca5bc57c4cd0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename tag , typename subtag &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Tuple::template nT&lt; tag &gt;<br class="typebreak"/>
::template nT&lt; subtag &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtk_1_1_control.html#a1497ed82ffeeab77e506c4c860c4b90d">get</a> () noexcept</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Rvalue accessor to single element at 2nd level.  <a href="#a1497ed82ffeeab77e506c4c860c4b90d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename tag , typename subtag , typename subsubtag &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">Tuple::template nT&lt; tag &gt;<br class="typebreak"/>
::template nT&lt; subtag &gt;<br class="typebreak"/>
::template nT&lt; subsubtag &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtk_1_1_control.html#a9831c060237cea68bf081565ede84d7c">get</a> () noexcept</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Rvalue accessor to single element at 3rd level.  <a href="#a9831c060237cea68bf081565ede84d7c"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Set value at three different depths</div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename tag &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtk_1_1_control.html#a409e5768e3e10339594a9988f3b4d686">set</a> (const typename Tuple::template nT&lt; tag &gt; &amp;value) noexcept</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set value at slot at tag at 1st level.  <a href="#a409e5768e3e10339594a9988f3b4d686"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename tag , typename subtag &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtk_1_1_control.html#a06c910f6c3ad625fd921af73a9c9f5ed">set</a> (const typename Tuple::template nT&lt; tag &gt;::template nT&lt; subtag &gt; &amp;value) noexcept</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set value at slot at tag at 2nd level.  <a href="#a06c910f6c3ad625fd921af73a9c9f5ed"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename tag , typename subtag , typename subsubtag &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtk_1_1_control.html#ad55a097d8172b28412c7c85160de1153">set</a> (const typename Tuple::template nT&lt; tag &gt;::template nT&lt; subtag &gt;::template nT&lt; subsubtag &gt; &amp;value) noexcept</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set value at slot at tag at 3rd level.  <a href="#ad55a097d8172b28412c7c85160de1153"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Convert and set value at tag at three different depths</div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename tag &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtk_1_1_control.html#af8b801a468c14c861354b18c9dd6bb1a">store</a> (const std::string &amp;value) noexcept</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert and set value at tag at 1st level.  <a href="#af8b801a468c14c861354b18c9dd6bb1a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename tag , typename subtag &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtk_1_1_control.html#a922c420c486f320570026856a10bd13b">store</a> (const std::string &amp;value) noexcept</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert and set value at tag at 2nd level.  <a href="#a922c420c486f320570026856a10bd13b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename tag , typename subtag , typename subsubtag &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtk_1_1_control.html#a8939571260ca76fa0d1d8323188bde5a">store</a> (const std::string &amp;value) noexcept</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert and set value at tag at 3rd level.  <a href="#a8939571260ca76fa0d1d8323188bde5a"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Push back value to vector at tag at three different depths</div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename tag &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtk_1_1_control.html#ab5f1173b8774b6e70d2fba5ab819d511">push_back</a> (const typename Tuple::template nT&lt; tag &gt;::value_type &amp;value=typename Tuple::template nT&lt; tag &gt;::value_type())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Push back value to vector at tag at 1st level without conversion.  <a href="#ab5f1173b8774b6e70d2fba5ab819d511"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename tag , typename subtag &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtk_1_1_control.html#aa52ec9ec800000777306f91d74b0cde1">push_back</a> (const typename Tuple::template nT&lt; tag &gt;::template nT&lt; subtag &gt;::value_type &amp;value=typename Tuple::template nT&lt; tag &gt;::template nT&lt; subtag &gt;::value_type())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Push back value to vector at tag at 2nd level without conversion.  <a href="#aa52ec9ec800000777306f91d74b0cde1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename tag , typename subtag , typename subsubtag &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtk_1_1_control.html#a547e70664c1fdad2ebef7ce1acde9f4c">push_back</a> (const typename Tuple::template nT&lt; tag &gt;::template nT&lt; subtag &gt;::template nT&lt; subsubtag &gt;::value_type &amp;value=typename Tuple::template nT&lt; tag &gt;::template nT&lt; subtag &gt;::template nT&lt; subsubtag &gt;::value_type())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Push back value to vector at tag at 3rd level without conversion.  <a href="#a547e70664c1fdad2ebef7ce1acde9f4c"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Push back value to vector of back of vector at tag at three different depths</div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename tag &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtk_1_1_control.html#a4cb86f8e688d964d4dfc32acfa0a05da">push_back_back</a> (const typename Tuple::template nT&lt; tag &gt;::value_type::value_type &amp;value=typename Tuple::template nT&lt; tag &gt;::value_type::value_type())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Push back value to vector of back of vector at tag at 1st level without conversion.  <a href="#a4cb86f8e688d964d4dfc32acfa0a05da"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename tag , typename subtag &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtk_1_1_control.html#a83bb8f2fb20df55d88f8b794aa383cde">push_back_back</a> (const typename Tuple::template nT&lt; tag &gt;::template nT&lt; subtag &gt;::value_type::value_type &amp;value=typename Tuple::template nT&lt; tag &gt;::template nT&lt; subtag &gt;::value_type::value_type())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Push back value to vector of back of vector at tag at 2nd level without conversion.  <a href="#a83bb8f2fb20df55d88f8b794aa383cde"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename tag , typename subtag , typename subsubtag &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtk_1_1_control.html#a583ee91b122cd6d17d7fecb80ff9a453">push_back_back</a> (const typename Tuple::template nT&lt; tag &gt;::template nT&lt; subtag &gt;::template nT&lt; subsubtag &gt;::value_type::value_type &amp;value=typename Tuple::template nT&lt; tag &gt;::template nT&lt; subtag &gt;::template nT&lt; subsubtag &gt;::value_type::value_type())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Push back value to vector of back of vector at tag at 3rd level without conversion.  <a href="#a583ee91b122cd6d17d7fecb80ff9a453"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Convert and push back value to vector at tag at three different</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>depths </p>
</div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename tag &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtk_1_1_control.html#af572dbca3b3fbc6f2c9fe07faedf321f">store_back</a> (const std::string &amp;value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert and push back value to vector at tag at 1st level.  <a href="#af572dbca3b3fbc6f2c9fe07faedf321f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename tag , typename subtag &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtk_1_1_control.html#a285ba8b13b8bce0f2b8beeadeebab2fe">store_back</a> (const std::string &amp;value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert and push back value to slot at tag at 2nd level.  <a href="#a285ba8b13b8bce0f2b8beeadeebab2fe"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename tag , typename subtag , typename subsubtag &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtk_1_1_control.html#a0fdb2011c4bc183cb54e2dad1c99648b">store_back</a> (const std::string &amp;value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert and push back value to slot at tag at 3rd level.  <a href="#a0fdb2011c4bc183cb54e2dad1c99648b"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Convert and push back value to vector of back of vector at tag at three different depths</div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename tag &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtk_1_1_control.html#aaee39a1de8b40b07189f5ab949902710">store_back_back</a> (const std::string &amp;value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert and push back value to vector of back of vector at tag at 1st level.  <a href="#aaee39a1de8b40b07189f5ab949902710"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename tag , typename subtag &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtk_1_1_control.html#abd404a2093d7a0752fa8c6c02d6dc2a3">store_back_back</a> (const std::string &amp;value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert and push back value to vector of back of vector at tag at 2nd level.  <a href="#abd404a2093d7a0752fa8c6c02d6dc2a3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename tag , typename subtag , typename subsubtag &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtk_1_1_control.html#afbfe4f5aa911d9b5d8763bf22806ceb9">store_back_back</a> (const std::string &amp;value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert and push back value to vector of back of vector at tag at 3rd level.  <a href="#afbfe4f5aa911d9b5d8763bf22806ceb9"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Convert and push back value to vector of back of vector of back of vector at tag at three different depths</div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename tag &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtk_1_1_control.html#a64ad377981664e89e12c6a5464ea5629">store_back_back_back</a> (const std::string &amp;value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert and push back value to vector of back of vector of back of vector at tag at 1st level.  <a href="#a64ad377981664e89e12c6a5464ea5629"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename tag , typename subtag &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtk_1_1_control.html#ab20ac4cdf3508f9807bd5661b0b1fd0b">store_back_back_back</a> (const std::string &amp;value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert and push back value to vector of back of vector of back of vector at tag at 2nd level.  <a href="#ab20ac4cdf3508f9807bd5661b0b1fd0b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename tag , typename subtag , typename subsubtag &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtk_1_1_control.html#a27723cdee73124465af0d02d37c23cfe">store_back_back_back</a> (const std::string &amp;value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert and push back value to vector of back of vector of back of vector at tag at 3rd level.  <a href="#a27723cdee73124465af0d02d37c23cfe"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Insert key-value pair to map at tag at three different depths</div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename tag &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtk_1_1_control.html#a7c0ec09f1e88a916a9e222ee3d13c307">insert</a> (const typename Tuple::template nT&lt; tag &gt;::key_type &amp;key, const typename Tuple::template nT&lt; tag &gt;::mapped_type &amp;value=typename Tuple::template nT&lt; tag &gt;::mapped_type())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert key-value pair to map at tag at 1st level using std::map::operator[].  <a href="#a7c0ec09f1e88a916a9e222ee3d13c307"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename tag , typename subtag &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtk_1_1_control.html#a23a09efce36dce4c523d63fc3c670e26">insert</a> (const typename Tuple::template nT&lt; tag &gt;::template nT&lt; subtag &gt;::key_type &amp;key, const typename Tuple::template nT&lt; tag &gt;::template nT&lt; subtag &gt;::mapped_type &amp;value=typename Tuple::template nT&lt; tag &gt;::template nT&lt; subtag &gt;::mapped_type())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert key-value pair to map at tag at 2nd level using std::map::operator[].  <a href="#a23a09efce36dce4c523d63fc3c670e26"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename tag , typename subtag , typename subsubtag &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtk_1_1_control.html#abc77025ff1870238591d64c0afe83ab9">insert</a> (const typename Tuple::template nT&lt; tag &gt;::template nT&lt; subtag &gt;::template nT&lt; subsubtag &gt;::key_type &amp;key, const typename Tuple::template nT&lt; tag &gt;::template nT&lt; subtag &gt;::template nT&lt; subsubtag &gt;::mapped_type &amp;value=typename Tuple::template nT&lt; tag &gt;::template nT&lt; subtag &gt;::template nT&lt; subsubtag &gt;::mapped_type())</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert key-value pair to map at tag at 3rd level using std::map::operator[].  <a href="#abc77025ff1870238591d64c0afe83ab9"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Insert key-value pair with converting value to map at tag at three different depths</div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename key_type , typename field , typename tag &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtk_1_1_control.html#aa17b6ff6883417430f802231103698ce">insert_field</a> (const key_type &amp;key, const std::string &amp;value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert key-value pair with converting value to map at tag at 1st level using std::map::operator[].  <a href="#aa17b6ff6883417430f802231103698ce"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename key_type , typename field , typename tag , typename subtag &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtk_1_1_control.html#aad115e5d2b416d91588a9adbdb6835ad">insert_field</a> (const key_type &amp;key, const std::string &amp;value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert key-value pair with converting value to map at tag at 2nd level using std::map::operator[].  <a href="#aad115e5d2b416d91588a9adbdb6835ad"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename key_type , typename field , typename tag , typename subtag , typename subsubtag &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtk_1_1_control.html#ab6a4074a6f110a23e2c28f3a7b8e336b">insert_field</a> (const key_type key, const std::string &amp;value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert key-value pair with converting value to map at tag at 3rd level using std::map::operator[].  <a href="#ab6a4074a6f110a23e2c28f3a7b8e336b"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Insert key-value pair without conversion of value to map at tag at three different depths</div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename key_type , typename field , typename field_type , typename tag &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtk_1_1_control.html#a6115a8bdd09d3210662350754086da0d">insert_opt</a> (const key_type &amp;key, const field_type &amp;value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert value to field of tagged tuple behind a key of a map at tag at 1st level.  <a href="#a6115a8bdd09d3210662350754086da0d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename key_type , typename field , typename field_type , typename tag , typename subtag &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtk_1_1_control.html#a0ac4e30a81f1750d876e2aa7946d0555">insert_opt</a> (const key_type &amp;key, const field_type &amp;value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert value to field of tagged tuple behind a key of a map at tag at 2nd level.  <a href="#a0ac4e30a81f1750d876e2aa7946d0555"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename key_type , typename field , typename field_type , typename tag , typename subtag , typename subsubtag &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtk_1_1_control.html#aac13d1641311a8059ddd05ea981cd1ec">insert_opt</a> (const key_type &amp;key, const field_type &amp;value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert key-value pair with converting value to map at tag at 3rd level using std::map::operator[].  <a href="#aac13d1641311a8059ddd05ea981cd1ec"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="member-group"></a>
Pack/Unpack: Serialize Control object for Charm++</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_control.html#a5e6ca99f05104e094945eb34662dbdfc">pup</a> (PUP::er &amp;p)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack/Unpack serialize member function.  <a href="#a5e6ca99f05104e094945eb34662dbdfc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtk_1_1_control.html#a99667f44f03b29d671ba915d15a89f33">operator|</a> (PUP::er &amp;p, <a class="el" href="classtk_1_1_control.html">Control</a>&lt; Ts...&gt; &amp;c)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack/Unpack serialize operator|.  <a href="#a99667f44f03b29d671ba915d15a89f33"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename... Ts&gt;<br/>
class tk::Control&lt; Ts &gt;</h3>

<p><a class="el" href="classtk_1_1_control.html">Control</a> is a slightly more specialized level of a tagged tuple, implementing still very generic accessors to tuple elements at various depths at the tuple hierarchy. At this time, max 3 levels are implemented, but it would be nice to replace the triple-overloads with a single generic one that works at all depths. For an example specialization, i.e., client-side code, see <a class="el" href="classwalker_1_1ctr_1_1_input_deck.html" title="InputDeck : Control&lt; specialized to Walker &gt;, see Types.h.">walker::ctr::InputDeck</a>. </p>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_control_8h_source.html#l00034">34</a> of file <a class="el" href="_control_8h_source.html">Control.h</a>.</p>
</div><hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ab808941c33e950bf6272cde25d5c8528"></a><!-- doxytag: member="tk::Control::convert" ref="ab808941c33e950bf6272cde25d5c8528" args="(const std::string &amp;str)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<div class="memtemplate">
template&lt;typename type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">type <a class="el" href="classtk_1_1_control.html">tk::Control</a>&lt; Ts &gt;::<a class="el" href="classtk_1_1_control.html#ab808941c33e950bf6272cde25d5c8528">convert</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert string to a type given by the template argument using std::stringstream. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>String to convert </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value of type given by the template argument </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_control_8h_source.html#l00651">651</a> of file <a class="el" href="_control_8h_source.html">Control.h</a>.</p>

<p>Referenced by <a class="el" href="_control_8h_source.html#l00539">tk::Control&lt; tag::title, kw::title::info::expect::type, tag::selected, selects, tag::discr, discretization, tag::component, ncomps, tag::interval, intervals, tag::cmd, CmdLine, tag::param, parameters, tag::stat, std::vector&lt; tk::ctr::Product &gt;, tag::pdf, std::vector&lt; tk::ctr::Probability &gt;, tag::error, std::vector&lt; std::string &gt; &gt;::insert_field()</a>, <a class="el" href="_control_8h_source.html#l00155">tk::Control&lt; tag::title, kw::title::info::expect::type, tag::selected, selects, tag::discr, discretization, tag::component, ncomps, tag::interval, intervals, tag::cmd, CmdLine, tag::param, parameters, tag::stat, std::vector&lt; tk::ctr::Product &gt;, tag::pdf, std::vector&lt; tk::ctr::Probability &gt;, tag::error, std::vector&lt; std::string &gt; &gt;::store()</a>, <a class="el" href="_control_8h_source.html#l00300">tk::Control&lt; tag::title, kw::title::info::expect::type, tag::selected, selects, tag::discr, discretization, tag::component, ncomps, tag::interval, intervals, tag::cmd, CmdLine, tag::param, parameters, tag::stat, std::vector&lt; tk::ctr::Product &gt;, tag::pdf, std::vector&lt; tk::ctr::Probability &gt;, tag::error, std::vector&lt; std::string &gt; &gt;::store_back()</a>, <a class="el" href="_control_8h_source.html#l00344">tk::Control&lt; tag::title, kw::title::info::expect::type, tag::selected, selects, tag::discr, discretization, tag::component, ncomps, tag::interval, intervals, tag::cmd, CmdLine, tag::param, parameters, tag::stat, std::vector&lt; tk::ctr::Product &gt;, tag::pdf, std::vector&lt; tk::ctr::Probability &gt;, tag::error, std::vector&lt; std::string &gt; &gt;::store_back_back()</a>, and <a class="el" href="_control_8h_source.html#l00390">tk::Control&lt; tag::title, kw::title::info::expect::type, tag::selected, selects, tag::discr, discretization, tag::component, ncomps, tag::interval, intervals, tag::cmd, CmdLine, tag::param, parameters, tag::stat, std::vector&lt; tk::ctr::Product &gt;, tag::pdf, std::vector&lt; tk::ctr::Probability &gt;, tag::error, std::vector&lt; std::string &gt; &gt;::store_back_back_back()</a>.</p>
<div class="fragment"><pre class="fragment">                                         {
      std::stringstream ss( str );
      type num;
      ss &gt;&gt; num;
      <span class="keywordflow">if</span> (ss.fail())
        <a class="code" href="_exception_8h.html#a0412f798470c18f503a2c2f63c970ba8" title="Throw macro that always throws an exception.">Throw</a>( <span class="stringliteral">&quot;Failed to convert &#39;&quot;</span> + str +
               <span class="stringliteral">&quot;&#39; to typeid &quot;</span> + <span class="keyword">typeid</span>(num).name() );
      <span class="keywordflow">return</span> num;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a6f38bfb5aee1c6b9b0ecf5ef4dec6fbc"></a><!-- doxytag: member="tk::Control::convert" ref="a6f38bfb5aee1c6b9b0ecf5ef4dec6fbc" args="(const type &amp;val)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<div class="memtemplate">
template&lt;typename type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classtk_1_1_control.html">tk::Control</a>&lt; Ts &gt;::<a class="el" href="classtk_1_1_control.html#ab808941c33e950bf6272cde25d5c8528">convert</a> </td>
          <td>(</td>
          <td class="paramtype">const type &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert value of type given by the template argument to std::string using std::stringstream. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>Value of type given by the template argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>std::string of value converted </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_control_8h_source.html#l00667">667</a> of file <a class="el" href="_control_8h_source.html">Control.h</a>.</p>
<div class="fragment"><pre class="fragment">                                         {
      std::stringstream ss;
      ss &lt;&lt; val;
      <span class="keywordflow">if</span> (ss.fail())
        <a class="code" href="_exception_8h.html#a0412f798470c18f503a2c2f63c970ba8" title="Throw macro that always throws an exception.">Throw</a>( <span class="stringliteral">&quot;Failed to convert value to string&quot;</span> );
      <span class="keywordflow">return</span> ss.str();
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a85c14acef1b9de96946fcf2ab7c08721"></a><!-- doxytag: member="tk::Control::get" ref="a85c14acef1b9de96946fcf2ab7c08721" args="() const noexcept" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<div class="memtemplate">
template&lt;typename tag &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr const Tuple::template nT&lt;tag&gt;&amp; <a class="el" href="classtk_1_1_control.html">tk::Control</a>&lt; Ts &gt;::<a class="el" href="classtk_1_1_control.html#a85c14acef1b9de96946fcf2ab7c08721">get</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Const-ref accessor to single element at 1st level. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A constant reference behind a tag given by the template argument </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_control_8h_source.html#l00049">49</a> of file <a class="el" href="_control_8h_source.html">Control.h</a>.</p>

<p>Referenced by <a class="el" href="_test_u01_suite_8h_source.html#l00082">rngtest::TestU01Suite::addTests()</a>, <a class="el" href="_integrator_8h_source.html#l00088">walker::Integrator&lt; Proxy &gt;::advance()</a>, <a class="el" href="_test_u01_suite_8_c_source.html#l00167">rngtest::TestU01Suite::assess()</a>, <a class="el" href="_r_n_g_test_print_8h_source.html#l00077">rngtest::RNGTestPrint::battery()</a>, <a class="el" href="_walker_2_cmd_line_2_parser_8_c_source.html#l00057">walker::CmdLineParser::CmdLineParser()</a>, <a class="el" href="_mesh_conv_2_cmd_line_2_parser_8_c_source.html#l00050">meshconv::CmdLineParser::CmdLineParser()</a>, <a class="el" href="_reg_test_2_cmd_line_2_parser_8_c_source.html#l00048">regtest::CmdLineParser::CmdLineParser()</a>, <a class="el" href="_r_n_g_test_2_cmd_line_2_parser_8_c_source.html#l00058">rngtest::CmdLineParser::CmdLineParser()</a>, <a class="el" href="_unit_test_2_cmd_line_2_parser_8_c_source.html#l00036">unittest::CmdLineParser::CmdLineParser()</a>, <a class="el" href="_inciter_2_cmd_line_2_parser_8_c_source.html#l00042">inciter::CmdLineParser::CmdLineParser()</a>, <a class="el" href="_distributor_8_c_source.html#l00205">walker::Distributor::computedt()</a>, <a class="el" href="_diff_eq_stack_8h_source.html#l00123">walker::DiffEqStack::createDiffEq()</a>, <a class="el" href="_distributor_8_c_source.html#l00063">walker::Distributor::Distributor()</a>, <a class="el" href="_distributor_8_c_source.html#l00257">walker::Distributor::estimateCen()</a>, <a class="el" href="_distributor_8_c_source.html#l00232">walker::Distributor::estimateOrd()</a>, <a class="el" href="_distributor_8_c_source.html#l00584">walker::Distributor::evaluateTime()</a>, <a class="el" href="_r_n_g_test_driver_8_c_source.html#l00058">rngtest::RNGTestDriver::execute()</a>, <a class="el" href="_inciter_setup_8_c_source.html#l00068">inciter::help()</a>, <a class="el" href="_diff_eq_stack_8_c_source.html#l00277">walker::DiffEqStack::info()</a>, <a class="el" href="_distributor_8_c_source.html#l00119">walker::Distributor::info()</a>, <a class="el" href="_diff_eq_stack_8_c_source.html#l00546">walker::DiffEqStack::infoBeta()</a>, <a class="el" href="_diff_eq_stack_8_c_source.html#l00501">walker::DiffEqStack::infoDiagOU()</a>, <a class="el" href="_diff_eq_stack_8_c_source.html#l00320">walker::DiffEqStack::infoDirichlet()</a>, <a class="el" href="_diff_eq_stack_8_c_source.html#l00895">walker::DiffEqStack::infoGamma()</a>, <a class="el" href="_diff_eq_stack_8_c_source.html#l00366">walker::DiffEqStack::infoGenDir()</a>, <a class="el" href="_diff_eq_stack_8_c_source.html#l00652">walker::DiffEqStack::infoMassFractionBeta()</a>, <a class="el" href="_diff_eq_stack_8_c_source.html#l00778">walker::DiffEqStack::infoMixMassFracBeta()</a>, <a class="el" href="_diff_eq_stack_8_c_source.html#l00712">walker::DiffEqStack::infoMixNumFracBeta()</a>, <a class="el" href="_diff_eq_stack_8_c_source.html#l00592">walker::DiffEqStack::infoNumberFractionBeta()</a>, <a class="el" href="_diff_eq_stack_8_c_source.html#l00458">walker::DiffEqStack::infoOU()</a>, <a class="el" href="_diff_eq_stack_8_c_source.html#l00844">walker::DiffEqStack::infoSkewNormal()</a>, <a class="el" href="_diff_eq_stack_8_c_source.html#l00415">walker::DiffEqStack::infoWrightFisher()</a>, <a class="el" href="_inciter_setup_8_c_source.html#l00411">inciter::init()</a>, <a class="el" href="_performer_8_c_source.html#l00336">inciter::Performer::initCoords()</a>, <a class="el" href="_walker_2_input_deck_2_parser_8_c_source.html#l00036">walker::InputDeckParser::InputDeckParser()</a>, <a class="el" href="_breeze_2_input_deck_2_parser_8_c_source.html#l00026">inciter::InputDeckParser::InputDeckParser()</a>, <a class="el" href="_r_n_g_test_print_8h_source.html#l00064">rngtest::RNGTestPrint::Item()</a>, <a class="el" href="_inciter_print_8h_source.html#l00065">inciter::InciterPrint::Item()</a>, <a class="el" href="_walker_print_8h_source.html#l00080">walker::WalkerPrint::Item()</a>, <a class="el" href="_inciter_8_c_source.html#l00133">Main::Main()</a>, <a class="el" href="_inciter_8_c_source.html#l00236">main()</a>, <a class="el" href="_mesh_conv_driver_8_c_source.html#l00034">meshconv::MeshConvDriver::MeshConvDriver()</a>, <a class="el" href="_test_u01_suite_8_c_source.html#l00086">rngtest::TestU01Suite::names()</a>, <a class="el" href="_test_u01_suite_8_c_source.html#l00196">rngtest::TestU01Suite::ntest()</a>, <a class="el" href="_walker_2_input_deck_2_input_deck_8h_source.html#l00061">walker::ctr::InputDeck::depvar::operator()()</a>, <a class="el" href="_walker_8_c_source.html#l00104">walker::operator|()</a>, <a class="el" href="_r_n_g_test_8_c_source.html#l00110">rngtest::operator|()</a>, <a class="el" href="_distributor_8_c_source.html#l00372">walker::Distributor::outPDF()</a>, <a class="el" href="_distributor_8_c_source.html#l00352">walker::Distributor::outStat()</a>, <a class="el" href="_walker_print_8_c_source.html#l00120">walker::WalkerPrint::pdfs()</a>, <a class="el" href="_inciter_setup_8_c_source.html#l00455">inciter::prepareMesh()</a>, <a class="el" href="_reg_suite_8_c_source.html#l00041">regtest::RegSuite::RegSuite()</a>, <a class="el" href="_distributor_8_c_source.html#l00684">walker::Distributor::report()</a>, <a class="el" href="_r_n_g_test_driver_8_c_source.html#l00037">rngtest::RNGTestDriver::RNGTestDriver()</a>, <a class="el" href="_r_n_g_test_print_8h_source.html#l00044">rngtest::RNGTestPrint::Section()</a>, <a class="el" href="_inciter_print_8h_source.html#l00044">inciter::InciterPrint::Section()</a>, <a class="el" href="_walker_print_8h_source.html#l00059">walker::WalkerPrint::Section()</a>, <a class="el" href="_diff_eq_stack_8_c_source.html#l00235">walker::DiffEqStack::selected()</a>, <a class="el" href="_walker_print_8_c_source.html#l00054">walker::WalkerPrint::statistics()</a>, <a class="el" href="_walker_print_8_c_source.html#l00095">walker::WalkerPrint::stats()</a>, <a class="el" href="_test_u01_stack_8_c_source.html#l00038">rngtest::TestU01Stack::TestU01Stack()</a>, <a class="el" href="_t_u_t_suite_8_c_source.html#l00039">unittest::TUTSuite::TUTSuite()</a>, <a class="el" href="_walker_driver_8_c_source.html#l00044">walker::WalkerDriver::WalkerDriver()</a>, <a class="el" href="_distributor_8_c_source.html#l00426">walker::Distributor::writeBiPDF()</a>, <a class="el" href="_performer_8_c_source.html#l00443">inciter::Performer::writeFields()</a>, <a class="el" href="_performer_8_c_source.html#l00375">inciter::Performer::writeMesh()</a>, <a class="el" href="_performer_8_c_source.html#l00426">inciter::Performer::writeMeta()</a>, <a class="el" href="_distributor_8_c_source.html#l00484">walker::Distributor::writeTriPDF()</a>, and <a class="el" href="_distributor_8_c_source.html#l00388">walker::Distributor::writeUniPDF()</a>.</p>
<div class="fragment"><pre class="fragment">                         {
      <span class="keywordflow">return</span> Tuple::template get&lt;tag&gt;();
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a667f8a630c8d08c2a29254395aecc86d"></a><!-- doxytag: member="tk::Control::get" ref="a667f8a630c8d08c2a29254395aecc86d" args="() const noexcept" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<div class="memtemplate">
template&lt;typename tag , typename subtag &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr const Tuple::template nT&lt;tag&gt;::template nT&lt;subtag&gt;&amp; <a class="el" href="classtk_1_1_control.html">tk::Control</a>&lt; Ts &gt;::<a class="el" href="classtk_1_1_control.html#a85c14acef1b9de96946fcf2ab7c08721">get</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Const-ref accessor to single element at 2nd level. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A constant reference behind a tag, subtag given by the template arguments </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_control_8h_source.html#l00059">59</a> of file <a class="el" href="_control_8h_source.html">Control.h</a>.</p>
<div class="fragment"><pre class="fragment">                         {
      <span class="keywordflow">return</span> Tuple::template get&lt;tag&gt;().<span class="keyword">template</span> get&lt;subtag&gt;();
    }
</pre></div>
</div>
</div>
<a class="anchor" id="aca9009d4b003a57a145cd45eaf698bc7"></a><!-- doxytag: member="tk::Control::get" ref="aca9009d4b003a57a145cd45eaf698bc7" args="() const noexcept" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<div class="memtemplate">
template&lt;typename tag , typename subtag , typename subsubtag &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr const Tuple::template nT&lt;tag&gt;::template nT&lt;subtag&gt;::template nT&lt;subsubtag&gt;&amp; <a class="el" href="classtk_1_1_control.html">tk::Control</a>&lt; Ts &gt;::<a class="el" href="classtk_1_1_control.html#a85c14acef1b9de96946fcf2ab7c08721">get</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Const-ref accessor to single element at 3rd level. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>A constant reference behind a tag, subtag, subsubtag given by the template arguments </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_control_8h_source.html#l00071">71</a> of file <a class="el" href="_control_8h_source.html">Control.h</a>.</p>
<div class="fragment"><pre class="fragment">                         {
      <span class="keywordflow">return</span> Tuple::template get&lt;tag&gt;().
                    <span class="keyword">template</span> get&lt;subtag&gt;().
                    <span class="keyword">template</span> get&lt;subsubtag&gt;();
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a8fdfaa86da44a4e90c6cca5bc57c4cd0"></a><!-- doxytag: member="tk::Control::get" ref="a8fdfaa86da44a4e90c6cca5bc57c4cd0" args="() noexcept" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<div class="memtemplate">
template&lt;typename tag &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Tuple::template nT&lt;tag&gt;&amp; <a class="el" href="classtk_1_1_control.html">tk::Control</a>&lt; Ts &gt;::<a class="el" href="classtk_1_1_control.html#a85c14acef1b9de96946fcf2ab7c08721">get</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rvalue accessor to single element at 1st level. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>An rvalue reference behind a tag given by the template argument </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_control_8h_source.html#l00085">85</a> of file <a class="el" href="_control_8h_source.html">Control.h</a>.</p>
<div class="fragment"><pre class="fragment">                                                   {
      <span class="keywordflow">return</span> Tuple::template get&lt;tag&gt;();
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a1497ed82ffeeab77e506c4c860c4b90d"></a><!-- doxytag: member="tk::Control::get" ref="a1497ed82ffeeab77e506c4c860c4b90d" args="() noexcept" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<div class="memtemplate">
template&lt;typename tag , typename subtag &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Tuple::template nT&lt;tag&gt;::template nT&lt;subtag&gt;&amp; <a class="el" href="classtk_1_1_control.html">tk::Control</a>&lt; Ts &gt;::<a class="el" href="classtk_1_1_control.html#a85c14acef1b9de96946fcf2ab7c08721">get</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rvalue accessor to single element at 2nd level. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>An rvalue reference behind a tag, subtag given by the template arguments </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_control_8h_source.html#l00094">94</a> of file <a class="el" href="_control_8h_source.html">Control.h</a>.</p>
<div class="fragment"><pre class="fragment">                                                                      {
      <span class="keywordflow">return</span> Tuple::template get&lt;tag&gt;().<span class="keyword">template</span> get&lt;subtag&gt;();
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a9831c060237cea68bf081565ede84d7c"></a><!-- doxytag: member="tk::Control::get" ref="a9831c060237cea68bf081565ede84d7c" args="() noexcept" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<div class="memtemplate">
template&lt;typename tag , typename subtag , typename subsubtag &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Tuple::template nT&lt;tag&gt;::template nT&lt;subtag&gt;::template nT&lt;subsubtag&gt;&amp; <a class="el" href="classtk_1_1_control.html">tk::Control</a>&lt; Ts &gt;::<a class="el" href="classtk_1_1_control.html#a85c14acef1b9de96946fcf2ab7c08721">get</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rvalue accessor to single element at 3rd level. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>An rvalue reference behind a tag, subtag, subsubtag given by the template arguments </dd></dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_control_8h_source.html#l00105">105</a> of file <a class="el" href="_control_8h_source.html">Control.h</a>.</p>
<div class="fragment"><pre class="fragment">                                                         {
      <span class="keywordflow">return</span> Tuple::template get&lt;tag&gt;().
                    <span class="keyword">template</span> get&lt;subtag&gt;().
                    <span class="keyword">template</span> get&lt;subsubtag&gt;();
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a7c0ec09f1e88a916a9e222ee3d13c307"></a><!-- doxytag: member="tk::Control::insert" ref="a7c0ec09f1e88a916a9e222ee3d13c307" args="(const typename Tuple::template nT&lt; tag &gt;::key_type &amp;key, const typename Tuple::template nT&lt; tag &gt;::mapped_type &amp;value=typename Tuple::template nT&lt; tag &gt;::mapped_type())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<div class="memtemplate">
template&lt;typename tag &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtk_1_1_control.html">tk::Control</a>&lt; Ts &gt;::<a class="el" href="classtk_1_1_control.html#a7c0ec09f1e88a916a9e222ee3d13c307">insert</a> </td>
          <td>(</td>
          <td class="paramtype">const typename Tuple::template nT&lt; tag &gt;::key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Tuple::template nT&lt; tag &gt;::mapped_type &amp;&#160;</td>
          <td class="paramname"><em>value</em> = <code>typename&#160;Tuple::template&#160;nT&lt;tag&gt;&#160;::mapped_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert key-value pair to map at tag at 1st level using std::map::operator[]. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key to insert to std::map behind tag given by the template argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to insert to std::map behind tag given by the template argument; optional argument, if not given, use default constructor </td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_control_8h_source.html#l00439">439</a> of file <a class="el" href="_control_8h_source.html">Control.h</a>.</p>
<div class="fragment"><pre class="fragment">    {
      Tuple::template get&lt;tag&gt;()[ key ] = value;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a23a09efce36dce4c523d63fc3c670e26"></a><!-- doxytag: member="tk::Control::insert" ref="a23a09efce36dce4c523d63fc3c670e26" args="(const typename Tuple::template nT&lt; tag &gt;::template nT&lt; subtag &gt;::key_type &amp;key, const typename Tuple::template nT&lt; tag &gt;::template nT&lt; subtag &gt;::mapped_type &amp;value=typename Tuple::template nT&lt; tag &gt;::template nT&lt; subtag &gt;::mapped_type())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<div class="memtemplate">
template&lt;typename tag , typename subtag &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtk_1_1_control.html">tk::Control</a>&lt; Ts &gt;::<a class="el" href="classtk_1_1_control.html#a7c0ec09f1e88a916a9e222ee3d13c307">insert</a> </td>
          <td>(</td>
          <td class="paramtype">const typename Tuple::template nT&lt; tag &gt;::template nT&lt; subtag &gt;::key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Tuple::template nT&lt; tag &gt;::template nT&lt; subtag &gt;::mapped_type &amp;&#160;</td>
          <td class="paramname"><em>value</em> = <code>typename&#160;Tuple::template&#160;nT&lt;tag&gt;&#160;::template&#160;nT&lt;subtag&gt;&#160;::mapped_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert key-value pair to map at tag at 2nd level using std::map::operator[]. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key to insert to std::map behind tag and subtag given by the template arguments </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to insert to std::map behind tag and subtag given by the template arguments; optional argument, if not given, use default constructor </td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_control_8h_source.html#l00458">458</a> of file <a class="el" href="_control_8h_source.html">Control.h</a>.</p>
<div class="fragment"><pre class="fragment">    {
      Tuple::template get&lt;tag&gt;().
             <span class="keyword">template</span> get&lt;subtag&gt;()[ key ] = value;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="abc77025ff1870238591d64c0afe83ab9"></a><!-- doxytag: member="tk::Control::insert" ref="abc77025ff1870238591d64c0afe83ab9" args="(const typename Tuple::template nT&lt; tag &gt;::template nT&lt; subtag &gt;::template nT&lt; subsubtag &gt;::key_type &amp;key, const typename Tuple::template nT&lt; tag &gt;::template nT&lt; subtag &gt;::template nT&lt; subsubtag &gt;::mapped_type &amp;value=typename Tuple::template nT&lt; tag &gt;::template nT&lt; subtag &gt;::template nT&lt; subsubtag &gt;::mapped_type())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<div class="memtemplate">
template&lt;typename tag , typename subtag , typename subsubtag &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtk_1_1_control.html">tk::Control</a>&lt; Ts &gt;::<a class="el" href="classtk_1_1_control.html#a7c0ec09f1e88a916a9e222ee3d13c307">insert</a> </td>
          <td>(</td>
          <td class="paramtype">const typename Tuple::template nT&lt; tag &gt;::template nT&lt; subtag &gt;::template nT&lt; subsubtag &gt;::key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename Tuple::template nT&lt; tag &gt;::template nT&lt; subtag &gt;::template nT&lt; subsubtag &gt;::mapped_type &amp;&#160;</td>
          <td class="paramname"><em>value</em> = <code>typename&#160;Tuple::template&#160;nT&lt;tag&gt;&#160;::template&#160;nT&lt;subtag&gt;&#160;::template&#160;nT&lt;subsubtag&gt;&#160;::mapped_type()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert key-value pair to map at tag at 3rd level using std::map::operator[]. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key to insert to std::map behind tag, subtag, and subsubtag given by the template arguments </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to insert to std::map behind tag, subtag, and subsubstag given by the template arguments; optional argument, if not given, use default constructor </td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_control_8h_source.html#l00481">481</a> of file <a class="el" href="_control_8h_source.html">Control.h</a>.</p>
<div class="fragment"><pre class="fragment">    {
      Tuple::template get&lt;tag&gt;().
             <span class="keyword">template</span> get&lt;subtag&gt;().
             <span class="keyword">template</span> get&lt;subsubtag&gt;()[ key ] = value;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="aa17b6ff6883417430f802231103698ce"></a><!-- doxytag: member="tk::Control::insert_field" ref="aa17b6ff6883417430f802231103698ce" args="(const key_type &amp;key, const std::string &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<div class="memtemplate">
template&lt;typename key_type , typename field , typename tag &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtk_1_1_control.html">tk::Control</a>&lt; Ts &gt;::<a class="el" href="classtk_1_1_control.html#aa17b6ff6883417430f802231103698ce">insert_field</a> </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert key-value pair with converting value to map at tag at 1st level using std::map::operator[]. </p>
<p>This member function is used to set a value behind a field given by the field template argument of a tagged tuple that exist as a value of a std::map behind a key at the 1st level of <a class="el" href="classtk_1_1_control.html">Control</a> object given by the tag template argument. The assumed hierarchy is: <a class="el" href="classtk_1_1_control.html">Control</a> (this object) -&gt; tag -&gt; std::map&lt; key_type, tagged_tuple &gt; -&gt; field = value. This is similar to insert_opt, but performs conversion. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key to insert to std::map behind tag given by the template argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to insert to std::map behind tag given by the template argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_control_8h_source.html#l00517">517</a> of file <a class="el" href="_control_8h_source.html">Control.h</a>.</p>
<div class="fragment"><pre class="fragment">                                                                   {
      Tuple::template get&lt;tag&gt;()[ key ].<span class="keyword">template</span> get&lt;field&gt;() =
        convert&lt;typename Tuple::template nT&lt;tag&gt;
                              ::mapped_type
                              ::template nT&lt;field&gt;&gt;( value );
    }
</pre></div>
</div>
</div>
<a class="anchor" id="aad115e5d2b416d91588a9adbdb6835ad"></a><!-- doxytag: member="tk::Control::insert_field" ref="aad115e5d2b416d91588a9adbdb6835ad" args="(const key_type &amp;key, const std::string &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<div class="memtemplate">
template&lt;typename key_type , typename field , typename tag , typename subtag &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtk_1_1_control.html">tk::Control</a>&lt; Ts &gt;::<a class="el" href="classtk_1_1_control.html#aa17b6ff6883417430f802231103698ce">insert_field</a> </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert key-value pair with converting value to map at tag at 2nd level using std::map::operator[]. </p>
<p>This member function is used to set a value behind a field given by the field template argument of a tagged tuple that exist as a value of a std::map behind a key at the 2nd level of <a class="el" href="classtk_1_1_control.html">Control</a> object given by the tag and subtag template arguments. The assumed hierarchy is: <a class="el" href="classtk_1_1_control.html">Control</a> (this object) -&gt; tag -&gt; subtag -&gt; std::map&lt; key_type, tagged_tuple &gt; -&gt; field = value. This is similar to insert_opt, but performs conversion. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key to insert to std::map behind tag and subtag given by the template arguments </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to insert to std::map behind tag and subtag given by the template arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_control_8h_source.html#l00539">539</a> of file <a class="el" href="_control_8h_source.html">Control.h</a>.</p>
<div class="fragment"><pre class="fragment">                                                                   {
      Tuple::template get&lt;tag&gt;().
             <span class="keyword">template</span> get&lt;subtag&gt;()[ key ].template get&lt;field&gt;() =
        <a class="code" href="classtk_1_1_control.html#ab808941c33e950bf6272cde25d5c8528" title="Convert string to a type given by the template argument using std::stringstream.">convert</a>&lt;<span class="keyword">typename</span> Tuple::template nT&lt;tag&gt;
                              ::<span class="keyword">template</span> nT&lt;subtag&gt;
                              ::mapped_type
                              ::<span class="keyword">template</span> nT&lt;field&gt;&gt;( value );
    }
</pre></div>
</div>
</div>
<a class="anchor" id="ab6a4074a6f110a23e2c28f3a7b8e336b"></a><!-- doxytag: member="tk::Control::insert_field" ref="ab6a4074a6f110a23e2c28f3a7b8e336b" args="(const key_type key, const std::string &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<div class="memtemplate">
template&lt;typename key_type , typename field , typename tag , typename subtag , typename subsubtag &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtk_1_1_control.html">tk::Control</a>&lt; Ts &gt;::<a class="el" href="classtk_1_1_control.html#aa17b6ff6883417430f802231103698ce">insert_field</a> </td>
          <td>(</td>
          <td class="paramtype">const key_type&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert key-value pair with converting value to map at tag at 3rd level using std::map::operator[]. </p>
<p>This member function is used to set a value behind a field given by the field template argument of a tagged tuple that exist as a value of a std::map behind a key at the 3rd level of <a class="el" href="classtk_1_1_control.html">Control</a> object given by the tag, subtag, and subsubtag template arguments. The assumed hierarchy is: <a class="el" href="classtk_1_1_control.html">Control</a> (this object) -&gt; tag -&gt; subtag -&gt; subsubtag -&gt; std::map&lt; key_type, tagged_tuple &gt; -&gt; field = value. This is similar to insert_opt, but performs conversion. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key to insert to std::map behind tag, subtag, and subsubtag given by the template arguments </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to insert to std::map behind tag, subtag, and subsubtag given by the template arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_control_8h_source.html#l00564">564</a> of file <a class="el" href="_control_8h_source.html">Control.h</a>.</p>
<div class="fragment"><pre class="fragment">                                                                  {
      Tuple::template get&lt;tag&gt;().
             <span class="keyword">template</span> get&lt;subtag&gt;().
             <span class="keyword">template</span> get&lt;subsubtag&gt;()[ key ].<span class="keyword">template</span> get&lt;field&gt;() =
        convert&lt;typename Tuple::template nT&lt;tag&gt;
                              ::template nT&lt;subtag&gt;
                              ::template nT&lt;subsubtag&gt;
                              ::mapped_type
                              ::template nT&lt;field&gt;&gt;( value );
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a6115a8bdd09d3210662350754086da0d"></a><!-- doxytag: member="tk::Control::insert_opt" ref="a6115a8bdd09d3210662350754086da0d" args="(const key_type &amp;key, const field_type &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<div class="memtemplate">
template&lt;typename key_type , typename field , typename field_type , typename tag &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtk_1_1_control.html">tk::Control</a>&lt; Ts &gt;::<a class="el" href="classtk_1_1_control.html#a6115a8bdd09d3210662350754086da0d">insert_opt</a> </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const field_type &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert value to field of tagged tuple behind a key of a map at tag at 1st level. </p>
<p>This member function is used to set a value behind a field given by the field template argument of a tagged tuple that exist as a value of a std::map behind a key at the 1st level of <a class="el" href="classtk_1_1_control.html">Control</a> object given by the tag template argument. The assumed hierarchy is: <a class="el" href="classtk_1_1_control.html">Control</a> (this object) -&gt; tag -&gt; subtag -&gt; std::map&lt; key_type, tagged_tuple &gt; -&gt; field = value. This is similar to insert_field, but performs no conversion. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key used to access the std::map value using std::map::operator[], behind which a type that defines the <a class="el" href="classtk_1_1_control.html#a8fdfaa86da44a4e90c6cca5bc57c4cd0" title="Rvalue accessor to single element at 1st level.">get()</a> member function (e.g., a tagged_tuple) is assumed to exist </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_control_8h_source.html#l00595">595</a> of file <a class="el" href="_control_8h_source.html">Control.h</a>.</p>
<div class="fragment"><pre class="fragment">                                                                    {
      Tuple::template get&lt;tag&gt;()[ key ].<span class="keyword">template</span> get&lt;field&gt;() = value;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a0ac4e30a81f1750d876e2aa7946d0555"></a><!-- doxytag: member="tk::Control::insert_opt" ref="a0ac4e30a81f1750d876e2aa7946d0555" args="(const key_type &amp;key, const field_type &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<div class="memtemplate">
template&lt;typename key_type , typename field , typename field_type , typename tag , typename subtag &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtk_1_1_control.html">tk::Control</a>&lt; Ts &gt;::<a class="el" href="classtk_1_1_control.html#a6115a8bdd09d3210662350754086da0d">insert_opt</a> </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const field_type &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert value to field of tagged tuple behind a key of a map at tag at 2nd level. </p>
<p>This member function is used to set a value behind a field given by the field template argument of a tagged tuple that exist as a value of a std::map behind a key at the 2nd level of <a class="el" href="classtk_1_1_control.html">Control</a> object given by the tag and subtag template arguments. The assumed hierarchy is: <a class="el" href="classtk_1_1_control.html">Control</a> (this object) -&gt; tag -&gt; subtag -&gt; std::map&lt; key_type, tagged_tuple &gt; -&gt; field = value. This is similar to insert_field, but performs no conversion. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key used to access the std::map value using std::map::operator[], behind which a type that defines the <a class="el" href="classtk_1_1_control.html#a8fdfaa86da44a4e90c6cca5bc57c4cd0" title="Rvalue accessor to single element at 1st level.">get()</a> member function (e.g., a tagged_tuple) is assumed to exist </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to insert </td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_control_8h_source.html#l00616">616</a> of file <a class="el" href="_control_8h_source.html">Control.h</a>.</p>
<div class="fragment"><pre class="fragment">                                                                    {
      Tuple::template get&lt;tag&gt;().
             <span class="keyword">template</span> get&lt;subtag&gt;()[ key ].template get&lt;field&gt;() = value;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="aac13d1641311a8059ddd05ea981cd1ec"></a><!-- doxytag: member="tk::Control::insert_opt" ref="aac13d1641311a8059ddd05ea981cd1ec" args="(const key_type &amp;key, const field_type &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<div class="memtemplate">
template&lt;typename key_type , typename field , typename field_type , typename tag , typename subtag , typename subsubtag &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtk_1_1_control.html">tk::Control</a>&lt; Ts &gt;::<a class="el" href="classtk_1_1_control.html#a6115a8bdd09d3210662350754086da0d">insert_opt</a> </td>
          <td>(</td>
          <td class="paramtype">const key_type &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const field_type &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert key-value pair with converting value to map at tag at 3rd level using std::map::operator[]. </p>
<p>This member function is used to set a value behind a field given by the field template argument of a tagged tuple that exist as a value of a std::map behind a key at the 3rd level of <a class="el" href="classtk_1_1_control.html">Control</a> object given by the tag, subtag, and subsubtag template arguments. The assumed hierarchy is: <a class="el" href="classtk_1_1_control.html">Control</a> (this object) -&gt; tag -&gt; subtag -&gt; subsubtag -&gt; std::map&lt; key_type, tagged_tuple &gt; -&gt; field = value. This is similar to insert_field, but performs no conversion. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>Key to insert to std::map behind tag, subtag, and subsubtag given by the template arguments </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to insert to std::map behind tag, subtag, and subsubtag given by the template arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_control_8h_source.html#l00638">638</a> of file <a class="el" href="_control_8h_source.html">Control.h</a>.</p>
<div class="fragment"><pre class="fragment">                                                                    {
      Tuple::template get&lt;tag&gt;().
             <span class="keyword">template</span> get&lt;subtag&gt;().
             <span class="keyword">template</span> get&lt;subsubtag&gt;()[ key ].<span class="keyword">template</span> get&lt;field&gt;() = value;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a5e6ca99f05104e094945eb34662dbdfc"></a><!-- doxytag: member="tk::Control::pup" ref="a5e6ca99f05104e094945eb34662dbdfc" args="(PUP::er &amp;p)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtk_1_1_control.html">tk::Control</a>&lt; Ts &gt;::<a class="el" href="classtk_1_1_control.html#a5e6ca99f05104e094945eb34662dbdfc">pup</a> </td>
          <td>(</td>
          <td class="paramtype">PUP::er &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pack/Unpack serialize member function. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">inout]</td><td>p Charm++'s PUP::er serializer object reference </td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Reimplemented from <a class="el" href="structtk_1_1tuple_1_1tagged__tuple.html#ad029ef69c35dc650cc6358777f191643">tk::tuple::tagged_tuple&lt; Ts...&gt;</a>.</p>

<p>Reimplemented in <a class="el" href="classwalker_1_1ctr_1_1_input_deck.html#a7374ce946332196f75108b478ff9605a">walker::ctr::InputDeck</a>, <a class="el" href="classbreeze_1_1ctr_1_1_input_deck.html#ab367342488071fe17257644b572b1b32">breeze::ctr::InputDeck</a>, <a class="el" href="classrngtest_1_1ctr_1_1_input_deck.html#a1e8fd8d26b82953f4b663ebd1d0ddfe7">rngtest::ctr::InputDeck</a>, <a class="el" href="classinciter_1_1ctr_1_1_cmd_line.html#a8c72efee8630170b9f74a83e2289b1cd">inciter::ctr::CmdLine</a>, <a class="el" href="classwalker_1_1ctr_1_1_cmd_line.html#a3ee248efebfbfa75e6a24c5abc646256">walker::ctr::CmdLine</a>, <a class="el" href="classrngtest_1_1ctr_1_1_cmd_line.html#aa13815efd6b7432da904477509767ce1">rngtest::ctr::CmdLine</a>, <a class="el" href="classinciter_1_1ctr_1_1_input_deck.html#a5569bf006d3c7de22c602db58aef6cc8">inciter::ctr::InputDeck</a>, <a class="el" href="classmeshconv_1_1ctr_1_1_cmd_line.html#a960b3d7d1d23b898e12cf2b0aef7437d">meshconv::ctr::CmdLine</a>, <a class="el" href="classregtest_1_1ctr_1_1_cmd_line.html#ad0e20b3181755bdf92098c9d8c9518a2">regtest::ctr::CmdLine</a>, and <a class="el" href="classunittest_1_1ctr_1_1_cmd_line.html#a63c1d8c197ab7064624e02189e7fd710">unittest::ctr::CmdLine</a>.</p>

<p>Definition at line <a class="el" href="_control_8h_source.html#l00680">680</a> of file <a class="el" href="_control_8h_source.html">Control.h</a>.</p>

<p>Referenced by <a class="el" href="_control_8h_source.html#l00680">tk::Control&lt; tag::title, kw::title::info::expect::type, tag::selected, selects, tag::discr, discretization, tag::component, ncomps, tag::interval, intervals, tag::cmd, CmdLine, tag::param, parameters, tag::stat, std::vector&lt; tk::ctr::Product &gt;, tag::pdf, std::vector&lt; tk::ctr::Probability &gt;, tag::error, std::vector&lt; std::string &gt; &gt;::pup()</a>.</p>
<div class="fragment"><pre class="fragment">{ <a class="code" href="classtk_1_1_control.html#a5e6ca99f05104e094945eb34662dbdfc" title="Pack/Unpack serialize member function.">Tuple::pup</a>(p); }
</pre></div>
</div>
</div>
<a class="anchor" id="ab5f1173b8774b6e70d2fba5ab819d511"></a><!-- doxytag: member="tk::Control::push_back" ref="ab5f1173b8774b6e70d2fba5ab819d511" args="(const typename Tuple::template nT&lt; tag &gt;::value_type &amp;value=typename Tuple::template nT&lt; tag &gt;::value_type())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<div class="memtemplate">
template&lt;typename tag &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtk_1_1_control.html">tk::Control</a>&lt; Ts &gt;::<a class="el" href="classtk_1_1_control.html#ab5f1173b8774b6e70d2fba5ab819d511">push_back</a> </td>
          <td>(</td>
          <td class="paramtype">const typename Tuple::template nT&lt; tag &gt;::value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em> = <code>typename&#160;Tuple::template&#160;nT&lt;tag&gt;::value_type()</code></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Push back value to vector at tag at 1st level without conversion. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to push back behind tag given by the template argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_control_8h_source.html#l00195">195</a> of file <a class="el" href="_control_8h_source.html">Control.h</a>.</p>

<p>Referenced by <a class="el" href="_control_8h_source.html#l00195">tk::Control&lt; tag::title, kw::title::info::expect::type, tag::selected, selects, tag::discr, discretization, tag::component, ncomps, tag::interval, intervals, tag::cmd, CmdLine, tag::param, parameters, tag::stat, std::vector&lt; tk::ctr::Product &gt;, tag::pdf, std::vector&lt; tk::ctr::Probability &gt;, tag::error, std::vector&lt; std::string &gt; &gt;::push_back()</a>, and <a class="el" href="_control_8h_source.html#l00300">tk::Control&lt; tag::title, kw::title::info::expect::type, tag::selected, selects, tag::discr, discretization, tag::component, ncomps, tag::interval, intervals, tag::cmd, CmdLine, tag::param, parameters, tag::stat, std::vector&lt; tk::ctr::Product &gt;, tag::pdf, std::vector&lt; tk::ctr::Probability &gt;, tag::error, std::vector&lt; std::string &gt; &gt;::store_back()</a>.</p>
<div class="fragment"><pre class="fragment">                                                                       {
      Tuple::template get&lt;tag&gt;().<a class="code" href="classtk_1_1_control.html#ab5f1173b8774b6e70d2fba5ab819d511" title="Push back value to vector at tag at 1st level without conversion.">push_back</a>( value );
    }
</pre></div>
</div>
</div>
<a class="anchor" id="aa52ec9ec800000777306f91d74b0cde1"></a><!-- doxytag: member="tk::Control::push_back" ref="aa52ec9ec800000777306f91d74b0cde1" args="(const typename Tuple::template nT&lt; tag &gt;::template nT&lt; subtag &gt;::value_type &amp;value=typename Tuple::template nT&lt; tag &gt;::template nT&lt; subtag &gt;::value_type())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<div class="memtemplate">
template&lt;typename tag , typename subtag &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtk_1_1_control.html">tk::Control</a>&lt; Ts &gt;::<a class="el" href="classtk_1_1_control.html#ab5f1173b8774b6e70d2fba5ab819d511">push_back</a> </td>
          <td>(</td>
          <td class="paramtype">const typename Tuple::template nT&lt; tag &gt;::template nT&lt; subtag &gt;::value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em> = <code>typename&#160;Tuple::template&#160;nT&lt;tag&gt;&#160;::template&#160;nT&lt;subtag&gt;&#160;::value_type()</code></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Push back value to vector at tag at 2nd level without conversion. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to push back behind tag and subtag given by the template argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_control_8h_source.html#l00205">205</a> of file <a class="el" href="_control_8h_source.html">Control.h</a>.</p>
<div class="fragment"><pre class="fragment">                                                       {
      Tuple::template get&lt;tag&gt;().
             <span class="keyword">template</span> get&lt;subtag&gt;().push_back( value );
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a547e70664c1fdad2ebef7ce1acde9f4c"></a><!-- doxytag: member="tk::Control::push_back" ref="a547e70664c1fdad2ebef7ce1acde9f4c" args="(const typename Tuple::template nT&lt; tag &gt;::template nT&lt; subtag &gt;::template nT&lt; subsubtag &gt;::value_type &amp;value=typename Tuple::template nT&lt; tag &gt;::template nT&lt; subtag &gt;::template nT&lt; subsubtag &gt;::value_type())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<div class="memtemplate">
template&lt;typename tag , typename subtag , typename subsubtag &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtk_1_1_control.html">tk::Control</a>&lt; Ts &gt;::<a class="el" href="classtk_1_1_control.html#ab5f1173b8774b6e70d2fba5ab819d511">push_back</a> </td>
          <td>(</td>
          <td class="paramtype">const typename Tuple::template nT&lt; tag &gt;::template nT&lt; subtag &gt;::template nT&lt; subsubtag &gt;::value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em> = <code>typename&#160;Tuple::template&#160;nT&lt;tag&gt;&#160;::template&#160;nT&lt;subtag&gt;&#160;::template&#160;nT&lt;subsubtag&gt;&#160;::value_type()</code></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Push back value to vector at tag at 3rd level without conversion. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to push back behind tag, subtag, and subsubtag given by the template argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_control_8h_source.html#l00220">220</a> of file <a class="el" href="_control_8h_source.html">Control.h</a>.</p>
<div class="fragment"><pre class="fragment">                                                       {
      Tuple::template get&lt;tag&gt;().
             <span class="keyword">template</span> get&lt;subtag&gt;().
             <span class="keyword">template</span> get&lt;subsubtag&gt;().<a class="code" href="classtk_1_1_control.html#ab5f1173b8774b6e70d2fba5ab819d511" title="Push back value to vector at tag at 1st level without conversion.">push_back</a>( value );
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a4cb86f8e688d964d4dfc32acfa0a05da"></a><!-- doxytag: member="tk::Control::push_back_back" ref="a4cb86f8e688d964d4dfc32acfa0a05da" args="(const typename Tuple::template nT&lt; tag &gt;::value_type::value_type &amp;value=typename Tuple::template nT&lt; tag &gt;::value_type::value_type())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<div class="memtemplate">
template&lt;typename tag &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtk_1_1_control.html">tk::Control</a>&lt; Ts &gt;::<a class="el" href="classtk_1_1_control.html#a4cb86f8e688d964d4dfc32acfa0a05da">push_back_back</a> </td>
          <td>(</td>
          <td class="paramtype">const typename Tuple::template nT&lt; tag &gt;::value_type::value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em> = <code>typename&#160;Tuple::template&#160;nT&lt;tag&gt;&#160;::value_type::value_type()</code></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Push back value to vector of back of vector at tag at 1st level without conversion. </p>
<p>This is similar to store_back_back but performes no conversion. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to push back behind tag given by the template argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_control_8h_source.html#l00244">244</a> of file <a class="el" href="_control_8h_source.html">Control.h</a>.</p>
<div class="fragment"><pre class="fragment">                                                                  {
      Tuple::template get&lt;tag&gt;().back().push_back( value );
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a83bb8f2fb20df55d88f8b794aa383cde"></a><!-- doxytag: member="tk::Control::push_back_back" ref="a83bb8f2fb20df55d88f8b794aa383cde" args="(const typename Tuple::template nT&lt; tag &gt;::template nT&lt; subtag &gt;::value_type::value_type &amp;value=typename Tuple::template nT&lt; tag &gt;::template nT&lt; subtag &gt;::value_type::value_type())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<div class="memtemplate">
template&lt;typename tag , typename subtag &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtk_1_1_control.html">tk::Control</a>&lt; Ts &gt;::<a class="el" href="classtk_1_1_control.html#a4cb86f8e688d964d4dfc32acfa0a05da">push_back_back</a> </td>
          <td>(</td>
          <td class="paramtype">const typename Tuple::template nT&lt; tag &gt;::template nT&lt; subtag &gt;::value_type::value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em> = <code>typename&#160;Tuple::template&#160;nT&lt;tag&gt;&#160;::template&#160;nT&lt;subtag&gt;&#160;::value_type::value_type()</code></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Push back value to vector of back of vector at tag at 2nd level without conversion. </p>
<p>This is similar to store_back_back but performes no conversion. no conversion. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to push back behind tag and subtag given by the template argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_control_8h_source.html#l00259">259</a> of file <a class="el" href="_control_8h_source.html">Control.h</a>.</p>
<div class="fragment"><pre class="fragment">                                                                 {
      Tuple::template get&lt;tag&gt;().
             <span class="keyword">template</span> get&lt;subtag&gt;().back().push_back( value );
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a583ee91b122cd6d17d7fecb80ff9a453"></a><!-- doxytag: member="tk::Control::push_back_back" ref="a583ee91b122cd6d17d7fecb80ff9a453" args="(const typename Tuple::template nT&lt; tag &gt;::template nT&lt; subtag &gt;::template nT&lt; subsubtag &gt;::value_type::value_type &amp;value=typename Tuple::template nT&lt; tag &gt;::template nT&lt; subtag &gt;::template nT&lt; subsubtag &gt;::value_type::value_type())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<div class="memtemplate">
template&lt;typename tag , typename subtag , typename subsubtag &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtk_1_1_control.html">tk::Control</a>&lt; Ts &gt;::<a class="el" href="classtk_1_1_control.html#a4cb86f8e688d964d4dfc32acfa0a05da">push_back_back</a> </td>
          <td>(</td>
          <td class="paramtype">const typename Tuple::template nT&lt; tag &gt;::template nT&lt; subtag &gt;::template nT&lt; subsubtag &gt;::value_type::value_type &amp;&#160;</td>
          <td class="paramname"><em>value</em> = <code>typename&#160;Tuple::template&#160;nT&lt;tag&gt;&#160;::template&#160;nT&lt;subtag&gt;&#160;::template&#160;nT&lt;subsubtag&gt;&#160;::value_type::value_type()</code></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Push back value to vector of back of vector at tag at 3rd level without conversion. </p>
<p>This is similar to store_back_back but performes no conversion. no conversion. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to push back behind tag, subtag, and subsubtag given by the template argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_control_8h_source.html#l00277">277</a> of file <a class="el" href="_control_8h_source.html">Control.h</a>.</p>
<div class="fragment"><pre class="fragment">                                                                 {
      Tuple::template get&lt;tag&gt;().
             <span class="keyword">template</span> get&lt;subtag&gt;().
             <span class="keyword">template</span> get&lt;subsubtag&gt;().back().push_back( value );
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a409e5768e3e10339594a9988f3b4d686"></a><!-- doxytag: member="tk::Control::set" ref="a409e5768e3e10339594a9988f3b4d686" args="(const typename Tuple::template nT&lt; tag &gt; &amp;value) noexcept" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<div class="memtemplate">
template&lt;typename tag &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtk_1_1_control.html">tk::Control</a>&lt; Ts &gt;::<a class="el" href="classtk_1_1_control.html#a409e5768e3e10339594a9988f3b4d686">set</a> </td>
          <td>(</td>
          <td class="paramtype">const typename Tuple::template nT&lt; tag &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set value at slot at tag at 1st level. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to set behind tag given by the template argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_control_8h_source.html#l00119">119</a> of file <a class="el" href="_control_8h_source.html">Control.h</a>.</p>
<div class="fragment"><pre class="fragment">                                                                   {
      Tuple::template get&lt;tag&gt;() = value;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a06c910f6c3ad625fd921af73a9c9f5ed"></a><!-- doxytag: member="tk::Control::set" ref="a06c910f6c3ad625fd921af73a9c9f5ed" args="(const typename Tuple::template nT&lt; tag &gt;::template nT&lt; subtag &gt; &amp;value) noexcept" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<div class="memtemplate">
template&lt;typename tag , typename subtag &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtk_1_1_control.html">tk::Control</a>&lt; Ts &gt;::<a class="el" href="classtk_1_1_control.html#a409e5768e3e10339594a9988f3b4d686">set</a> </td>
          <td>(</td>
          <td class="paramtype">const typename Tuple::template nT&lt; tag &gt;::template nT&lt; subtag &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set value at slot at tag at 2nd level. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to set behind tag and subtag given by the template arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_control_8h_source.html#l00128">128</a> of file <a class="el" href="_control_8h_source.html">Control.h</a>.</p>
<div class="fragment"><pre class="fragment">                                                                      {
      Tuple::template get&lt;tag&gt;().<span class="keyword">template</span> get&lt;subtag&gt;() = value;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="ad55a097d8172b28412c7c85160de1153"></a><!-- doxytag: member="tk::Control::set" ref="ad55a097d8172b28412c7c85160de1153" args="(const typename Tuple::template nT&lt; tag &gt;::template nT&lt; subtag &gt;::template nT&lt; subsubtag &gt; &amp;value) noexcept" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<div class="memtemplate">
template&lt;typename tag , typename subtag , typename subsubtag &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtk_1_1_control.html">tk::Control</a>&lt; Ts &gt;::<a class="el" href="classtk_1_1_control.html#a409e5768e3e10339594a9988f3b4d686">set</a> </td>
          <td>(</td>
          <td class="paramtype">const typename Tuple::template nT&lt; tag &gt;::template nT&lt; subtag &gt;::template nT&lt; subsubtag &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set value at slot at tag at 3rd level. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to set behind tag, subtag, and subsubtag given by the template arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_control_8h_source.html#l00138">138</a> of file <a class="el" href="_control_8h_source.html">Control.h</a>.</p>
<div class="fragment"><pre class="fragment">                                                                         {
      Tuple::template get&lt;tag&gt;().
             <span class="keyword">template</span> get&lt;subtag&gt;().
             <span class="keyword">template</span> get&lt;subsubtag&gt;() = value;
    }
</pre></div>
</div>
</div>
<a class="anchor" id="af8b801a468c14c861354b18c9dd6bb1a"></a><!-- doxytag: member="tk::Control::store" ref="af8b801a468c14c861354b18c9dd6bb1a" args="(const std::string &amp;value) noexcept" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<div class="memtemplate">
template&lt;typename tag &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtk_1_1_control.html">tk::Control</a>&lt; Ts &gt;::<a class="el" href="classtk_1_1_control.html#af8b801a468c14c861354b18c9dd6bb1a">store</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert and set value at tag at 1st level. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to convert and set behind tag given by the template argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_control_8h_source.html#l00155">155</a> of file <a class="el" href="_control_8h_source.html">Control.h</a>.</p>
<div class="fragment"><pre class="fragment">                                                {
      Tuple::template get&lt;tag&gt;() =
        <a class="code" href="classtk_1_1_control.html#ab808941c33e950bf6272cde25d5c8528" title="Convert string to a type given by the template argument using std::stringstream.">convert</a>&lt;<span class="keyword">typename</span> Tuple::template nT&lt;tag&gt;&gt;( value );
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a922c420c486f320570026856a10bd13b"></a><!-- doxytag: member="tk::Control::store" ref="a922c420c486f320570026856a10bd13b" args="(const std::string &amp;value) noexcept" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<div class="memtemplate">
template&lt;typename tag , typename subtag &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtk_1_1_control.html">tk::Control</a>&lt; Ts &gt;::<a class="el" href="classtk_1_1_control.html#af8b801a468c14c861354b18c9dd6bb1a">store</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert and set value at tag at 2nd level. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to convert and set behind tag and subtag given by the template arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_control_8h_source.html#l00165">165</a> of file <a class="el" href="_control_8h_source.html">Control.h</a>.</p>
<div class="fragment"><pre class="fragment">                                                {
      Tuple::template get&lt;tag&gt;().
             <span class="keyword">template</span> get&lt;subtag&gt;() =
        convert&lt;typename Tuple::template nT&lt;tag&gt;
                              ::template nT&lt;subtag&gt;&gt;( value );
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a8939571260ca76fa0d1d8323188bde5a"></a><!-- doxytag: member="tk::Control::store" ref="a8939571260ca76fa0d1d8323188bde5a" args="(const std::string &amp;value) noexcept" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<div class="memtemplate">
template&lt;typename tag , typename subtag , typename subsubtag &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtk_1_1_control.html">tk::Control</a>&lt; Ts &gt;::<a class="el" href="classtk_1_1_control.html#af8b801a468c14c861354b18c9dd6bb1a">store</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert and set value at tag at 3rd level. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to convert and set behind tag, subtag, and </td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_control_8h_source.html#l00177">177</a> of file <a class="el" href="_control_8h_source.html">Control.h</a>.</p>
<div class="fragment"><pre class="fragment">                                                {
      Tuple::template get&lt;tag&gt;().
             <span class="keyword">template</span> get&lt;subtag&gt;().
             <span class="keyword">template</span> get&lt;subsubtag&gt;() =
        <a class="code" href="classtk_1_1_control.html#ab808941c33e950bf6272cde25d5c8528" title="Convert string to a type given by the template argument using std::stringstream.">convert</a>&lt;<span class="keyword">typename</span> Tuple::template nT&lt;tag&gt;
                              ::<span class="keyword">template</span> nT&lt;subtag&gt;
                              ::<span class="keyword">template</span> nT&lt;subsubtag&gt;&gt;( value );
    }
</pre></div>
</div>
</div>
<a class="anchor" id="af572dbca3b3fbc6f2c9fe07faedf321f"></a><!-- doxytag: member="tk::Control::store_back" ref="af572dbca3b3fbc6f2c9fe07faedf321f" args="(const std::string &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<div class="memtemplate">
template&lt;typename tag &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtk_1_1_control.html">tk::Control</a>&lt; Ts &gt;::<a class="el" href="classtk_1_1_control.html#af572dbca3b3fbc6f2c9fe07faedf321f">store_back</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert and push back value to vector at tag at 1st level. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to convert and push back behind tag given by the template argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_control_8h_source.html#l00300">300</a> of file <a class="el" href="_control_8h_source.html">Control.h</a>.</p>
<div class="fragment"><pre class="fragment">                                            {
      Tuple::template get&lt;tag&gt;().<a class="code" href="classtk_1_1_control.html#ab5f1173b8774b6e70d2fba5ab819d511" title="Push back value to vector at tag at 1st level without conversion.">push_back</a>(
        <a class="code" href="classtk_1_1_control.html#ab808941c33e950bf6272cde25d5c8528" title="Convert string to a type given by the template argument using std::stringstream.">convert</a>&lt;<span class="keyword">typename</span> Tuple::template nT&lt;tag&gt;
                              ::value_type&gt;( value ));
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a285ba8b13b8bce0f2b8beeadeebab2fe"></a><!-- doxytag: member="tk::Control::store_back" ref="a285ba8b13b8bce0f2b8beeadeebab2fe" args="(const std::string &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<div class="memtemplate">
template&lt;typename tag , typename subtag &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtk_1_1_control.html">tk::Control</a>&lt; Ts &gt;::<a class="el" href="classtk_1_1_control.html#af572dbca3b3fbc6f2c9fe07faedf321f">store_back</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert and push back value to slot at tag at 2nd level. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to convert and push back behind tag and subtag given by the template arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_control_8h_source.html#l00311">311</a> of file <a class="el" href="_control_8h_source.html">Control.h</a>.</p>
<div class="fragment"><pre class="fragment">                                            {
      Tuple::template get&lt;tag&gt;().
             <span class="keyword">template</span> get&lt;subtag&gt;().push_back(
        <a class="code" href="classtk_1_1_control.html#ab808941c33e950bf6272cde25d5c8528" title="Convert string to a type given by the template argument using std::stringstream.">convert</a>&lt;<span class="keyword">typename</span> Tuple::template nT&lt;tag&gt;
                              ::<span class="keyword">template</span> nT&lt;subtag&gt;
                              ::value_type&gt;( value ));
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a0fdb2011c4bc183cb54e2dad1c99648b"></a><!-- doxytag: member="tk::Control::store_back" ref="a0fdb2011c4bc183cb54e2dad1c99648b" args="(const std::string &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<div class="memtemplate">
template&lt;typename tag , typename subtag , typename subsubtag &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtk_1_1_control.html">tk::Control</a>&lt; Ts &gt;::<a class="el" href="classtk_1_1_control.html#af572dbca3b3fbc6f2c9fe07faedf321f">store_back</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert and push back value to slot at tag at 3rd level. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to convert and push back behind tag, subtag, and subsubtag given by the template arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_control_8h_source.html#l00324">324</a> of file <a class="el" href="_control_8h_source.html">Control.h</a>.</p>
<div class="fragment"><pre class="fragment">                                            {
      Tuple::template get&lt;tag&gt;().
             <span class="keyword">template</span> get&lt;subtag&gt;().
             <span class="keyword">template</span> get&lt;subsubtag&gt;().<a class="code" href="classtk_1_1_control.html#ab5f1173b8774b6e70d2fba5ab819d511" title="Push back value to vector at tag at 1st level without conversion.">push_back</a>(
        <a class="code" href="classtk_1_1_control.html#ab808941c33e950bf6272cde25d5c8528" title="Convert string to a type given by the template argument using std::stringstream.">convert</a>&lt;<span class="keyword">typename</span> Tuple::template nT&lt;tag&gt;
                              ::<span class="keyword">template</span> nT&lt;subtag&gt;
                              ::<span class="keyword">template</span> nT&lt;subsubtag&gt;
                              ::value_type&gt;( value ));
    }
</pre></div>
</div>
</div>
<a class="anchor" id="aaee39a1de8b40b07189f5ab949902710"></a><!-- doxytag: member="tk::Control::store_back_back" ref="aaee39a1de8b40b07189f5ab949902710" args="(const std::string &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<div class="memtemplate">
template&lt;typename tag &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtk_1_1_control.html">tk::Control</a>&lt; Ts &gt;::<a class="el" href="classtk_1_1_control.html#aaee39a1de8b40b07189f5ab949902710">store_back_back</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert and push back value to vector of back of vector at tag at 1st level. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to convert and push back behind tag given by the template arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_control_8h_source.html#l00344">344</a> of file <a class="el" href="_control_8h_source.html">Control.h</a>.</p>
<div class="fragment"><pre class="fragment">                                                 {
      Tuple::template get&lt;tag&gt;().back().push_back(
        <a class="code" href="classtk_1_1_control.html#ab808941c33e950bf6272cde25d5c8528" title="Convert string to a type given by the template argument using std::stringstream.">convert</a>&lt;<span class="keyword">typename</span> Tuple::template nT&lt;tag&gt;
                              ::value_type::value_type&gt;( value ) );
    }
</pre></div>
</div>
</div>
<a class="anchor" id="abd404a2093d7a0752fa8c6c02d6dc2a3"></a><!-- doxytag: member="tk::Control::store_back_back" ref="abd404a2093d7a0752fa8c6c02d6dc2a3" args="(const std::string &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<div class="memtemplate">
template&lt;typename tag , typename subtag &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtk_1_1_control.html">tk::Control</a>&lt; Ts &gt;::<a class="el" href="classtk_1_1_control.html#aaee39a1de8b40b07189f5ab949902710">store_back_back</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert and push back value to vector of back of vector at tag at 2nd level. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to convert and push back behind tag and subtag given by the template arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_control_8h_source.html#l00356">356</a> of file <a class="el" href="_control_8h_source.html">Control.h</a>.</p>
<div class="fragment"><pre class="fragment">                                                 {
      Tuple::template get&lt;tag&gt;().
             <span class="keyword">template</span> get&lt;subtag&gt;().back().push_back(
        <a class="code" href="classtk_1_1_control.html#ab808941c33e950bf6272cde25d5c8528" title="Convert string to a type given by the template argument using std::stringstream.">convert</a>&lt;<span class="keyword">typename</span> Tuple::template nT&lt;tag&gt;
                              ::<span class="keyword">template</span> nT&lt;subtag&gt;
                              ::value_type::value_type&gt;( value ) );
    }
</pre></div>
</div>
</div>
<a class="anchor" id="afbfe4f5aa911d9b5d8763bf22806ceb9"></a><!-- doxytag: member="tk::Control::store_back_back" ref="afbfe4f5aa911d9b5d8763bf22806ceb9" args="(const std::string &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<div class="memtemplate">
template&lt;typename tag , typename subtag , typename subsubtag &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtk_1_1_control.html">tk::Control</a>&lt; Ts &gt;::<a class="el" href="classtk_1_1_control.html#aaee39a1de8b40b07189f5ab949902710">store_back_back</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert and push back value to vector of back of vector at tag at 3rd level. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to convert and push back behind tag, subtag, and subsubtag given by the template arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_control_8h_source.html#l00370">370</a> of file <a class="el" href="_control_8h_source.html">Control.h</a>.</p>
<div class="fragment"><pre class="fragment">                                                 {
      Tuple::template get&lt;tag&gt;().
             <span class="keyword">template</span> get&lt;subtag&gt;().
             <span class="keyword">template</span> get&lt;subsubtag&gt;().back().push_back(
        <a class="code" href="classtk_1_1_control.html#ab808941c33e950bf6272cde25d5c8528" title="Convert string to a type given by the template argument using std::stringstream.">convert</a>&lt;<span class="keyword">typename</span> Tuple::template nT&lt;tag&gt;
                              ::<span class="keyword">template</span> nT&lt;subtag&gt;
                              ::<span class="keyword">template</span> nT&lt;subsubtag&gt;
                              ::value_type::value_type&gt;( value ) );
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a64ad377981664e89e12c6a5464ea5629"></a><!-- doxytag: member="tk::Control::store_back_back_back" ref="a64ad377981664e89e12c6a5464ea5629" args="(const std::string &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<div class="memtemplate">
template&lt;typename tag &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtk_1_1_control.html">tk::Control</a>&lt; Ts &gt;::<a class="el" href="classtk_1_1_control.html#a64ad377981664e89e12c6a5464ea5629">store_back_back_back</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert and push back value to vector of back of vector of back of vector at tag at 1st level. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to convert and push back behind tag given by the template arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_control_8h_source.html#l00390">390</a> of file <a class="el" href="_control_8h_source.html">Control.h</a>.</p>
<div class="fragment"><pre class="fragment">                                                      {
      Tuple::template get&lt;tag&gt;().back().back().push_back(
        <a class="code" href="classtk_1_1_control.html#ab808941c33e950bf6272cde25d5c8528" title="Convert string to a type given by the template argument using std::stringstream.">convert</a>&lt;<span class="keyword">typename</span> Tuple::template nT&lt;tag&gt;
                              ::value_type::value_type::value_type&gt;( value ) );
    }
</pre></div>
</div>
</div>
<a class="anchor" id="ab20ac4cdf3508f9807bd5661b0b1fd0b"></a><!-- doxytag: member="tk::Control::store_back_back_back" ref="ab20ac4cdf3508f9807bd5661b0b1fd0b" args="(const std::string &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<div class="memtemplate">
template&lt;typename tag , typename subtag &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtk_1_1_control.html">tk::Control</a>&lt; Ts &gt;::<a class="el" href="classtk_1_1_control.html#a64ad377981664e89e12c6a5464ea5629">store_back_back_back</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert and push back value to vector of back of vector of back of vector at tag at 2nd level. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to convert and push back behind tag and subtag given by the template arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_control_8h_source.html#l00402">402</a> of file <a class="el" href="_control_8h_source.html">Control.h</a>.</p>
<div class="fragment"><pre class="fragment">                                                      {
      Tuple::template get&lt;tag&gt;().
             <span class="keyword">template</span> get&lt;subtag&gt;().back().back().push_back(
        <a class="code" href="classtk_1_1_control.html#ab808941c33e950bf6272cde25d5c8528" title="Convert string to a type given by the template argument using std::stringstream.">convert</a>&lt;<span class="keyword">typename</span> Tuple::template nT&lt;tag&gt;
                              ::<span class="keyword">template</span> nT&lt;subtag&gt;
                              ::value_type::value_type::value_type&gt;( value ) );
    }
</pre></div>
</div>
</div>
<a class="anchor" id="a27723cdee73124465af0d02d37c23cfe"></a><!-- doxytag: member="tk::Control::store_back_back_back" ref="a27723cdee73124465af0d02d37c23cfe" args="(const std::string &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<div class="memtemplate">
template&lt;typename tag , typename subtag , typename subsubtag &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtk_1_1_control.html">tk::Control</a>&lt; Ts &gt;::<a class="el" href="classtk_1_1_control.html#a64ad377981664e89e12c6a5464ea5629">store_back_back_back</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Convert and push back value to vector of back of vector of back of vector at tag at 3rd level. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to convert and push back behind tag, subtag, and subsubtag given by the template arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_control_8h_source.html#l00416">416</a> of file <a class="el" href="_control_8h_source.html">Control.h</a>.</p>
<div class="fragment"><pre class="fragment">                                                      {
      Tuple::template get&lt;tag&gt;().
             <span class="keyword">template</span> get&lt;subtag&gt;().
             <span class="keyword">template</span> get&lt;subsubtag&gt;().back().back().push_back(
        <a class="code" href="classtk_1_1_control.html#ab808941c33e950bf6272cde25d5c8528" title="Convert string to a type given by the template argument using std::stringstream.">convert</a>&lt;<span class="keyword">typename</span> Tuple::template nT&lt;tag&gt;
                              ::<span class="keyword">template</span> nT&lt;subtag&gt;
                              ::<span class="keyword">template</span> nT&lt;subsubtag&gt;
                              ::value_type::value_type::value_type&gt;( value ) );
    }
</pre></div>
</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a99667f44f03b29d671ba915d15a89f33"></a><!-- doxytag: member="tk::Control::operator|" ref="a99667f44f03b29d671ba915d15a89f33" args="(PUP::er &amp;p, Control&lt; Ts...&gt; &amp;c)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void operator| </td>
          <td>(</td>
          <td class="paramtype">PUP::er &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtk_1_1_control.html">Control</a>&lt; Ts...&gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pack/Unpack serialize operator|. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">inout]</td><td>p Charm++'s PUP::er serializer object reference </td></tr>
    <tr><td class="paramname">inout]</td><td>c <a class="el" href="classtk_1_1_control.html">Control</a> object reference </td></tr>
  </table>
  </dd>
</dl>
<dl class="author"><dt><b>Author:</b></dt><dd>J. Bakosi </dd></dl>

<p>Definition at line <a class="el" href="_control_8h_source.html#l00685">685</a> of file <a class="el" href="_control_8h_source.html">Control.h</a>.</p>
<div class="fragment"><pre class="fragment">{ c.pup(p); }
</pre></div>
</div>
</div>

<p><a href="classtk_1_1_control-members.html">List of all members.</a></p>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/travis/build/jbakosi/quinoa/src/Control/<a class="el" href="_control_8h_source.html">Control.h</a></li>
</ul>
</div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespacetk.html">tk</a>      </li>
      <li class="navelem"><a class="el" href="classtk_1_1_control.html">Control</a>      </li>

    <li class="footer">Generated on Tue Jul 7 2015 00:09:49 for Quinoa by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
