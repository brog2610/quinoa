<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Quinoa: /home/travis/build/jbakosi/quinoa/src/Control/CommonGrammar.h Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Quinoa
   
   </div>
   <div id="projectbrief">Adaptive computational fluid dynamics</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Documents</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('_common_grammar_8h.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">/home/travis/build/jbakosi/quinoa/src/Control/CommonGrammar.h</div>  </div>
</div><!--header-->
<div class="contents">
<a href="_common_grammar_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">//******************************************************************************</span><span class="comment"></span>
<a name="l00002"></a>00002 <span class="comment">/*!</span>
<a name="l00003"></a>00003 <span class="comment">  \file      src/Control/CommonGrammar.h</span>
<a name="l00004"></a>00004 <span class="comment">  \author    J. Bakosi</span>
<a name="l00005"></a>00005 <span class="comment">  \date      Mon 01 Jun 2015 02:02:39 PM MDT</span>
<a name="l00006"></a>00006 <span class="comment">  \copyright 2012-2015, Jozsef Bakosi.</span>
<a name="l00007"></a>00007 <span class="comment">  \brief     Generic, low-level grammar, re-used by specific grammars</span>
<a name="l00008"></a>00008 <span class="comment">  \details   Generic, low-level grammar. We use the [Parsing Expression Grammar</span>
<a name="l00009"></a>00009 <span class="comment">    Template Library (PEGTL)](https://code.google.com/p/pegtl/wiki/PEGTL0) to</span>
<a name="l00010"></a>00010 <span class="comment">    create the grammar and the associated parser. Credit goes to Colin Hirsch</span>
<a name="l00011"></a>00011 <span class="comment">    (pegtl@cohi.at) for PEGTL.</span>
<a name="l00012"></a>00012 <span class="comment">*/</span>
<a name="l00013"></a>00013 <span class="comment">//******************************************************************************</span>
<a name="l00014"></a>00014 <span class="preprocessor">#ifndef CommonGrammar_h</span>
<a name="l00015"></a>00015 <span class="preprocessor"></span><span class="preprocessor">#define CommonGrammar_h</span>
<a name="l00016"></a>00016 <span class="preprocessor"></span>
<a name="l00017"></a>00017 <span class="preprocessor">#include &lt;sstream&gt;</span>
<a name="l00018"></a>00018 
<a name="l00019"></a>00019 <span class="comment">// See documentation for tk::grm::use below for why these macros are here</span>
<a name="l00020"></a>00020 <span class="preprocessor">#undef BOOST_MPL_CFG_NO_PREPROCESSED_HEADERS</span>
<a name="l00021"></a><a class="code" href="_common_grammar_8h.html#a5cfc0a80bcb9c742a4dd13252e8e70b2">00021</a> <span class="preprocessor"></span><span class="preprocessor">#define BOOST_MPL_CFG_NO_PREPROCESSED_HEADERS</span>
<a name="l00022"></a>00022 <span class="preprocessor"></span><span class="preprocessor">#undef BOOST_MPL_LIMIT_METAFUNCTION_ARITY</span>
<a name="l00023"></a><a class="code" href="_common_grammar_8h.html#add19bfd3b2b79f9086bc116a851c03a3">00023</a> <span class="preprocessor"></span><span class="preprocessor">#define BOOST_MPL_LIMIT_METAFUNCTION_ARITY 10</span>
<a name="l00024"></a>00024 <span class="preprocessor"></span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;boost/mpl/or.hpp&gt;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;boost/mpl/for_each.hpp&gt;</span>
<a name="l00027"></a>00027 
<a name="l00028"></a>00028 <span class="preprocessor">#include &quot;<a class="code" href="_if_8h.html" title="Compile-time type selection.">If.h</a>&quot;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &quot;<a class="code" href="_exception_8h.html" title="Exception class declaration.">Exception.h</a>&quot;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &quot;<a class="code" href="_tags_8h.html" title="Tags.">Tags.h</a>&quot;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &quot;<a class="code" href="_stat_ctr_8h.html" title="Types and associated functions to deal with moments and PDFs.">StatCtr.h</a>&quot;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &quot;<a class="code" href="_p_d_f_file_8h.html" title="PDF output file type options.">Options/PDFFile.h</a>&quot;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &quot;<a class="code" href="_p_d_f_policy_8h.html" title="PDF output file policy options.">Options/PDFPolicy.h</a>&quot;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &quot;<a class="code" href="_p_d_f_centering_8h.html" title="PDF output file centering type options.">Options/PDFCentering.h</a>&quot;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &quot;<a class="code" href="_txt_float_format_8h.html" title="Text floating-point output options.">Options/TxtFloatFormat.h</a>&quot;</span>
<a name="l00036"></a>00036 
<a name="l00037"></a>00037 <span class="keyword">namespace </span>tk {<span class="comment"></span>
<a name="l00038"></a>00038 <span class="comment">//! Toolkit general purpose grammar definition</span>
<a name="l00039"></a>00039 <span class="comment"></span><span class="keyword">namespace </span>grm {
<a name="l00040"></a>00040 
<a name="l00041"></a>00041   <span class="keyword">using</span> ncomp_t = kw::ncomp::info::expect::type;
<a name="l00042"></a>00042 <span class="comment"></span>
<a name="l00043"></a>00043 <span class="comment">  //! Parser&#39;s printer: this should be defined once per library in global-scope</span>
<a name="l00044"></a>00044 <span class="comment">  //! (still in namespace, of course) by a parser. It is defined in</span>
<a name="l00045"></a>00045 <span class="comment">  //! Control/[executable]/CmdLine/Parser.C, since every executable has at least</span>
<a name="l00046"></a>00046 <span class="comment">  //! a command line parser.</span>
<a name="l00047"></a><a class="code" href="namespacetk_1_1grm.html#ab83bd20afe2c1386bf4e95bd0e86776e">00047</a> <span class="comment"></span>  <span class="keyword">extern</span> <a class="code" href="classtk_1_1_print.html">Print</a> <a class="code" href="namespacetk_1_1grm.html#ab83bd20afe2c1386bf4e95bd0e86776e">g_print</a>;
<a name="l00048"></a>00048 
<a name="l00049"></a>00049   <span class="comment">// Common InputDeck state</span>
<a name="l00050"></a>00050 <span class="comment"></span>
<a name="l00051"></a>00051 <span class="comment">  //! Out-of-struct storage of field ID for pushing terms for statistics</span>
<a name="l00052"></a><a class="code" href="namespacetk_1_1grm.html#a1b809dbbd954026ab2bc003ec27a80f2">00052</a> <span class="comment"></span>  <span class="keyword">static</span> ncomp_t <a class="code" href="namespacetk_1_1grm.html#a1b809dbbd954026ab2bc003ec27a80f2" title="Out-of-struct storage of field ID for pushing terms for statistics.">field</a> = 0;<span class="comment"></span>
<a name="l00053"></a>00053 <span class="comment">  //! \brief Parser-lifetime storage for dependent variables selected.</span>
<a name="l00054"></a>00054 <span class="comment">  //! \details Used to track the dependent variable of differential equations</span>
<a name="l00055"></a>00055 <span class="comment">  //!   (i.e., models) assigned during parsing. It needs to be case insensitive</span>
<a name="l00056"></a>00056 <span class="comment">  //!   since we only care about whether the variable is selected or not and not</span>
<a name="l00057"></a>00057 <span class="comment">  //!   whether it denotes a full variable (upper case) or a fluctuation (lower</span>
<a name="l00058"></a>00058 <span class="comment">  //!   case). This is true for both inserting variables into the set as well as</span>
<a name="l00059"></a>00059 <span class="comment">  //!   at matching terms of products in parsing requested statistics.</span>
<a name="l00060"></a><a class="code" href="namespacetk_1_1grm.html#ab631f9f35bdba1b71a2cff1112364971">00060</a> <span class="comment"></span>  <span class="keyword">static</span> std::set&lt; char, tk::ctr::CaseInsensitiveCharLess &gt; <a class="code" href="namespacetk_1_1grm.html#ab631f9f35bdba1b71a2cff1112364971" title="Parser-lifetime storage for dependent variables selected.">depvars</a>;<span class="comment"></span>
<a name="l00061"></a>00061 <span class="comment">  //! \brief Parser-lifetime storage for PDF names.</span>
<a name="l00062"></a>00062 <span class="comment">  //! \details Used to track the names registered  so that parsing new ones can</span>
<a name="l00063"></a>00063 <span class="comment">  //!    be required to be unique.</span>
<a name="l00064"></a><a class="code" href="namespacetk_1_1grm.html#aadf18699e85fe7ff02a1dfbb37d78977">00064</a> <span class="comment"></span>  <span class="keyword">static</span> std::set&lt; std::string &gt; <a class="code" href="namespacetk_1_1grm.html#aadf18699e85fe7ff02a1dfbb37d78977" title="Parser-lifetime storage for PDF names.">pdfnames</a>;
<a name="l00065"></a>00065 
<a name="l00066"></a>00066   <span class="comment">// Common auxiliary functions (reused by multiple grammars)</span>
<a name="l00067"></a>00067 <span class="comment"></span>
<a name="l00068"></a>00068 <span class="comment">  //! C-style enum indicating warning or error (used as template argument)</span>
<a name="l00069"></a><a class="code" href="namespacetk_1_1grm.html#aaea8b8be7c61e0bfb422394a315b2b64a91b152b474fe56d25c1f3e0c60fcfdcd">00069</a> <span class="comment"></span>  <span class="keyword">enum</span> <a class="code" href="namespacetk_1_1grm.html#aaea8b8be7c61e0bfb422394a315b2b64" title="C-style enum indicating warning or error (used as template argument)">MsgType</a> { <a class="code" href="namespacetk_1_1grm.html#aaea8b8be7c61e0bfb422394a315b2b64a2524effb18ba47fd4b68e016bc4618a5">ERROR</a>=0, <a class="code" href="namespacetk_1_1grm.html#aaea8b8be7c61e0bfb422394a315b2b64a91b152b474fe56d25c1f3e0c60fcfdcd">WARNING</a> };
<a name="l00070"></a>00070 <span class="comment"></span>
<a name="l00071"></a>00071 <span class="comment">  //! Parser error types</span>
<a name="l00072"></a><a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8">00072</a> <span class="comment"></span>  <span class="keyword">enum class</span> <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8" title="Parser error types.">MsgKey</a> : uint8_t {
<a name="l00073"></a><a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a44caa25e7ef241394a696329fd872765">00073</a>     <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a44caa25e7ef241394a696329fd872765" title="Unknown keyword.">KEYWORD</a>,            <span class="comment">//!&lt; Unknown keyword</span>
<a name="l00074"></a><a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a11f443b3aa706121791c29ca07d8bc35">00074</a> <span class="comment"></span>    <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a11f443b3aa706121791c29ca07d8bc35" title="Unknown Term in a Moment.">MOMENT</a>,             <span class="comment">//!&lt; Unknown Term in a Moment</span>
<a name="l00075"></a><a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8ac11c16e0c25418f529e8d06119e78097">00075</a> <span class="comment"></span>    <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8ac11c16e0c25418f529e8d06119e78097" title="String must be double-quoted.">QUOTED</a>,             <span class="comment">//!&lt; String must be double-quoted</span>
<a name="l00076"></a><a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8ab6d7e7c9f0567c0debd7050e259ca76d">00076</a> <span class="comment"></span>    <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8ab6d7e7c9f0567c0debd7050e259ca76d" title="Unknown value in list.">LIST</a>,               <span class="comment">//!&lt; Unknown value in list</span>
<a name="l00077"></a><a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a5b2e6d2320e1382baf87f10b3dc3fc9c">00077</a> <span class="comment"></span>    <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a5b2e6d2320e1382baf87f10b3dc3fc9c" title="Alias keyword too long.">ALIAS</a>,              <span class="comment">//!&lt; Alias keyword too long</span>
<a name="l00078"></a><a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8ad67b13891add9ac8c072692edb515855">00078</a> <span class="comment"></span>    <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8ad67b13891add9ac8c072692edb515855" title="Required field missing.">MISSING</a>,            <span class="comment">//!&lt; Required field missing</span>
<a name="l00079"></a><a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a90c9f12ef4e01eebb9744a9804014942">00079</a> <span class="comment"></span>    <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a90c9f12ef4e01eebb9744a9804014942" title="Premature end of line.">PREMATURE</a>,          <span class="comment">//!&lt; Premature end of line</span>
<a name="l00080"></a><a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8aded9518443effe497ef2c8e8829f2ab2">00080</a> <span class="comment"></span>    <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8aded9518443effe497ef2c8e8829f2ab2" title="Option not supported.">UNSUPPORTED</a>,        <span class="comment">//!&lt; Option not supported</span>
<a name="l00081"></a><a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a492099849097caa604e3de14a342bd04">00081</a> <span class="comment"></span>    <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a492099849097caa604e3de14a342bd04" title="Option does not exist.">NOOPTION</a>,           <span class="comment">//!&lt; Option does not exist</span>
<a name="l00082"></a><a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a629b2d189b5bfc8d7b4249de406c5792">00082</a> <span class="comment"></span>    <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a629b2d189b5bfc8d7b4249de406c5792" title="No initialization policy selected.">NOINIT</a>,             <span class="comment">//!&lt; No initialization policy selected</span>
<a name="l00083"></a><a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8ae079d545a224bcc061f1542e7e8c73a8">00083</a> <span class="comment"></span>    <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8ae079d545a224bcc061f1542e7e8c73a8" title="No test problem type selected.">NOPROBLEM</a>,          <span class="comment">//!&lt; No test problem type selected</span>
<a name="l00084"></a><a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8ae957443afa58b57eb6ad260cb5743adc">00084</a> <span class="comment"></span>    <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8ae957443afa58b57eb6ad260cb5743adc" title="No coefficients policy selected.">NOCOEFF</a>,            <span class="comment">//!&lt; No coefficients policy selected</span>
<a name="l00085"></a><a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a09f86b84bd40fadcf5a1e173e63a18a2">00085</a> <span class="comment"></span>    <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a09f86b84bd40fadcf5a1e173e63a18a2" title="Option not selected upstream.">NOTSELECTED</a>,        <span class="comment">//!&lt; Option not selected upstream</span>
<a name="l00086"></a><a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a2968ef086326862aabd43b079da1c518">00086</a> <span class="comment"></span>    <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a2968ef086326862aabd43b079da1c518" title="Variable already used.">EXISTS</a>,             <span class="comment">//!&lt; Variable already used</span>
<a name="l00087"></a><a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a824fcd1c511c8c1eefd309414dcb3bfc">00087</a> <span class="comment"></span>    <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a824fcd1c511c8c1eefd309414dcb3bfc" title="Dependent variable has not been specified.">NODEPVAR</a>,           <span class="comment">//!&lt; Dependent variable has not been specified</span>
<a name="l00088"></a><a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a8e5972b53dcde3ec6238b7d6c8315ada">00088</a> <span class="comment"></span>    <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a8e5972b53dcde3ec6238b7d6c8315ada" title="Dependent variable has not been previously selected.">NOSUCHDEPVAR</a>,       <span class="comment">//!&lt; Dependent variable has not been previously selected</span>
<a name="l00089"></a><a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a472f55b1579c5a1910ae21bc79aa7cbd">00089</a> <span class="comment"></span>    <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a472f55b1579c5a1910ae21bc79aa7cbd" title="Variable must be alphanumeric.">NOTALPHA</a>,           <span class="comment">//!&lt; Variable must be alphanumeric</span>
<a name="l00090"></a><a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a0155acc6f48c59b108a5a14217eeedbc">00090</a> <span class="comment"></span>    <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a0155acc6f48c59b108a5a14217eeedbc" title="Statistic need a variable.">NOTERMS</a>,            <span class="comment">//!&lt; Statistic need a variable</span>
<a name="l00091"></a><a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8abd57100130c075df8283623a930235b8">00091</a> <span class="comment"></span>    <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8abd57100130c075df8283623a930235b8" title="Incomplete spikes block.">ODDSPIKES</a>,          <span class="comment">//!&lt; Incomplete spikes block</span>
<a name="l00092"></a><a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a49476752860f376d78c219d95e43d2d8">00092</a> <span class="comment"></span>    <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a49476752860f376d78c219d95e43d2d8" title="Height-sum of spikes does not add up to unity.">HEIGHTSPIKES</a>,       <span class="comment">//!&lt; Height-sum of spikes does not add up to unity</span>
<a name="l00093"></a><a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a76aed51984d3d7a7820af21c3c1af1e5">00093</a> <span class="comment"></span>    <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a76aed51984d3d7a7820af21c3c1af1e5" title="No icdelta...end block when initpolicy = jointdelta.">NODELTA</a>,            <span class="comment">//!&lt; No icdelta...end block when initpolicy = jointdelta</span>
<a name="l00094"></a><a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8aa7facd6c043e37186ce57b5ad54e4aaf">00094</a> <span class="comment"></span>    <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8aa7facd6c043e37186ce57b5ad54e4aaf" title="No icbeta...end block when initpolicy = jointbeta.">NOBETA</a>,             <span class="comment">//!&lt; No icbeta...end block when initpolicy = jointbeta</span>
<a name="l00095"></a><a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a3215fc85dd4e5a7fe6ebd6fb26e4d515">00095</a> <span class="comment"></span>    <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a3215fc85dd4e5a7fe6ebd6fb26e4d515" title="Wrong number of parameters configuring a beta pdf.">WRONGBETAPDF</a>,       <span class="comment">//!&lt; Wrong number of parameters configuring a beta pdf</span>
<a name="l00096"></a><a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a724ba9fa5b04a8a80ee55d0163ed054f">00096</a> <span class="comment"></span>    <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a724ba9fa5b04a8a80ee55d0163ed054f" title="No number of components selected.">NONCOMP</a>,            <span class="comment">//!&lt; No number of components selected</span>
<a name="l00097"></a><a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8ae3022fa9fbe8d21bc1777f3cd190e0c6">00097</a> <span class="comment"></span>    <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8ae3022fa9fbe8d21bc1777f3cd190e0c6" title="No RNG selected.">NORNG</a>,              <span class="comment">//!&lt; No RNG selected</span>
<a name="l00098"></a><a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8aad77aebcd52dee136217f5536c4d04fa">00098</a> <span class="comment"></span>    <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8aad77aebcd52dee136217f5536c4d04fa" title="PDF need a variable.">NOSAMPLES</a>,          <span class="comment">//!&lt; PDF need a variable</span>
<a name="l00099"></a><a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8ae84e53494919c34919e3614f1647c41a">00099</a> <span class="comment"></span>    <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8ae84e53494919c34919e3614f1647c41a" title="PDF sample space specification incorrect.">INVALIDSAMPLESPACE</a>, <span class="comment">//!&lt; PDF sample space specification incorrect</span>
<a name="l00100"></a><a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8afcaa37d6725306c81daaee00f6867e55">00100</a> <span class="comment"></span>    <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8afcaa37d6725306c81daaee00f6867e55" title="PDF sample space variable specification incorrect.">MALFORMEDSAMPLE</a>,    <span class="comment">//!&lt; PDF sample space variable specification incorrect</span>
<a name="l00101"></a><a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a815c220f90757b039f8f85eee346a4d2">00101</a> <span class="comment"></span>    <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a815c220f90757b039f8f85eee346a4d2" title="PDF sample space bin size specification incorrect.">INVALIDBINSIZE</a>,     <span class="comment">//!&lt; PDF sample space bin size specification incorrect</span>
<a name="l00102"></a><a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a13fd60277779d872349fb4c25daf14a9">00102</a> <span class="comment"></span>    <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a13fd60277779d872349fb4c25daf14a9" title="PDF sample space extent specification incorrect.">INVALIDEXTENT</a>,      <span class="comment">//!&lt; PDF sample space extent specification incorrect</span>
<a name="l00103"></a><a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a454a930fc0522488df21c892fedc1616">00103</a> <span class="comment"></span>    <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a454a930fc0522488df21c892fedc1616" title="PDF sample space extent-pair in non-increasing order.">EXTENTLOWER</a>,        <span class="comment">//!&lt; PDF sample space extent-pair in non-increasing order</span>
<a name="l00104"></a><a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a5b747f26362c8a2575391a4cb0d905ab">00104</a> <span class="comment"></span>    <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a5b747f26362c8a2575391a4cb0d905ab" title="PDF sample space bin size required.">NOBINS</a>,             <span class="comment">//!&lt; PDF sample space bin size required</span>
<a name="l00105"></a><a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8ad22a642552616b8063d9e3a16e7165bd">00105</a> <span class="comment"></span>    <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8ad22a642552616b8063d9e3a16e7165bd" title="PDF sample space bin size incorrect.">ZEROBINSIZE</a>,        <span class="comment">//!&lt; PDF sample space bin size incorrect</span>
<a name="l00106"></a><a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a251961498650f688d984e63f4bdbccab">00106</a> <span class="comment"></span>    <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a251961498650f688d984e63f4bdbccab" title="PDF sample space dimension too large.">MAXSAMPLES</a>,         <span class="comment">//!&lt; PDF sample space dimension too large</span>
<a name="l00107"></a><a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a4ba58143df09d07f85cf924fad16b1b6">00107</a> <span class="comment"></span>    <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a4ba58143df09d07f85cf924fad16b1b6" title="PDF sample space bin sizes too many.">MAXBINSIZES</a>,        <span class="comment">//!&lt; PDF sample space bin sizes too many</span>
<a name="l00108"></a><a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8ad0d07b609d00be7ee5d505be32d752cb">00108</a> <span class="comment"></span>    <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8ad0d07b609d00be7ee5d505be32d752cb" title="PDF sample space extent-pairs too many.">MAXEXTENTS</a>,         <span class="comment">//!&lt; PDF sample space extent-pairs too many</span>
<a name="l00109"></a><a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8af8436b97256da1817ede388752c61579">00109</a> <span class="comment"></span>    <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8af8436b97256da1817ede388752c61579" title="PDF sample space variables unequal to number of bins.">BINSIZES</a>,           <span class="comment">//!&lt; PDF sample space variables unequal to number of bins</span>
<a name="l00110"></a><a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a43b8a8ece988cd158c55fef49a4ba5be">00110</a> <span class="comment"></span>    <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a43b8a8ece988cd158c55fef49a4ba5be" title="PDF specification syntax error.">PDF</a>,                <span class="comment">//!&lt; PDF specification syntax error</span>
<a name="l00111"></a><a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a9d439db1ff93aa2880f0d6962d3f559e">00111</a> <span class="comment"></span>    <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a9d439db1ff93aa2880f0d6962d3f559e" title="PDF identifier already defined.">PDFEXISTS</a>,          <span class="comment">//!&lt; PDF identifier already defined</span>
<a name="l00112"></a><a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a4e637b887f7afa8f133d52671d076eee">00112</a> <span class="comment"></span>    <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a4e637b887f7afa8f133d52671d076eee" title="Floating point precision specification incorrect.">BADPRECISION</a>,       <span class="comment">//!&lt; Floating point precision specification incorrect</span>
<a name="l00113"></a><a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8abb45f410bc513749b006bec09d8f24aa">00113</a> <span class="comment"></span>    <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8abb45f410bc513749b006bec09d8f24aa" title="Floating point precision specification out of bounds.">PRECISIONBOUNDS</a>,    <span class="comment">//!&lt; Floating point precision specification out of bounds</span>
<a name="l00114"></a><a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a7beb30526fd80ffe7829036459a42740">00114</a> <span class="comment"></span>    <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a7beb30526fd80ffe7829036459a42740" title="Unfinished block.">UNFINISHED</a>,         <span class="comment">//!&lt; Unfinished block</span>
<a name="l00115"></a><a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8ad6a56b571b4951a0b61b83299f7b7601">00115</a> <span class="comment"></span>    <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8ad6a56b571b4951a0b61b83299f7b7601">CHARMARG</a> };         <span class="comment">//!&lt; Argument inteded for the Charm++ runtime system</span>
<a name="l00116"></a>00116 <span class="comment"></span><span class="comment"></span>
<a name="l00117"></a>00117 <span class="comment">  //! Associate parser errors to error messages</span>
<a name="l00118"></a>00118 <span class="comment"></span>  <span class="keyword">static</span> <span class="keyword">const</span> std::map&lt; MsgKey, std::string &gt; <a class="code" href="namespacetk_1_1grm.html#a1708d508a10590fee9a3f8fb621f64ec" title="Associate parser errors to error messages.">message</a>( {
<a name="l00119"></a>00119     { <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a44caa25e7ef241394a696329fd872765" title="Unknown keyword.">MsgKey::KEYWORD</a>, <span class="stringliteral">&quot;Unknown keyword or keyword unrecognized in this &quot;</span>
<a name="l00120"></a>00120       <span class="stringliteral">&quot;block.&quot;</span> },
<a name="l00121"></a>00121     { <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a11f443b3aa706121791c29ca07d8bc35" title="Unknown Term in a Moment.">MsgKey::MOMENT</a>, <span class="stringliteral">&quot;Unknown term in moment.&quot;</span> },
<a name="l00122"></a>00122     { <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8ac11c16e0c25418f529e8d06119e78097" title="String must be double-quoted.">MsgKey::QUOTED</a>, <span class="stringliteral">&quot;Must be double-quoted.&quot;</span> },
<a name="l00123"></a>00123     { <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8ab6d7e7c9f0567c0debd7050e259ca76d" title="Unknown value in list.">MsgKey::LIST</a>, <span class="stringliteral">&quot;Unknown value in list.&quot;</span> },
<a name="l00124"></a>00124     { <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a5b2e6d2320e1382baf87f10b3dc3fc9c" title="Alias keyword too long.">MsgKey::ALIAS</a>, <span class="stringliteral">&quot;Alias keyword too long. Use either a full-length keyword &quot;</span>
<a name="l00125"></a>00125       <span class="stringliteral">&quot;with double-hyphens, e.g., --keyword, or its alias, a single character, &quot;</span>
<a name="l00126"></a>00126       <span class="stringliteral">&quot;with a single hyphen, e.g., -k.&quot;</span> },
<a name="l00127"></a>00127     { <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8ad67b13891add9ac8c072692edb515855" title="Required field missing.">MsgKey::MISSING</a>, <span class="stringliteral">&quot;Required field missing.&quot;</span> },
<a name="l00128"></a>00128     { <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a90c9f12ef4e01eebb9744a9804014942" title="Premature end of line.">MsgKey::PREMATURE</a>, <span class="stringliteral">&quot;Premature end of line.&quot;</span> },
<a name="l00129"></a>00129     { <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8aded9518443effe497ef2c8e8829f2ab2" title="Option not supported.">MsgKey::UNSUPPORTED</a>, <span class="stringliteral">&quot;Option not supported.&quot;</span> },
<a name="l00130"></a>00130     { <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a492099849097caa604e3de14a342bd04" title="Option does not exist.">MsgKey::NOOPTION</a>, <span class="stringliteral">&quot;Option does not exist.&quot;</span> },
<a name="l00131"></a>00131     { <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a09f86b84bd40fadcf5a1e173e63a18a2" title="Option not selected upstream.">MsgKey::NOTSELECTED</a>, <span class="stringliteral">&quot;Option is not among the selected ones. The keyword &quot;</span>
<a name="l00132"></a>00132       <span class="stringliteral">&quot;here is appropriate, but in order to use this keyword in this context, &quot;</span>
<a name="l00133"></a>00133       <span class="stringliteral">&quot;the option must be selected upstream.&quot;</span> },
<a name="l00134"></a>00134     { <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a2968ef086326862aabd43b079da1c518" title="Variable already used.">MsgKey::EXISTS</a>, <span class="stringliteral">&quot;Dependent variable already used.&quot;</span> },
<a name="l00135"></a>00135     { <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a8e5972b53dcde3ec6238b7d6c8315ada" title="Dependent variable has not been previously selected.">MsgKey::NOSUCHDEPVAR</a>, <span class="stringliteral">&quot;Dependent variable not selected. To request a &quot;</span>
<a name="l00136"></a>00136       <span class="stringliteral">&quot;statistic or PDF involving this variable, or use this variable as a &quot;</span>
<a name="l00137"></a>00137       <span class="stringliteral">&quot;coefficients policy variable, an equation must be specified &quot;</span>
<a name="l00138"></a>00138       <span class="stringliteral">&quot;upstream in the control file assigning this variable to an &quot;</span>
<a name="l00139"></a>00139       <span class="stringliteral">&quot;equation to be integrated using the depvar keyword.&quot;</span> },
<a name="l00140"></a>00140     { <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a472f55b1579c5a1910ae21bc79aa7cbd" title="Variable must be alphanumeric.">MsgKey::NOTALPHA</a>, <span class="stringliteral">&quot;Variable not alphanumeric.&quot;</span> },
<a name="l00141"></a>00141     { <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a49476752860f376d78c219d95e43d2d8" title="Height-sum of spikes does not add up to unity.">MsgKey::HEIGHTSPIKES</a>, <span class="stringliteral">&quot;The sum of all spike heights given in the &quot;</span>
<a name="l00142"></a>00142       <span class="stringliteral">&quot;spike...end block does not add up to unity. A spike...end block &quot;</span>
<a name="l00143"></a>00143       <span class="stringliteral">&quot;must contain an even number of real numbers, where every odd one is the &quot;</span>
<a name="l00144"></a>00144       <span class="stringliteral">&quot;sample space position of a spike followed by the spike height &quot;</span>
<a name="l00145"></a>00145       <span class="stringliteral">&quot;specifying the relative probability of the spike. Since the spike &quot;</span>
<a name="l00146"></a>00146       <span class="stringliteral">&quot;heights are probabilities relative to unity, they must sum to one.&quot;</span> },
<a name="l00147"></a>00147     { <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a824fcd1c511c8c1eefd309414dcb3bfc" title="Dependent variable has not been specified.">MsgKey::NODEPVAR</a>, <span class="stringliteral">&quot;Dependent variable not specified within the block &quot;</span>
<a name="l00148"></a>00148       <span class="stringliteral">&quot;preceding this position. This is mandatory for the preceding block. Use &quot;</span>
<a name="l00149"></a>00149       <span class="stringliteral">&quot;the keyword &#39;depvar&#39; to specify the dependent variable.&quot;</span> },
<a name="l00150"></a>00150     { <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a724ba9fa5b04a8a80ee55d0163ed054f" title="No number of components selected.">MsgKey::NONCOMP</a>, <span class="stringliteral">&quot;The number of components has not specified within the &quot;</span>
<a name="l00151"></a>00151       <span class="stringliteral">&quot;block preceding this position. This is mandatory for the preceding &quot;</span>
<a name="l00152"></a>00152       <span class="stringliteral">&quot;block. Use the keyword &#39;ncomp&#39; to specify the number of components.&quot;</span> },
<a name="l00153"></a>00153     { <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8ae3022fa9fbe8d21bc1777f3cd190e0c6" title="No RNG selected.">MsgKey::NORNG</a>, <span class="stringliteral">&quot;The random number generator has not specified within the &quot;</span>
<a name="l00154"></a>00154       <span class="stringliteral">&quot;block preceding this position. This is mandatory for the preceding &quot;</span>
<a name="l00155"></a>00155       <span class="stringliteral">&quot;block. Use the keyword &#39;rng&#39; to specify the random number generator.&quot;</span> },
<a name="l00156"></a>00156     { <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a629b2d189b5bfc8d7b4249de406c5792" title="No initialization policy selected.">MsgKey::NOINIT</a>, <span class="stringliteral">&quot;No initialization policy has been specified within the &quot;</span>
<a name="l00157"></a>00157       <span class="stringliteral">&quot;block preceding this position. This is mandatory for the preceding &quot;</span>
<a name="l00158"></a>00158       <span class="stringliteral">&quot;block. Use the keyword &#39;init&#39; to specify an initialization policy.&quot;</span> },
<a name="l00159"></a>00159     { <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8ae079d545a224bcc061f1542e7e8c73a8" title="No test problem type selected.">MsgKey::NOPROBLEM</a>, <span class="stringliteral">&quot;No test problem has been specified within the &quot;</span>
<a name="l00160"></a>00160       <span class="stringliteral">&quot;block preceding this position. This is mandatory for the preceding &quot;</span>
<a name="l00161"></a>00161       <span class="stringliteral">&quot;block. Use the keyword &#39;problem&#39; to specify a test problem.&quot;</span> },
<a name="l00162"></a>00162     { <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8ae957443afa58b57eb6ad260cb5743adc" title="No coefficients policy selected.">MsgKey::NOCOEFF</a>, <span class="stringliteral">&quot;No coefficients policy has been specified within the &quot;</span>
<a name="l00163"></a>00163       <span class="stringliteral">&quot;block preceding this position. This is mandatory for the preceding &quot;</span>
<a name="l00164"></a>00164       <span class="stringliteral">&quot;block. Use the keyword &#39;coeff&#39; to specify an coefficients policy.&quot;</span> },
<a name="l00165"></a>00165     { <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a76aed51984d3d7a7820af21c3c1af1e5" title="No icdelta...end block when initpolicy = jointdelta.">MsgKey::NODELTA</a>, <span class="stringliteral">&quot;No icdelta...end block with at least a single &quot;</span>
<a name="l00166"></a>00166       <span class="stringliteral">&quot;spike...end block has been specified within the block preceding this &quot;</span>
<a name="l00167"></a>00167       <span class="stringliteral">&quot;position. This is mandatory for the preceding block if the joint delta &quot;</span>
<a name="l00168"></a>00168       <span class="stringliteral">&quot;initpolicy is selected. Pick an initpolicy different than jointdelta &quot;</span>
<a name="l00169"></a>00169       <span class="stringliteral">&quot;(using keyword &#39;init&#39;) or specify at least a single spike...end block &quot;</span>
<a name="l00170"></a>00170       <span class="stringliteral">&quot;(within an icdelta...end block).&quot;</span> },
<a name="l00171"></a>00171     { <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8aa7facd6c043e37186ce57b5ad54e4aaf" title="No icbeta...end block when initpolicy = jointbeta.">MsgKey::NOBETA</a>, <span class="stringliteral">&quot;No beta...end block with at least a single &quot;</span>
<a name="l00172"></a>00172       <span class="stringliteral">&quot;betapdf...end block has been specified within the block preceding this &quot;</span>
<a name="l00173"></a>00173       <span class="stringliteral">&quot;position. This is mandatory for the preceding block if jointbeta &quot;</span>
<a name="l00174"></a>00174       <span class="stringliteral">&quot;initpolicy is selected. Pick an initpolicy different than jointbeta &quot;</span>
<a name="l00175"></a>00175       <span class="stringliteral">&quot;(using keyword &#39;init&#39;) or specify at least a single betapdf...end block &quot;</span>
<a name="l00176"></a>00176       <span class="stringliteral">&quot;(within a icbeta...end block).&quot;</span> },
<a name="l00177"></a>00177     { <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8abd57100130c075df8283623a930235b8" title="Incomplete spikes block.">MsgKey::ODDSPIKES</a>, <span class="stringliteral">&quot;Incomplete spike...end block has been specified &quot;</span>
<a name="l00178"></a>00178       <span class="stringliteral">&quot;within the  block preceding this position. A spike...end block &quot;</span>
<a name="l00179"></a>00179       <span class="stringliteral">&quot;must contain an even number of real numbers, where every odd one is the &quot;</span>
<a name="l00180"></a>00180       <span class="stringliteral">&quot;sample space position of a spike followed by the spike height &quot;</span>
<a name="l00181"></a>00181       <span class="stringliteral">&quot;specifying the relative probability of the spike.&quot;</span> },
<a name="l00182"></a>00182     { <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a3215fc85dd4e5a7fe6ebd6fb26e4d515" title="Wrong number of parameters configuring a beta pdf.">MsgKey::WRONGBETAPDF</a>, <span class="stringliteral">&quot;Wrong number of beta distribution parameters. A &quot;</span>
<a name="l00183"></a>00183       <span class="stringliteral">&quot;beta distribution must be configured by exactly four real numbers in a &quot;</span>
<a name="l00184"></a>00184       <span class="stringliteral">&quot;betapdf...end block.&quot;</span> },
<a name="l00185"></a>00185     { <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a0155acc6f48c59b108a5a14217eeedbc" title="Statistic need a variable.">MsgKey::NOTERMS</a>, <span class="stringliteral">&quot;Statistic requires at least one variable.&quot;</span> },
<a name="l00186"></a>00186     { <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8aad77aebcd52dee136217f5536c4d04fa" title="PDF need a variable.">MsgKey::NOSAMPLES</a>, <span class="stringliteral">&quot;PDF requires at least one sample space variable.&quot;</span> },
<a name="l00187"></a>00187     { <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8ae84e53494919c34919e3614f1647c41a" title="PDF sample space specification incorrect.">MsgKey::INVALIDSAMPLESPACE</a>, <span class="stringliteral">&quot;PDF sample space specification incorrect. A &quot;</span>
<a name="l00188"></a>00188       <span class="stringliteral">&quot;non-empty list of sample space variables, must be followed by a &quot;</span>
<a name="l00189"></a>00189       <span class="stringliteral">&quot;colon, followed by a non-empty list of bin sizes (reals numbers), e.g., &quot;</span>
<a name="l00190"></a>00190       <span class="stringliteral">&quot;\&quot;(x y : 0.1 0.2)\&quot;&quot;</span> },
<a name="l00191"></a>00191     { <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8afcaa37d6725306c81daaee00f6867e55" title="PDF sample space variable specification incorrect.">MsgKey::MALFORMEDSAMPLE</a>, <span class="stringliteral">&quot;A PDF sample space variable must be a single &quot;</span>
<a name="l00192"></a>00192       <span class="stringliteral">&quot;upper or lowercase letter optionally followed by an integer. &quot;</span>
<a name="l00193"></a>00193       <span class="stringliteral">&quot;Multiple variables, specifying a multi-dimensional sample space, must &quot;</span>
<a name="l00194"></a>00194       <span class="stringliteral">&quot;be separated by white spaces.&quot;</span> },
<a name="l00195"></a>00195     { <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a815c220f90757b039f8f85eee346a4d2" title="PDF sample space bin size specification incorrect.">MsgKey::INVALIDBINSIZE</a>, <span class="stringliteral">&quot;PDF sample space bin size(s) specification &quot;</span>
<a name="l00196"></a>00196       <span class="stringliteral">&quot;incorrect. A non-empty list of sample space variables, must be followed &quot;</span>
<a name="l00197"></a>00197       <span class="stringliteral">&quot;by a colon, followed by a non-empty list of bin sizes (real numbers), &quot;</span>
<a name="l00198"></a>00198       <span class="stringliteral">&quot;e.g., \&quot;(x y : 0.1 0.2)\&quot;&quot;</span> },
<a name="l00199"></a>00199     { <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a13fd60277779d872349fb4c25daf14a9" title="PDF sample space extent specification incorrect.">MsgKey::INVALIDEXTENT</a>, <span class="stringliteral">&quot;PDF sample space extents specification &quot;</span>
<a name="l00200"></a>00200       <span class="stringliteral">&quot;incorrect. The semi-colon following the list of bin sizes, must be &quot;</span>
<a name="l00201"></a>00201       <span class="stringliteral">&quot;followed by a non-empty list of extents (real numbers), e.g., \&quot;(x y : &quot;</span>
<a name="l00202"></a>00202       <span class="stringliteral">&quot;0.1 0.2 ; 0.0 1.0 0.2 0.9)\&quot;. The number of real numbers representing &quot;</span>
<a name="l00203"></a>00203       <span class="stringliteral">&quot;the sample space extents must be exactly twice the number of sample &quot;</span>
<a name="l00204"></a>00204       <span class="stringliteral">&quot;space dimensions, i.e., in this 2D example 4 (2 pairs).&quot;</span> },
<a name="l00205"></a>00205     { <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a454a930fc0522488df21c892fedc1616" title="PDF sample space extent-pair in non-increasing order.">MsgKey::EXTENTLOWER</a>, <span class="stringliteral">&quot;PDF sample space extents must be a pair of a &quot;</span>
<a name="l00206"></a>00206       <span class="stringliteral">&quot;smaller and a larger numerical value, in that order.&quot;</span> },
<a name="l00207"></a>00207     { <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a5b747f26362c8a2575391a4cb0d905ab" title="PDF sample space bin size required.">MsgKey::NOBINS</a>, <span class="stringliteral">&quot;Need at least one sample space bin size, followed by a &quot;</span>
<a name="l00208"></a>00208       <span class="stringliteral">&quot;colon, in a PDF specification.&quot;</span> },
<a name="l00209"></a>00209     { <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8ad22a642552616b8063d9e3a16e7165bd" title="PDF sample space bin size incorrect.">MsgKey::ZEROBINSIZE</a>, <span class="stringliteral">&quot;Sample space bin size must be a real number and &quot;</span>
<a name="l00210"></a>00210       <span class="stringliteral">&quot;greater than zero.&quot;</span> },
<a name="l00211"></a>00211     { <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a251961498650f688d984e63f4bdbccab" title="PDF sample space dimension too large.">MsgKey::MAXSAMPLES</a>, <span class="stringliteral">&quot;The maximum number of sample space variables for a &quot;</span>
<a name="l00212"></a>00212       <span class="stringliteral">&quot;joint PDF is 3.&quot;</span> },
<a name="l00213"></a>00213     { <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a4ba58143df09d07f85cf924fad16b1b6" title="PDF sample space bin sizes too many.">MsgKey::MAXBINSIZES</a>, <span class="stringliteral">&quot;The maximum number of bins sizes for a joint PDF &quot;</span>
<a name="l00214"></a>00214       <span class="stringliteral">&quot;is 3.&quot;</span>},
<a name="l00215"></a>00215     { <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8ad0d07b609d00be7ee5d505be32d752cb" title="PDF sample space extent-pairs too many.">MsgKey::MAXEXTENTS</a>, <span class="stringliteral">&quot;The maximum number of optional sample space extents &quot;</span>
<a name="l00216"></a>00216       <span class="stringliteral">&quot;for a joint PDF is 3 pairs.&quot;</span>},
<a name="l00217"></a>00217     { <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8af8436b97256da1817ede388752c61579" title="PDF sample space variables unequal to number of bins.">MsgKey::BINSIZES</a>, <span class="stringliteral">&quot;The number of sample space variables for a PDF must &quot;</span>
<a name="l00218"></a>00218       <span class="stringliteral">&quot;equal the number of bin sizes given.&quot;</span> },
<a name="l00219"></a>00219     { <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a43b8a8ece988cd158c55fef49a4ba5be" title="PDF specification syntax error.">MsgKey::PDF</a>, <span class="stringliteral">&quot;Syntax error while parsing PDF specification.&quot;</span> },
<a name="l00220"></a>00220     { <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a9d439db1ff93aa2880f0d6962d3f559e" title="PDF identifier already defined.">MsgKey::PDFEXISTS</a>, <span class="stringliteral">&quot;PDF already exists. PDF identifiers must be unique.&quot;</span>},
<a name="l00221"></a>00221     { <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a4e637b887f7afa8f133d52671d076eee" title="Floating point precision specification incorrect.">MsgKey::BADPRECISION</a>, <span class="stringliteral">&quot;Precision specification invalid. It should be a &quot;</span>
<a name="l00222"></a>00222       <span class="stringliteral">&quot;positive integer or the word \&#39;max\&#39;, selecting the maximum number of &quot;</span>
<a name="l00223"></a>00223       <span class="stringliteral">&quot;digits for the underyling floating point type.&quot;</span>},
<a name="l00224"></a>00224     { <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8abb45f410bc513749b006bec09d8f24aa" title="Floating point precision specification out of bounds.">MsgKey::PRECISIONBOUNDS</a>, <span class="stringliteral">&quot;Precision specification out of bounds. It &quot;</span>
<a name="l00225"></a>00225       <span class="stringliteral">&quot;should be a positive integer between 1 and the maximum number of digits &quot;</span>
<a name="l00226"></a>00226       <span class="stringliteral">&quot;for the underyling floating point type on the machine. (Set \&#39;max\&#39; for &quot;</span>
<a name="l00227"></a>00227       <span class="stringliteral">&quot;the maximum.)&quot;</span>},
<a name="l00228"></a>00228     { <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8a7beb30526fd80ffe7829036459a42740" title="Unfinished block.">MsgKey::UNFINISHED</a>, <span class="stringliteral">&quot;Block started but not finished by the &#39;end&#39; &quot;</span>
<a name="l00229"></a>00229       <span class="stringliteral">&quot;keyword.&quot;</span> },
<a name="l00230"></a>00230     { <a class="code" href="namespacetk_1_1grm.html#a67ae826c4edeadbc0ec01bcc0f3264c8ad6a56b571b4951a0b61b83299f7b7601">MsgKey::CHARMARG</a>, <span class="stringliteral">&quot;Arguments starting with &#39;+&#39; are assumed to be inteded &quot;</span>
<a name="l00231"></a>00231       <span class="stringliteral">&quot;for the Charm++ runtime system. Did you forget to prefix the command &quot;</span>
<a name="l00232"></a>00232       <span class="stringliteral">&quot;line with charmrun? If this warning persists even after running with &quot;</span>
<a name="l00233"></a>00233       <span class="stringliteral">&quot;charmrun, then Charm++ does not understand it either. See the Charm++ &quot;</span>
<a name="l00234"></a>00234       <span class="stringliteral">&quot;manual at http://charm.cs.illinois.edu/manuals/html/charm++/&quot;</span>
<a name="l00235"></a>00235       <span class="stringliteral">&quot;manual.html.&quot;</span> }
<a name="l00236"></a>00236   } );
<a name="l00237"></a>00237 <span class="comment"></span>
<a name="l00238"></a>00238 <span class="comment">  //! \brief Parser error and warning message handler.</span>
<a name="l00239"></a>00239 <span class="comment">  //! \details This function is used to associated and dispatch an error or a</span>
<a name="l00240"></a>00240 <span class="comment">  //!   warning during parsing. After finding the error message corresponding to</span>
<a name="l00241"></a>00241 <span class="comment">  //!   a key, it pushes back the message to a std::vector of std::string, which</span>
<a name="l00242"></a>00242 <span class="comment">  //!   then will be diagnosed later by tk::FileParser::diagnostics. The</span>
<a name="l00243"></a>00243 <span class="comment">  //!   template arguments define (1) the grammar stack (Stack, a tagged tuple)</span>
<a name="l00244"></a>00244 <span class="comment">  //!   to operate on, (2) the message type (error or warning), and (3) the</span>
<a name="l00245"></a>00245 <span class="comment">  //!   message key used to look up the error message associated with the key.</span>
<a name="l00246"></a>00246 <span class="comment">  //! \param[inout] stack Grammar stack (a tagged tuple) to operate on</span>
<a name="l00247"></a>00247 <span class="comment">  //! \param[in] value Last parsed token (can be empty, depending on what</span>
<a name="l00248"></a>00248 <span class="comment">  //!   context this function gets called.</span>
<a name="l00249"></a>00249 <span class="comment">  //! \author J. Bakosi</span>
<a name="l00250"></a>00250 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class</span> Stack, MsgType type, MsgKey key &gt;
<a name="l00251"></a><a class="code" href="namespacetk_1_1grm.html#a854479484c0cf43370a9fbc4c3821dcc">00251</a>   <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="namespacetk_1_1grm.html#a854479484c0cf43370a9fbc4c3821dcc" title="Parser error and warning message handler.">Message</a>( Stack&amp; stack, <span class="keyword">const</span> std::string&amp; value ) {
<a name="l00252"></a>00252     <span class="keyword">const</span> <span class="keyword">auto</span>&amp; msg = <a class="code" href="namespacetk_1_1grm.html#a1708d508a10590fee9a3f8fb621f64ec" title="Associate parser errors to error messages.">message</a>.find(key);
<a name="l00253"></a>00253     <span class="keywordflow">if</span> (msg != <a class="code" href="namespacetk_1_1grm.html#a1708d508a10590fee9a3f8fb621f64ec" title="Associate parser errors to error messages.">message</a>.end()) {
<a name="l00254"></a>00254       std::stringstream ss;
<a name="l00255"></a>00255       <span class="keyword">const</span> std::string typestr( type == <a class="code" href="namespacetk_1_1grm.html#aaea8b8be7c61e0bfb422394a315b2b64a2524effb18ba47fd4b68e016bc4618a5">MsgType::ERROR</a> ? <span class="stringliteral">&quot;Error&quot;</span> : <span class="stringliteral">&quot;Warning&quot;</span> );
<a name="l00256"></a>00256       <span class="keywordflow">if</span> (!value.empty()) {
<a name="l00257"></a>00257         ss &lt;&lt; typestr &lt;&lt; <span class="stringliteral">&quot; while parsing &#39;&quot;</span> &lt;&lt; value &lt;&lt; <span class="stringliteral">&quot;&#39; at &quot;</span>
<a name="l00258"></a>00258            &lt;&lt; stack.location() &lt;&lt; <span class="stringliteral">&quot;. &quot;</span> &lt;&lt; msg-&gt;second;
<a name="l00259"></a>00259       } <span class="keywordflow">else</span> {
<a name="l00260"></a>00260         ss &lt;&lt; typestr &lt;&lt; <span class="stringliteral">&quot; while parsing at &quot;</span> &lt;&lt; stack.location() &lt;&lt; <span class="stringliteral">&quot;. &quot;</span>
<a name="l00261"></a>00261            &lt;&lt; msg-&gt;second;
<a name="l00262"></a>00262       }
<a name="l00263"></a>00263       stack.template push_back&lt; tag::error &gt;( ss.str() );
<a name="l00264"></a>00264     } <span class="keywordflow">else</span> {
<a name="l00265"></a>00265       stack.template push_back&lt; tag::error &gt;
<a name="l00266"></a>00266         ( std::string(<span class="stringliteral">&quot;Unknown parser &quot;</span>) + 
<a name="l00267"></a>00267           (type == <a class="code" href="namespacetk_1_1grm.html#aaea8b8be7c61e0bfb422394a315b2b64a2524effb18ba47fd4b68e016bc4618a5">MsgType::ERROR</a> ? <span class="stringliteral">&quot;error&quot;</span> : <span class="stringliteral">&quot;warning&quot;</span> ) +
<a name="l00268"></a>00268           <span class="stringliteral">&quot; with no location information.&quot;</span> );
<a name="l00269"></a>00269     }
<a name="l00270"></a>00270   }
<a name="l00271"></a>00271 <span class="comment"></span>
<a name="l00272"></a>00272 <span class="comment">  //! \brief Compile-time test functor verifying that type U is a keyword</span>
<a name="l00273"></a>00273 <span class="comment">  //! \details This functor is used for triggering a compiler error if any of</span>
<a name="l00274"></a>00274 <span class="comment">  //!   the expected option values is not in the keywords pool of the grammar.</span>
<a name="l00275"></a>00275 <span class="comment">  //!   It is used inside of a boost::mpl::for_each to run a compile-time loop</span>
<a name="l00276"></a>00276 <span class="comment">  //!   over an MPL sequence, e.g., a vector, which verifies that each type in</span>
<a name="l00277"></a>00277 <span class="comment">  //!   the vector is a valid keyword that defines the type &#39;pegtl_string&#39;.</span>
<a name="l00278"></a>00278 <span class="comment">  //!  \see kw::keyword in Control/Keyword.h</span>
<a name="l00279"></a>00279 <span class="comment">  //!  \see e.g. store_option</span>
<a name="l00280"></a>00280 <span class="comment"></span>  <span class="comment">// \author J. Bakosi</span>
<a name="l00281"></a>00281   <span class="keyword">template</span>&lt; <span class="keyword">template</span>&lt; <span class="keyword">class</span> &gt; <span class="keyword">class </span>use &gt;
<a name="l00282"></a><a class="code" href="structtk_1_1grm_1_1is__keyword.html">00282</a>   <span class="keyword">struct </span><a class="code" href="structtk_1_1grm_1_1is__keyword.html" title="Compile-time test functor verifying that type U is a keyword.">is_keyword</a> {
<a name="l00283"></a><a class="code" href="structtk_1_1grm_1_1is__keyword.html#ab0f3fe9d6b2dd79d9066a101ae2b8e02">00283</a>     <span class="keyword">template</span>&lt; <span class="keyword">typename</span> U &gt; <span class="keywordtype">void</span> <a class="code" href="structtk_1_1grm_1_1is__keyword.html#ab0f3fe9d6b2dd79d9066a101ae2b8e02">operator()</a>( U ) {
<a name="l00284"></a>00284       <span class="keyword">using</span> kw = <span class="keyword">typename</span> use&lt; U &gt;::pegtl_string;
<a name="l00285"></a>00285     }
<a name="l00286"></a>00286   };
<a name="l00287"></a>00287 <span class="comment"></span>
<a name="l00288"></a>00288 <span class="comment">  //! \brief Put option (i.e., a tk::Toggle) in grammar state (or stack) at a</span>
<a name="l00289"></a>00289 <span class="comment">  //!   position given by tags</span>
<a name="l00290"></a>00290 <span class="comment">  //! \details This function is used to store an option (an object deriving from</span>
<a name="l00291"></a>00291 <span class="comment">  //!   tk::Toggle) into the grammar stack. See walker::ctr::DiffEq for an</span>
<a name="l00292"></a>00292 <span class="comment">  //!   example specialization of tk::Toggle to see how an option is created</span>
<a name="l00293"></a>00293 <span class="comment">  //!   from tk::Toggle.) The grammar stack is a hiearchical tagged tuple and</span>
<a name="l00294"></a>00294 <span class="comment">  //!   the variadic list of template arguments, tags..., are used to specify</span>
<a name="l00295"></a>00295 <span class="comment">  //!   a series tags (empty structs, see Control/Tags.h) addressing a</span>
<a name="l00296"></a>00296 <span class="comment">  //!   particular field of the tagged tuple, i.e., one tag for every additional</span>
<a name="l00297"></a>00297 <span class="comment">  //!   depth level.</span>
<a name="l00298"></a>00298 <span class="comment">  //! \param[inout] stack Grammar stack (a tagged tuple) to operate on</span>
<a name="l00299"></a>00299 <span class="comment">  //! \param[in] value Last parsed token</span>
<a name="l00300"></a>00300 <span class="comment">  //! \param[in] defaults Reference to a copy of the full grammar stack at the</span>
<a name="l00301"></a>00301 <span class="comment">  //!   initial state, i.e., containing the defaults for all of its fields. This</span>
<a name="l00302"></a>00302 <span class="comment">  //!   is used to detect if the user wants to overwrite an option value that</span>
<a name="l00303"></a>00303 <span class="comment">  //!   has already been set differently from the default</span>
<a name="l00304"></a>00304 <span class="comment">  //! \author J. Bakosi</span>
<a name="l00305"></a>00305 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class</span> Stack, <span class="keyword">template</span>&lt; <span class="keyword">class</span> &gt; <span class="keyword">class </span>use, <span class="keyword">class </span>Option,
<a name="l00306"></a>00306             <span class="keyword">class </span>DefaultStack, <span class="keyword">class</span>... tags &gt;
<a name="l00307"></a><a class="code" href="namespacetk_1_1grm.html#a9131f0a09dab5d6bd4c8d84d8339e5e4">00307</a>   <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="namespacetk_1_1grm.html#a9131f0a09dab5d6bd4c8d84d8339e5e4" title="Put option (i.e., a tk::Toggle) in grammar state (or stack) at a position given by tags...">store_option</a>( Stack&amp; stack,
<a name="l00308"></a>00308                             <span class="keyword">const</span> std::string&amp; value,
<a name="l00309"></a>00309                             <span class="keyword">const</span> DefaultStack&amp; defaults ) {
<a name="l00310"></a>00310     Option opt;
<a name="l00311"></a>00311     <span class="keywordflow">if</span> (opt.exist(value)) {
<a name="l00312"></a>00312       <span class="comment">// Emit warning on overwriting a non-default option value. This is</span>
<a name="l00313"></a>00313       <span class="comment">// slightly inelegant. To be more elegant, we could simply call Message()</span>
<a name="l00314"></a>00314       <span class="comment">// here, but the warning message can be more customized here (inside of</span>
<a name="l00315"></a>00315       <span class="comment">// this function) and thus produces a more user-friendly message, compared</span>
<a name="l00316"></a>00316       <span class="comment">// to a static message that Message() operates with due to its generic</span>
<a name="l00317"></a>00317       <span class="comment">// nature. Instead, we emit this more user-friendly message here</span>
<a name="l00318"></a>00318       <span class="comment">// (during parsing), instead of after parsing as part of the final parser-</span>
<a name="l00319"></a>00319       <span class="comment">// diagnostics. We still provide location information here though.</span>
<a name="l00320"></a>00320       <span class="keywordflow">if</span> (stack.template get&lt; tags... &gt;() != opt.value( value ) &amp;&amp;
<a name="l00321"></a>00321           stack.template <span class="keyword">get</span>&lt; tags... &gt;() != defaults.template get&lt; tags... &gt;())
<a name="l00322"></a>00322         <a class="code" href="namespacetk_1_1grm.html#ab83bd20afe2c1386bf4e95bd0e86776e">g_print</a> &lt;&lt; <span class="stringliteral">&quot;\n&gt;&gt;&gt; WARNING: Multiple definitions for &#39;&quot;</span>
<a name="l00323"></a>00323                 &lt;&lt; opt.group() &lt;&lt; <span class="stringliteral">&quot;&#39; option. Overwriting &#39;&quot;</span>
<a name="l00324"></a>00324                 &lt;&lt; opt.name( stack.template get&lt; tags... &gt;() ) &lt;&lt; <span class="stringliteral">&quot;&#39; with &#39;&quot;</span>
<a name="l00325"></a>00325                 &lt;&lt; opt.name( opt.value( value ) ) &lt;&lt; <span class="stringliteral">&quot;&#39; at &quot;</span>
<a name="l00326"></a>00326                 &lt;&lt; stack.location() &lt;&lt; <span class="stringliteral">&quot;.\n\n&quot;</span>;
<a name="l00327"></a>00327       stack.template <span class="keyword">set</span>&lt; tags... &gt;( opt.value( value ) );
<a name="l00328"></a>00328     } <span class="keywordflow">else</span> {
<a name="l00329"></a>00329       Message&lt; Stack, ERROR, MsgKey::NOOPTION &gt;( stack, value );
<a name="l00330"></a>00330     }
<a name="l00331"></a>00331     <span class="comment">// trigger error at compile-time if any of the expected option values</span>
<a name="l00332"></a>00332     <span class="comment">// is not in the keywords pool of the grammar</span>
<a name="l00333"></a>00333     boost::mpl::for_each&lt; typename Option::keywords &gt;( <a class="code" href="structtk_1_1grm_1_1is__keyword.html" title="Compile-time test functor verifying that type U is a keyword.">is_keyword&lt; use &gt;</a>() );
<a name="l00334"></a>00334   }
<a name="l00335"></a>00335 
<a name="l00336"></a>00336   <span class="comment">// Common PEGTL actions (PEGTL actions reused by multiple grammars)</span>
<a name="l00337"></a>00337 <span class="comment"></span>
<a name="l00338"></a>00338 <span class="comment">  //! \brief Error message dispatch</span>
<a name="l00339"></a>00339 <span class="comment">  //! \details This struct and its apply function are used to dispatch an error</span>
<a name="l00340"></a>00340 <span class="comment">  //!   message from the parser. It is simply an interface to Message with a</span>
<a name="l00341"></a>00341 <span class="comment">  //!   specialization of the message type to ERROR. This struct is practically</span>
<a name="l00342"></a>00342 <span class="comment">  //!   used as a functor, i.e., a struct or class that defines the function</span>
<a name="l00343"></a>00343 <span class="comment">  //!   call operator, but instead the function call operator, PEGTL uses the</span>
<a name="l00344"></a>00344 <span class="comment">  //!   apply() member function for the actions. Thus this struct can be passed</span>
<a name="l00345"></a>00345 <span class="comment">  //!   to, i.e., specialize a template, such as tk::grm::unknown, injecting in</span>
<a name="l00346"></a>00346 <span class="comment">  //!   it the desired behavior.</span>
<a name="l00347"></a>00347 <span class="comment">  //! \author J. Bakosi</span>
<a name="l00348"></a>00348 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class</span> Stack, MsgKey key &gt;
<a name="l00349"></a><a class="code" href="structtk_1_1grm_1_1error.html">00349</a>   <span class="keyword">struct </span><a class="code" href="structtk_1_1grm_1_1error.html" title="Error message dispatch.">error</a> : pegtl::<a class="code" href="classpegtl_1_1action__base.html">action_base</a>&lt; error&lt;Stack,key&gt; &gt; {
<a name="l00350"></a><a class="code" href="structtk_1_1grm_1_1error.html#aaed572a5283a14b89ba3d230145d5d10">00350</a>     <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structtk_1_1grm_1_1error.html#aaed572a5283a14b89ba3d230145d5d10">apply</a>(<span class="keyword">const</span> std::string&amp; value, Stack&amp; stack) {
<a name="l00351"></a>00351       Message&lt; Stack, ERROR, key &gt;( stack, value );
<a name="l00352"></a>00352     }
<a name="l00353"></a>00353   };
<a name="l00354"></a>00354 <span class="comment"></span>
<a name="l00355"></a>00355 <span class="comment">  //! \brief Warning message dispatch</span>
<a name="l00356"></a>00356 <span class="comment">  //! \details This struct and its apply function are used to dispatch a warning</span>
<a name="l00357"></a>00357 <span class="comment">  //!   message from the parser. It is simply an interface to Message with a</span>
<a name="l00358"></a>00358 <span class="comment">  //!   specialization of the message type to WARNING. This struct is practically</span>
<a name="l00359"></a>00359 <span class="comment">  //!   used as a functor, i.e., a struct or class that defines the function</span>
<a name="l00360"></a>00360 <span class="comment">  //!   call operator, but instead the function call operator, PEGTL uses the</span>
<a name="l00361"></a>00361 <span class="comment">  //!   apply() member function for the actions. Thus this struct can be passed</span>
<a name="l00362"></a>00362 <span class="comment">  //!   to, i.e., specialize a template, such as tk::grm::unknown, injecting in</span>
<a name="l00363"></a>00363 <span class="comment">  //!   it the desired behavior.</span>
<a name="l00364"></a>00364 <span class="comment">  //! \author J. Bakosi</span>
<a name="l00365"></a>00365 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class</span> Stack, MsgKey key &gt;
<a name="l00366"></a><a class="code" href="structtk_1_1grm_1_1warning.html">00366</a>   <span class="keyword">struct </span><a class="code" href="structtk_1_1grm_1_1warning.html" title="Warning message dispatch.">warning</a> : pegtl::<a class="code" href="classpegtl_1_1action__base.html">action_base</a>&lt; warning&lt;Stack,key&gt; &gt; {
<a name="l00367"></a><a class="code" href="structtk_1_1grm_1_1warning.html#a9c09c67a1a0530542d4b3fcc324e21ff">00367</a>     <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structtk_1_1grm_1_1warning.html#a9c09c67a1a0530542d4b3fcc324e21ff">apply</a>(<span class="keyword">const</span> std::string&amp; value, Stack&amp; stack) {
<a name="l00368"></a>00368       Message&lt; Stack, WARNING, key &gt;( stack, value );
<a name="l00369"></a>00369     }
<a name="l00370"></a>00370   };
<a name="l00371"></a>00371 <span class="comment"></span>
<a name="l00372"></a>00372 <span class="comment">  //! \brief Put value in state at position given by tags without conversion</span>
<a name="l00373"></a>00373 <span class="comment">  //! \details This struct and its apply function are used as a functor-like</span>
<a name="l00374"></a>00374 <span class="comment">  //!    wrapper for calling the set member function of the underlying grammar</span>
<a name="l00375"></a>00375 <span class="comment">  //!    stack, tk::Control::set.</span>
<a name="l00376"></a>00376 <span class="comment">  //! \author J. Bakosi</span>
<a name="l00377"></a>00377 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class </span>Stack, <span class="keyword">typename</span> tag, <span class="keyword">typename</span>... tags &gt;
<a name="l00378"></a><a class="code" href="structtk_1_1grm_1_1_set.html">00378</a>   <span class="keyword">struct </span><a class="code" href="structtk_1_1grm_1_1_set.html" title="Put value in state at position given by tags without conversion.">Set</a> : pegtl::<a class="code" href="classpegtl_1_1action__base.html">action_base</a>&lt; Set&lt;Stack,tag,tags...&gt; &gt; {
<a name="l00379"></a><a class="code" href="structtk_1_1grm_1_1_set.html#af80d43eec629fb3e2117c736ab367e6e">00379</a>     <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structtk_1_1grm_1_1_set.html#af80d43eec629fb3e2117c736ab367e6e">apply</a>(<span class="keyword">const</span> std::string&amp; value, Stack&amp; stack) {
<a name="l00380"></a>00380       stack.template <span class="keyword">set</span>&lt; tag, tags... &gt;( value );
<a name="l00381"></a>00381     }
<a name="l00382"></a>00382   };
<a name="l00383"></a>00383 <span class="comment"></span>
<a name="l00384"></a>00384 <span class="comment">  //! \brief Put value in state at position given by tags with conversion</span>
<a name="l00385"></a>00385 <span class="comment">  //! \details This struct and its apply function are used as a functor-like</span>
<a name="l00386"></a>00386 <span class="comment">  //!    wrapper for calling the store member function of the underlying grammar</span>
<a name="l00387"></a>00387 <span class="comment">  //!    stack, tk::Control::store.</span>
<a name="l00388"></a>00388 <span class="comment">  //! \author J. Bakosi</span>
<a name="l00389"></a>00389 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class </span>Stack, <span class="keyword">typename</span> tag, <span class="keyword">typename</span>... tags &gt;
<a name="l00390"></a><a class="code" href="structtk_1_1grm_1_1_store.html">00390</a>   <span class="keyword">struct </span><a class="code" href="structtk_1_1grm_1_1_store.html" title="Put value in state at position given by tags with conversion.">Store</a> : pegtl::<a class="code" href="classpegtl_1_1action__base.html">action_base</a>&lt; Store&lt; Stack, tag, tags... &gt; &gt; {
<a name="l00391"></a><a class="code" href="structtk_1_1grm_1_1_store.html#abc2a875901ead98272f7541a8f0d3634">00391</a>     <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structtk_1_1grm_1_1_store.html#abc2a875901ead98272f7541a8f0d3634">apply</a>( <span class="keyword">const</span> std::string&amp; value, Stack&amp; stack ) {
<a name="l00392"></a>00392       <span class="keywordflow">if</span> (!value.empty())
<a name="l00393"></a>00393         stack.template store&lt; tag, tags... &gt;( value );
<a name="l00394"></a>00394       <span class="keywordflow">else</span>
<a name="l00395"></a>00395         Message&lt; Stack, ERROR, MsgKey::MISSING &gt;( stack, value );
<a name="l00396"></a>00396     }
<a name="l00397"></a>00397   };
<a name="l00398"></a>00398 <span class="comment"></span>
<a name="l00399"></a>00399 <span class="comment">  //! \brief Convert and push back value to vector in state at position given by</span>
<a name="l00400"></a>00400 <span class="comment">  //!    tags</span>
<a name="l00401"></a>00401 <span class="comment">  //! \details This struct and its apply function are used as a functor-like</span>
<a name="l00402"></a>00402 <span class="comment">  //!    wrapper for calling the store_back member function of the underlying</span>
<a name="l00403"></a>00403 <span class="comment">  //!    grammar stack, tk::Control::store_back.</span>
<a name="l00404"></a>00404 <span class="comment">  //! \author J. Bakosi</span>
<a name="l00405"></a>00405 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class </span>Stack, <span class="keyword">typename</span> tag, <span class="keyword">typename</span>...tags &gt;
<a name="l00406"></a><a class="code" href="structtk_1_1grm_1_1_store__back.html">00406</a>   <span class="keyword">struct </span><a class="code" href="structtk_1_1grm_1_1_store__back.html" title="Convert and push back value to vector in state at position given by tags.">Store_back</a> : pegtl::<a class="code" href="classpegtl_1_1action__base.html">action_base</a>&lt; Store_back&lt; Stack, tag, tags... &gt; &gt; {
<a name="l00407"></a><a class="code" href="structtk_1_1grm_1_1_store__back.html#a713e490a6cb1a85385d12ef00f4855ea">00407</a>     <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structtk_1_1grm_1_1_store__back.html#a713e490a6cb1a85385d12ef00f4855ea">apply</a>( <span class="keyword">const</span> std::string&amp; value, Stack&amp; stack ) {
<a name="l00408"></a>00408       stack.template store_back&lt; tag, tags... &gt;( value );
<a name="l00409"></a>00409     }
<a name="l00410"></a>00410   };
<a name="l00411"></a>00411 <span class="comment"></span>
<a name="l00412"></a>00412 <span class="comment">  //! \brief Convert and push back value to vector of back of vector in state at</span>
<a name="l00413"></a>00413 <span class="comment">  //!    position given by tags</span>
<a name="l00414"></a>00414 <span class="comment">  //! \details This struct and its apply function are used as a functor-like</span>
<a name="l00415"></a>00415 <span class="comment">  //!    wrapper for calling the store_back_back member function of the</span>
<a name="l00416"></a>00416 <span class="comment">  //!    underlying grammar stack, tk::Control::store_back_back.</span>
<a name="l00417"></a>00417 <span class="comment">  //! \author J. Bakosi</span>
<a name="l00418"></a>00418 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class </span>Stack, <span class="keyword">typename</span> tag, <span class="keyword">typename</span>...tags &gt;
<a name="l00419"></a><a class="code" href="structtk_1_1grm_1_1_store__back__back.html">00419</a>   <span class="keyword">struct </span><a class="code" href="structtk_1_1grm_1_1_store__back__back.html" title="Convert and push back value to vector of back of vector in state at position given by tags...">Store_back_back</a> :
<a name="l00420"></a>00420   pegtl::<a class="code" href="classpegtl_1_1action__base.html">action_base</a>&lt; Store_back_back&lt; Stack, tag, tags... &gt; &gt; {
<a name="l00421"></a><a class="code" href="structtk_1_1grm_1_1_store__back__back.html#ae09106cc25c3c66cd82327b5cad18cfa">00421</a>     <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structtk_1_1grm_1_1_store__back__back.html#ae09106cc25c3c66cd82327b5cad18cfa">apply</a>( <span class="keyword">const</span> std::string&amp; value, Stack&amp; stack ) {
<a name="l00422"></a>00422       stack.template store_back_back&lt; tag, tags... &gt;( value );
<a name="l00423"></a>00423     }
<a name="l00424"></a>00424   };
<a name="l00425"></a>00425 <span class="comment"></span>
<a name="l00426"></a>00426 <span class="comment">  //! \brief Convert and push back value to vector of back of vector of back of</span>
<a name="l00427"></a>00427 <span class="comment">  //!   vector in state at position given by tags</span>
<a name="l00428"></a>00428 <span class="comment">  //! \details This struct and its apply function are used as a functor-like</span>
<a name="l00429"></a>00429 <span class="comment">  //!    wrapper for calling the store_back_back_back member function of the</span>
<a name="l00430"></a>00430 <span class="comment">  //!    underlying grammar stack, tk::Control::store_back_back_back.</span>
<a name="l00431"></a>00431 <span class="comment">  //! \author J. Bakosi</span>
<a name="l00432"></a>00432 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class </span>Stack, <span class="keyword">typename</span> tag, <span class="keyword">typename</span>...tags &gt;
<a name="l00433"></a><a class="code" href="structtk_1_1grm_1_1_store__back__back__back.html">00433</a>   <span class="keyword">struct </span><a class="code" href="structtk_1_1grm_1_1_store__back__back__back.html" title="Convert and push back value to vector of back of vector of back of vector in state at position given ...">Store_back_back_back</a> :
<a name="l00434"></a>00434   pegtl::<a class="code" href="classpegtl_1_1action__base.html">action_base</a>&lt; Store_back_back_back&lt; Stack, tag, tags... &gt; &gt; {
<a name="l00435"></a><a class="code" href="structtk_1_1grm_1_1_store__back__back__back.html#a81e9da08a67c9596976e621ea324edc3">00435</a>     <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structtk_1_1grm_1_1_store__back__back__back.html#a81e9da08a67c9596976e621ea324edc3">apply</a>( <span class="keyword">const</span> std::string&amp; value, Stack&amp; stack ) {
<a name="l00436"></a>00436       stack.template store_back_back_back&lt; tag, tags... &gt;( value );
<a name="l00437"></a>00437     }
<a name="l00438"></a>00438   };
<a name="l00439"></a>00439 <span class="comment"></span>
<a name="l00440"></a>00440 <span class="comment">  //! \brief Put true in switch in state at position given by tags</span>
<a name="l00441"></a>00441 <span class="comment">  //! \details This struct and its apply function are used as a functor-like</span>
<a name="l00442"></a>00442 <span class="comment">  //!    wrapper for setting a boolean value to true in the underlying grammar</span>
<a name="l00443"></a>00443 <span class="comment">  //!    stack via the member function tk::Control::set.</span>
<a name="l00444"></a>00444 <span class="comment">  //! \author J. Bakosi</span>
<a name="l00445"></a>00445 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class </span>Stack, <span class="keyword">typename</span> tag, <span class="keyword">typename</span>... tags &gt;
<a name="l00446"></a><a class="code" href="structtk_1_1grm_1_1_store__switch.html">00446</a>   <span class="keyword">struct </span><a class="code" href="structtk_1_1grm_1_1_store__switch.html" title="Put true in switch in state at position given by tags.">Store_switch</a> : pegtl::<a class="code" href="classpegtl_1_1action__base.html">action_base</a>&lt; Store_switch&lt;Stack,tag,tags...&gt; &gt; {
<a name="l00447"></a><a class="code" href="structtk_1_1grm_1_1_store__switch.html#a9978fc26dc4b6992d69fa6c02e3c915a">00447</a>     <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structtk_1_1grm_1_1_store__switch.html#a9978fc26dc4b6992d69fa6c02e3c915a">apply</a>(<span class="keyword">const</span> std::string&amp; value, Stack&amp; stack) {
<a name="l00448"></a>00448       stack.template <span class="keyword">set</span>&lt;tag,tags...&gt;(<span class="keyword">true</span>);
<a name="l00449"></a>00449     }
<a name="l00450"></a>00450   };
<a name="l00451"></a>00451 <span class="comment"></span>
<a name="l00452"></a>00452 <span class="comment">  //! \brief Push back option in state at position given by tags</span>
<a name="l00453"></a>00453 <span class="comment">  //! \details This struct and its apply function are used as a functor-like</span>
<a name="l00454"></a>00454 <span class="comment">  //!   wrapper for pushing back an option (an object deriving from</span>
<a name="l00455"></a>00455 <span class="comment">  //!   tk::Toggle) into a vector in the grammar stack. See walker::ctr::DiffEq</span>
<a name="l00456"></a>00456 <span class="comment">  //!   for an example specialization of tk::Toggle to see how an option is</span>
<a name="l00457"></a>00457 <span class="comment">  //!   created from tk::Toggle. We also do a simple sanity check here testing</span>
<a name="l00458"></a>00458 <span class="comment">  //!   if the desried option value exist for the particular option type and</span>
<a name="l00459"></a>00459 <span class="comment">  //!   error out if there is problem. Errors and warnings are accumulated</span>
<a name="l00460"></a>00460 <span class="comment">  //!   during parsing and diagnostics are given after the parsing is finished.</span>
<a name="l00461"></a>00461 <span class="comment">  //! \author J. Bakosi</span>
<a name="l00462"></a>00462 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class</span> Stack, <span class="keyword">template</span> &lt; <span class="keyword">class</span> &gt; <span class="keyword">class </span>use, <span class="keyword">class </span>Option,
<a name="l00463"></a>00463             <span class="keyword">typename</span> tag, <span class="keyword">typename</span>... tags &gt;
<a name="l00464"></a><a class="code" href="structtk_1_1grm_1_1store__back__option.html">00464</a>   <span class="keyword">struct </span><a class="code" href="structtk_1_1grm_1_1store__back__option.html" title="Push back option in state at position given by tags.">store_back_option</a> :
<a name="l00465"></a>00465     pegtl::<a class="code" href="classpegtl_1_1action__base.html">action_base</a>&lt; store_back_option&lt; Stack, use, Option, tag, tags...&gt; &gt;
<a name="l00466"></a>00466   {
<a name="l00467"></a><a class="code" href="structtk_1_1grm_1_1store__back__option.html#a8c1ec64cf956d88fc6874241ee04e119">00467</a>     <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structtk_1_1grm_1_1store__back__option.html#a8c1ec64cf956d88fc6874241ee04e119">apply</a>( <span class="keyword">const</span> std::string&amp; value, Stack&amp; stack ) {
<a name="l00468"></a>00468       Option opt;
<a name="l00469"></a>00469       <span class="keywordflow">if</span> (opt.exist(value)) {
<a name="l00470"></a>00470         stack.template push_back&lt;tag,tags...&gt;( opt.value( value ) );
<a name="l00471"></a>00471       } <span class="keywordflow">else</span> {
<a name="l00472"></a>00472         Message&lt; Stack, ERROR, MsgKey::NOOPTION &gt;( stack, value );
<a name="l00473"></a>00473       }
<a name="l00474"></a>00474       <span class="comment">// trigger error at compile-time if any of the expected option values</span>
<a name="l00475"></a>00475       <span class="comment">// is not in the keywords pool of the grammar</span>
<a name="l00476"></a>00476       boost::mpl::for_each&lt; typename Option::keywords &gt;( <a class="code" href="structtk_1_1grm_1_1is__keyword.html" title="Compile-time test functor verifying that type U is a keyword.">is_keyword&lt; use &gt;</a>() );
<a name="l00477"></a>00477     }
<a name="l00478"></a>00478   };
<a name="l00479"></a>00479 <span class="comment"></span>
<a name="l00480"></a>00480 <span class="comment">  //! \brief Convert and insert value to map at position given by tags</span>
<a name="l00481"></a>00481 <span class="comment">  //! \details This struct and its apply function are used as a functor-like</span>
<a name="l00482"></a>00482 <span class="comment">  //!   wrapper for inserting a value into a std::map behind a key in the</span>
<a name="l00483"></a>00483 <span class="comment">  //!   underlying grammar stack via the member function</span>
<a name="l00484"></a>00484 <span class="comment">  //!   tk::Control::insert_field. We detect a recently inserted key and its</span>
<a name="l00485"></a>00485 <span class="comment">  //!   type from the companion tuple field, &quot;selected vector&quot;, given by types,</span>
<a name="l00486"></a>00486 <span class="comment">  //!   sel and vec, and use that key to insert an associated value in a</span>
<a name="l00487"></a>00487 <span class="comment">  //!   std::map addressed by tag and tags..., requiring at least one tag to</span>
<a name="l00488"></a>00488 <span class="comment">  //!   address the map. As an example, this is used in parsing parameters</span>
<a name="l00489"></a>00489 <span class="comment">  //!   associated to a particular random number generator, such as seed.</span>
<a name="l00490"></a>00490 <span class="comment">  //!   Example input file: &quot;mkl_mcg59 seed 2134 uniform_method accurate end&quot;.</span>
<a name="l00491"></a>00491 <span class="comment">  //!   The selected vector here is the std::vector&lt; tk::ctr::RNGType &gt; under</span>
<a name="l00492"></a>00492 <span class="comment">  //!   tag::sel (at the second level of the tagged tuple). The</span>
<a name="l00493"></a>00493 <span class="comment">  //!   std::vector and its member function back() are then interrogated to find</span>
<a name="l00494"></a>00494 <span class="comment">  //!   out the key type and its value (an enum value) for the particular RNG.</span>
<a name="l00495"></a>00495 <span class="comment">  //!   This key is then used to insert a new entry in the std::map under</span>
<a name="l00496"></a>00496 <span class="comment">  //!   tag::param to store the RNG parameter. Client-code is in, e.g.,</span>
<a name="l00497"></a>00497 <span class="comment">  //!   tk::rngsse::seed.</span>
<a name="l00498"></a>00498 <span class="comment">  //! \author J. Bakosi</span>
<a name="l00499"></a>00499 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class </span>Stack, <span class="keyword">typename</span> <a class="code" href="namespacetk_1_1grm.html#a1b809dbbd954026ab2bc003ec27a80f2" title="Out-of-struct storage of field ID for pushing terms for statistics.">field</a>, <span class="keyword">typename</span> sel, <span class="keyword">typename</span> vec,
<a name="l00500"></a>00500             <span class="keyword">typename</span> tag, <span class="keyword">typename</span>...tags &gt;
<a name="l00501"></a><a class="code" href="structtk_1_1grm_1_1_insert__field.html">00501</a>   <span class="keyword">struct </span><a class="code" href="structtk_1_1grm_1_1_insert__field.html" title="Convert and insert value to map at position given by tags.">Insert_field</a> :
<a name="l00502"></a>00502   pegtl::<a class="code" href="classpegtl_1_1action__base.html">action_base</a>&lt; Insert_field&lt; Stack, field, sel, vec, tag, tags... &gt; &gt; {
<a name="l00503"></a><a class="code" href="structtk_1_1grm_1_1_insert__field.html#a941ffba76414022c39ace1a671a51dd3">00503</a>     <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structtk_1_1grm_1_1_insert__field.html#a941ffba76414022c39ace1a671a51dd3">apply</a>( <span class="keyword">const</span> std::string&amp; value, Stack&amp; stack ) {
<a name="l00504"></a>00504       <span class="comment">// get recently inserted key from &lt;sel,vec&gt;</span>
<a name="l00505"></a>00505       <span class="keyword">using</span> key_type =
<a name="l00506"></a>00506         <span class="keyword">typename</span> Stack::template nT&lt; sel &gt;::template nT&lt; vec &gt;::value_type;
<a name="l00507"></a>00507       <span class="keyword">const</span> key_type&amp; key = stack.template get&lt; sel, vec &gt;().back();
<a name="l00508"></a>00508       stack.template insert_field&lt;key_type, <a class="code" href="namespacetk_1_1grm.html#a1b809dbbd954026ab2bc003ec27a80f2" title="Out-of-struct storage of field ID for pushing terms for statistics.">field</a>, tag, tags...&gt;( key, value );
<a name="l00509"></a>00509     }
<a name="l00510"></a>00510   };
<a name="l00511"></a>00511 <span class="comment"></span>
<a name="l00512"></a>00512 <span class="comment">  //! \brief Convert and insert option value to map at position given by tags</span>
<a name="l00513"></a>00513 <span class="comment">  //! \details This struct and its apply function are used as a functor-like</span>
<a name="l00514"></a>00514 <span class="comment">  //!   wrapper for converting and inserting an option in a std::map in the</span>
<a name="l00515"></a>00515 <span class="comment">  //!   grammar stack. An option is an object deriving from tk::Toggle. See,</span>
<a name="l00516"></a>00516 <span class="comment">  //!   e.g., walker::ctr::DiffEq for an example specialization of tk::Toggle to</span>
<a name="l00517"></a>00517 <span class="comment">  //!   see how an option is created from tk::Toggle.</span>
<a name="l00518"></a>00518 <span class="comment">  //! \author J. Bakosi</span>
<a name="l00519"></a>00519 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class</span> Stack, <span class="keyword">template</span>&lt; <span class="keyword">class</span> &gt; <span class="keyword">class </span>use, <span class="keyword">class </span>Option,
<a name="l00520"></a>00520             <span class="keyword">typename</span> <a class="code" href="namespacetk_1_1grm.html#a1b809dbbd954026ab2bc003ec27a80f2" title="Out-of-struct storage of field ID for pushing terms for statistics.">field</a>, <span class="keyword">typename</span> sel, <span class="keyword">typename</span> vec, <span class="keyword">typename</span> tag,
<a name="l00521"></a>00521             <span class="keyword">typename</span>... tags &gt;
<a name="l00522"></a><a class="code" href="structtk_1_1grm_1_1insert__option.html">00522</a>   <span class="keyword">struct </span><a class="code" href="structtk_1_1grm_1_1insert__option.html" title="Convert and insert option value to map at position given by tags.">insert_option</a> : pegtl::<a class="code" href="classpegtl_1_1action__base.html">action_base</a>&lt;
<a name="l00523"></a>00523                            insert_option&lt; Stack, use, Option, field, sel, vec,
<a name="l00524"></a>00524                                           tag, tags... &gt; &gt; {
<a name="l00525"></a><a class="code" href="structtk_1_1grm_1_1insert__option.html#a4a0f37cd254bb2b2b422a78e05088f58">00525</a>     <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structtk_1_1grm_1_1insert__option.html#a4a0f37cd254bb2b2b422a78e05088f58">apply</a>( <span class="keyword">const</span> std::string&amp; value, Stack&amp; stack ) {
<a name="l00526"></a>00526       <span class="comment">// get recently inserted key from &lt;sel,vec&gt;</span>
<a name="l00527"></a>00527       <span class="keyword">using</span> key_type =
<a name="l00528"></a>00528         <span class="keyword">typename</span> Stack::template nT&lt; sel &gt;::template nT&lt; vec &gt;::value_type;
<a name="l00529"></a>00529       <span class="keyword">const</span> key_type&amp; key = stack.template get&lt; sel, vec &gt;().back();
<a name="l00530"></a>00530       stack.template
<a name="l00531"></a>00531         insert_opt&lt; key_type, <a class="code" href="namespacetk_1_1grm.html#a1b809dbbd954026ab2bc003ec27a80f2" title="Out-of-struct storage of field ID for pushing terms for statistics.">field</a>, <span class="keyword">typename</span> Option::EnumType, tag, tags... &gt;
<a name="l00532"></a>00532                   ( key, Option().value(value) );
<a name="l00533"></a>00533       <span class="comment">// trigger error at compile-time if any of the expected option values</span>
<a name="l00534"></a>00534       <span class="comment">// is not in the keywords pool of the grammar</span>
<a name="l00535"></a>00535       boost::mpl::for_each&lt; typename Option::keywords &gt;( <a class="code" href="structtk_1_1grm_1_1is__keyword.html" title="Compile-time test functor verifying that type U is a keyword.">is_keyword&lt; use &gt;</a>() );
<a name="l00536"></a>00536     }
<a name="l00537"></a>00537   };
<a name="l00538"></a>00538 <span class="comment"></span>
<a name="l00539"></a>00539 <span class="comment">  //! \brief Set numeric precision for ASCII output of floating-point values</span>
<a name="l00540"></a>00540 <span class="comment">  //! \details This struct and its apply function are used as a functor-like</span>
<a name="l00541"></a>00541 <span class="comment">  //!   wrapper for setting the precision used for outputing floating-point</span>
<a name="l00542"></a>00542 <span class="comment">  //!   values into text files. We also make sure that the precision to be set</span>
<a name="l00543"></a>00543 <span class="comment">  //!   is between the correct bounds of the underlying floating-point type.</span>
<a name="l00544"></a>00544 <span class="comment">  //! \see kw::precision_info</span>
<a name="l00545"></a>00545 <span class="comment">  //! \author J. Bakosi</span>
<a name="l00546"></a>00546 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class</span> Stack, <span class="keyword">class</span> prec &gt;
<a name="l00547"></a><a class="code" href="structtk_1_1grm_1_1store__precision.html">00547</a>   <span class="keyword">struct </span><a class="code" href="structtk_1_1grm_1_1store__precision.html" title="Set numeric precision for ASCII output of floating-point values.">store_precision</a> : pegtl::<a class="code" href="classpegtl_1_1action__base.html">action_base</a>&lt; store_precision&lt;Stack,prec&gt; &gt; {
<a name="l00548"></a><a class="code" href="structtk_1_1grm_1_1store__precision.html#ad0b75106ec19342e684f992a8a0314b1">00548</a>     <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structtk_1_1grm_1_1store__precision.html#ad0b75106ec19342e684f992a8a0314b1">apply</a>( <span class="keyword">const</span> std::string&amp; value, Stack&amp; stack ) {
<a name="l00549"></a>00549       <span class="keyword">using</span> PrEx = kw::precision::info::expect;
<a name="l00550"></a>00550       std::string low( value );
<a name="l00551"></a>00551       std::transform( begin(low), end(low), begin(low), ::tolower );
<a name="l00552"></a>00552       <span class="keywordflow">if</span> (low == <span class="stringliteral">&quot;max&quot;</span>) {
<a name="l00553"></a>00553         <span class="keyword">const</span> <span class="keyword">auto</span> maxprec = PrEx::upper;
<a name="l00554"></a>00554         stack.template set&lt; tag::prec, prec &gt;( maxprec );
<a name="l00555"></a>00555       } <span class="keywordflow">else</span> {
<a name="l00556"></a>00556         PrEx::type precision = std::cout.precision();  <span class="comment">// set default</span>
<a name="l00557"></a>00557         <span class="keywordflow">try</span> {
<a name="l00558"></a>00558           precision = std::stol( value ); <span class="comment">// try to convert matched str to int</span>
<a name="l00559"></a>00559         }
<a name="l00560"></a>00560         <span class="keywordflow">catch</span> ( std::exception&amp; e ) {
<a name="l00561"></a>00561           Message&lt; Stack, ERROR, MsgKey::BADPRECISION &gt;( stack, value );
<a name="l00562"></a>00562         }
<a name="l00563"></a>00563         <span class="comment">// only set precision given if it makes sense</span>
<a name="l00564"></a>00564         <span class="keywordflow">if</span> (precision &gt;= PrEx::lower &amp;&amp; precision &lt;= PrEx::upper)
<a name="l00565"></a>00565           stack.template set&lt; tag::prec, prec &gt;( precision );
<a name="l00566"></a>00566         <span class="keywordflow">else</span>
<a name="l00567"></a>00567           Message&lt; Stack, WARNING, MsgKey::PRECISIONBOUNDS &gt;( stack, value );
<a name="l00568"></a>00568       }
<a name="l00569"></a>00569     }
<a name="l00570"></a>00570   };
<a name="l00571"></a>00571 <span class="comment"></span>
<a name="l00572"></a>00572 <span class="comment">  //! \brief Find keyword among all keywords and if found, store the keyword</span>
<a name="l00573"></a>00573 <span class="comment">  //!    and its info on which help was requested behind tag::helpkw in Stack</span>
<a name="l00574"></a>00574 <span class="comment">  //! \details This struct and its apply function are used as a functor-like</span>
<a name="l00575"></a>00575 <span class="comment">  //!    wrapper to search for a keyword in the pool of registered keywords</span>
<a name="l00576"></a>00576 <span class="comment">  //!    recognized by a grammar and store the keyword and its info on which</span>
<a name="l00577"></a>00577 <span class="comment">  //!    help was requested behind tag::helpkw. Note that this functor assumes</span>
<a name="l00578"></a>00578 <span class="comment">  //!    a specific location for the std::maps of the command-line and control</span>
<a name="l00579"></a>00579 <span class="comment">  //!    file keywords pools (behind tag::cmdinfo and tag::ctrinfo,</span>
<a name="l00580"></a>00580 <span class="comment">  //!    respectively), and for the keyword and its info on which help was</span>
<a name="l00581"></a>00581 <span class="comment">  //!    requested (behind tag::helpkw). This is the structure of CmdLine</span>
<a name="l00582"></a>00582 <span class="comment">  //!    objects, thus this functor should be called from command line parsers.</span>
<a name="l00583"></a>00583 <span class="comment">  //! \author J. Bakosi</span>
<a name="l00584"></a>00584 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class</span> Stack &gt;
<a name="l00585"></a><a class="code" href="structtk_1_1grm_1_1helpkw.html">00585</a>   <span class="keyword">struct </span><a class="code" href="structtk_1_1grm_1_1helpkw.html" title="Find keyword among all keywords and if found, store the keyword and its info on which help was reques...">helpkw</a> : pegtl::<a class="code" href="classpegtl_1_1action__base.html">action_base</a>&lt; helpkw&lt; Stack &gt; &gt; {
<a name="l00586"></a><a class="code" href="structtk_1_1grm_1_1helpkw.html#a5680adad92bd1a8393ec253e3b679c6a">00586</a>     <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structtk_1_1grm_1_1helpkw.html#a5680adad92bd1a8393ec253e3b679c6a">apply</a>( <span class="keyword">const</span> std::string&amp; value, Stack&amp; stack ) {
<a name="l00587"></a>00587       <span class="keyword">const</span> <span class="keyword">auto</span>&amp; cmdinfo = stack.template get&lt; tag::cmdinfo &gt;();
<a name="l00588"></a>00588       <span class="keyword">const</span> <span class="keyword">auto</span>&amp; ctrinfo = stack.template get&lt; tag::ctrinfo &gt;();
<a name="l00589"></a>00589       <span class="keyword">auto</span> it = cmdinfo.find( value );
<a name="l00590"></a>00590       <span class="keywordflow">if</span> (it != cmdinfo.end()) {
<a name="l00591"></a>00591         <span class="comment">// store keyword and its info on which help was requested</span>
<a name="l00592"></a>00592         stack.template set&lt; tag::helpkw &gt;( { it-&gt;first, it-&gt;second, <span class="keyword">true</span> } );
<a name="l00593"></a>00593       } <span class="keywordflow">else</span> {
<a name="l00594"></a>00594         it = ctrinfo.find( value );
<a name="l00595"></a>00595         <span class="keywordflow">if</span> (it != ctrinfo.end())
<a name="l00596"></a>00596           <span class="comment">// store keyword and its info on which help was requested</span>
<a name="l00597"></a>00597           stack.template set&lt; tag::helpkw &gt;( { it-&gt;first, it-&gt;second, <span class="keyword">false</span> } );
<a name="l00598"></a>00598         <span class="keywordflow">else</span>
<a name="l00599"></a>00599           Message&lt; Stack, ERROR, MsgKey::KEYWORD &gt;( stack, value );
<a name="l00600"></a>00600       }
<a name="l00601"></a>00601     }
<a name="l00602"></a>00602   };
<a name="l00603"></a>00603 <span class="comment"></span>
<a name="l00604"></a>00604 <span class="comment">  //! \brief Match depvar (dependent variable) to one of the selected ones</span>
<a name="l00605"></a>00605 <span class="comment">  //! \details This is used to check the set of dependent variables previously</span>
<a name="l00606"></a>00606 <span class="comment">  //!    assigned to registered differential equations (or models).</span>
<a name="l00607"></a>00607 <span class="comment">  //! \author J. Bakosi</span>
<a name="l00608"></a>00608 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class</span> Stack, <span class="keyword">class</span> push &gt;
<a name="l00609"></a><a class="code" href="structtk_1_1grm_1_1match__depvar.html">00609</a>   <span class="keyword">struct </span><a class="code" href="structtk_1_1grm_1_1match__depvar.html" title="Match depvar (dependent variable) to one of the selected ones.">match_depvar</a> : pegtl::<a class="code" href="classpegtl_1_1action__base.html">action_base</a>&lt; match_depvar&lt; Stack, push &gt; &gt; {
<a name="l00610"></a><a class="code" href="structtk_1_1grm_1_1match__depvar.html#a7809335029be1160e0d9acb22869d1c4">00610</a>     <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structtk_1_1grm_1_1match__depvar.html#a7809335029be1160e0d9acb22869d1c4">apply</a>( <span class="keyword">const</span> std::string&amp; value, Stack&amp; stack ) {
<a name="l00611"></a>00611       <span class="comment">// convert matched string to char</span>
<a name="l00612"></a>00612       <span class="keyword">auto</span> var = stack.template convert&lt; char &gt;( value );
<a name="l00613"></a>00613       <span class="comment">// find matched variable in set of selected ones</span>
<a name="l00614"></a>00614       <span class="keywordflow">if</span> (<a class="code" href="namespacetk_1_1grm.html#ab631f9f35bdba1b71a2cff1112364971" title="Parser-lifetime storage for dependent variables selected.">depvars</a>.find( var ) != <a class="code" href="namespacetk_1_1grm.html#ab631f9f35bdba1b71a2cff1112364971" title="Parser-lifetime storage for dependent variables selected.">depvars</a>.end())
<a name="l00615"></a>00615         push::apply( value, stack );
<a name="l00616"></a>00616       <span class="keywordflow">else</span>  <span class="comment">// error out if matched var is not selected</span>
<a name="l00617"></a>00617         Message&lt; Stack, ERROR, MsgKey::NOSUCHDEPVAR &gt;( stack, value );
<a name="l00618"></a>00618     }
<a name="l00619"></a>00619   };
<a name="l00620"></a>00620 <span class="comment"></span>
<a name="l00621"></a>00621 <span class="comment">  //! \brief Match PDF name to the registered ones</span>
<a name="l00622"></a>00622 <span class="comment">  //! \details This is used to check the set of PDF names dependent previously</span>
<a name="l00623"></a>00623 <span class="comment">  //!    registered to make sure all are unique.</span>
<a name="l00624"></a>00624 <span class="comment">  //! \author J. Bakosi</span>
<a name="l00625"></a>00625 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class</span> Stack &gt;
<a name="l00626"></a><a class="code" href="structtk_1_1grm_1_1match__pdfname.html">00626</a>   <span class="keyword">struct </span><a class="code" href="structtk_1_1grm_1_1match__pdfname.html" title="Match PDF name to the registered ones.">match_pdfname</a> : pegtl::<a class="code" href="classpegtl_1_1action__base.html">action_base</a>&lt; match_pdfname&lt; Stack &gt; &gt; {
<a name="l00627"></a><a class="code" href="structtk_1_1grm_1_1match__pdfname.html#a808520a169a27073838e46809072d11e">00627</a>     <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structtk_1_1grm_1_1match__pdfname.html#a808520a169a27073838e46809072d11e">apply</a>( <span class="keyword">const</span> std::string&amp; value, Stack&amp; stack ) {
<a name="l00628"></a>00628       <span class="comment">// find matched name in set of registered ones</span>
<a name="l00629"></a>00629       <span class="keywordflow">if</span> (<a class="code" href="namespacetk_1_1grm.html#aadf18699e85fe7ff02a1dfbb37d78977" title="Parser-lifetime storage for PDF names.">pdfnames</a>.find( value ) == <a class="code" href="namespacetk_1_1grm.html#aadf18699e85fe7ff02a1dfbb37d78977" title="Parser-lifetime storage for PDF names.">pdfnames</a>.end()) {
<a name="l00630"></a>00630         <a class="code" href="namespacetk_1_1grm.html#aadf18699e85fe7ff02a1dfbb37d78977" title="Parser-lifetime storage for PDF names.">pdfnames</a>.insert( value );
<a name="l00631"></a>00631         stack.template push_back&lt; tag::cmd, tag::io, tag::pdfnames &gt;( value );
<a name="l00632"></a>00632       }
<a name="l00633"></a>00633       <span class="keywordflow">else</span>  <span class="comment">// error out if name matched var is already registered</span>
<a name="l00634"></a>00634         Message&lt; Stack, ERROR, MsgKey::PDFEXISTS &gt;( stack, value );
<a name="l00635"></a>00635     }
<a name="l00636"></a>00636   };
<a name="l00637"></a>00637 <span class="comment"></span>
<a name="l00638"></a>00638 <span class="comment">  //! \brief Put option in state at position given by tags if among the selected</span>
<a name="l00639"></a>00639 <span class="comment">  //! \author J. Bakosi</span>
<a name="l00640"></a>00640 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class</span> Stack, <span class="keyword">template</span> &lt; <span class="keyword">class</span> &gt; <span class="keyword">class </span>use, <span class="keyword">class </span>Option,
<a name="l00641"></a>00641             <span class="keyword">typename</span> sel, <span class="keyword">typename</span> vec, <span class="keyword">typename</span>... tags &gt;
<a name="l00642"></a><a class="code" href="structtk_1_1grm_1_1check__store__option.html">00642</a>   <span class="keyword">struct </span><a class="code" href="structtk_1_1grm_1_1check__store__option.html" title="Put option in state at position given by tags if among the selected.">check_store_option</a> :
<a name="l00643"></a>00643     pegtl::<a class="code" href="classpegtl_1_1action__base.html">action_base</a>&lt;
<a name="l00644"></a>00644       check_store_option&lt; Stack, use, Option, sel, vec, tags... &gt; &gt;
<a name="l00645"></a>00645   {
<a name="l00646"></a><a class="code" href="structtk_1_1grm_1_1check__store__option.html#a26754d63f7a58602a52af1d7c3386fee">00646</a>     <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structtk_1_1grm_1_1check__store__option.html#a26754d63f7a58602a52af1d7c3386fee">apply</a>(<span class="keyword">const</span> std::string&amp; value, Stack&amp; stack) {
<a name="l00647"></a>00647       <span class="comment">// error out if chosen item does not exist in selected vector</span>
<a name="l00648"></a>00648       <span class="keywordtype">bool</span> exists = <span class="keyword">false</span>;
<a name="l00649"></a>00649       <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; r : stack.template get&lt; sel, vec &gt;()) {
<a name="l00650"></a>00650         <span class="keywordflow">if</span> (Option().value(value) == r) exists = <span class="keyword">true</span>;
<a name="l00651"></a>00651       }
<a name="l00652"></a>00652       <span class="keywordflow">if</span> (exists)
<a name="l00653"></a>00653         <a class="code" href="structtk_1_1grm_1_1store__back__option.html" title="Push back option in state at position given by tags.">store_back_option</a>&lt; Stack, use, Option, tags... &gt;().apply( value, stack );
<a name="l00654"></a>00654       <span class="keywordflow">else</span>
<a name="l00655"></a>00655         Message&lt; Stack, ERROR, MsgKey::NOTSELECTED &gt;( stack, value );
<a name="l00656"></a>00656     }
<a name="l00657"></a>00657   };
<a name="l00658"></a>00658 <span class="comment"></span>
<a name="l00659"></a>00659 <span class="comment">  //! \brief Add depvar (dependent variable) to the selected ones</span>
<a name="l00660"></a>00660 <span class="comment">  //! \author J. Bakosi</span>
<a name="l00661"></a>00661 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class</span> Stack &gt;
<a name="l00662"></a><a class="code" href="structtk_1_1grm_1_1add__depvar.html">00662</a>   <span class="keyword">struct </span><a class="code" href="structtk_1_1grm_1_1add__depvar.html" title="Add depvar (dependent variable) to the selected ones.">add_depvar</a> : pegtl::<a class="code" href="classpegtl_1_1action__base.html">action_base</a>&lt; add_depvar&lt; Stack &gt; &gt; {
<a name="l00663"></a><a class="code" href="structtk_1_1grm_1_1add__depvar.html#adc5c416d164492af48d8be9cef051dd7">00663</a>     <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structtk_1_1grm_1_1add__depvar.html#adc5c416d164492af48d8be9cef051dd7">apply</a>(<span class="keyword">const</span> std::string&amp; value, Stack&amp; stack) {
<a name="l00664"></a>00664       <span class="comment">// convert matched string to char</span>
<a name="l00665"></a>00665       <span class="keyword">auto</span> newvar = stack.template convert&lt; char &gt;( value );
<a name="l00666"></a>00666       <span class="comment">// put in new dependent variable to set of already selected ones</span>
<a name="l00667"></a>00667       <span class="keywordflow">if</span> (<a class="code" href="namespacetk_1_1grm.html#ab631f9f35bdba1b71a2cff1112364971" title="Parser-lifetime storage for dependent variables selected.">depvars</a>.find( newvar ) == <a class="code" href="namespacetk_1_1grm.html#ab631f9f35bdba1b71a2cff1112364971" title="Parser-lifetime storage for dependent variables selected.">depvars</a>.end())
<a name="l00668"></a>00668         <a class="code" href="namespacetk_1_1grm.html#ab631f9f35bdba1b71a2cff1112364971" title="Parser-lifetime storage for dependent variables selected.">depvars</a>.insert( newvar );
<a name="l00669"></a>00669       <span class="keywordflow">else</span>  <span class="comment">// error out if depvar is already taken</span>
<a name="l00670"></a>00670         Message&lt; Stack, ERROR, MsgKey::EXISTS &gt;( stack, value );
<a name="l00671"></a>00671     }
<a name="l00672"></a>00672   };
<a name="l00673"></a>00673 <span class="comment"></span>
<a name="l00674"></a>00674 <span class="comment">  //! \brief Start new vector in vector</span>
<a name="l00675"></a>00675 <span class="comment">  //! \author J. Bakosi</span>
<a name="l00676"></a>00676 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class </span>Stack, <span class="keyword">class </span>tag, <span class="keyword">class</span>... tags &gt;
<a name="l00677"></a><a class="code" href="structtk_1_1grm_1_1start__vector.html">00677</a>   <span class="keyword">struct </span><a class="code" href="structtk_1_1grm_1_1start__vector.html" title="Start new vector in vector.">start_vector</a> : pegtl::<a class="code" href="classpegtl_1_1action__base.html">action_base</a>&lt;
<a name="l00678"></a>00678                           start_vector&lt; Stack, tag, tags... &gt; &gt; {
<a name="l00679"></a><a class="code" href="structtk_1_1grm_1_1start__vector.html#acd56467faffd3ac6e06400a45d5835c9">00679</a>     <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structtk_1_1grm_1_1start__vector.html#acd56467faffd3ac6e06400a45d5835c9">apply</a>( <span class="keyword">const</span> std::string&amp;, Stack&amp; stack ) {
<a name="l00680"></a>00680       stack.template push_back&lt; tag, tags... &gt;();  <span class="comment">// no arg: use default ctor</span>
<a name="l00681"></a>00681     }
<a name="l00682"></a>00682   };
<a name="l00683"></a>00683 <span class="comment"></span>
<a name="l00684"></a>00684 <span class="comment">  //! \brief Start new vector in back of a vector</span>
<a name="l00685"></a>00685 <span class="comment">  //! \author J. Bakosi</span>
<a name="l00686"></a>00686 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class </span>Stack, <span class="keyword">class </span>tag, <span class="keyword">class</span>... tags &gt;
<a name="l00687"></a><a class="code" href="structtk_1_1grm_1_1start__vector__back.html">00687</a>   <span class="keyword">struct </span><a class="code" href="structtk_1_1grm_1_1start__vector__back.html" title="Start new vector in back of a vector.">start_vector_back</a> : pegtl::<a class="code" href="classpegtl_1_1action__base.html">action_base</a>&lt;
<a name="l00688"></a>00688                              start_vector_back&lt; Stack, tag, tags... &gt; &gt; {
<a name="l00689"></a><a class="code" href="structtk_1_1grm_1_1start__vector__back.html#a2f42bc7c48a825141511dd067cd25e06">00689</a>     <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structtk_1_1grm_1_1start__vector__back.html#a2f42bc7c48a825141511dd067cd25e06">apply</a>( <span class="keyword">const</span> std::string&amp;, Stack&amp; stack ) {
<a name="l00690"></a>00690       <span class="comment">// no arg: use default ctor</span>
<a name="l00691"></a>00691       stack.template push_back_back&lt; tag, tags... &gt;();
<a name="l00692"></a>00692     }
<a name="l00693"></a>00693   };
<a name="l00694"></a>00694 <span class="comment"></span>
<a name="l00695"></a>00695 <span class="comment">  //! \brief Add matched value as Term into vector of vector of statistics</span>
<a name="l00696"></a>00696 <span class="comment">  //! \author J. Bakosi</span>
<a name="l00697"></a>00697 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class</span> Stack, tk::ctr::Moment m, <span class="keywordtype">char</span> var = &#39;\0&#39; &gt;
<a name="l00698"></a><a class="code" href="structtk_1_1grm_1_1push__term.html">00698</a>   <span class="keyword">struct </span><a class="code" href="structtk_1_1grm_1_1push__term.html" title="Add matched value as Term into vector of vector of statistics.">push_term</a> : pegtl::<a class="code" href="classpegtl_1_1action__base.html">action_base</a>&lt; push_term&lt; Stack, m, var &gt; &gt; {
<a name="l00699"></a><a class="code" href="structtk_1_1grm_1_1push__term.html#ad4beea5fd87da12b7b870af184186d81">00699</a>     <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structtk_1_1grm_1_1push__term.html#ad4beea5fd87da12b7b870af184186d81">apply</a>( <span class="keyword">const</span> std::string&amp; value, Stack&amp; stack ) {
<a name="l00700"></a>00700       <span class="comment">// If var is given, push var, otherwise push first char of value</span>
<a name="l00701"></a>00701       <span class="keywordtype">char</span> v(var ? var : value[0]);
<a name="l00702"></a>00702       <span class="comment">// Use a shorthand of reference to vector to push_back to</span>
<a name="l00703"></a>00703       <span class="keyword">auto</span>&amp; stats = stack.template get&lt; tag::stat &gt;();
<a name="l00704"></a>00704       <span class="comment">// Push term into current vector</span>
<a name="l00705"></a>00705       stats.back().emplace_back( <a class="code" href="structtk_1_1ctr_1_1_term.html" title="Term is a Moment of a quantity with a field ID to be ensemble averaged.">tk::ctr::Term</a>( v, <a class="code" href="namespacetk_1_1grm.html#a1b809dbbd954026ab2bc003ec27a80f2" title="Out-of-struct storage of field ID for pushing terms for statistics.">field</a>, m ) );
<a name="l00706"></a>00706       <span class="comment">// If central moment, trigger mean (in statistics)</span>
<a name="l00707"></a>00707       <span class="keywordflow">if</span> (m == <a class="code" href="namespacetk_1_1ctr.html#a0810374f0c22a0bd157d9ff8bc9d0a60ace122858bb821c10699d9e484c897127" title="Fluctuation.">tk::ctr::Moment::CENTRAL</a>) {
<a name="l00708"></a>00708         <a class="code" href="structtk_1_1ctr_1_1_term.html" title="Term is a Moment of a quantity with a field ID to be ensemble averaged.">tk::ctr::Term</a> <a class="code" href="structtk_1_1grm_1_1term.html" title="term: upper or lowercase fieldvar matched to selected depvars for stats">term</a>( static_cast&lt;char&gt;(toupper(v)),
<a name="l00709"></a>00709                             <a class="code" href="namespacetk_1_1grm.html#a1b809dbbd954026ab2bc003ec27a80f2" title="Out-of-struct storage of field ID for pushing terms for statistics.">field</a>,
<a name="l00710"></a>00710                             <a class="code" href="namespacetk_1_1ctr.html#a0810374f0c22a0bd157d9ff8bc9d0a60a07e3ada6004b214beb21caf6492eec6f" title="Full variable.">tk::ctr::Moment::ORDINARY</a> );
<a name="l00711"></a>00711         stats.insert( stats.end()-1, tk::ctr::Product( 1, term ) );
<a name="l00712"></a>00712       }
<a name="l00713"></a>00713       <a class="code" href="namespacetk_1_1grm.html#a1b809dbbd954026ab2bc003ec27a80f2" title="Out-of-struct storage of field ID for pushing terms for statistics.">field</a> = 0;            <span class="comment">// reset default field</span>
<a name="l00714"></a>00714     }
<a name="l00715"></a>00715   };
<a name="l00716"></a>00716 <span class="comment"></span>
<a name="l00717"></a>00717 <span class="comment">  //! \brief Add matched value as Term into vector of vector of PDFs</span>
<a name="l00718"></a>00718 <span class="comment">  //! \author J. Bakosi</span>
<a name="l00719"></a>00719 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class</span> Stack, tk::ctr::Moment m &gt;
<a name="l00720"></a><a class="code" href="structtk_1_1grm_1_1push__sample.html">00720</a>   <span class="keyword">struct </span><a class="code" href="structtk_1_1grm_1_1push__sample.html" title="Add matched value as Term into vector of vector of PDFs.">push_sample</a> : pegtl::<a class="code" href="classpegtl_1_1action__base.html">action_base</a>&lt; push_sample&lt; Stack, m &gt; &gt; {
<a name="l00721"></a><a class="code" href="structtk_1_1grm_1_1push__sample.html#a9025a58a94b0a514078545b3fcd8afca">00721</a>     <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structtk_1_1grm_1_1push__sample.html#a9025a58a94b0a514078545b3fcd8afca">apply</a>( <span class="keyword">const</span> std::string&amp; value, Stack&amp; stack ) {
<a name="l00722"></a>00722       <span class="comment">// Use a shorthand of reference to vector to push_back to</span>
<a name="l00723"></a>00723       <span class="keyword">auto</span>&amp; <a class="code" href="namespacetk_1_1ctr.html#a1ae4f5b7ac9b69c29ce96ee87042e499" title="Function for writing PDF sample space variables to output streams.">pdf</a> = stack.template get&lt; tag::pdf &gt;();
<a name="l00724"></a>00724       <span class="comment">// Error out if sample space already has at least 3 dimensions</span>
<a name="l00725"></a>00725       <span class="keywordflow">if</span> ( <a class="code" href="namespacetk_1_1ctr.html#a1ae4f5b7ac9b69c29ce96ee87042e499" title="Function for writing PDF sample space variables to output streams.">pdf</a>.back().size() &gt;= 3 ) {
<a name="l00726"></a>00726         Message&lt; Stack, ERROR, MsgKey::MAXSAMPLES &gt;( stack, value );
<a name="l00727"></a>00727       }
<a name="l00728"></a>00728       <span class="comment">// Error out if matched sample space variable starts with a digit</span>
<a name="l00729"></a>00729       <span class="keywordflow">if</span> ( std::isdigit(value[0]) )
<a name="l00730"></a>00730         Message&lt; Stack, ERROR, MsgKey::MALFORMEDSAMPLE &gt;( stack, value );
<a name="l00731"></a>00731       <span class="comment">// Push term into current vector</span>
<a name="l00732"></a>00732       <a class="code" href="namespacetk_1_1ctr.html#a1ae4f5b7ac9b69c29ce96ee87042e499" title="Function for writing PDF sample space variables to output streams.">pdf</a>.back().emplace_back( <a class="code" href="structtk_1_1ctr_1_1_term.html" title="Term is a Moment of a quantity with a field ID to be ensemble averaged.">tk::ctr::Term</a>( value[0], <a class="code" href="namespacetk_1_1grm.html#a1b809dbbd954026ab2bc003ec27a80f2" title="Out-of-struct storage of field ID for pushing terms for statistics.">field</a>, m ) );
<a name="l00733"></a>00733       <span class="comment">// If central moment, trigger estimation of mean (in statistics)</span>
<a name="l00734"></a>00734       <span class="keywordflow">if</span> (m == <a class="code" href="namespacetk_1_1ctr.html#a0810374f0c22a0bd157d9ff8bc9d0a60ace122858bb821c10699d9e484c897127" title="Fluctuation.">tk::ctr::Moment::CENTRAL</a>) {
<a name="l00735"></a>00735         <a class="code" href="structtk_1_1ctr_1_1_term.html" title="Term is a Moment of a quantity with a field ID to be ensemble averaged.">tk::ctr::Term</a> <a class="code" href="structtk_1_1grm_1_1term.html" title="term: upper or lowercase fieldvar matched to selected depvars for stats">term</a>( static_cast&lt;char&gt;(toupper(value[0])),
<a name="l00736"></a>00736                             <a class="code" href="namespacetk_1_1grm.html#a1b809dbbd954026ab2bc003ec27a80f2" title="Out-of-struct storage of field ID for pushing terms for statistics.">field</a>,
<a name="l00737"></a>00737                             <a class="code" href="namespacetk_1_1ctr.html#a0810374f0c22a0bd157d9ff8bc9d0a60a07e3ada6004b214beb21caf6492eec6f" title="Full variable.">tk::ctr::Moment::ORDINARY</a> );
<a name="l00738"></a>00738         <span class="keyword">auto</span>&amp; stats = stack.template get&lt; tag::stat &gt;();
<a name="l00739"></a>00739         <span class="keywordflow">if</span> (!stats.empty())
<a name="l00740"></a>00740           stats.insert( stats.end()-1, tk::ctr::Product( 1, term ) );
<a name="l00741"></a>00741         <span class="keywordflow">else</span>
<a name="l00742"></a>00742           stats.emplace_back( tk::ctr::Product( 1, term ) );
<a name="l00743"></a>00743       }
<a name="l00744"></a>00744       <a class="code" href="namespacetk_1_1grm.html#a1b809dbbd954026ab2bc003ec27a80f2" title="Out-of-struct storage of field ID for pushing terms for statistics.">field</a> = 0;            <span class="comment">// reset default field</span>
<a name="l00745"></a>00745     }
<a name="l00746"></a>00746   };
<a name="l00747"></a>00747 <span class="comment"></span>
<a name="l00748"></a>00748 <span class="comment">  //! \brief Push matched value into vector of vector binsizes</span>
<a name="l00749"></a>00749 <span class="comment">  //! \author J. Bakosi</span>
<a name="l00750"></a>00750 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class</span> Stack &gt;
<a name="l00751"></a><a class="code" href="structtk_1_1grm_1_1push__binsize.html">00751</a>   <span class="keyword">struct </span><a class="code" href="structtk_1_1grm_1_1push__binsize.html" title="Push matched value into vector of vector binsizes.">push_binsize</a> : pegtl::<a class="code" href="classpegtl_1_1action__base.html">action_base</a>&lt; push_binsize&lt; Stack &gt; &gt; {
<a name="l00752"></a><a class="code" href="structtk_1_1grm_1_1push__binsize.html#a39736aa1c9ae77f984733df9cc9e5419">00752</a>     <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structtk_1_1grm_1_1push__binsize.html#a39736aa1c9ae77f984733df9cc9e5419">apply</a>( <span class="keyword">const</span> std::string&amp; value, Stack&amp; stack ) {
<a name="l00753"></a>00753       <span class="comment">// Use a shorthand of reference to vector to push_back to</span>
<a name="l00754"></a>00754       <span class="keyword">auto</span>&amp; bins = stack.template get&lt; tag::discr, tag::binsize &gt;().back();
<a name="l00755"></a>00755       <span class="comment">// Error out if binsize vector already has at least 3 dimensions</span>
<a name="l00756"></a>00756       <span class="keywordflow">if</span> ( bins.size() &gt;= 3 ) {
<a name="l00757"></a>00757         Message&lt; Stack, ERROR, MsgKey::MAXBINSIZES &gt;( stack, value );
<a name="l00758"></a>00758       }
<a name="l00759"></a>00759       <span class="comment">// Push term into vector if larger than zero</span>
<a name="l00760"></a>00760       <span class="keyword">const</span> <span class="keyword">auto</span>&amp; binsize = stack.template convert&lt; tk::real &gt;( value );
<a name="l00761"></a>00761       <span class="keywordflow">if</span> ( !(binsize &gt; std::numeric_limits&lt; tk::real &gt;::epsilon()) )
<a name="l00762"></a>00762         Message&lt; Stack, ERROR, MsgKey::ZEROBINSIZE &gt;( stack, value );
<a name="l00763"></a>00763       <span class="keywordflow">else</span>
<a name="l00764"></a>00764         bins.emplace_back( binsize );
<a name="l00765"></a>00765     }
<a name="l00766"></a>00766   };
<a name="l00767"></a>00767 <span class="comment"></span>
<a name="l00768"></a>00768 <span class="comment">  //! \brief Push matched value into vector of PDF extents</span>
<a name="l00769"></a>00769 <span class="comment">  //! \author J. Bakosi</span>
<a name="l00770"></a>00770 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class</span> Stack &gt;
<a name="l00771"></a><a class="code" href="structtk_1_1grm_1_1push__extents.html">00771</a>   <span class="keyword">struct </span><a class="code" href="structtk_1_1grm_1_1push__extents.html" title="Push matched value into vector of PDF extents.">push_extents</a> : pegtl::<a class="code" href="classpegtl_1_1action__base.html">action_base</a>&lt; push_extents&lt; Stack &gt; &gt; {
<a name="l00772"></a><a class="code" href="structtk_1_1grm_1_1push__extents.html#ad7e8150834046e4b93a6e041f85f0411">00772</a>     <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structtk_1_1grm_1_1push__extents.html#ad7e8150834046e4b93a6e041f85f0411">apply</a>( <span class="keyword">const</span> std::string&amp; value, Stack&amp; stack ) {
<a name="l00773"></a>00773       <span class="comment">// Use a shorthand of reference to vector to push_back to</span>
<a name="l00774"></a>00774       <span class="keyword">auto</span>&amp; vec = stack.template get&lt; tag::discr, tag::extent &gt;().back();
<a name="l00775"></a>00775       <span class="comment">// Error out if extents vector already has at least 3 pairs</span>
<a name="l00776"></a>00776       <span class="keywordflow">if</span> (vec.size() &gt;= 6)
<a name="l00777"></a>00777         Message&lt; Stack, ERROR, MsgKey::MAXEXTENTS &gt;( stack, value );
<a name="l00778"></a>00778       <span class="comment">// Error out if extents vector already has the enough pairs to match the</span>
<a name="l00779"></a>00779       <span class="comment">// number of sample space dimensions</span>
<a name="l00780"></a>00780       <span class="keywordflow">if</span> (vec.size() &gt;=
<a name="l00781"></a>00781           stack.template get&lt; tag::discr, tag::binsize &gt;().back().size() * 2) {
<a name="l00782"></a>00782         Message&lt; Stack, ERROR, MsgKey::INVALIDEXTENT &gt;( stack, value );
<a name="l00783"></a>00783       }
<a name="l00784"></a>00784       <span class="comment">// Push extent into vector</span>
<a name="l00785"></a>00785       vec.emplace_back( stack.template convert&lt; tk::real &gt;( value ) );
<a name="l00786"></a>00786     }
<a name="l00787"></a>00787   };
<a name="l00788"></a>00788 <span class="comment"></span>
<a name="l00789"></a>00789 <span class="comment">  //! \brief Check parameter vector</span>
<a name="l00790"></a>00790 <span class="comment">  //! \author J. Bakosi</span>
<a name="l00791"></a>00791 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class</span> Stack, <span class="keyword">class</span> eq, <span class="keyword">class</span> param &gt;
<a name="l00792"></a><a class="code" href="structtk_1_1grm_1_1check__vector.html">00792</a>   <span class="keyword">struct </span><a class="code" href="structtk_1_1grm_1_1check__vector.html" title="Check parameter vector.">check_vector</a> : pegtl::<a class="code" href="classpegtl_1_1action__base.html">action_base</a>&lt; check_vector&lt; Stack, eq, param &gt; &gt; {
<a name="l00793"></a><a class="code" href="structtk_1_1grm_1_1check__vector.html#a60541538f9442bc0924303a8dc1e0fff">00793</a>     <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structtk_1_1grm_1_1check__vector.html#a60541538f9442bc0924303a8dc1e0fff">apply</a>( <span class="keyword">const</span> std::string&amp; value, Stack&amp; stack ) {}
<a name="l00794"></a>00794   };
<a name="l00795"></a>00795 <span class="comment"></span>
<a name="l00796"></a>00796 <span class="comment">  //! \brief Check if the spikes parameter vector specifications are correct</span>
<a name="l00797"></a>00797 <span class="comment">  //! \details Spikes are used to specify sample-space locations and relative</span>
<a name="l00798"></a>00798 <span class="comment">  //!    probability heights for a joint-delta PDF.</span>
<a name="l00799"></a>00799 <span class="comment">  //! \author J. Bakosi</span>
<a name="l00800"></a>00800 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class</span> Stack, <span class="keyword">class</span> eq, <span class="keyword">class</span> param &gt;
<a name="l00801"></a><a class="code" href="structtk_1_1grm_1_1check__spikes.html">00801</a>   <span class="keyword">struct </span><a class="code" href="structtk_1_1grm_1_1check__spikes.html" title="Check if the spikes parameter vector specifications are correct.">check_spikes</a> : pegtl::<a class="code" href="classpegtl_1_1action__base.html">action_base</a>&lt; check_spikes&lt; Stack, eq, param &gt; &gt; {
<a name="l00802"></a><a class="code" href="structtk_1_1grm_1_1check__spikes.html#aed51c75b4a7e012d3522a0ce5ac8c42b">00802</a>     <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structtk_1_1grm_1_1check__spikes.html#aed51c75b4a7e012d3522a0ce5ac8c42b">apply</a>( <span class="keyword">const</span> std::string&amp; value, Stack&amp; stack ) {
<a name="l00803"></a>00803       <span class="keyword">const</span> <span class="keyword">auto</span>&amp; spike =
<a name="l00804"></a>00804         stack.template get&lt; tag::param, eq, param &gt;().back().back();
<a name="l00805"></a>00805       <span class="comment">// Error out if the number of spikes-vector is odd</span>
<a name="l00806"></a>00806       <span class="keywordflow">if</span> (spike.size() % 2)
<a name="l00807"></a>00807         Message&lt; Stack, ERROR, MsgKey::ODDSPIKES &gt;( stack, value );
<a name="l00808"></a>00808       <span class="comment">// Error out if the sum of spike heights does not add up to unity, but</span>
<a name="l00809"></a>00809       <span class="comment">// only if the spike block is not empty (an empty spike..end block</span>
<a name="l00810"></a>00810       <span class="comment">// is okay and is used to specify no delta spikes for a dependent</span>
<a name="l00811"></a>00811       <span class="comment">// variable).</span>
<a name="l00812"></a>00812       <span class="keywordflow">if</span> (!spike.empty()) {
<a name="l00813"></a>00813         tk::real sum = 0.0;
<a name="l00814"></a>00814         <span class="keywordflow">for</span> (std::size_t i=1; i&lt;spike.size(); i+=2)  <span class="comment">// every even is a height</span>
<a name="l00815"></a>00815           sum += spike[i];
<a name="l00816"></a>00816         <span class="keywordflow">if</span> (std::abs(sum-1.0) &gt; std::numeric_limits&lt; tk::real &gt;::epsilon())
<a name="l00817"></a>00817           Message&lt; Stack, ERROR, MsgKey::HEIGHTSPIKES &gt;( stack, value );
<a name="l00818"></a>00818       }
<a name="l00819"></a>00819     }
<a name="l00820"></a>00820   };
<a name="l00821"></a>00821 <span class="comment"></span>
<a name="l00822"></a>00822 <span class="comment">  //! \brief Check if the betapdf parameter vector specifications are correct</span>
<a name="l00823"></a>00823 <span class="comment">  //! \details Betapdf vectors are used to configure univariate beta</span>
<a name="l00824"></a>00824 <span class="comment">  //!   distributions.</span>
<a name="l00825"></a>00825 <span class="comment">  //! \author J. Bakosi</span>
<a name="l00826"></a>00826 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class</span> Stack, <span class="keyword">class</span> eq, <span class="keyword">class</span> param &gt;
<a name="l00827"></a><a class="code" href="structtk_1_1grm_1_1check__betapdfs.html">00827</a>   <span class="keyword">struct </span><a class="code" href="structtk_1_1grm_1_1check__betapdfs.html" title="Check if the betapdf parameter vector specifications are correct.">check_betapdfs</a> :
<a name="l00828"></a>00828     pegtl::<a class="code" href="classpegtl_1_1action__base.html">action_base</a>&lt; check_betapdfs&lt; Stack, eq, param &gt; &gt;
<a name="l00829"></a>00829   {
<a name="l00830"></a><a class="code" href="structtk_1_1grm_1_1check__betapdfs.html#a1af65df1d456acfbbe0e94081380c0d0">00830</a>     <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structtk_1_1grm_1_1check__betapdfs.html#a1af65df1d456acfbbe0e94081380c0d0">apply</a>( <span class="keyword">const</span> std::string&amp; value, Stack&amp; stack ) {
<a name="l00831"></a>00831       <span class="keyword">const</span> <span class="keyword">auto</span>&amp; betapdf =
<a name="l00832"></a>00832         stack.template get&lt; tag::param, eq, param &gt;().back().back();
<a name="l00833"></a>00833       <span class="comment">// Error out if the number parameters is not four</span>
<a name="l00834"></a>00834       <span class="keywordflow">if</span> (betapdf.size() != 4)
<a name="l00835"></a>00835         Message&lt; Stack, ERROR, MsgKey::WRONGBETAPDF &gt;( stack, value );
<a name="l00836"></a>00836     }
<a name="l00837"></a>00837   };
<a name="l00838"></a>00838 <span class="comment"></span>
<a name="l00839"></a>00839 <span class="comment">  //! \brief Check if there is at least one variable in expectation</span>
<a name="l00840"></a>00840 <span class="comment">  //! \author J. Bakosi</span>
<a name="l00841"></a>00841 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class</span> Stack &gt;
<a name="l00842"></a><a class="code" href="structtk_1_1grm_1_1check__expectation.html">00842</a>   <span class="keyword">struct </span><a class="code" href="structtk_1_1grm_1_1check__expectation.html" title="Check if there is at least one variable in expectation.">check_expectation</a> : pegtl::<a class="code" href="classpegtl_1_1action__base.html">action_base</a>&lt; check_expectation&lt; Stack &gt; &gt; {
<a name="l00843"></a><a class="code" href="structtk_1_1grm_1_1check__expectation.html#a744723e2902118e91ca89a54d3ceaa84">00843</a>     <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structtk_1_1grm_1_1check__expectation.html#a744723e2902118e91ca89a54d3ceaa84">apply</a>( <span class="keyword">const</span> std::string&amp; value, Stack&amp; stack ) {
<a name="l00844"></a>00844       <span class="keywordflow">if</span> (stack.template get&lt; tag::stat &gt;().back().empty())
<a name="l00845"></a>00845         Message&lt; Stack, ERROR, MsgKey::NOTERMS &gt;( stack, value );
<a name="l00846"></a>00846     }
<a name="l00847"></a>00847   };
<a name="l00848"></a>00848 <span class="comment"></span>
<a name="l00849"></a>00849 <span class="comment">  //! \brief Check if the number of binsizes equal the PDF sample space</span>
<a name="l00850"></a>00850 <span class="comment">  //!   variables</span>
<a name="l00851"></a>00851 <span class="comment">  //! \author J. Bakosi</span>
<a name="l00852"></a>00852 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class</span> Stack &gt;
<a name="l00853"></a><a class="code" href="structtk_1_1grm_1_1check__binsizes.html">00853</a>   <span class="keyword">struct </span><a class="code" href="structtk_1_1grm_1_1check__binsizes.html" title="Check if the number of binsizes equal the PDF sample space variables.">check_binsizes</a> : pegtl::<a class="code" href="classpegtl_1_1action__base.html">action_base</a>&lt; check_binsizes&lt; Stack &gt; &gt; {
<a name="l00854"></a><a class="code" href="structtk_1_1grm_1_1check__binsizes.html#a3cec5324440e55416da4eb3b626508a6">00854</a>     <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structtk_1_1grm_1_1check__binsizes.html#a3cec5324440e55416da4eb3b626508a6">apply</a>( <span class="keyword">const</span> std::string&amp; value, Stack&amp; stack ) {
<a name="l00855"></a>00855       <span class="keywordflow">if</span> (stack.template get&lt; tag::pdf &gt;().back().size() !=
<a name="l00856"></a>00856           stack.template get&lt; tag::discr, tag::binsize &gt;().back().size())
<a name="l00857"></a>00857           Message&lt; Stack, ERROR, MsgKey::BINSIZES &gt;( stack, value );
<a name="l00858"></a>00858     }
<a name="l00859"></a>00859   };
<a name="l00860"></a>00860 <span class="comment"></span>
<a name="l00861"></a>00861 <span class="comment">  //! \brief Check if the number of extents equal 2 * the PDF sample space</span>
<a name="l00862"></a>00862 <span class="comment">  //!    variables</span>
<a name="l00863"></a>00863 <span class="comment">  //! \author J. Bakosi</span>
<a name="l00864"></a>00864 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class</span> Stack &gt;
<a name="l00865"></a><a class="code" href="structtk_1_1grm_1_1check__extents.html">00865</a>   <span class="keyword">struct </span><a class="code" href="structtk_1_1grm_1_1check__extents.html" title="Check if the number of extents equal 2 * the PDF sample space variables.">check_extents</a> : pegtl::<a class="code" href="classpegtl_1_1action__base.html">action_base</a>&lt; check_extents&lt; Stack &gt; &gt; {
<a name="l00866"></a><a class="code" href="structtk_1_1grm_1_1check__extents.html#a5bca86ddd25a5ca3876884e24aeabddd">00866</a>     <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structtk_1_1grm_1_1check__extents.html#a5bca86ddd25a5ca3876884e24aeabddd">apply</a>( <span class="keyword">const</span> std::string&amp; value, Stack&amp; stack ) {
<a name="l00867"></a>00867       <span class="comment">// Use a shorthand to extents vector</span>
<a name="l00868"></a>00868       <span class="keyword">const</span> <span class="keyword">auto</span>&amp; e = stack.template get&lt; tag::discr, tag::extent &gt;().back();
<a name="l00869"></a>00869       <span class="comment">// Check if the number of extents are correct</span>
<a name="l00870"></a>00870       <span class="keywordflow">if</span> (!e.empty() &amp;&amp;
<a name="l00871"></a>00871           e.size() !=
<a name="l00872"></a>00872             stack.template get&lt; tag::discr, tag::binsize &gt;().back().size()*2)
<a name="l00873"></a>00873         Message&lt; Stack, ERROR, MsgKey::INVALIDEXTENT &gt;( stack, value );
<a name="l00874"></a>00874       <span class="comment">// Check if the lower extents are indeed lower than the higher extents</span>
<a name="l00875"></a>00875       <span class="keywordflow">if</span> (e.size() &gt; 1 &amp;&amp; e[0] &gt; e[1])
<a name="l00876"></a>00876         Message&lt; Stack, ERROR, MsgKey::EXTENTLOWER &gt;( stack, value );
<a name="l00877"></a>00877       <span class="keywordflow">if</span> (e.size() &gt; 3 &amp;&amp; e[2] &gt; e[3])
<a name="l00878"></a>00878         Message&lt; Stack, ERROR, MsgKey::EXTENTLOWER &gt;( stack, value );
<a name="l00879"></a>00879       <span class="keywordflow">if</span> (e.size() &gt; 5 &amp;&amp; e[4] &gt; e[5])
<a name="l00880"></a>00880         Message&lt; Stack, ERROR, MsgKey::EXTENTLOWER &gt;( stack, value );
<a name="l00881"></a>00881     }
<a name="l00882"></a>00882   };
<a name="l00883"></a>00883 <span class="comment"></span>
<a name="l00884"></a>00884 <span class="comment">  //! \brief Check if there is at least one sample space variable in PDF</span>
<a name="l00885"></a>00885 <span class="comment">  //! \author J. Bakosi</span>
<a name="l00886"></a>00886 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class</span> Stack &gt;
<a name="l00887"></a><a class="code" href="structtk_1_1grm_1_1check__samples.html">00887</a>   <span class="keyword">struct </span><a class="code" href="structtk_1_1grm_1_1check__samples.html" title="Check if there is at least one sample space variable in PDF.">check_samples</a> : pegtl::<a class="code" href="classpegtl_1_1action__base.html">action_base</a>&lt; check_samples&lt; Stack &gt; &gt; {
<a name="l00888"></a><a class="code" href="structtk_1_1grm_1_1check__samples.html#abbaf8ff3984b9c5dee502650011eba29">00888</a>     <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structtk_1_1grm_1_1check__samples.html#abbaf8ff3984b9c5dee502650011eba29">apply</a>( <span class="keyword">const</span> std::string&amp; value, Stack&amp; stack ) {
<a name="l00889"></a>00889       <span class="keywordflow">if</span> (stack.template get&lt; tag::pdf &gt;().back().empty())
<a name="l00890"></a>00890         Message&lt; Stack, ERROR, MsgKey::NOSAMPLES &gt;( stack, value );
<a name="l00891"></a>00891     }
<a name="l00892"></a>00892   };
<a name="l00893"></a>00893 <span class="comment"></span>
<a name="l00894"></a>00894 <span class="comment">  //! \brief Save field ID to parser&#39;s state so push_term can pick it up</span>
<a name="l00895"></a>00895 <span class="comment">  //! \author J. Bakosi</span>
<a name="l00896"></a>00896 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class</span> Stack &gt;
<a name="l00897"></a><a class="code" href="structtk_1_1grm_1_1save__field.html">00897</a>   <span class="keyword">struct </span><a class="code" href="structtk_1_1grm_1_1save__field.html" title="Save field ID to parser&#39;s state so push_term can pick it up.">save_field</a> : pegtl::<a class="code" href="classpegtl_1_1action__base.html">action_base</a>&lt; save_field&lt; Stack &gt; &gt; {
<a name="l00898"></a><a class="code" href="structtk_1_1grm_1_1save__field.html#a0dd69e3ff94b566ad0b21f15ba514010">00898</a>     <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="structtk_1_1grm_1_1save__field.html#a0dd69e3ff94b566ad0b21f15ba514010">apply</a>( <span class="keyword">const</span> std::string&amp; value, Stack&amp; stack ) {
<a name="l00899"></a>00899       <span class="comment">// field ID numbers start at 0</span>
<a name="l00900"></a>00900       <span class="keyword">auto</span> f = stack.template convert&lt; long &gt;( value ) - 1; 
<a name="l00901"></a>00901       <a class="code" href="_exception_8h.html#a6e509ba096551a0924ec024afadba810" title="Assert macro that only throws an exception if expr fails.">Assert</a>( f&gt;=0, <span class="stringliteral">&quot;Field value must be non-negative in tk::grm::save_field&quot;</span> );
<a name="l00902"></a>00902       <a class="code" href="namespacetk_1_1grm.html#a1b809dbbd954026ab2bc003ec27a80f2" title="Out-of-struct storage of field ID for pushing terms for statistics.">field</a> = <span class="keyword">static_cast&lt;</span> ncomp_t <span class="keyword">&gt;</span>( f );
<a name="l00903"></a>00903     }
<a name="l00904"></a>00904   };
<a name="l00905"></a>00905 
<a name="l00906"></a>00906   <span class="comment">// Common grammar (grammar that is reused by multiple grammars)</span>
<a name="l00907"></a>00907 <span class="comment"></span>
<a name="l00908"></a>00908 <span class="comment">  //! \brief Read &#39;token&#39; until &#39;erased&#39; trimming, i.e., not consuming, &#39;erased&#39;</span>
<a name="l00909"></a>00909 <span class="comment">  //! \author J. Bakosi</span>
<a name="l00910"></a>00910 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class</span> Stack, <span class="keyword">class</span> token, <span class="keyword">class</span> erased &gt;
<a name="l00911"></a><a class="code" href="structtk_1_1grm_1_1trim.html">00911</a>   <span class="keyword">struct </span><a class="code" href="structtk_1_1grm_1_1trim.html" title="Read &#39;token&#39; until &#39;erased&#39; trimming, i.e., not consuming, &#39;erased&#39;.">trim</a> :
<a name="l00912"></a>00912          pegtl::seq&lt; token,
<a name="l00913"></a>00913                      pegtl::sor&lt;
<a name="l00914"></a>00914                        pegtl::until&lt; pegtl::at&lt; erased &gt; &gt;,
<a name="l00915"></a>00915                        pegtl::apply&lt; error&lt; Stack, MsgKey::PREMATURE &gt; &gt; &gt; &gt; {};
<a name="l00916"></a>00916 <span class="comment"></span>
<a name="l00917"></a>00917 <span class="comment">  //! \brief Match unknown keyword and handle error</span>
<a name="l00918"></a>00918 <span class="comment">  //! \author J. Bakosi</span>
<a name="l00919"></a>00919 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class</span> Stack, MsgKey key, <span class="keyword">template</span>&lt; <span class="keyword">class</span>, MsgKey &gt; <span class="keyword">class </span>msg &gt;
<a name="l00920"></a><a class="code" href="structtk_1_1grm_1_1unknown.html">00920</a>   <span class="keyword">struct </span><a class="code" href="structtk_1_1grm_1_1unknown.html" title="Match unknown keyword and handle error.">unknown</a> :
<a name="l00921"></a>00921          pegtl::<a class="code" href="classpegtl_1_1pad.html">pad</a>&lt; pegtl::ifapply&lt; trim&lt; Stack, pegtl::any, pegtl::space &gt;,
<a name="l00922"></a>00922                                      msg&lt; Stack, key &gt; &gt;,
<a name="l00923"></a>00923                      pegtl::blank,
<a name="l00924"></a>00924                      pegtl::space &gt; {};
<a name="l00925"></a>00925 <span class="comment"></span>
<a name="l00926"></a>00926 <span class="comment">  //! \brief Match alias cmdline keyword</span>
<a name="l00927"></a>00927 <span class="comment">  //! \details An alias command line keyword is prefixed by a single dash, &#39;-&#39;.</span>
<a name="l00928"></a>00928 <span class="comment">  //! \author J. Bakosi</span>
<a name="l00929"></a>00929 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class</span> Stack, <span class="keyword">class</span> keyword &gt;
<a name="l00930"></a><a class="code" href="structtk_1_1grm_1_1alias.html">00930</a>   <span class="keyword">struct </span><a class="code" href="structtk_1_1grm_1_1alias.html" title="Match alias cmdline keyword.">alias</a> :
<a name="l00931"></a>00931          pegtl::seq&lt;
<a name="l00932"></a>00932            pegtl::one&lt; &#39;-&#39; &gt;,
<a name="l00933"></a>00933            typename keyword::info::alias::type,
<a name="l00934"></a>00934            pegtl::sor&lt; pegtl::space,
<a name="l00935"></a>00935                        pegtl::apply&lt; error&lt; Stack, MsgKey::ALIAS &gt; &gt; &gt; &gt; {};
<a name="l00936"></a>00936 <span class="comment"></span>
<a name="l00937"></a>00937 <span class="comment">  //! \brief Match verbose cmdline keyword</span>
<a name="l00938"></a>00938 <span class="comment">  //! \details A verbose command line keyword is prefixed by a double-dash,</span>
<a name="l00939"></a>00939 <span class="comment">  //!   &#39;--&#39;.</span>
<a name="l00940"></a>00940 <span class="comment">  //! \author J. Bakosi</span>
<a name="l00941"></a>00941 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class</span> keyword &gt;
<a name="l00942"></a><a class="code" href="structtk_1_1grm_1_1verbose.html">00942</a>   <span class="keyword">struct </span><a class="code" href="structtk_1_1grm_1_1verbose.html" title="Match verbose cmdline keyword.">verbose</a> :
<a name="l00943"></a>00943          pegtl::seq&lt; pegtl::string&lt;&#39;-&#39;,&#39;-&#39;&gt;,
<a name="l00944"></a>00944                      typename keyword::pegtl_string,
<a name="l00945"></a>00945                      pegtl::space &gt; {};
<a name="l00946"></a>00946 <span class="comment"></span>
<a name="l00947"></a>00947 <span class="comment">  //! \brief Read keyword &#39;token&#39; padded by blank at left and space at right</span>
<a name="l00948"></a>00948 <span class="comment">  //! \author J. Bakosi</span>
<a name="l00949"></a>00949 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class</span> Stack, <span class="keyword">class</span> token &gt;
<a name="l00950"></a><a class="code" href="structtk_1_1grm_1_1readkw.html">00950</a>   <span class="keyword">struct </span><a class="code" href="structtk_1_1grm_1_1readkw.html" title="Read keyword &#39;token&#39; padded by blank at left and space at right.">readkw</a> :
<a name="l00951"></a>00951          pegtl::<a class="code" href="classpegtl_1_1pad.html">pad</a>&lt; trim&lt; Stack, token, pegtl::space &gt;,
<a name="l00952"></a>00952                      pegtl::blank,
<a name="l00953"></a>00953                      pegtl::space &gt; {};
<a name="l00954"></a>00954 <span class="comment"></span>
<a name="l00955"></a>00955 <span class="comment">  //! \brief Read command line &#39;keyword&#39; in verbose form, i.e., &#39;--keyword&#39;</span>
<a name="l00956"></a>00956 <span class="comment">  //! \details This version is used if no alias is defined for the given keyword</span>
<a name="l00957"></a>00957 <span class="comment">  //! \author J. Bakosi</span>
<a name="l00958"></a>00958 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class</span> Stack, <span class="keyword">class</span> keyword, <span class="keyword">typename</span> = <span class="keywordtype">void</span> &gt;
<a name="l00959"></a><a class="code" href="structtk_1_1grm_1_1readcmd.html">00959</a>   <span class="keyword">struct </span><a class="code" href="structtk_1_1grm_1_1readcmd.html" title="Read command line &#39;keyword&#39; in verbose form, i.e., &#39;--keyword&#39;.">readcmd</a> :
<a name="l00960"></a>00960          <a class="code" href="structtk_1_1grm_1_1verbose.html" title="Match verbose cmdline keyword.">verbose</a>&lt; keyword &gt; {};
<a name="l00961"></a>00961 <span class="comment"></span>
<a name="l00962"></a>00962 <span class="comment">  //! \brief Read command line &#39;keyword&#39; in either verbose or alias form</span>
<a name="l00963"></a>00963 <span class="comment">  //! \details This version is used if an alias is defined for the given</span>
<a name="l00964"></a>00964 <span class="comment">  //!   keyword, in which case either the verbose or the alias form of the</span>
<a name="l00965"></a>00965 <span class="comment">  //!   keyword is matched, i.e., either &#39;--keyword&#39; or &#39;-a&#39;, where &#39;a&#39; is the</span>
<a name="l00966"></a>00966 <span class="comment">  //!   single-character alias for the longer &#39;keyword&#39;. This is a partial</span>
<a name="l00967"></a>00967 <span class="comment">  //!   specialization of the simpler verbose-only readcmd, which attempts to</span>
<a name="l00968"></a>00968 <span class="comment">  //!   find the typedef &#39;alias&#39; in keyword::info. If it finds it, it uses this</span>
<a name="l00969"></a>00969 <span class="comment">  //!   specialization. If it fails, it is [SFINAE]</span>
<a name="l00970"></a>00970 <span class="comment">  //!   (http://en.cppreference.com/w/cpp/language/sfinae), and falls back to</span>
<a name="l00971"></a>00971 <span class="comment">  //!   the verbose-only definition. Credit goes to David Rodriguez at</span>
<a name="l00972"></a>00972 <span class="comment">  //!   stackoverflow.com. This allows not having to change this client-code to</span>
<a name="l00973"></a>00973 <span class="comment">  //!   the keywords definitions: a keyword either defines an alias or not, and</span>
<a name="l00974"></a>00974 <span class="comment">  //!   the grammar here will do the right thing: if there is an alias, it will</span>
<a name="l00975"></a>00975 <span class="comment">  //!   build the grammar that optionally parses for it.</span>
<a name="l00976"></a>00976 <span class="comment">  //! \see tk::if_</span>
<a name="l00977"></a>00977 <span class="comment">  //! \see Control/Keyword.h and Control/Keywords.h</span>
<a name="l00978"></a>00978 <span class="comment">  //! \see http://en.cppreference.com/w/cpp/language/sfinae</span>
<a name="l00979"></a>00979 <span class="comment">  //! \see http://stackoverflow.com/a/11814074</span>
<a name="l00980"></a>00980 <span class="comment">  //! \author J. Bakosi</span>
<a name="l00981"></a>00981 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class</span> Stack, <span class="keyword">class</span> keyword &gt;
<a name="l00982"></a><a class="code" href="structtk_1_1grm_1_1readcmd_3_01_stack_00_01keyword_00_01typename_01if___3_01false_00_01typename_6c4a4d81424e1c6859b814d622a53cdb.html">00982</a>   <span class="keyword">struct </span><a class="code" href="structtk_1_1grm_1_1readcmd.html" title="Read command line &#39;keyword&#39; in verbose form, i.e., &#39;--keyword&#39;.">readcmd</a>&lt; Stack, keyword,
<a name="l00983"></a>00983                   typename <a class="code" href="structtk_1_1if__.html" title="Type selection: if_&lt; Condition, Then, Else &gt;::type.">if_</a>&lt; false, typename keyword::info::<a class="code" href="structtk_1_1grm_1_1alias.html" title="Match alias cmdline keyword.">alias</a> &gt;::type &gt; :
<a name="l00984"></a>00984          pegtl::sor&lt; verbose&lt; keyword &gt;, alias&lt; Stack, keyword &gt; &gt; {};
<a name="l00985"></a>00985 <span class="comment"></span>
<a name="l00986"></a>00986 <span class="comment">  //! \brief Scan input padded by blank at left and space at right and if it</span>
<a name="l00987"></a>00987 <span class="comment">  //!   matches &#39;keywords&#39;, apply &#39;actions&#39;</span>
<a name="l00988"></a>00988 <span class="comment">  //! \details As opposed to scan_until this rule, allows multiple actions</span>
<a name="l00989"></a>00989 <span class="comment">  //! \author J. Bakosi</span>
<a name="l00990"></a>00990 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class </span>Stack, <span class="keyword">class </span>keywords, <span class="keyword">class</span>... actions &gt;
<a name="l00991"></a><a class="code" href="structtk_1_1grm_1_1scan.html">00991</a>   <span class="keyword">struct </span><a class="code" href="structtk_1_1grm_1_1scan.html" title="Scan input padded by blank at left and space at right and if it matches &#39;keywords&#39;, apply &#39;actions&#39;.">scan</a> :
<a name="l00992"></a>00992            pegtl::<a class="code" href="classpegtl_1_1pad.html">pad</a>&lt; pegtl::ifapply&lt; trim&lt; Stack, keywords, pegtl::space &gt;,
<a name="l00993"></a>00993                                        actions... &gt;,
<a name="l00994"></a>00994                        pegtl::blank,
<a name="l00995"></a>00995                        pegtl::space &gt; {};
<a name="l00996"></a>00996 <span class="comment"></span>
<a name="l00997"></a>00997 <span class="comment">  //! \brief Scan input padded by blank at left and space at right and if it</span>
<a name="l00998"></a>00998 <span class="comment">  //!   matches &#39;keywords&#39;, apply &#39;action&#39;</span>
<a name="l00999"></a>00999 <span class="comment">  //! \details This version uses an additional custom end rule. As opposed</span>
<a name="l01000"></a>01000 <span class="comment">  //!   to scan, this rule allows an additional end-rule until which parsing is</span>
<a name="l01001"></a>01001 <span class="comment">  //!   continued. The additional custom end-rule is OR&#39;d to pegtl::space.</span>
<a name="l01002"></a>01002 <span class="comment">  //! \author J. Bakosi</span>
<a name="l01003"></a>01003 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class</span> Stack, <span class="keyword">class</span> keywords, <span class="keyword">class</span> action, <span class="keyword">class</span> end = pegtl::space &gt;
<a name="l01004"></a><a class="code" href="structtk_1_1grm_1_1scan__until.html">01004</a>   <span class="keyword">struct </span><a class="code" href="structtk_1_1grm_1_1scan__until.html" title="Scan input padded by blank at left and space at right and if it matches &#39;keywords&#39;, apply &#39;action&#39;.">scan_until</a> :
<a name="l01005"></a>01005          pegtl::<a class="code" href="classpegtl_1_1pad.html">pad</a>&lt; pegtl::ifapply&lt; trim&lt; Stack, keywords,
<a name="l01006"></a>01006                                            pegtl::sor&lt; pegtl::space, end &gt; &gt;,
<a name="l01007"></a>01007                                      action &gt;,
<a name="l01008"></a>01008                      pegtl::blank,
<a name="l01009"></a>01009                      pegtl::space &gt; {};
<a name="l01010"></a>01010 <span class="comment"></span>
<a name="l01011"></a>01011 <span class="comment">  //! \brief Parse comment: start with &#39;#&#39; until eol</span>
<a name="l01012"></a>01012 <span class="comment">  //! \author J. Bakosi</span>
<a name="l01013"></a>01013 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class</span> Stack &gt;
<a name="l01014"></a><a class="code" href="structtk_1_1grm_1_1comment.html">01014</a>   <span class="keyword">struct </span><a class="code" href="structtk_1_1grm_1_1comment.html" title="Parse comment: start with &#39;#&#39; until eol.">comment</a> :
<a name="l01015"></a>01015          pegtl::<a class="code" href="classpegtl_1_1pad.html">pad</a>&lt; trim&lt; Stack, pegtl::one&lt;&#39;#&#39;&gt;, pegtl::eol &gt;,
<a name="l01016"></a>01016                      pegtl::blank,
<a name="l01017"></a>01017                      pegtl::eol &gt; {};
<a name="l01018"></a>01018 <span class="comment"></span>
<a name="l01019"></a>01019 <span class="comment">  //! \brief Ignore comments and empty lines</span>
<a name="l01020"></a>01020 <span class="comment">  //! \author J. Bakosi</span>
<a name="l01021"></a>01021 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class</span> Stack &gt;
<a name="l01022"></a><a class="code" href="structtk_1_1grm_1_1ignore.html">01022</a>   <span class="keyword">struct </span><a class="code" href="structtk_1_1grm_1_1ignore.html" title="Ignore comments and empty lines.">ignore</a> :
<a name="l01023"></a>01023          pegtl::sor&lt; comment&lt; Stack &gt;, pegtl::until&lt; pegtl::eol, pegtl::space &gt; &gt; {};
<a name="l01024"></a>01024 <span class="comment"></span>
<a name="l01025"></a>01025 <span class="comment">  //! \brief Parse a number: an optional sign followed by digits</span>
<a name="l01026"></a>01026 <span class="comment">  //! \author J. Bakosi</span>
<a name="l01027"></a><a class="code" href="structtk_1_1grm_1_1number.html">01027</a> <span class="comment"></span>  <span class="keyword">struct </span><a class="code" href="structtk_1_1grm_1_1number.html" title="Parse a number: an optional sign followed by digits.">number</a> :
<a name="l01028"></a>01028          pegtl::seq&lt; pegtl::opt&lt; pegtl::sor&lt; pegtl::one&lt;&#39;+&#39;&gt;,
<a name="l01029"></a>01029                                              pegtl::one&lt;&#39;-&#39;&gt; &gt; &gt;,
<a name="l01030"></a>01030                      pegtl::digit &gt; {};
<a name="l01031"></a>01031 <span class="comment"></span>
<a name="l01032"></a>01032 <span class="comment">  //! \brief Plow through &#39;tokens&#39; until &#39;endkeyword&#39;</span>
<a name="l01033"></a>01033 <span class="comment">  //! \author J. Bakosi</span>
<a name="l01034"></a>01034 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class </span>Stack, <span class="keyword">class </span>endkeyword, <span class="keyword">typename</span>... tokens &gt;
<a name="l01035"></a><a class="code" href="structtk_1_1grm_1_1block.html">01035</a>   <span class="keyword">struct </span><a class="code" href="structtk_1_1grm_1_1block.html" title="Plow through &#39;tokens&#39; until &#39;endkeyword&#39;.">block</a> :
<a name="l01036"></a>01036          pegtl::<a class="code" href="classpegtl_1_1until.html">until</a>&lt;
<a name="l01037"></a>01037            readkw&lt; Stack, typename endkeyword::pegtl_string &gt;,
<a name="l01038"></a>01038            pegtl::sor&lt; comment&lt; Stack &gt;,
<a name="l01039"></a>01039                        tokens...,
<a name="l01040"></a>01040                        unknown&lt; Stack, MsgKey::KEYWORD, error &gt; &gt; &gt; {};
<a name="l01041"></a>01041 <span class="comment"></span>
<a name="l01042"></a>01042 <span class="comment">  //! \brief Plow through vector of values between keywords &#39;key&#39; and</span>
<a name="l01043"></a>01043 <span class="comment">  //!   &#39;endkeyword&#39;, calling &#39;insert&#39; for each if matches and allow comments</span>
<a name="l01044"></a>01044 <span class="comment">  //!   between values</span>
<a name="l01045"></a>01045 <span class="comment">  //! \author J. Bakosi</span>
<a name="l01046"></a>01046 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class </span>Stack, <span class="keyword">class </span>key, <span class="keyword">class </span>insert, <span class="keyword">class </span>endkeyword,
<a name="l01047"></a>01047             <span class="keyword">class </span>starter, <span class="keyword">class </span>value = <a class="code" href="structtk_1_1grm_1_1number.html" title="Parse a number: an optional sign followed by digits.">number</a> &gt;
<a name="l01048"></a><a class="code" href="structtk_1_1grm_1_1vector.html">01048</a>   <span class="keyword">struct </span><a class="code" href="structtk_1_1grm_1_1vector.html" title="Plow through vector of values between keywords &#39;key&#39; and &#39;endkeyword&#39;, calling &#39;insert&#39; for each if m...">vector</a> :
<a name="l01049"></a>01049          pegtl::<a class="code" href="classpegtl_1_1ifmust.html">ifmust</a>&lt; readkw&lt; Stack, typename key::pegtl_string &gt;,
<a name="l01050"></a>01050                         starter,
<a name="l01051"></a>01051                         pegtl::until&lt;
<a name="l01052"></a>01052                           readkw&lt; Stack, typename endkeyword::pegtl_string &gt;,
<a name="l01053"></a>01053                           pegtl::sor&lt;
<a name="l01054"></a>01054                             comment&lt; Stack &gt;,
<a name="l01055"></a>01055                             scan&lt; Stack, value, insert &gt;,
<a name="l01056"></a>01056                             unknown&lt; Stack, MsgKey::LIST, error &gt; &gt; &gt; &gt; {};
<a name="l01057"></a>01057 <span class="comment"></span>
<a name="l01058"></a>01058 <span class="comment">  //! \brief Scan string between characters &#39;lbound&#39; and &#39;rbound&#39; and if matches</span>
<a name="l01059"></a>01059 <span class="comment">  //!   apply action &#39;insert&#39;</span>
<a name="l01060"></a>01060 <span class="comment">  //! \author J. Bakosi</span>
<a name="l01061"></a>01061 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class </span>Stack, <span class="keyword">class </span>insert, <span class="keywordtype">char</span> lbound = <span class="charliteral">&#39;&quot;&#39;</span>, <span class="keywordtype">char</span> rbound = <span class="charliteral">&#39;&quot;&#39;</span> &gt;
<a name="l01062"></a><a class="code" href="structtk_1_1grm_1_1quoted.html">01062</a>   <span class="keyword">struct </span><a class="code" href="structtk_1_1grm_1_1quoted.html" title="Scan string between characters &#39;lbound&#39; and &#39;rbound&#39; and if matches apply action &#39;insert&#39;.">quoted</a> :
<a name="l01063"></a>01063          pegtl::<a class="code" href="classpegtl_1_1ifmust.html">ifmust</a>&lt; pegtl::one&lt; lbound &gt;,
<a name="l01064"></a>01064                         pegtl::ifapply&lt;
<a name="l01065"></a>01065                           pegtl::sor&lt; trim&lt; Stack, pegtl::not_one&lt; lbound &gt;,
<a name="l01066"></a>01066                                             pegtl::one&lt; rbound &gt; &gt;,
<a name="l01067"></a>01067                                       unknown&lt; Stack, MsgKey::QUOTED, error &gt; &gt;,
<a name="l01068"></a>01068                         insert &gt;,
<a name="l01069"></a>01069                         pegtl::one&lt; rbound &gt; &gt; {};
<a name="l01070"></a>01070 <span class="comment"></span>
<a name="l01071"></a>01071 <span class="comment">  //! \brief Process &#39;keyword&#39; and call its &#39;insert&#39; action if matches &#39;kw_type&#39;</span>
<a name="l01072"></a>01072 <span class="comment">  //! \author J. Bakosi</span>
<a name="l01073"></a>01073 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class </span>Stack, <span class="keyword">class </span>keyword, <span class="keyword">class </span>insert,
<a name="l01074"></a>01074             <span class="keyword">class </span>kw_type = pegtl::digit &gt;
<a name="l01075"></a><a class="code" href="structtk_1_1grm_1_1process.html">01075</a>   <span class="keyword">struct </span><a class="code" href="structtk_1_1grm_1_1process.html" title="Process &#39;keyword&#39; and call its &#39;insert&#39; action if matches &#39;kw_type&#39;.">process</a> :
<a name="l01076"></a>01076          pegtl::<a class="code" href="classpegtl_1_1ifmust.html">ifmust</a>&lt; readkw&lt; Stack, typename keyword::pegtl_string &gt;,
<a name="l01077"></a>01077                         scan&lt; Stack, pegtl::sor&lt;
<a name="l01078"></a>01078                                 kw_type,
<a name="l01079"></a>01079                                 pegtl::apply&lt; error&lt; Stack,
<a name="l01080"></a>01080                                                      MsgKey::MISSING &gt; &gt; &gt;,
<a name="l01081"></a>01081                               insert &gt; &gt; {};
<a name="l01082"></a>01082 <span class="comment"></span>
<a name="l01083"></a>01083 <span class="comment">  //! \brief Process &#39;keyword&#39; and call its &#39;insert&#39; action for a string matched</span>
<a name="l01084"></a>01084 <span class="comment">  //!   between characters &#39;lbound&#39; and &#39;rbound&#39;</span>
<a name="l01085"></a>01085 <span class="comment">  //! \author J. Bakosi</span>
<a name="l01086"></a>01086 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class </span>Stack, <span class="keyword">class </span>keyword, <span class="keyword">class </span>insert, <span class="keywordtype">char</span> lbound=<span class="charliteral">&#39;&quot;&#39;</span>,
<a name="l01087"></a>01087             <span class="keywordtype">char</span> rbound=<span class="charliteral">&#39;&quot;&#39;</span> &gt;
<a name="l01088"></a><a class="code" href="structtk_1_1grm_1_1process__quoted.html">01088</a>   <span class="keyword">struct </span><a class="code" href="structtk_1_1grm_1_1process__quoted.html" title="Process &#39;keyword&#39; and call its &#39;insert&#39; action for a string matched between characters &#39;lbound&#39; and &#39;...">process_quoted</a> :
<a name="l01089"></a>01089          pegtl::<a class="code" href="classpegtl_1_1ifmust.html">ifmust</a>&lt; readkw&lt; Stack, keyword &gt;,
<a name="l01090"></a>01090                         pegtl::sor&lt;
<a name="l01091"></a>01091                           quoted&lt; Stack, insert, lbound, rbound &gt;,
<a name="l01092"></a>01092                           unknown&lt; Stack, MsgKey::QUOTED, error &gt; &gt; &gt; {};
<a name="l01093"></a>01093 <span class="comment"></span>
<a name="l01094"></a>01094 <span class="comment">  //! \brief Process command line &#39;keyword&#39; and call its &#39;insert&#39; action if</span>
<a name="l01095"></a>01095 <span class="comment">  //!   matches &#39;kw_type&#39;</span>
<a name="l01096"></a>01096 <span class="comment">  //! \author J. Bakosi</span>
<a name="l01097"></a>01097 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class </span>Stack, <span class="keyword">class </span>keyword, <span class="keyword">class </span>insert,
<a name="l01098"></a>01098             <span class="keyword">class </span>kw_type = pegtl::any &gt;
<a name="l01099"></a><a class="code" href="structtk_1_1grm_1_1process__cmd.html">01099</a>   <span class="keyword">struct </span><a class="code" href="structtk_1_1grm_1_1process__cmd.html" title="Process command line &#39;keyword&#39; and call its &#39;insert&#39; action if matches &#39;kw_type&#39;.">process_cmd</a> :
<a name="l01100"></a>01100          pegtl::<a class="code" href="classpegtl_1_1ifmust.html">ifmust</a>&lt; readcmd&lt; Stack, keyword &gt;,
<a name="l01101"></a>01101                         scan&lt; Stack, 
<a name="l01102"></a>01102                               pegtl::sor&lt;
<a name="l01103"></a>01103                                 kw_type,
<a name="l01104"></a>01104                                 pegtl::apply&lt; error&lt; Stack,
<a name="l01105"></a>01105                                                      MsgKey::MISSING &gt; &gt; &gt;,
<a name="l01106"></a>01106                         insert &gt; &gt; {};
<a name="l01107"></a>01107 <span class="comment"></span>
<a name="l01108"></a>01108 <span class="comment">  //! \brief Process command line switch &#39;keyword&#39;</span>
<a name="l01109"></a>01109 <span class="comment">  //! \details The value of a command line switch is a boolean, i.e., it can be</span>
<a name="l01110"></a>01110 <span class="comment">  //!    either set or unset.</span>
<a name="l01111"></a>01111 <span class="comment">  //! \author J. Bakosi</span>
<a name="l01112"></a>01112 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class </span>Stack, <span class="keyword">class </span>keyword, <span class="keyword">typename</span> tag, <span class="keyword">typename</span>... tags &gt;
<a name="l01113"></a><a class="code" href="structtk_1_1grm_1_1process__cmd__switch.html">01113</a>   <span class="keyword">struct </span><a class="code" href="structtk_1_1grm_1_1process__cmd__switch.html" title="Process command line switch &#39;keyword&#39;.">process_cmd_switch</a> :
<a name="l01114"></a>01114          pegtl::<a class="code" href="classpegtl_1_1ifmust.html">ifmust</a>&lt;
<a name="l01115"></a>01115            readcmd&lt; Stack, keyword &gt;,
<a name="l01116"></a>01116            pegtl::apply&lt; Store_switch&lt; Stack, tag, tags... &gt; &gt; &gt; {};
<a name="l01117"></a>01117 <span class="comment"></span>
<a name="l01118"></a>01118 <span class="comment">  //! \brief Generic file parser entry point: parse &#39;keywords&#39; and &#39;ignore&#39;</span>
<a name="l01119"></a>01119 <span class="comment">  //!   until end of file</span>
<a name="l01120"></a>01120 <span class="comment">  //! \author J. Bakosi</span>
<a name="l01121"></a>01121 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class</span> Stack, <span class="keyword">typename</span> keywords, <span class="keyword">typename</span> ign &gt;
<a name="l01122"></a><a class="code" href="structtk_1_1grm_1_1read__file.html">01122</a>   <span class="keyword">struct </span><a class="code" href="structtk_1_1grm_1_1read__file.html" title="Generic file parser entry point: parse &#39;keywords&#39; and &#39;ignore&#39; until end of file.">read_file</a> :
<a name="l01123"></a>01123          pegtl::<a class="code" href="classpegtl_1_1until.html">until</a>&lt; pegtl::eof,
<a name="l01124"></a>01124                        pegtl::sor&lt;
<a name="l01125"></a>01125                          keywords,
<a name="l01126"></a>01126                          ign,
<a name="l01127"></a>01127                          unknown&lt; Stack, MsgKey::KEYWORD, error &gt; &gt; &gt; {};
<a name="l01128"></a>01128 <span class="comment"></span>
<a name="l01129"></a>01129 <span class="comment">  //! \brief Process but ignore Charm++&#39;s charmrun arguments starting with &#39;+&#39;</span>
<a name="l01130"></a>01130 <span class="comment">  //! \author J. Bakosi</span>
<a name="l01131"></a>01131 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class</span> Stack &gt;
<a name="l01132"></a><a class="code" href="structtk_1_1grm_1_1charmarg.html">01132</a>   <span class="keyword">struct </span><a class="code" href="structtk_1_1grm_1_1charmarg.html" title="Process but ignore Charm++&#39;s charmrun arguments starting with &#39;+&#39;.">charmarg</a> :
<a name="l01133"></a>01133          pegtl::seq&lt; pegtl::one&lt;&#39;+&#39;&gt;,
<a name="l01134"></a>01134                      unknown&lt; Stack, MsgKey::CHARMARG, warning &gt; &gt; {};
<a name="l01135"></a>01135 <span class="comment"></span>
<a name="l01136"></a>01136 <span class="comment">  //! \brief Generic string parser entry point: parse &#39;keywords&#39; until end of</span>
<a name="l01137"></a>01137 <span class="comment">  //!   string</span>
<a name="l01138"></a>01138 <span class="comment">  //! \author J. Bakosi</span>
<a name="l01139"></a>01139 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class</span> Stack, <span class="keyword">typename</span> keywords &gt;
<a name="l01140"></a><a class="code" href="structtk_1_1grm_1_1read__string.html">01140</a>   <span class="keyword">struct </span><a class="code" href="structtk_1_1grm_1_1read__string.html" title="Generic string parser entry point: parse &#39;keywords&#39; until end of string.">read_string</a> :
<a name="l01141"></a>01141          pegtl::<a class="code" href="classpegtl_1_1until.html">until</a>&lt; pegtl::eof,
<a name="l01142"></a>01142                        pegtl::sor&lt;
<a name="l01143"></a>01143                          keywords,
<a name="l01144"></a>01144                          charmarg&lt; Stack &gt;,
<a name="l01145"></a>01145                          unknown&lt; Stack, MsgKey::KEYWORD, error &gt; &gt; &gt; {};
<a name="l01146"></a>01146 <span class="comment"></span>
<a name="l01147"></a>01147 <span class="comment">  //! \brief Insert RNG parameter</span>
<a name="l01148"></a>01148 <span class="comment">  //! \details A parameter here is always an option. An option is an object</span>
<a name="l01149"></a>01149 <span class="comment">  //!   deriving from tk::Toggle. See, e.g., walker::ctr::DiffEq for an example</span>
<a name="l01150"></a>01150 <span class="comment">  //!   specialization of tk::Toggle to see how an option is created from</span>
<a name="l01151"></a>01151 <span class="comment">  //!   tk::Toggle.</span>
<a name="l01152"></a>01152 <span class="comment">  //! \author J. Bakosi</span>
<a name="l01153"></a>01153 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">typename</span> Stack, <span class="keyword">template</span>&lt; <span class="keyword">class</span> &gt; <span class="keyword">class </span>use, <span class="keyword">typename</span> keyword,
<a name="l01154"></a>01154             <span class="keyword">typename</span> option, <span class="keyword">typename</span> <a class="code" href="namespacetk_1_1grm.html#a1b809dbbd954026ab2bc003ec27a80f2" title="Out-of-struct storage of field ID for pushing terms for statistics.">field</a>, <span class="keyword">typename</span> sel, <span class="keyword">typename</span> vec,
<a name="l01155"></a>01155             <span class="keyword">typename</span>... tags &gt;
<a name="l01156"></a><a class="code" href="structtk_1_1grm_1_1rng__option.html">01156</a>   <span class="keyword">struct </span><a class="code" href="structtk_1_1grm_1_1rng__option.html" title="Insert RNG parameter.">rng_option</a> :
<a name="l01157"></a>01157          <a class="code" href="structtk_1_1grm_1_1process.html" title="Process &#39;keyword&#39; and call its &#39;insert&#39; action if matches &#39;kw_type&#39;.">process</a>&lt; Stack,
<a name="l01158"></a>01158                   keyword,
<a name="l01159"></a>01159                   insert_option&lt; Stack,
<a name="l01160"></a>01160                                  use,
<a name="l01161"></a>01161                                  option,
<a name="l01162"></a>01162                                  field,
<a name="l01163"></a>01163                                  sel, vec, tags... &gt;,
<a name="l01164"></a>01164                   pegtl::alpha &gt; {};
<a name="l01165"></a>01165 <span class="comment"></span>
<a name="l01166"></a>01166 <span class="comment">  //! \brief fieldvar: a character, denoting a variable, optionally followed by</span>
<a name="l01167"></a>01167 <span class="comment">  //!   a digit</span>
<a name="l01168"></a>01168 <span class="comment">  //! \author J. Bakosi</span>
<a name="l01169"></a>01169 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">typename</span> Stack, <span class="keyword">typename</span> var &gt;
<a name="l01170"></a><a class="code" href="structtk_1_1grm_1_1fieldvar.html">01170</a>   <span class="keyword">struct </span><a class="code" href="structtk_1_1grm_1_1fieldvar.html" title="fieldvar: a character, denoting a variable, optionally followed by a digit">fieldvar</a> :
<a name="l01171"></a>01171          pegtl::sor&lt;
<a name="l01172"></a>01172            pegtl::seq&lt; var, pegtl::ifapply&lt; pegtl::plus&lt; pegtl::digit &gt;,
<a name="l01173"></a>01173                                             save_field&lt; Stack &gt; &gt; &gt;,
<a name="l01174"></a>01174            var &gt; {};
<a name="l01175"></a>01175 <span class="comment"></span>
<a name="l01176"></a>01176 <span class="comment">  //! \brief term: upper or lowercase fieldvar matched to selected depvars for</span>
<a name="l01177"></a>01177 <span class="comment">  //!   stats</span>
<a name="l01178"></a>01178 <span class="comment">  //! \author J. Bakosi</span>
<a name="l01179"></a>01179 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class</span> Stack &gt;
<a name="l01180"></a><a class="code" href="structtk_1_1grm_1_1term.html">01180</a>   <span class="keyword">struct </span><a class="code" href="structtk_1_1grm_1_1term.html" title="term: upper or lowercase fieldvar matched to selected depvars for stats">term</a> :
<a name="l01181"></a>01181          pegtl::sor&lt;
<a name="l01182"></a>01182            pegtl::ifapply&lt;
<a name="l01183"></a>01183              fieldvar&lt; Stack, pegtl::upper &gt;,
<a name="l01184"></a>01184              match_depvar&lt;
<a name="l01185"></a>01185                Stack,
<a name="l01186"></a>01186                push_term&lt; Stack, tk::ctr::Moment::ORDINARY &gt; &gt; &gt;,
<a name="l01187"></a>01187            pegtl::ifapply&lt;
<a name="l01188"></a>01188              fieldvar&lt; Stack, pegtl::lower &gt;,
<a name="l01189"></a>01189              match_depvar&lt;
<a name="l01190"></a>01190                Stack,
<a name="l01191"></a>01191                push_term&lt; Stack, tk::ctr::Moment::CENTRAL &gt; &gt; &gt; &gt; {};
<a name="l01192"></a>01192 <span class="comment"></span>
<a name="l01193"></a>01193 <span class="comment">  //! \brief sample space variable: fieldvar matched to selected depvars</span>
<a name="l01194"></a>01194 <span class="comment">  //! \author J. Bakosi</span>
<a name="l01195"></a>01195 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class</span> Stack, <span class="keyword">class</span> c, tk::ctr::Moment m &gt;
<a name="l01196"></a><a class="code" href="structtk_1_1grm_1_1sample__space__var.html">01196</a>   <span class="keyword">struct </span><a class="code" href="structtk_1_1grm_1_1sample__space__var.html" title="sample space variable: fieldvar matched to selected depvars">sample_space_var</a> :
<a name="l01197"></a>01197          <a class="code" href="structtk_1_1grm_1_1scan__until.html" title="Scan input padded by blank at left and space at right and if it matches &#39;keywords&#39;, apply &#39;action&#39;.">scan_until</a>&lt;
<a name="l01198"></a>01198            Stack,
<a name="l01199"></a>01199            fieldvar&lt; Stack, c &gt;,
<a name="l01200"></a>01200            match_depvar&lt; Stack, push_sample&lt; Stack, m &gt; &gt;,
<a name="l01201"></a>01201            pegtl::one&lt;&#39;:&#39;&gt; &gt; {};
<a name="l01202"></a>01202 <span class="comment"></span>
<a name="l01203"></a>01203 <span class="comment">  //! \brief samples: sample space variables optionally separated by fillers</span>
<a name="l01204"></a>01204 <span class="comment">  //! \author J. Bakosi</span>
<a name="l01205"></a>01205 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class</span> Stack &gt;
<a name="l01206"></a><a class="code" href="structtk_1_1grm_1_1samples.html">01206</a>   <span class="keyword">struct </span><a class="code" href="structtk_1_1grm_1_1samples.html" title="samples: sample space variables optionally separated by fillers">samples</a> :
<a name="l01207"></a>01207          pegtl::sor&lt;
<a name="l01208"></a>01208            sample_space_var&lt; Stack, pegtl::upper, tk::ctr::Moment::ORDINARY &gt;,
<a name="l01209"></a>01209            sample_space_var&lt; Stack, pegtl::lower, tk::ctr::Moment::CENTRAL &gt;
<a name="l01210"></a>01210          &gt; {};
<a name="l01211"></a>01211 <span class="comment"></span>
<a name="l01212"></a>01212 <span class="comment">  //! \brief bin(sizes): real numbers as many sample space dimensions were given</span>
<a name="l01213"></a>01213 <span class="comment">  //! \author J. Bakosi</span>
<a name="l01214"></a>01214 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class</span> Stack &gt;
<a name="l01215"></a>01215   <span class="keyword">struct </span>bins :
<a name="l01216"></a>01216          pegtl::sor&lt; scan_until&lt; Stack,
<a name="l01217"></a>01217                                  number,
<a name="l01218"></a>01218                                  push_binsize&lt; Stack &gt;,
<a name="l01219"></a>01219                                  pegtl::one&lt;&#39;)&#39;&gt; &gt;,
<a name="l01220"></a>01220                      pegtl::ifapply&lt;
<a name="l01221"></a>01221                        pegtl::until&lt; pegtl::at&lt; pegtl::one&lt;&#39;)&#39;&gt; &gt;, pegtl::any &gt;,
<a name="l01222"></a>01222                        <a class="code" href="structtk_1_1grm_1_1error.html" title="Error message dispatch.">error</a>&lt; Stack, MsgKey::INVALIDBINSIZE &gt; &gt; &gt; {};
<a name="l01223"></a>01223 <span class="comment"></span>
<a name="l01224"></a>01224 <span class="comment">  //! \brief plow through expectations between characters &#39;&lt;&#39; and &#39;&gt;&#39;</span>
<a name="l01225"></a>01225 <span class="comment">  //! \author J. Bakosi</span>
<a name="l01226"></a>01226 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class</span> Stack &gt;
<a name="l01227"></a>01227   <span class="keyword">struct </span>parse_expectations :
<a name="l01228"></a>01228          readkw&lt;
<a name="l01229"></a>01229            Stack,
<a name="l01230"></a>01230            pegtl::ifmust&lt;
<a name="l01231"></a>01231              pegtl::one&lt;&#39;&lt;&#39;&gt;,
<a name="l01232"></a>01232              pegtl::apply&lt; start_vector&lt; Stack, tag::stat &gt; &gt;,
<a name="l01233"></a>01233              pegtl::until&lt; pegtl::one&lt;&#39;&gt;&#39;&gt;, term&lt; Stack &gt; &gt;,
<a name="l01234"></a>01234              pegtl::apply&lt; check_expectation&lt; Stack &gt; &gt; &gt; &gt; {};
<a name="l01235"></a>01235 <span class="comment"></span>
<a name="l01236"></a>01236 <span class="comment">  //! \brief list of sample space variables with error checking</span>
<a name="l01237"></a>01237 <span class="comment">  //! \author J. Bakosi</span>
<a name="l01238"></a>01238 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class</span> Stack &gt;
<a name="l01239"></a>01239   <span class="keyword">struct </span>sample_space :
<a name="l01240"></a>01240          pegtl::seq&lt;
<a name="l01241"></a>01241            pegtl::apply&lt; start_vector&lt; Stack, tag::pdf &gt; &gt;,
<a name="l01242"></a>01242            pegtl::until&lt; pegtl::one&lt;&#39;:&#39;&gt;, samples&lt; Stack &gt; &gt;,
<a name="l01243"></a>01243            pegtl::apply&lt; check_samples&lt; Stack &gt; &gt; &gt; {};
<a name="l01244"></a>01244 <span class="comment"></span>
<a name="l01245"></a>01245 <span class="comment">  //! \brief extents: optional user-specified extents of PDF sample space</span>
<a name="l01246"></a>01246 <span class="comment">  //! \author J. Bakosi</span>
<a name="l01247"></a>01247 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class</span> Stack &gt;
<a name="l01248"></a>01248   <span class="keyword">struct </span>extents :
<a name="l01249"></a>01249          pegtl::sor&lt; scan_until&lt; Stack,
<a name="l01250"></a>01250                                  number,
<a name="l01251"></a>01251                                  push_extents&lt; Stack &gt;,
<a name="l01252"></a>01252                                  pegtl::one&lt;&#39;)&#39;&gt; &gt;,
<a name="l01253"></a>01253                      pegtl::ifapply&lt;
<a name="l01254"></a>01254                        pegtl::until&lt; pegtl::at&lt; pegtl::one&lt;&#39;)&#39;&gt; &gt;, pegtl::any &gt;,
<a name="l01255"></a>01255                        error&lt; Stack, MsgKey::INVALIDEXTENT &gt; &gt; &gt; {};
<a name="l01256"></a>01256 <span class="comment"></span>
<a name="l01257"></a>01257 <span class="comment">  //! \brief binsizes followed by optional extents with error checking</span>
<a name="l01258"></a>01258 <span class="comment">  //! \author J. Bakosi</span>
<a name="l01259"></a>01259 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class</span> Stack &gt;
<a name="l01260"></a>01260   <span class="keyword">struct </span>bins_exts :
<a name="l01261"></a>01261          pegtl::seq&lt;
<a name="l01262"></a>01262            pegtl::apply&lt; start_vector&lt; Stack, tag::discr, tag::binsize &gt;,
<a name="l01263"></a>01263                          start_vector&lt; Stack, tag::discr, tag::extent &gt; &gt;,
<a name="l01264"></a>01264            pegtl::until&lt; pegtl::sor&lt; pegtl::one&lt;&#39;;&#39;&gt;,
<a name="l01265"></a>01265                                      pegtl::at&lt; pegtl::one&lt;&#39;)&#39;&gt; &gt; &gt;,
<a name="l01266"></a>01266                          bins&lt; Stack &gt; &gt;,
<a name="l01267"></a>01267            pegtl::<a class="code" href="classpegtl_1_1until.html">until</a>&lt; pegtl::one&lt;&#39;)&#39;&gt;, extents&lt; Stack &gt; &gt;,
<a name="l01268"></a>01268            pegtl::apply&lt; check_binsizes&lt; Stack &gt; &gt;,
<a name="l01269"></a>01269            pegtl::apply&lt; check_extents&lt; Stack &gt; &gt; &gt; {};
<a name="l01270"></a>01270 <span class="comment"></span>
<a name="l01271"></a>01271 <span class="comment">  //! \brief PDF name</span>
<a name="l01272"></a>01272 <span class="comment">  //! \details A PDF name is a C-language identifier (alphas, digits, and</span>
<a name="l01273"></a>01273 <span class="comment">  //!    underscores, no leading digit), matched to already selected pdf name</span>
<a name="l01274"></a>01274 <span class="comment">  //!    requiring unique names.</span>
<a name="l01275"></a>01275 <span class="comment">  //! \author J. Bakosi</span>
<a name="l01276"></a>01276 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class</span> Stack &gt;
<a name="l01277"></a>01277   <span class="keyword">struct </span>pdf_name :
<a name="l01278"></a>01278          pegtl::ifapply&lt; pegtl::identifier,
<a name="l01279"></a>01279                          match_pdfname&lt; Stack &gt; &gt; {};
<a name="l01280"></a>01280 <span class="comment"></span>
<a name="l01281"></a>01281 <span class="comment">  //! \brief Match pdf description: name + sample space specification</span>
<a name="l01282"></a>01282 <span class="comment">  //! \details Example syntax (without the quotes): &quot;name(x y z : 1.0 2.0 3.0)&quot;,</span>
<a name="l01283"></a>01283 <span class="comment">  //!    &#39;name&#39; is the name of the pdf, and x,y,z are sample space variables,</span>
<a name="l01284"></a>01284 <span class="comment">  //!    while 1.0 2.0 3.0 are bin sizes corresponding to the x y z sample space</span>
<a name="l01285"></a>01285 <span class="comment">  //!    dimensions, respectively.</span>
<a name="l01286"></a>01286 <span class="comment">  //! \author J. Bakosi</span>
<a name="l01287"></a>01287 <span class="comment"></span>  <span class="keyword">template</span>&lt; <span class="keyword">class</span> Stack &gt;
<a name="l01288"></a>01288   <span class="keyword">struct </span>parse_pdf :
<a name="l01289"></a>01289          readkw&lt;
<a name="l01290"></a>01290            Stack,
<a name="l01291"></a>01291            pegtl::ifmust&lt;
<a name="l01292"></a>01292              pegtl::seq&lt; pdf_name&lt; Stack &gt;, pegtl::at&lt; pegtl::one&lt;&#39;(&#39;&gt; &gt; &gt;,
<a name="l01293"></a>01293              pegtl::sor&lt; pegtl::one&lt;&#39;(&#39;&gt;,
<a name="l01294"></a>01294                          pegtl::apply&lt; error&lt; Stack, MsgKey::KEYWORD &gt; &gt; &gt;,
<a name="l01295"></a>01295              pegtl::sor&lt; pegtl::seq&lt; sample_space&lt; Stack &gt;, bins_exts&lt; Stack &gt; &gt;,
<a name="l01296"></a>01296                          pegtl::apply&lt;
<a name="l01297"></a>01297                            error&lt; Stack, MsgKey::INVALIDSAMPLESPACE &gt; &gt; &gt; &gt; &gt; {};
<a name="l01298"></a>01298 <span class="comment"></span>
<a name="l01299"></a>01299 <span class="comment">  //! \brief Match precision of floating-point numbers in digits (for text</span>
<a name="l01300"></a>01300 <span class="comment">  //!   output)</span>
<a name="l01301"></a>01301 <span class="comment">  //! \author J. Bakosi</span>
<a name="l01302"></a>01302 <span class="comment"></span>  template&lt; class Stack, template&lt; class &gt; class use, class prec &gt;
<a name="l01303"></a>01303   struct precision :
<a name="l01304"></a>01304          process&lt; Stack,
<a name="l01305"></a>01305                   use&lt; kw::precision &gt;,
<a name="l01306"></a>01306                   store_precision&lt; Stack, prec &gt;,
<a name="l01307"></a>01307                   pegtl::alnum &gt; {};
<a name="l01308"></a>01308 <span class="comment"></span>
<a name="l01309"></a>01309 <span class="comment">  //! \brief Match control parameter</span>
<a name="l01310"></a>01310 <span class="comment">  //! \author J. Bakosi</span>
<a name="l01311"></a>01311 <span class="comment"></span>  template&lt; class Stack, typename keyword, class kw_type, typename... tags &gt;
<a name="l01312"></a>01312   struct control :
<a name="l01313"></a>01313          process&lt; Stack, keyword, Store&lt; Stack, tags... &gt;, kw_type &gt; {};
<a name="l01314"></a>01314 <span class="comment"></span>
<a name="l01315"></a>01315 <span class="comment">  //! \brief Match discretization control parameter</span>
<a name="l01316"></a>01316 <span class="comment">  //! \author J. Bakosi</span>
<a name="l01317"></a>01317 <span class="comment"></span>  template&lt; class Stack, typename keyword, typename Tag &gt;
<a name="l01318"></a>01318   struct discr :
<a name="l01319"></a>01319          control&lt; Stack, keyword, pegtl::digit, tag::discr, Tag &gt; {};
<a name="l01320"></a>01320 <span class="comment"></span>
<a name="l01321"></a>01321 <span class="comment">  //! \brief Match component control parameter</span>
<a name="l01322"></a>01322 <span class="comment">  //! \author J. Bakosi</span>
<a name="l01323"></a>01323 <span class="comment"></span>  template&lt; class Stack, typename keyword, typename Tag &gt;
<a name="l01324"></a>01324   struct component :
<a name="l01325"></a>01325          process&lt; Stack,
<a name="l01326"></a>01326                   keyword,
<a name="l01327"></a>01327                   Store_back&lt; Stack, tag::component, Tag &gt;,
<a name="l01328"></a>01328                   pegtl::digit &gt; {};
<a name="l01329"></a>01329 <span class="comment"></span>
<a name="l01330"></a>01330 <span class="comment">  //! \brief Match interval control parameter</span>
<a name="l01331"></a>01331 <span class="comment">  //! \author J. Bakosi</span>
<a name="l01332"></a>01332 <span class="comment"></span>  template&lt; class Stack, typename keyword, typename Tag &gt;
<a name="l01333"></a>01333   struct interval :
<a name="l01334"></a>01334          control&lt; Stack, keyword, pegtl::digit, tag::interval, Tag &gt; {};
<a name="l01335"></a>01335 <span class="comment"></span>
<a name="l01336"></a>01336 <span class="comment">  //! \brief Parse statistics ... end block</span>
<a name="l01337"></a>01337 <span class="comment">  //! \author J. Bakosi</span>
<a name="l01338"></a>01338 <span class="comment"></span>  template&lt; class Stack,
<a name="l01339"></a>01339             template&lt; class &gt; class use,
<a name="l01340"></a>01340             template&lt; class... Ts &gt; class store &gt;
<a name="l01341"></a>01341   struct statistics :
<a name="l01342"></a>01342          pegtl::ifmust&lt; readkw&lt; Stack,
<a name="l01343"></a>01343                                 typename use&lt; kw::statistics &gt;::pegtl_string &gt;,
<a name="l01344"></a>01344                         block&lt; Stack,
<a name="l01345"></a>01345                                use&lt; kw::end &gt;,
<a name="l01346"></a>01346                                interval&lt; Stack, use&lt; kw::interval &gt;,
<a name="l01347"></a>01347                                          tag::stat &gt;,
<a name="l01348"></a>01348                                process&lt; Stack,
<a name="l01349"></a>01349                                         use&lt; kw::txt_float_format &gt;,
<a name="l01350"></a>01350                                         store&lt; tk::ctr::TxtFloatFormat,
<a name="l01351"></a>01351                                                tag::flformat,
<a name="l01352"></a>01352                                                tag::stat &gt;,
<a name="l01353"></a>01353                                         pegtl::alpha &gt;,
<a name="l01354"></a>01354                                precision&lt; Stack, use, tag::stat &gt;,
<a name="l01355"></a>01355                                parse_expectations&lt; Stack &gt; &gt; &gt; {};
<a name="l01356"></a>01356 <span class="comment"></span>
<a name="l01357"></a>01357 <span class="comment">  //! \brief Match model parameter</span>
<a name="l01358"></a>01358 <span class="comment">  //! \author J. Bakosi</span>
<a name="l01359"></a>01359 <span class="comment"></span>  template&lt; class Stack, typename keyword, typename kw_type, typename model,
<a name="l01360"></a>01360             typename Tag &gt;
<a name="l01361"></a>01361   struct parameter :
<a name="l01362"></a>01362          control&lt; Stack, keyword, kw_type, tag::param, model, Tag &gt; {};
<a name="l01363"></a>01363 <span class="comment"></span>
<a name="l01364"></a>01364 <span class="comment">  //! \brief Match rng parameter</span>
<a name="l01365"></a>01365 <span class="comment">  //! \author J. Bakosi</span>
<a name="l01366"></a>01366 <span class="comment"></span>  template&lt; class Stack, template&lt; class &gt; class use, typename keyword,
<a name="l01367"></a>01367             typename option, typename model, typename... tags &gt;
<a name="l01368"></a>01368   struct rng :
<a name="l01369"></a>01369          process&lt; Stack,
<a name="l01370"></a>01370                   keyword,
<a name="l01371"></a>01371                   check_store_option&lt; Stack,
<a name="l01372"></a>01372                                       use,
<a name="l01373"></a>01373                                       option,
<a name="l01374"></a>01374                                       tag::selected,
<a name="l01375"></a>01375                                       tag::rng,
<a name="l01376"></a>01376                                       tag::param, model, tags... &gt;,
<a name="l01377"></a>01377                   pegtl::alpha &gt; {};
<a name="l01378"></a>01378 <span class="comment"></span>
<a name="l01379"></a>01379 <span class="comment">  //! \brief Match rngs ... end block</span>
<a name="l01380"></a>01380 <span class="comment">  //! \author J. Bakosi</span>
<a name="l01381"></a>01381 <span class="comment"></span>  template&lt; class Stack, template&lt; class &gt; class use, class rngs &gt;
<a name="l01382"></a>01382   struct rngblock :
<a name="l01383"></a>01383          pegtl::ifmust&lt; readkw&lt; Stack, typename use&lt; kw::rngs &gt;::pegtl_string &gt;,
<a name="l01384"></a>01384                         block&lt; Stack, use&lt; kw::end &gt;, rngs &gt; &gt; {};
<a name="l01385"></a>01385 
<a name="l01386"></a>01386 <span class="comment"></span>
<a name="l01387"></a>01387 <span class="comment">  //! \brief Match equation/model parameter vector</span>
<a name="l01388"></a>01388 <span class="comment">  //! \details This structure is used to match a keyword ... end block that</span>
<a name="l01389"></a>01389 <span class="comment">  //!   contains a list (i.e., a vector) of numbers. The keyword that starts the</span>
<a name="l01390"></a>01390 <span class="comment">  //!   block is passed in via the &#39;keyword&#39; template argument. The &#39;store&#39;</span>
<a name="l01391"></a>01391 <span class="comment">  //!   argument abstracts away a &quot;functor&quot; used to store the parsed values</span>
<a name="l01392"></a>01392 <span class="comment">  //!   (usually a push_back operaton on a std::vector. The &#39;start&#39; argument</span>
<a name="l01393"></a>01393 <span class="comment">  //!   abstracts away the starter functor used to start the inserting operation</span>
<a name="l01394"></a>01394 <span class="comment">  //!   before parsing a value (usually a push_back on a vector using the</span>
<a name="l01395"></a>01395 <span class="comment">  //!   default value constructor). The &#39;check&#39; argument abstracts away a</span>
<a name="l01396"></a>01396 <span class="comment">  //!   functor used to do error checking on the value parsed. Arguments &#39;eq&#39;</span>
<a name="l01397"></a>01397 <span class="comment">  //!   and &#39;param&#39; denote two levels of the hierarchy relative to tag::param,</span>
<a name="l01398"></a>01398 <span class="comment">  //!   at which the parameter vector lives. Example client-code: see</span>
<a name="l01399"></a>01399 <span class="comment">  //!   walker::deck::icbeta, or walker::deck::icdelta.</span>
<a name="l01400"></a>01400 <span class="comment">  //! \author J. Bakosi</span>
<a name="l01401"></a>01401 <span class="comment"></span>  template&lt; class Stack,
<a name="l01402"></a>01402             template&lt; class &gt; class use,
<a name="l01403"></a>01403             typename keyword,
<a name="l01404"></a>01404             template&lt; class, class, class... &gt; class store,
<a name="l01405"></a>01405             template&lt; class, class, class... &gt; class start,
<a name="l01406"></a>01406             template&lt; class, class, class &gt; class check,
<a name="l01407"></a>01407             typename eq,
<a name="l01408"></a>01408             typename param &gt;
<a name="l01409"></a>01409   struct parameter_vector :
<a name="l01410"></a>01410          pegtl::ifmust&lt;
<a name="l01411"></a>01411            vector&lt;
<a name="l01412"></a>01412              Stack,
<a name="l01413"></a>01413              keyword,
<a name="l01414"></a>01414              store&lt; Stack, tag::param, eq, param &gt;,
<a name="l01415"></a>01415              use&lt; kw::end &gt;,
<a name="l01416"></a>01416              pegtl::apply&lt; start&lt; Stack, tag::param, eq, param &gt; &gt; &gt;,
<a name="l01417"></a>01417            pegtl::apply&lt; check&lt; Stack, eq, param &gt; &gt; &gt; {};
<a name="l01418"></a>01418 <span class="comment"></span>
<a name="l01419"></a>01419 <span class="comment">  //! \brief Match model parameter dependent variable</span>
<a name="l01420"></a>01420 <span class="comment">  //! \author J. Bakosi</span>
<a name="l01421"></a>01421 <span class="comment"></span>  template&lt; class Stack, template&lt; class &gt; class use, typename model,
<a name="l01422"></a>01422             typename Tag &gt;
<a name="l01423"></a>01423   struct depvar :
<a name="l01424"></a>01424          pegtl::ifmust&lt;
<a name="l01425"></a>01425            readkw&lt; Stack, typename use&lt; kw::depvar &gt;::pegtl_string &gt;,
<a name="l01426"></a>01426            scan&lt;
<a name="l01427"></a>01427              Stack, 
<a name="l01428"></a>01428              pegtl::sor&lt; pegtl::alpha,
<a name="l01429"></a>01429                          pegtl::apply&lt; error&lt; Stack, MsgKey::NOTALPHA &gt; &gt; &gt;,
<a name="l01430"></a>01430              Store_back&lt; Stack, tag::param, model, Tag &gt;,
<a name="l01431"></a>01431              add_depvar&lt; Stack &gt; &gt; &gt; {};
<a name="l01432"></a>01432 <span class="comment"></span>
<a name="l01433"></a>01433 <span class="comment">  //! \brief Match and set keyword &#39;title&#39;</span>
<a name="l01434"></a>01434 <span class="comment">  //! \author J. Bakosi</span>
<a name="l01435"></a>01435 <span class="comment"></span>  template&lt; class Stack, template&lt; class &gt; class use &gt;
<a name="l01436"></a>01436   struct title :
<a name="l01437"></a>01437          pegtl::ifmust&lt; readkw&lt; Stack, typename use&lt; kw::title &gt;::pegtl_string &gt;,
<a name="l01438"></a>01438                         quoted&lt; Stack, Set&lt; Stack, tag::title &gt; &gt; &gt; {};
<a name="l01439"></a>01439 <span class="comment"></span>
<a name="l01440"></a>01440 <span class="comment">  //! \brief Match and set policy parameter</span>
<a name="l01441"></a>01441 <span class="comment">  //! \author J. Bakosi</span>
<a name="l01442"></a>01442 <span class="comment"></span>  template&lt; class Stack, template&lt; class &gt; class use, typename keyword,
<a name="l01443"></a>01443             typename option, typename sde, typename... tags &gt;
<a name="l01444"></a>01444   struct policy :
<a name="l01445"></a>01445          process&lt;
<a name="l01446"></a>01446            Stack,
<a name="l01447"></a>01447            keyword,
<a name="l01448"></a>01448            store_back_option&lt; Stack, use, option, tag::param, sde, tags... &gt;,
<a name="l01449"></a>01449            pegtl::alpha &gt; {};
<a name="l01450"></a>01450 <span class="comment"></span>
<a name="l01451"></a>01451 <span class="comment">  //! \brief Match and set a PDF option</span>
<a name="l01452"></a>01452 <span class="comment">  //! \author J. Bakosi</span>
<a name="l01453"></a>01453 <span class="comment"></span>  template&lt; class Stack, class keyword, class store &gt;
<a name="l01454"></a>01454   struct pdf_option :
<a name="l01455"></a>01455          process&lt; Stack, keyword, store, pegtl::alpha &gt; {};
<a name="l01456"></a>01456 <span class="comment"></span>
<a name="l01457"></a>01457 <span class="comment">  //! \brief Match pdfs ... end block</span>
<a name="l01458"></a>01458 <span class="comment">  //! \author J. Bakosi</span>
<a name="l01459"></a>01459 <span class="comment"></span>  template&lt; class Stack, template&lt; class &gt; class use,
<a name="l01460"></a>01460             template&lt; class... Ts &gt; class store &gt;
<a name="l01461"></a>01461   struct pdfs :
<a name="l01462"></a>01462          pegtl::ifmust&lt;
<a name="l01463"></a>01463            tk::grm::readkw&lt; Stack, typename use &lt; kw::pdfs &gt;::pegtl_string &gt;,
<a name="l01464"></a>01464            tk::grm::block&lt;
<a name="l01465"></a>01465              Stack,
<a name="l01466"></a>01466              use&lt; kw::end &gt;,
<a name="l01467"></a>01467              tk::grm::interval&lt; Stack, use&lt; kw::interval &gt;, tag::pdf &gt;,
<a name="l01468"></a>01468              pdf_option&lt; Stack,
<a name="l01469"></a>01469                          use&lt; kw::pdf_filetype &gt;,
<a name="l01470"></a>01470                          store&lt; tk::ctr::PDFFile,
<a name="l01471"></a>01471                                 tag::selected,
<a name="l01472"></a>01472                                 tag::pdffiletype &gt; &gt;,
<a name="l01473"></a>01473              pdf_option&lt; Stack,
<a name="l01474"></a>01474                          use&lt; kw::pdf_policy &gt;,
<a name="l01475"></a>01475                          store&lt; tk::ctr::PDFPolicy,
<a name="l01476"></a>01476                                 tag::selected,
<a name="l01477"></a>01477                                 tag::pdfpolicy &gt; &gt;,
<a name="l01478"></a>01478              pdf_option&lt; Stack,
<a name="l01479"></a>01479                          use&lt; kw::pdf_centering &gt;,
<a name="l01480"></a>01480                          store&lt; tk::ctr::PDFCentering,
<a name="l01481"></a>01481                                 tag::selected,
<a name="l01482"></a>01482                                 tag::pdfctr &gt; &gt;,
<a name="l01483"></a>01483              pdf_option&lt; Stack,
<a name="l01484"></a>01484                          use&lt; kw::txt_float_format &gt;,
<a name="l01485"></a>01485                          store&lt; tk::ctr::TxtFloatFormat,
<a name="l01486"></a>01486                                 tag::flformat,
<a name="l01487"></a>01487                                 tag::pdf &gt; &gt;,
<a name="l01488"></a>01488              precision&lt; Stack, use, tag::pdf &gt;,
<a name="l01489"></a>01489              parse_pdf&lt; Stack &gt; &gt; &gt; {};
<a name="l01490"></a>01490 <span class="comment"></span>
<a name="l01491"></a>01491 <span class="comment">  //! \brief Ensures that a grammar only uses keywords from a pool of</span>
<a name="l01492"></a>01492 <span class="comment">  //!   pre-defined keywords</span>
<a name="l01493"></a>01493 <span class="comment">  //! \details In grammar definitions, every keyword should be wrapped around</span>
<a name="l01494"></a>01494 <span class="comment">  //!   this use template, which conditionally inherits the keyword type its</span>
<a name="l01495"></a>01495 <span class="comment">  //!   templated on (as defined in Control/Keywords.h) if the keyword is listed</span>
<a name="l01496"></a>01496 <span class="comment">  //!   in any of the pools of keywords passed in as the required pool template</span>
<a name="l01497"></a>01497 <span class="comment">  //!   argument and zero or more additional pools. If the keyword is not in any</span>
<a name="l01498"></a>01498 <span class="comment">  //!   of the pools, a compiler error is generated, since the struct cannot</span>
<a name="l01499"></a>01499 <span class="comment">  //!   inherit from base class &#39;char&#39;. In that case, simply add the new keyword</span>
<a name="l01500"></a>01500 <span class="comment">  //!   into one of the pools of keywords corresponding to the given grammar.</span>
<a name="l01501"></a>01501 <span class="comment">  //!   The rationale behind this wrapper is to force the developer to maintain</span>
<a name="l01502"></a>01502 <span class="comment">  //!   the keywords pool for a grammar. The pools are boost::mpl::sets and are</span>
<a name="l01503"></a>01503 <span class="comment">  //!   used to provide help on command line arguments for a given executable.</span>
<a name="l01504"></a>01504 <span class="comment">  //!   They allow compile-time iteration with boost::mpl::for_each or</span>
<a name="l01505"></a>01505 <span class="comment">  //!   generating a run-time std::map associating, e.g., keywords to their help</span>
<a name="l01506"></a>01506 <span class="comment">  //!   strings.</span>
<a name="l01507"></a>01507 <span class="comment">  //! \warning Since the default maximum number of elements in a</span>
<a name="l01508"></a>01508 <span class="comment">  //!   boost::mpl::set is 20, and increasing this number would require custom</span>
<a name="l01509"></a>01509 <span class="comment">  //!   boost::preprocessor-generated boost::mpl headers, which is cumbersome</span>
<a name="l01510"></a>01510 <span class="comment">  //!   and error-prone, instead we work with several pools here that can each</span>
<a name="l01511"></a>01511 <span class="comment">  //!   hold a maximum 20 items and use boost::mpl::or_ and boost::mpl::has_key</span>
<a name="l01512"></a>01512 <span class="comment">  //!   to search for the keyword in either of the pools. Note that</span>
<a name="l01513"></a>01513 <span class="comment">  //!   boost::mpl::or_ allows a maximum 5 template arguments by definition,</span>
<a name="l01514"></a>01514 <span class="comment">  //!   i.e., max 5 OR&#39;d pools, which corresponds to a maximum of 5x20=100</span>
<a name="l01515"></a>01515 <span class="comment">  //!   keywords. If you need more than that, increase</span>
<a name="l01516"></a>01516 <span class="comment">  //!   BOOST_MPL_LIMIT_METAFUNCTION_ARITY at the top of this file.</span>
<a name="l01517"></a>01517 <span class="comment">  //! \warning Note that an even more elegant solution to the problem this</span>
<a name="l01518"></a>01518 <span class="comment">  //!   wrapper is intended to solve is to use a metaprogram that collects all</span>
<a name="l01519"></a>01519 <span class="comment">  //!   occurrences of the keywords in a grammar. However, that does not seem to</span>
<a name="l01520"></a>01520 <span class="comment">  //!   be possible without extensive macro-trickery. Instead, if all keywords</span>
<a name="l01521"></a>01521 <span class="comment">  //!   in all grammar definitions are wrapped inside this use template (or one</span>
<a name="l01522"></a>01522 <span class="comment">  //!   of its specializations), we make sure that only those keywords can be</span>
<a name="l01523"></a>01523 <span class="comment">  //!   used by a grammar that are listed in the pool corresponding to a</span>
<a name="l01524"></a>01524 <span class="comment">  //!   grammar. However, this is still only a partial solution, since listing</span>
<a name="l01525"></a>01525 <span class="comment">  //!   more keywords in the pool than those used in the grammar is still</span>
<a name="l01526"></a>01526 <span class="comment">  //!   possible, which would result in those keywords included in, e.g., the</span>
<a name="l01527"></a>01527 <span class="comment">  //!   on-screen help generated even though some of the keywords may not be</span>
<a name="l01528"></a>01528 <span class="comment">  //!   implemented by the given grammar. So please don&#39;t abuse and don&#39;t list</span>
<a name="l01529"></a>01529 <span class="comment">  //!   keywords in the pool only if they are implemented in the grammar.</span>
<a name="l01530"></a>01530 <span class="comment">  //! \see For example usage with a single pool, see the template typedef</span>
<a name="l01531"></a>01531 <span class="comment">  //!   walker::cmd::use in Control/Walker/CmdLine/Grammar.h and its keywords</span>
<a name="l01532"></a>01532 <span class="comment">  //!   pool, walker::ctr::CmdLine::keywords, in</span>
<a name="l01533"></a>01533 <span class="comment">  //!   Control/Walker/CmdLine/CmdLine.h.</span>
<a name="l01534"></a>01534 <span class="comment">  //! \see For example usage with multiple pools, see the template typedef,</span>
<a name="l01535"></a>01535 <span class="comment">  //!   walker::deck::use, in Control/Walker/InputDeck/Grammar.h and its</span>
<a name="l01536"></a>01536 <span class="comment">  //!   keywords pools, walker::ctr::InputDeck::keywords1,</span>
<a name="l01537"></a>01537 <span class="comment">  //!   walker::ctr::InputDeck::keywords2, etc., in</span>
<a name="l01538"></a>01538 <span class="comment">  //!   Control/Walker/InputDeck/InputDeck.h.</span>
<a name="l01539"></a>01539 <span class="comment">  //! \see http://en.cppreference.com/w/cpp/types/conditional</span>
<a name="l01540"></a>01540 <span class="comment">  //! \see http://www.boost.org/doc/libs/release/libs/mpl/doc/refmanual/set.html</span>
<a name="l01541"></a>01541 <span class="comment">  //! \see http://www.boost.org/doc/libs/release/libs/mpl/doc/refmanual/has_key.html</span>
<a name="l01542"></a>01542 <span class="comment">  //! \see http://www.boost.org/doc/libs/release/libs/mpl/doc/refmanual/or.html</span>
<a name="l01543"></a>01543 <span class="comment">  //! \see http://www.boost.org/doc/libs/release/libs/mpl/doc/refmanual/limit-metafunction-arity.html</span>
<a name="l01544"></a>01544 <span class="comment">  //! TODO It still would be nice to generate a more developer-friendly</span>
<a name="l01545"></a>01545 <span class="comment">  //!    compiler error if the keyword is not in the pool.</span>
<a name="l01546"></a>01546 <span class="comment">  //! \author J. Bakosi</span>
<a name="l01547"></a>01547 <span class="comment"></span>  template&lt; typename keyword, typename pool, typename... pools &gt;
<a name="l01548"></a>01548   struct use :
<a name="l01549"></a>01549          std::conditional&lt; boost::mpl::or_&lt;
<a name="l01550"></a>01550                              boost::mpl::has_key&lt; pool, keyword &gt;,
<a name="l01551"></a>01551                              boost::mpl::has_key&lt; pools, keyword &gt;... &gt;::value,
<a name="l01552"></a>01552                            keyword,
<a name="l01553"></a>01553                            char &gt;::type {};
<a name="l01554"></a>01554 
<a name="l01555"></a>01555 } <span class="comment">// grm::</span>
<a name="l01556"></a>01556 } <span class="comment">// tk::</span>
<a name="l01557"></a>01557 
<a name="l01558"></a>01558 #endif <span class="comment">// CommonGrammar_h</span>
</pre></div></div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="_common_grammar_8h.html">CommonGrammar.h</a>      </li>

    <li class="footer">Generated on Tue Jul 7 2015 00:09:42 for Quinoa by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
