<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>Quinoa unit test code coverage report</title>
  <link rel="stylesheet" type="text/css" href="../../../../gcov.css">
</head>
<body>
  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">Quinoa all test code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">tpl/install/gnu/include</a> - Zoltan2_AlgMultiJagged.hpp<span style="font-size: 80%;"> (source / <a href="Zoltan2_AlgMultiJagged.hpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Commit:</td>
            <td class="headerValue">refs/heads/master:79cc6ba4cc39cf808497be15a706fe41255e3d0d</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">2025</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2016-01-16 07:19:09</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">99</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
            | Branches:
            <span class="coverLegendCov">+</span> taken
            <span class="coverLegendNoCov">-</span> not taken
            <span class="coverLegendNoCov">#</span> not executed
</td>
            <td></td>
            <td class="headerItem">Branches:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntryHi">-</td>
          </tr>
          <tr><td><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">           Branch data     Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>                :            : // @HEADER</a>
<span class="lineNum">       2 </span>                :            : //
<span class="lineNum">       3 </span>                :            : // ***********************************************************************
<span class="lineNum">       4 </span>                :            : //
<span class="lineNum">       5 </span>                :            : //   Zoltan2: A package of combinatorial algorithms for scientific computing
<span class="lineNum">       6 </span>                :            : //                  Copyright 2012 Sandia Corporation
<span class="lineNum">       7 </span>                :            : //
<span class="lineNum">       8 </span>                :            : // Under the terms of Contract DE-AC04-94AL85000 with Sandia Corporation,
<span class="lineNum">       9 </span>                :            : // the U.S. Government retains certain rights in this software.
<span class="lineNum">      10 </span>                :            : //
<span class="lineNum">      11 </span>                :            : // Redistribution and use in source and binary forms, with or without
<span class="lineNum">      12 </span>                :            : // modification, are permitted provided that the following conditions are
<span class="lineNum">      13 </span>                :            : // met:
<span class="lineNum">      14 </span>                :            : //
<span class="lineNum">      15 </span>                :            : // 1. Redistributions of source code must retain the above copyright
<span class="lineNum">      16 </span>                :            : // notice, this list of conditions and the following disclaimer.
<span class="lineNum">      17 </span>                :            : //
<span class="lineNum">      18 </span>                :            : // 2. Redistributions in binary form must reproduce the above copyright
<span class="lineNum">      19 </span>                :            : // notice, this list of conditions and the following disclaimer in the
<span class="lineNum">      20 </span>                :            : // documentation and/or other materials provided with the distribution.
<span class="lineNum">      21 </span>                :            : //
<span class="lineNum">      22 </span>                :            : // 3. Neither the name of the Corporation nor the names of the
<span class="lineNum">      23 </span>                :            : // contributors may be used to endorse or promote products derived from
<span class="lineNum">      24 </span>                :            : // this software without specific prior written permission.
<span class="lineNum">      25 </span>                :            : //
<span class="lineNum">      26 </span>                :            : // THIS SOFTWARE IS PROVIDED BY SANDIA CORPORATION &quot;AS IS&quot; AND ANY
<span class="lineNum">      27 </span>                :            : // EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
<span class="lineNum">      28 </span>                :            : // IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
<span class="lineNum">      29 </span>                :            : // PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL SANDIA CORPORATION OR THE
<span class="lineNum">      30 </span>                :            : // CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
<span class="lineNum">      31 </span>                :            : // EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
<span class="lineNum">      32 </span>                :            : // PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
<span class="lineNum">      33 </span>                :            : // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
<span class="lineNum">      34 </span>                :            : // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
<span class="lineNum">      35 </span>                :            : // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
<span class="lineNum">      36 </span>                :            : // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<span class="lineNum">      37 </span>                :            : //
<span class="lineNum">      38 </span>                :            : // Questions? Contact Karen Devine      (kddevin@sandia.gov)
<span class="lineNum">      39 </span>                :            : //                    Erik Boman        (egboman@sandia.gov)
<span class="lineNum">      40 </span>                :            : //                    Siva Rajamanickam (srajama@sandia.gov)
<span class="lineNum">      41 </span>                :            : //
<span class="lineNum">      42 </span>                :            : // ***********************************************************************
<span class="lineNum">      43 </span>                :            : //
<span class="lineNum">      44 </span>                :            : // @HEADER
<span class="lineNum">      45 </span>                :            : /*! \file Zoltan2_AlgMultiJagged.hpp
<span class="lineNum">      46 </span>                :            :   \brief Contains the Multi-jagged algorthm.
<span class="lineNum">      47 </span>                :            :  */
<span class="lineNum">      48 </span>                :            : 
<span class="lineNum">      49 </span>                :            : #ifndef _ZOLTAN2_ALGMultiJagged_HPP_
<span class="lineNum">      50 </span>                :            : #define _ZOLTAN2_ALGMultiJagged_HPP_
<span class="lineNum">      51 </span>                :            : 
<span class="lineNum">      52 </span>                :            : #include &lt;Zoltan2_MultiJagged_ReductionOps.hpp&gt;
<span class="lineNum">      53 </span>                :            : #include &lt;Zoltan2_CoordinateModel.hpp&gt;
<span class="lineNum">      54 </span>                :            : #include &lt;Zoltan2_Parameters.hpp&gt;
<span class="lineNum">      55 </span>                :            : #include &lt;Zoltan2_Algorithm.hpp&gt;
<span class="lineNum">      56 </span>                :            : 
<span class="lineNum">      57 </span>                :            : #include &lt;Tpetra_Distributor.hpp&gt;
<span class="lineNum">      58 </span>                :            : #include &lt;Teuchos_ParameterList.hpp&gt;
<span class="lineNum">      59 </span>                :            : #include &lt;Zoltan2_CoordinatePartitioningGraph.hpp&gt;
<span class="lineNum">      60 </span>                :            : #include &lt;new&gt;          // ::operator new[]
<span class="lineNum">      61 </span>                :            : #include &lt;algorithm&gt;    // std::sort
<span class="lineNum">      62 </span>                :            : #include &lt;Zoltan2_Util.hpp&gt;
<span class="lineNum">      63 </span>                :            : #include &lt;vector&gt;
<span class="lineNum">      64 </span>                :            : 
<span class="lineNum">      65 </span>                :            : #if defined(__cplusplus) &amp;&amp; __cplusplus &gt;= 201103L
<span class="lineNum">      66 </span>                :            : #include &lt;unordered_map&gt;
<span class="lineNum">      67 </span>                :            : #else
<span class="lineNum">      68 </span>                :            : #include &lt;Teuchos_Hashtable.hpp&gt;
<span class="lineNum">      69 </span>                :            : #endif // C++11 is enabled
<span class="lineNum">      70 </span>                :            : 
<span class="lineNum">      71 </span>                :            : #ifdef ZOLTAN2_USEZOLTANCOMM
<span class="lineNum">      72 </span>                :            : #ifdef HAVE_ZOLTAN2_MPI
<span class="lineNum">      73 </span>                :            : #define ENABLE_ZOLTAN_MIGRATION
<span class="lineNum">      74 </span>                :            : #include &quot;zoltan_comm_cpp.h&quot;
<span class="lineNum">      75 </span>                :            : #include &quot;zoltan_types.h&quot; // for error codes
<span class="lineNum">      76 </span>                :            : #endif
<span class="lineNum">      77 </span>                :            : #endif
<span class="lineNum">      78 </span>                :            : 
<span class="lineNum">      79 </span>                :            : #ifdef HAVE_ZOLTAN2_OMP
<span class="lineNum">      80 </span>                :            : #include &lt;omp.h&gt;
<span class="lineNum">      81 </span>                :            : #endif
<span class="lineNum">      82 </span>                :            : 
<span class="lineNum">      83 </span>                :            : #define LEAST_SIGNIFICANCE 0.0001
<span class="lineNum">      84 </span>                :            : #define SIGNIFICANCE_MUL 1000
<span class="lineNum">      85 </span>                :            : 
<span class="lineNum">      86 </span>                :            : //if the (last dimension reduce all count) x the mpi world size
<span class="lineNum">      87 </span>                :            : //estimated to be bigger than this number then migration will be forced
<span class="lineNum">      88 </span>                :            : //in earlier iterations.
<span class="lineNum">      89 </span>                :            : #define FUTURE_REDUCEALL_CUTOFF 1500000
<span class="lineNum">      90 </span>                :            : //if parts right before last dimension are estimated to have less than
<span class="lineNum">      91 </span>                :            : //MIN_WORK_LAST_DIM many coords, migration will be forced in earlier iterations.
<span class="lineNum">      92 </span>                :            : #define MIN_WORK_LAST_DIM 1000
<span class="lineNum">      93 </span>                :            : 
<span class="lineNum">      94 </span>                :            : 
<span class="lineNum">      95 </span>                :            : 
<span class="lineNum">      96 </span>                :            : 
<span class="lineNum">      97 </span>                :            : #define ZOLTAN2_ABS(x) ((x) &gt;= 0 ? (x) : -(x))
<span class="lineNum">      98 </span>                :            : //imbalance calculation. Wreal / Wexpected - 1
<span class="lineNum">      99 </span>                :            : #define imbalanceOf(Wachieved, totalW, expectedRatio) \
<span class="lineNum">     100 </span>                :            :         (Wachieved) / ((totalW) * (expectedRatio)) - 1
<span class="lineNum">     101 </span>                :            : #define imbalanceOf2(Wachieved, wExpected) \
<span class="lineNum">     102 </span>                :            :         (Wachieved) / (wExpected) - 1
<span class="lineNum">     103 </span>                :            : 
<span class="lineNum">     104 </span>                :            : 
<span class="lineNum">     105 </span>                :            : #define ZOLTAN2_ALGMULTIJAGGED_SWAP(a,b,temp) temp=(a);(a)=(b);(b)=temp;
<span class="lineNum">     106 </span>                :            : 
<span class="lineNum">     107 </span>                :            : 
<span class="lineNum">     108 </span>                :            : namespace Teuchos{
<span class="lineNum">     109 </span>                :            : 
<span class="lineNum">     110 </span>                :            : /*! \brief Zoltan2_BoxBoundaries is a reduction operation
<span class="lineNum">     111 </span>                :            :  * to all reduce the all box boundaries.
<span class="lineNum">     112 </span>                :            : */
<a name="113"><span class="lineNum">     113 </span>                :            : </a>
<span class="lineNum">     114 </span>                :            : template &lt;typename Ordinal, typename T&gt;
<span class="lineNum">     115 </span>                :<span class="lineNoCov">          0 : class Zoltan2_BoxBoundaries  : public ValueTypeReductionOp&lt;Ordinal,T&gt;</span>
<span class="lineNum">     116 </span>                :            : {
<span class="lineNum">     117 </span>                :            : private:
<span class="lineNum">     118 </span>                :            :     Ordinal size;
<span class="lineNum">     119 </span>                :            :     T _EPSILON;
<span class="lineNum">     120 </span>                :            : 
<span class="lineNum">     121 </span>                :            : public:
<span class="lineNum">     122 </span>                :            :     /*! \brief Default Constructor
<span class="lineNum">     123 </span>                :            :      */
<span class="lineNum">     124 </span>                :            :     Zoltan2_BoxBoundaries ():size(0), _EPSILON (std::numeric_limits&lt;T&gt;::epsilon()){}
<span class="lineNum">     125 </span>                :            : 
<span class="lineNum">     126 </span>                :            :     /*! \brief Constructor
<span class="lineNum">     127 </span>                :            :      *   \param nsum  the count of how many sums will be computed at the
<span class="lineNum">     128 </span>                :            :      *             start of the list.
<span class="lineNum">     129 </span>                :            :      *   \param nmin  following the sums, this many minimums will be computed.
<a name="130"><span class="lineNum">     130 </span>                :            :      *   \param nmax  following the minimums, this many maximums will be computed.</a>
<span class="lineNum">     131 </span>                :            :      */
<span class="lineNum">     132 </span>                :<span class="lineNoCov">          0 :     Zoltan2_BoxBoundaries (Ordinal s_):</span>
<span class="lineNum">     133 </span>                :<span class="lineNoCov">          0 :         size(s_), _EPSILON (std::numeric_limits&lt;T&gt;::epsilon()){}</span>
<span class="lineNum">     134 </span>                :            : 
<a name="135"><span class="lineNum">     135 </span>                :            :     /*! \brief Implement Teuchos::ValueTypeReductionOp interface</a>
<span class="lineNum">     136 </span>                :            :      */
<span class="lineNum">     137 </span>                :<span class="lineNoCov">          0 :     void reduce( const Ordinal count, const T inBuffer[], T inoutBuffer[]) const</span>
<span class="lineNum">     138 </span>                :            :     {
<span class="lineNum">     139 </span>                :<span class="lineNoCov">          0 :         for (Ordinal i=0; i &lt; count; i++){</span>
<span class="lineNum">     140 </span>                :<span class="lineNoCov">          0 :             if (Z2_ABS(inBuffer[i]) &gt;  _EPSILON){</span>
<span class="lineNum">     141 </span>                :<span class="lineNoCov">          0 :                 inoutBuffer[i] = inBuffer[i];</span>
<span class="lineNum">     142 </span>                :            :             }
<span class="lineNum">     143 </span>                :            :         }
<span class="lineNum">     144 </span>                :<span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     145 </span>                :            : };
<span class="lineNum">     146 </span>                :            : } // namespace Teuchos
<span class="lineNum">     147 </span>                :            : 
<span class="lineNum">     148 </span>                :            : namespace Zoltan2{
<span class="lineNum">     149 </span>                :            : 
<span class="lineNum">     150 </span>                :            : /*! \brief Allocates memory for the given size.
<span class="lineNum">     151 </span>                :            :  *
<a name="152"><span class="lineNum">     152 </span>                :            :  */</a>
<span class="lineNum">     153 </span>                :            : template &lt;typename T&gt;
<span class="lineNum">     154 </span>                :<span class="lineNoCov">          0 : T *allocMemory(size_t size){</span>
<span class="lineNum">     155 </span>                :<span class="lineNoCov">          0 :     if (size &gt; 0){</span>
<span class="lineNum">     156 </span>                :<span class="lineNoCov">          0 :         T * a = new T[size];</span>
<span class="lineNum">     157 </span>                :<span class="lineNoCov">          0 :         if (a == NULL) {</span>
<span class="lineNum">     158 </span>                :<span class="lineNoCov">          0 :             throw  &quot;cannot allocate memory&quot;;</span>
<span class="lineNum">     159 </span>                :            :         }
<span class="lineNum">     160 </span>                :<span class="lineNoCov">          0 :         return a;</span>
<span class="lineNum">     161 </span>                :            :     }
<span class="lineNum">     162 </span>                :            :     else {
<span class="lineNum">     163 </span>                :<span class="lineNoCov">          0 :         return NULL;</span>
<span class="lineNum">     164 </span>                :            :     }
<span class="lineNum">     165 </span>                :            : }
<span class="lineNum">     166 </span>                :            : 
<span class="lineNum">     167 </span>                :            : /*! \brief Frees the given array.
<span class="lineNum">     168 </span>                :            :  *
<a name="169"><span class="lineNum">     169 </span>                :            :  */</a>
<span class="lineNum">     170 </span>                :            : template &lt;typename T&gt;
<span class="lineNum">     171 </span>                :<span class="lineNoCov">          0 : void freeArray(T *&amp;array){</span>
<span class="lineNum">     172 </span>                :<span class="lineNoCov">          0 :     if(array != NULL){</span>
<span class="lineNum">     173 </span>                :<span class="lineNoCov">          0 :         delete [] array;</span>
<span class="lineNum">     174 </span>                :<span class="lineNoCov">          0 :         array = NULL;</span>
<span class="lineNum">     175 </span>                :            :     }
<span class="lineNum">     176 </span>                :<span class="lineNoCov">          0 : }</span>
<span class="lineNum">     177 </span>                :            : 
<span class="lineNum">     178 </span>                :            : /*! \brief Converts the given object to string.
<span class="lineNum">     179 </span>                :            :  *
<a name="180"><span class="lineNum">     180 </span>                :            :  */</a>
<span class="lineNum">     181 </span>                :            : template &lt;typename tt&gt;
<span class="lineNum">     182 </span>                :<span class="lineNoCov">          0 : std::string toString(tt obj){</span>
<span class="lineNum">     183 </span>                :<span class="lineNoCov">          0 :     std::stringstream ss (std::stringstream::in |std::stringstream::out);</span>
<span class="lineNum">     184 </span>                :<span class="lineNoCov">          0 :     ss &lt;&lt; obj;</span>
<span class="lineNum">     185 </span>                :<span class="lineNoCov">          0 :     std::string tmp = &quot;&quot;;</span>
<span class="lineNum">     186 </span>                :<span class="lineNoCov">          0 :     ss &gt;&gt; tmp;</span>
<span class="lineNum">     187 </span>                :<span class="lineNoCov">          0 :     return tmp;</span>
<span class="lineNum">     188 </span>                :            : }
<span class="lineNum">     189 </span>                :            : 
<span class="lineNum">     190 </span>                :            : /*! \brief Class for sorting items with multiple values.
<span class="lineNum">     191 </span>                :            :  * First sorting with respect to val[0], then val[1] then ... val[count-1].
<span class="lineNum">     192 </span>                :            :  * The last tie breaking is done with index values.
<span class="lineNum">     193 </span>                :            :  * Used for task mapping partitioning where the points on a cut line needs to be
<span class="lineNum">     194 </span>                :            :  * distributed consistently.
<span class="lineNum">     195 </span>                :            :  *
<span class="lineNum">     196 </span>                :            :  */
<span class="lineNum">     197 </span>                :            : template &lt;typename IT, typename CT, typename WT&gt;
<span class="lineNum">     198 </span>                :            : class uMultiSortItem
<span class="lineNum">     199 </span>                :            : {
<span class="lineNum">     200 </span>                :            : public:
<span class="lineNum">     201 </span>                :            :     IT index;
<span class="lineNum">     202 </span>                :            :     CT count;
<span class="lineNum">     203 </span>                :            :     //unsigned int val;
<span class="lineNum">     204 </span>                :            :     WT *val;
<span class="lineNum">     205 </span>                :            :     WT _EPSILON;
<span class="lineNum">     206 </span>                :            : 
<span class="lineNum">     207 </span>                :            :     uMultiSortItem(){
<span class="lineNum">     208 </span>                :            :         this-&gt;index = 0;
<span class="lineNum">     209 </span>                :            :         this-&gt;count = 0;
<span class="lineNum">     210 </span>                :            :         this-&gt;val = NULL;
<span class="lineNum">     211 </span>                :            :         this-&gt;_EPSILON = std::numeric_limits&lt;WT&gt;::epsilon() * 100;
<span class="lineNum">     212 </span>                :            :     }
<a name="213"><span class="lineNum">     213 </span>                :            : </a>
<span class="lineNum">     214 </span>                :            : 
<span class="lineNum">     215 </span>                :<span class="lineNoCov">          0 :     uMultiSortItem(IT index_ ,CT count_, WT *vals_){</span>
<span class="lineNum">     216 </span>                :<span class="lineNoCov">          0 :         this-&gt;index = index_;</span>
<span class="lineNum">     217 </span>                :<span class="lineNoCov">          0 :         this-&gt;count = count_;</span>
<span class="lineNum">     218 </span>                :<span class="lineNoCov">          0 :         this-&gt;val = vals_;</span>
<span class="lineNum">     219 </span>                :<span class="lineNoCov">          0 :         this-&gt;_EPSILON = std::numeric_limits&lt;WT&gt;::epsilon() * 100;</span>
<a name="220"><span class="lineNum">     220 </span>                :<span class="lineNoCov">          0 :     }</span></a>
<span class="lineNum">     221 </span>                :            : 
<span class="lineNum">     222 </span>                :<span class="lineNoCov">          0 :     uMultiSortItem( const uMultiSortItem&lt;IT,CT,WT&gt;&amp; other ){</span>
<span class="lineNum">     223 </span>                :<span class="lineNoCov">          0 :         this-&gt;index = other.index;</span>
<span class="lineNum">     224 </span>                :<span class="lineNoCov">          0 :         this-&gt;count = other.count;</span>
<span class="lineNum">     225 </span>                :<span class="lineNoCov">          0 :         this-&gt;val = other.val;</span>
<span class="lineNum">     226 </span>                :<span class="lineNoCov">          0 :         this-&gt;_EPSILON = other._EPSILON;</span>
<a name="227"><span class="lineNum">     227 </span>                :<span class="lineNoCov">          0 :     }</span></a>
<span class="lineNum">     228 </span>                :            : 
<span class="lineNum">     229 </span>                :<span class="lineNoCov">          0 :     ~uMultiSortItem(){</span>
<span class="lineNum">     230 </span>                :            :         //freeArray&lt;WT&gt;(this-&gt;val);
<span class="lineNum">     231 </span>                :<span class="lineNoCov">          0 :     }</span>
<span class="lineNum">     232 </span>                :            : 
<span class="lineNum">     233 </span>                :            :     void set(IT index_ ,CT count_, WT *vals_){
<span class="lineNum">     234 </span>                :            :         this-&gt;index = index_;
<span class="lineNum">     235 </span>                :            :         this-&gt;count = count_;
<span class="lineNum">     236 </span>                :            :         this-&gt;val = vals_;
<span class="lineNum">     237 </span>                :            :     }
<a name="238"><span class="lineNum">     238 </span>                :            : </a>
<span class="lineNum">     239 </span>                :            : 
<span class="lineNum">     240 </span>                :<span class="lineNoCov">          0 :     uMultiSortItem&lt;IT,CT,WT&gt; operator=(const uMultiSortItem&lt;IT,CT,WT&gt;&amp; other){</span>
<span class="lineNum">     241 </span>                :<span class="lineNoCov">          0 :         this-&gt;index = other.index;</span>
<span class="lineNum">     242 </span>                :<span class="lineNoCov">          0 :         this-&gt;count = other.count;</span>
<span class="lineNum">     243 </span>                :<span class="lineNoCov">          0 :         this-&gt;val = other.val;</span>
<span class="lineNum">     244 </span>                :<span class="lineNoCov">          0 :         return *(this);</span>
<a name="245"><span class="lineNum">     245 </span>                :            :     }</a>
<span class="lineNum">     246 </span>                :            : 
<span class="lineNum">     247 </span>                :<span class="lineNoCov">          0 :     bool operator&lt;(const uMultiSortItem&lt;IT,CT,WT&gt;&amp; other) const{</span>
<span class="lineNum">     248 </span>                :<span class="lineNoCov">          0 :         assert (this-&gt;count == other.count);</span>
<span class="lineNum">     249 </span>                :<span class="lineNoCov">          0 :         for(CT i = 0; i &lt; this-&gt;count; ++i){</span>
<span class="lineNum">     250 </span>                :            :             //if the values are equal go to next one.
<span class="lineNum">     251 </span>                :<span class="lineNoCov">          0 :             if (ZOLTAN2_ABS(this-&gt;val[i] - other.val[i]) &lt; this-&gt;_EPSILON){</span>
<span class="lineNum">     252 </span>                :<span class="lineNoCov">          0 :                 continue;</span>
<span class="lineNum">     253 </span>                :            :             }
<span class="lineNum">     254 </span>                :            :             //if next value is smaller return true;
<span class="lineNum">     255 </span>                :<span class="lineNoCov">          0 :             if(this-&gt;val[i] &lt; other.val[i]){</span>
<span class="lineNum">     256 </span>                :<span class="lineNoCov">          0 :                 return true;</span>
<span class="lineNum">     257 </span>                :            :             }
<span class="lineNum">     258 </span>                :            :             //if next value is bigger return false;
<span class="lineNum">     259 </span>                :            :             else {
<span class="lineNum">     260 </span>                :<span class="lineNoCov">          0 :                 return false;</span>
<span class="lineNum">     261 </span>                :            :             }
<span class="lineNum">     262 </span>                :            :         }
<span class="lineNum">     263 </span>                :            :         //if they are totally equal.
<span class="lineNum">     264 </span>                :<span class="lineNoCov">          0 :         return this-&gt;index &lt; other.index;</span>
<span class="lineNum">     265 </span>                :            :     }
<span class="lineNum">     266 </span>                :            :     bool operator&gt;(const uMultiSortItem&lt;IT,CT,WT&gt;&amp; other) const{
<span class="lineNum">     267 </span>                :            :         assert (this-&gt;count == other.count);
<span class="lineNum">     268 </span>                :            :         for(CT i = 0; i &lt; this-&gt;count; ++i){
<span class="lineNum">     269 </span>                :            :             //if the values are equal go to next one.
<span class="lineNum">     270 </span>                :            :             if (ZOLTAN2_ABS(this-&gt;val[i] - other.val[i]) &lt; this-&gt;_EPSILON){
<span class="lineNum">     271 </span>                :            :                 continue;
<span class="lineNum">     272 </span>                :            :             }
<span class="lineNum">     273 </span>                :            :             //if next value is bigger return true;
<span class="lineNum">     274 </span>                :            :             if(this-&gt;val[i] &gt; other.val[i]){
<span class="lineNum">     275 </span>                :            :                 return true;
<span class="lineNum">     276 </span>                :            :             }
<span class="lineNum">     277 </span>                :            :             //if next value is smaller return false;
<span class="lineNum">     278 </span>                :            :             else //(this-&gt;val[i] &gt; other.val[i])
<span class="lineNum">     279 </span>                :            :             {
<span class="lineNum">     280 </span>                :            :                 return false;
<span class="lineNum">     281 </span>                :            :             }
<span class="lineNum">     282 </span>                :            :         }
<span class="lineNum">     283 </span>                :            :         //if they are totally equal.
<span class="lineNum">     284 </span>                :            :         return this-&gt;index &gt; other.index;
<span class="lineNum">     285 </span>                :            :     }
<span class="lineNum">     286 </span>                :            : };// uSortItem;
<span class="lineNum">     287 </span>                :            : 
<span class="lineNum">     288 </span>                :            : /*! \brief Sort items for quick sort function.
<span class="lineNum">     289 </span>                :            :  *
<span class="lineNum">     290 </span>                :            :  */
<span class="lineNum">     291 </span>                :            : template &lt;class IT, class WT&gt;
<span class="lineNum">     292 </span>                :            : struct uSortItem
<span class="lineNum">     293 </span>                :            : {
<span class="lineNum">     294 </span>                :            :     IT id;
<span class="lineNum">     295 </span>                :            :     //unsigned int val;
<span class="lineNum">     296 </span>                :            :     WT val;
<span class="lineNum">     297 </span>                :            : };// uSortItem;
<span class="lineNum">     298 </span>                :            : 
<span class="lineNum">     299 </span>                :            : /*! \brief Quick sort function.
<span class="lineNum">     300 </span>                :            :  *      Sorts the arr of uSortItems, with respect to increasing vals.
<a name="301"><span class="lineNum">     301 </span>                :            :  */</a>
<span class="lineNum">     302 </span>                :            : template &lt;class IT, class WT&gt;
<span class="lineNum">     303 </span>                :<span class="lineNoCov">          0 : void uqsort(IT n, uSortItem&lt;IT, WT&gt; * arr)</span>
<span class="lineNum">     304 </span>                :            : {
<span class="lineNum">     305 </span>                :<span class="lineNoCov">          0 :     int NSTACK = 50;</span>
<span class="lineNum">     306 </span>                :<span class="lineNoCov">          0 :     int M = 7;</span>
<span class="lineNum">     307 </span>                :<span class="lineNoCov">          0 :     IT         i, ir=n, j, k, l=1;</span>
<span class="lineNum">     308 </span>                :<span class="lineNoCov">          0 :     IT         jstack=0, istack[50];</span>
<span class="lineNum">     309 </span>                :            :     WT aval;
<span class="lineNum">     310 </span>                :            :     uSortItem&lt;IT,WT&gt;    a, temp;
<span class="lineNum">     311 </span>                :            : 
<span class="lineNum">     312 </span>                :<span class="lineNoCov">          0 :     --arr;</span>
<span class="lineNum">     313 </span>                :<span class="lineNoCov">          0 :     for (;;)</span>
<span class="lineNum">     314 </span>                :            :     {
<span class="lineNum">     315 </span>                :<span class="lineNoCov">          0 :         if (ir-l &lt; M)</span>
<span class="lineNum">     316 </span>                :            :         {
<span class="lineNum">     317 </span>                :<span class="lineNoCov">          0 :             for (j=l+1;j&lt;=ir;j++)</span>
<span class="lineNum">     318 </span>                :            :             {
<span class="lineNum">     319 </span>                :<span class="lineNoCov">          0 :                 a=arr[j];</span>
<span class="lineNum">     320 </span>                :<span class="lineNoCov">          0 :                 aval = a.val;</span>
<span class="lineNum">     321 </span>                :<span class="lineNoCov">          0 :                 for (i=j-1;i&gt;=1;i--)</span>
<span class="lineNum">     322 </span>                :            :                 {
<span class="lineNum">     323 </span>                :<span class="lineNoCov">          0 :                     if (arr[i].val &lt;= aval)</span>
<span class="lineNum">     324 </span>                :<span class="lineNoCov">          0 :                         break;</span>
<span class="lineNum">     325 </span>                :<span class="lineNoCov">          0 :                     arr[i+1] = arr[i];</span>
<span class="lineNum">     326 </span>                :            :                 }
<span class="lineNum">     327 </span>                :<span class="lineNoCov">          0 :                 arr[i+1]=a;</span>
<span class="lineNum">     328 </span>                :            :             }
<span class="lineNum">     329 </span>                :<span class="lineNoCov">          0 :             if (jstack == 0)</span>
<span class="lineNum">     330 </span>                :<span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">     331 </span>                :<span class="lineNoCov">          0 :             ir=istack[jstack--];</span>
<span class="lineNum">     332 </span>                :<span class="lineNoCov">          0 :             l=istack[jstack--];</span>
<span class="lineNum">     333 </span>                :            :         }
<span class="lineNum">     334 </span>                :            :         else
<span class="lineNum">     335 </span>                :            :         {
<span class="lineNum">     336 </span>                :<span class="lineNoCov">          0 :             k=(l+ir) &gt;&gt; 1;</span>
<span class="lineNum">     337 </span>                :<span class="lineNoCov">          0 :             ZOLTAN2_ALGMULTIJAGGED_SWAP(arr[k],arr[l+1], temp)</span>
<span class="lineNum">     338 </span>                :<span class="lineNoCov">          0 :             if (arr[l+1].val &gt; arr[ir].val)</span>
<span class="lineNum">     339 </span>                :            :             {
<span class="lineNum">     340 </span>                :<span class="lineNoCov">          0 :                 ZOLTAN2_ALGMULTIJAGGED_SWAP(arr[l+1],arr[ir],temp)</span>
<span class="lineNum">     341 </span>                :            :             }
<span class="lineNum">     342 </span>                :<span class="lineNoCov">          0 :             if (arr[l].val &gt; arr[ir].val)</span>
<span class="lineNum">     343 </span>                :            :             {
<span class="lineNum">     344 </span>                :<span class="lineNoCov">          0 :                 ZOLTAN2_ALGMULTIJAGGED_SWAP(arr[l],arr[ir],temp)</span>
<span class="lineNum">     345 </span>                :            :             }
<span class="lineNum">     346 </span>                :<span class="lineNoCov">          0 :             if (arr[l+1].val &gt; arr[l].val)</span>
<span class="lineNum">     347 </span>                :            :             {
<span class="lineNum">     348 </span>                :<span class="lineNoCov">          0 :                 ZOLTAN2_ALGMULTIJAGGED_SWAP(arr[l+1],arr[l],temp)</span>
<span class="lineNum">     349 </span>                :            :             }
<span class="lineNum">     350 </span>                :<span class="lineNoCov">          0 :             i=l+1;</span>
<span class="lineNum">     351 </span>                :<span class="lineNoCov">          0 :             j=ir;</span>
<span class="lineNum">     352 </span>                :<span class="lineNoCov">          0 :             a=arr[l];</span>
<span class="lineNum">     353 </span>                :<span class="lineNoCov">          0 :             aval = a.val;</span>
<span class="lineNum">     354 </span>                :<span class="lineNoCov">          0 :             for (;;)</span>
<span class="lineNum">     355 </span>                :            :             {
<span class="lineNum">     356 </span>                :<span class="lineNoCov">          0 :                 do i++; while (arr[i].val &lt; aval);</span>
<span class="lineNum">     357 </span>                :<span class="lineNoCov">          0 :                 do j--; while (arr[j].val &gt; aval);</span>
<span class="lineNum">     358 </span>                :<span class="lineNoCov">          0 :                 if (j &lt; i) break;</span>
<span class="lineNum">     359 </span>                :<span class="lineNoCov">          0 :                 ZOLTAN2_ALGMULTIJAGGED_SWAP(arr[i],arr[j],temp);</span>
<span class="lineNum">     360 </span>                :            :             }
<span class="lineNum">     361 </span>                :<span class="lineNoCov">          0 :             arr[l]=arr[j];</span>
<span class="lineNum">     362 </span>                :<span class="lineNoCov">          0 :             arr[j]=a;</span>
<span class="lineNum">     363 </span>                :<span class="lineNoCov">          0 :             jstack += 2;</span>
<span class="lineNum">     364 </span>                :<span class="lineNoCov">          0 :             if (jstack &gt; NSTACK){</span>
<span class="lineNum">     365 </span>                :<span class="lineNoCov">          0 :                 std::cout &lt;&lt; &quot;uqsort: NSTACK too small in sort.&quot; &lt;&lt; std::endl;</span>
<span class="lineNum">     366 </span>                :<span class="lineNoCov">          0 :                 exit(1);</span>
<span class="lineNum">     367 </span>                :            :             }
<span class="lineNum">     368 </span>                :<span class="lineNoCov">          0 :             if (ir-i+1 &gt;= j-l)</span>
<span class="lineNum">     369 </span>                :            :             {
<span class="lineNum">     370 </span>                :<span class="lineNoCov">          0 :                 istack[jstack]=ir;</span>
<span class="lineNum">     371 </span>                :<span class="lineNoCov">          0 :                 istack[jstack-1]=i;</span>
<span class="lineNum">     372 </span>                :<span class="lineNoCov">          0 :                 ir=j-1;</span>
<span class="lineNum">     373 </span>                :            :             }
<span class="lineNum">     374 </span>                :            :             else
<span class="lineNum">     375 </span>                :            :             {
<span class="lineNum">     376 </span>                :<span class="lineNoCov">          0 :                 istack[jstack]=j-1;</span>
<span class="lineNum">     377 </span>                :<span class="lineNoCov">          0 :                 istack[jstack-1]=l;</span>
<span class="lineNum">     378 </span>                :<span class="lineNoCov">          0 :                 l=i;</span>
<span class="lineNum">     379 </span>                :            :             }
<span class="lineNum">     380 </span>                :            :         }
<span class="lineNum">     381 </span>                :            :     }
<span class="lineNum">     382 </span>                :<span class="lineNoCov">          0 : }</span>
<span class="lineNum">     383 </span>                :            : 
<span class="lineNum">     384 </span>                :            : 
<span class="lineNum">     385 </span>                :            : 
<span class="lineNum">     386 </span>                :            : /*! \brief Multi Jagged coordinate partitioning algorithm.
<span class="lineNum">     387 </span>                :            :  *
<span class="lineNum">     388 </span>                :            :  */
<a name="389"><span class="lineNum">     389 </span>                :            : template &lt;typename mj_scalar_t, typename mj_lno_t, typename mj_gno_t,</a>
<span class="lineNum">     390 </span>                :            :           typename mj_part_t&gt;
<span class="lineNum">     391 </span>                :<span class="lineNoCov">          0 : class AlgMJ</span>
<span class="lineNum">     392 </span>                :            : {
<span class="lineNum">     393 </span>                :            : private:
<span class="lineNum">     394 </span>                :            :     typedef coordinateModelPartBox&lt;mj_scalar_t, mj_part_t&gt; mj_partBox_t;
<span class="lineNum">     395 </span>                :            :     typedef std::vector&lt;mj_partBox_t&gt; mj_partBoxVector_t;
<span class="lineNum">     396 </span>                :            : 
<span class="lineNum">     397 </span>                :            :     RCP&lt;const Environment&gt; mj_env; //the environment object
<span class="lineNum">     398 </span>                :            :     RCP&lt;Comm&lt;int&gt; &gt; mj_problemComm; //initial comm object
<span class="lineNum">     399 </span>                :            : 
<span class="lineNum">     400 </span>                :            :     double imbalance_tolerance; //input imbalance tolerance.
<span class="lineNum">     401 </span>                :            :     mj_part_t *part_no_array; //input part array specifying num part to divide along each dim.
<span class="lineNum">     402 </span>                :            :     int recursion_depth; //the number of steps that partitioning will be solved in.
<span class="lineNum">     403 </span>                :            :     int coord_dim, num_weights_per_coord; //coordinate dim and # of weights per coord
<span class="lineNum">     404 </span>                :            : 
<span class="lineNum">     405 </span>                :            :     size_t initial_num_loc_coords; //initial num local coords.
<span class="lineNum">     406 </span>                :            :     global_size_t initial_num_glob_coords; //initial num global coords.
<span class="lineNum">     407 </span>                :            : 
<span class="lineNum">     408 </span>                :            :     mj_lno_t num_local_coords; //number of local coords.
<span class="lineNum">     409 </span>                :            :     mj_gno_t num_global_coords; //number of global coords.
<span class="lineNum">     410 </span>                :            : 
<span class="lineNum">     411 </span>                :            :     mj_scalar_t **mj_coordinates; //two dimension coordinate array
<span class="lineNum">     412 </span>                :            :     mj_scalar_t **mj_weights; //two dimension weight array
<span class="lineNum">     413 </span>                :            :     bool *mj_uniform_parts; //if the target parts are uniform
<span class="lineNum">     414 </span>                :            :     mj_scalar_t **mj_part_sizes; //target part weight sizes.
<span class="lineNum">     415 </span>                :            :     bool *mj_uniform_weights; //if the coordinates have uniform weights.
<span class="lineNum">     416 </span>                :            : 
<span class="lineNum">     417 </span>                :            :     ArrayView&lt;const mj_gno_t&gt; mj_gnos; //global ids of the coordinates, comes from the input
<span class="lineNum">     418 </span>                :            :     size_t num_global_parts; //the targeted number of parts
<span class="lineNum">     419 </span>                :            : 
<span class="lineNum">     420 </span>                :            :     mj_gno_t *initial_mj_gnos; //initial global ids of the coordinates.
<span class="lineNum">     421 </span>                :            :     mj_gno_t *current_mj_gnos; //current global ids of the coordinates, might change during migration.
<span class="lineNum">     422 </span>                :            :     int *owner_of_coordinate; //the actual processor owner of the coordinate, to track after migrations.
<span class="lineNum">     423 </span>                :            : 
<span class="lineNum">     424 </span>                :            :     mj_lno_t *coordinate_permutations; //permutation of coordinates, for partitioning.
<span class="lineNum">     425 </span>                :            :     mj_lno_t *new_coordinate_permutations; //permutation work array.
<span class="lineNum">     426 </span>                :            :     mj_part_t *assigned_part_ids; //the part ids assigned to coordinates.
<span class="lineNum">     427 </span>                :            : 
<span class="lineNum">     428 </span>                :            :     mj_lno_t *part_xadj; //beginning and end of each part.
<span class="lineNum">     429 </span>                :            :     mj_lno_t *new_part_xadj; // work array for beginning and end of each part.
<span class="lineNum">     430 </span>                :            : 
<span class="lineNum">     431 </span>                :            :     //get mj specific parameters.
<span class="lineNum">     432 </span>                :            :     bool distribute_points_on_cut_lines; //if partitioning can distribute points on same coordiante to different parts.
<span class="lineNum">     433 </span>                :            :     mj_part_t max_concurrent_part_calculation; // how many parts we can calculate concurrently.
<span class="lineNum">     434 </span>                :            : 
<span class="lineNum">     435 </span>                :            :     int mj_run_as_rcb; //if this is set, then recursion depth is adjusted to its maximum value.
<span class="lineNum">     436 </span>                :            :     int mj_user_recursion_depth; //the recursion depth value provided by user.
<span class="lineNum">     437 </span>                :            :     int mj_keep_part_boxes; //if the boxes need to be kept.
<span class="lineNum">     438 </span>                :            : 
<span class="lineNum">     439 </span>                :            :     int check_migrate_avoid_migration_option; //whether to migrate=1, avoid migrate=2, or leave decision to MJ=0
<span class="lineNum">     440 </span>                :            :     mj_scalar_t minimum_migration_imbalance; //when MJ decides whether to migrate, the minimum imbalance for migration.
<span class="lineNum">     441 </span>                :            :     int num_threads; //num threads
<span class="lineNum">     442 </span>                :            : 
<span class="lineNum">     443 </span>                :            :     mj_part_t total_num_cut ; //how many cuts will be totally
<span class="lineNum">     444 </span>                :            :     mj_part_t total_num_part;    //how many parts will be totally
<span class="lineNum">     445 </span>                :            : 
<span class="lineNum">     446 </span>                :            :     mj_part_t max_num_part_along_dim ;         //maximum part count along a dimension.
<span class="lineNum">     447 </span>                :            :     mj_part_t max_num_cut_along_dim; //maximum cut count along a dimension.
<span class="lineNum">     448 </span>                :            :     size_t max_num_total_part_along_dim; //maximum part+cut count along a dimension.
<span class="lineNum">     449 </span>                :            : 
<span class="lineNum">     450 </span>                :            :     mj_part_t total_dim_num_reduce_all;    //estimate on #reduceAlls can be done.
<span class="lineNum">     451 </span>                :            :     mj_part_t last_dim_num_part; //max no of parts that might occur
<span class="lineNum">     452 </span>                :            :                                 //during the partition before the
<span class="lineNum">     453 </span>                :            :                                 //last partitioning dimension.
<span class="lineNum">     454 </span>                :            : 
<span class="lineNum">     455 </span>                :            :     RCP&lt;Comm&lt;int&gt; &gt; comm; //comm object than can be altered during execution
<span class="lineNum">     456 </span>                :            :     float fEpsilon; //epsilon for float
<span class="lineNum">     457 </span>                :            :     mj_scalar_t sEpsilon; //epsilon for mj_scalar_t
<span class="lineNum">     458 </span>                :            : 
<span class="lineNum">     459 </span>                :            :     mj_scalar_t maxScalar_t; //max possible scalar
<span class="lineNum">     460 </span>                :            :     mj_scalar_t minScalar_t; //min scalar
<span class="lineNum">     461 </span>                :            : 
<span class="lineNum">     462 </span>                :            :     mj_scalar_t *all_cut_coordinates;
<span class="lineNum">     463 </span>                :            :     mj_scalar_t *max_min_coords;
<span class="lineNum">     464 </span>                :            :     mj_scalar_t *process_cut_line_weight_to_put_left; //how much weight should a MPI put left side of the each cutline
<span class="lineNum">     465 </span>                :            :     mj_scalar_t **thread_cut_line_weight_to_put_left; //how much weight percentage should each thread in MPI put left side of the each outline
<span class="lineNum">     466 </span>                :            : 
<span class="lineNum">     467 </span>                :            :     // work array to manipulate coordinate of cutlines in different iterations.
<span class="lineNum">     468 </span>                :            :     //necessary because previous cut line information is used for determining
<span class="lineNum">     469 </span>                :            :     //the next cutline information. therefore, cannot update the cut work array
<span class="lineNum">     470 </span>                :            :     //until all cutlines are determined.
<span class="lineNum">     471 </span>                :            :     mj_scalar_t *cut_coordinates_work_array;
<span class="lineNum">     472 </span>                :            : 
<span class="lineNum">     473 </span>                :            :     //cumulative part weight array.
<span class="lineNum">     474 </span>                :            :     mj_scalar_t *target_part_weights;
<span class="lineNum">     475 </span>                :            : 
<span class="lineNum">     476 </span>                :            :     mj_scalar_t *cut_upper_bound_coordinates ;  //upper bound coordinate of a cut line
<span class="lineNum">     477 </span>                :            :     mj_scalar_t *cut_lower_bound_coordinates ;  //lower bound coordinate of a cut line
<span class="lineNum">     478 </span>                :            :     mj_scalar_t *cut_lower_bound_weights ;  //lower bound weight of a cut line
<span class="lineNum">     479 </span>                :            :     mj_scalar_t *cut_upper_bound_weights ;  //upper bound weight of a cut line
<span class="lineNum">     480 </span>                :            : 
<span class="lineNum">     481 </span>                :            :     mj_scalar_t *process_local_min_max_coord_total_weight ; //combined array to exchange the min and max coordinate, and total weight of part.
<span class="lineNum">     482 </span>                :            :     mj_scalar_t *global_min_max_coord_total_weight ;//global combined array with the results for min, max and total weight.
<span class="lineNum">     483 </span>                :            : 
<span class="lineNum">     484 </span>                :            :     //isDone is used to determine if a cutline is determined already.
<span class="lineNum">     485 </span>                :            :     //If a cut line is already determined, the next iterations will skip this cut line.
<span class="lineNum">     486 </span>                :            :     bool *is_cut_line_determined;
<span class="lineNum">     487 </span>                :            :     //my_incomplete_cut_count count holds the number of cutlines that have not been finalized for each part
<span class="lineNum">     488 </span>                :            :     //when concurrentPartCount&gt;1, using this information, if my_incomplete_cut_count[x]==0, then no work is done for this part.
<span class="lineNum">     489 </span>                :            :     mj_part_t *my_incomplete_cut_count;
<span class="lineNum">     490 </span>                :            :     //local part weights of each thread.
<span class="lineNum">     491 </span>                :            :     double **thread_part_weights;
<span class="lineNum">     492 </span>                :            :     //the work manupulation array for partweights.
<span class="lineNum">     493 </span>                :            :     double **thread_part_weight_work;
<span class="lineNum">     494 </span>                :            : 
<span class="lineNum">     495 </span>                :            :     //thread_cut_left_closest_point to hold the closest coordinate to a cutline from left (for each thread).
<span class="lineNum">     496 </span>                :            :     mj_scalar_t **thread_cut_left_closest_point;
<span class="lineNum">     497 </span>                :            :     //thread_cut_right_closest_point to hold the closest coordinate to a cutline from right (for each thread)
<span class="lineNum">     498 </span>                :            :     mj_scalar_t **thread_cut_right_closest_point;
<span class="lineNum">     499 </span>                :            : 
<span class="lineNum">     500 </span>                :            :     //to store how many points in each part a thread has.
<span class="lineNum">     501 </span>                :            :     mj_lno_t **thread_point_counts;
<span class="lineNum">     502 </span>                :            : 
<span class="lineNum">     503 </span>                :            :     mj_scalar_t *process_rectilinear_cut_weight;
<span class="lineNum">     504 </span>                :            :     mj_scalar_t *global_rectilinear_cut_weight;
<span class="lineNum">     505 </span>                :            : 
<span class="lineNum">     506 </span>                :            :     //for faster communication, concatanation of
<span class="lineNum">     507 </span>                :            :     //totalPartWeights sized 2P-1, since there are P parts and P-1 cut lines
<span class="lineNum">     508 </span>                :            :     //leftClosest distances sized P-1, since P-1 cut lines
<span class="lineNum">     509 </span>                :            :     //rightClosest distances size P-1, since P-1 cut lines.
<span class="lineNum">     510 </span>                :            :     mj_scalar_t *total_part_weight_left_right_closests ;
<span class="lineNum">     511 </span>                :            :     mj_scalar_t *global_total_part_weight_left_right_closests;
<span class="lineNum">     512 </span>                :            : 
<span class="lineNum">     513 </span>                :            :     RCP&lt;mj_partBoxVector_t&gt; kept_boxes;  // vector of all boxes for all parts;
<span class="lineNum">     514 </span>                :            :                                          // constructed only if
<span class="lineNum">     515 </span>                :            :                                          // mj_keep_part_boxes == true
<span class="lineNum">     516 </span>                :            :     RCP&lt;mj_partBox_t&gt; global_box;
<span class="lineNum">     517 </span>                :            :     int myRank, myActualRank; //processor rank, and initial rank
<span class="lineNum">     518 </span>                :            : 
<span class="lineNum">     519 </span>                :            :     /* \brief Either the mj array (part_no_array) or num_global_parts should be provided in
<span class="lineNum">     520 </span>                :            :      * the input. part_no_array takes
<span class="lineNum">     521 </span>                :            :      * precedence if both are provided.
<span class="lineNum">     522 </span>                :            :      * Depending on these parameters, total cut/part number,
<span class="lineNum">     523 </span>                :            :      * maximum part/cut number along a dimension, estimated number of reduceAlls,
<span class="lineNum">     524 </span>                :            :      * and the number of parts before the last dimension is calculated.
<span class="lineNum">     525 </span>                :            :      * */
<span class="lineNum">     526 </span>                :            :     void set_part_specifications();
<span class="lineNum">     527 </span>                :            : 
<span class="lineNum">     528 </span>                :            :     /* \brief Tries to determine the part number for current dimension,
<span class="lineNum">     529 </span>                :            :      * by trying to make the partitioning as square as possible.
<span class="lineNum">     530 </span>                :            :      * \param num_total_future how many more partitionings are required.
<span class="lineNum">     531 </span>                :            :      * \param root how many more recursion depth is left.
<span class="lineNum">     532 </span>                :            :      */
<span class="lineNum">     533 </span>                :            :     inline mj_part_t get_part_count(
<span class="lineNum">     534 </span>                :            :                 mj_part_t num_total_future,
<span class="lineNum">     535 </span>                :            :                 double root);
<span class="lineNum">     536 </span>                :            : 
<span class="lineNum">     537 </span>                :            :     /* \brief Allocates the all required memory for the mj partitioning algorithm.
<span class="lineNum">     538 </span>                :            :      *
<span class="lineNum">     539 </span>                :            :      */
<span class="lineNum">     540 </span>                :            :     void allocate_set_work_memory();
<span class="lineNum">     541 </span>                :            : 
<span class="lineNum">     542 </span>                :            :     /* \brief for part communication we keep track of the box boundaries.
<span class="lineNum">     543 </span>                :            :      * This is performed when either asked specifically, or when geometric mapping is performed afterwards.
<span class="lineNum">     544 </span>                :            :      * This function initializes a single box with all global min and max coordinates.
<span class="lineNum">     545 </span>                :            :      * \param initial_partitioning_boxes the input and output vector for boxes.
<span class="lineNum">     546 </span>                :            :      */
<span class="lineNum">     547 </span>                :            :     void init_part_boxes(RCP&lt;mj_partBoxVector_t&gt; &amp; outPartBoxes);
<span class="lineNum">     548 </span>                :            : 
<span class="lineNum">     549 </span>                :            :     /* \brief compute global bounding box:  min/max coords of global domain */
<span class="lineNum">     550 </span>                :            :     void compute_global_box();
<span class="lineNum">     551 </span>                :            : 
<span class="lineNum">     552 </span>                :            :     /* \brief Function returns how many parts that will be obtained after this dimension partitioning.
<span class="lineNum">     553 </span>                :            :      * It sets how many parts each current part will be partitioned into in this dimension to num_partitioning_in_current_dim vector,
<span class="lineNum">     554 </span>                :            :      * sets how many total future parts each obtained part will be partitioned into in next_future_num_parts_in_parts vector,
<span class="lineNum">     555 </span>                :            :      * If part boxes are kept, then sets initializes the output_part_boxes as its ancestor.
<span class="lineNum">     556 </span>                :            :      *
<span class="lineNum">     557 </span>                :            :      *  \param num_partitioning_in_current_dim: output. How many parts each current part will be partitioned into.
<span class="lineNum">     558 </span>                :            :      *  \param future_num_part_in_parts: input, how many future parts each current part will be partitioned into.
<span class="lineNum">     559 </span>                :            :      *  \param next_future_num_parts_in_parts: output, how many future parts each obtained part will be partitioned into.
<span class="lineNum">     560 </span>                :            :      *  \param future_num_parts: output, max number of future parts that will be obtained from a single
<span class="lineNum">     561 </span>                :            :      *  \param current_num_parts: input, how many parts are there currently.
<span class="lineNum">     562 </span>                :            :      *  \param current_iteration: input, current dimension iteration number.
<span class="lineNum">     563 </span>                :            :      *  \param input_part_boxes: input, if boxes are kept, current boxes.
<span class="lineNum">     564 </span>                :            :      *  \param output_part_boxes: output, if boxes are kept, the initial box boundaries for obtained parts.
<span class="lineNum">     565 </span>                :            :      */
<span class="lineNum">     566 </span>                :            :     mj_part_t update_part_num_arrays(
<span class="lineNum">     567 </span>                :            :                 std::vector&lt;mj_part_t&gt; &amp;num_partitioning_in_current_dim, //assumes this vector is empty.
<span class="lineNum">     568 </span>                :            :                 std::vector&lt;mj_part_t&gt; *future_num_part_in_parts,
<span class="lineNum">     569 </span>                :            :                 std::vector&lt;mj_part_t&gt; *next_future_num_parts_in_parts, //assumes this vector is empty.
<span class="lineNum">     570 </span>                :            :                 mj_part_t &amp;future_num_parts,
<span class="lineNum">     571 </span>                :            :                 mj_part_t current_num_parts,
<span class="lineNum">     572 </span>                :            :                 int current_iteration,
<span class="lineNum">     573 </span>                :            :                 RCP&lt;mj_partBoxVector_t&gt; input_part_boxes,
<span class="lineNum">     574 </span>                :            :                 RCP&lt;mj_partBoxVector_t&gt; output_part_boxes);
<span class="lineNum">     575 </span>                :            : 
<span class="lineNum">     576 </span>                :            :     /*! \brief Function to determine the local minimum and maximum coordinate, and local total weight
<span class="lineNum">     577 </span>                :            :      * in the given set of local points.
<span class="lineNum">     578 </span>                :            :      * \param coordinate_begin_index is the start index of the given partition on partitionedPointPermutations.
<span class="lineNum">     579 </span>                :            :      * \param coordinate_end_index is the end index of the given partition on partitionedPointPermutations.
<span class="lineNum">     580 </span>                :            :      * \param mj_current_coordinate_permutations is the permutation array that point to the actual coordinate index. Sized as numLocalCoords.
<span class="lineNum">     581 </span>                :            :      * \param mj_current_dim_coords float-like array representing the coordinates in a single dimension. Sized as numLocalCoords.
<span class="lineNum">     582 </span>                :            :      * \param min_coordinate is the output to represent the local minimumCoordinate in  given range of coordinates.
<span class="lineNum">     583 </span>                :            :      * \param max_coordinate is the output to represent the local maximum coordinate in the given range of coordinates.
<span class="lineNum">     584 </span>                :            :      * \param total_weight is the output to represent the local total weight in the coordinate in the given range of coordinates.
<span class="lineNum">     585 </span>                :            :      *
<span class="lineNum">     586 </span>                :            :      */
<span class="lineNum">     587 </span>                :            :     void mj_get_local_min_max_coord_totW(
<span class="lineNum">     588 </span>                :            :                 mj_lno_t coordinate_begin_index,
<span class="lineNum">     589 </span>                :            :                 mj_lno_t coordinate_end_index,
<span class="lineNum">     590 </span>                :            :                 mj_lno_t *mj_current_coordinate_permutations,
<span class="lineNum">     591 </span>                :            :                 mj_scalar_t *mj_current_dim_coords,
<span class="lineNum">     592 </span>                :            :                 mj_scalar_t &amp;min_coordinate,
<span class="lineNum">     593 </span>                :            :                 mj_scalar_t &amp;max_coordinate,
<span class="lineNum">     594 </span>                :            :                 mj_scalar_t &amp;total_weight);
<span class="lineNum">     595 </span>                :            : 
<span class="lineNum">     596 </span>                :            :     /*! \brief Function that reduces global minimum and maximum coordinates with global total weight from given local arrays.
<span class="lineNum">     597 </span>                :            :      * \param current_concurrent_num_parts is the number of parts whose cut lines will be calculated concurrently.
<span class="lineNum">     598 </span>                :            :      * \param local_min_max_total is the array holding local min and max coordinate values with local total weight.
<span class="lineNum">     599 </span>                :            :      * First current_concurrent_num_parts entries are minimums of the parts, next current_concurrent_num_parts entries are max, and then the total weights.
<span class="lineNum">     600 </span>                :            :      * \param global_min_max_total is the output array holding global min and global coordinate values with global total weight.
<span class="lineNum">     601 </span>                :            :      * The structure is same as local_min_max_total.
<span class="lineNum">     602 </span>                :            :      */
<span class="lineNum">     603 </span>                :            :     void mj_get_global_min_max_coord_totW(
<span class="lineNum">     604 </span>                :            :         mj_part_t current_concurrent_num_parts,
<span class="lineNum">     605 </span>                :            :         mj_scalar_t *local_min_max_total,
<span class="lineNum">     606 </span>                :            :         mj_scalar_t *global_min_max_total);
<span class="lineNum">     607 </span>                :            : 
<span class="lineNum">     608 </span>                :            :     /*! \brief Function that calculates the new coordinates for the cut lines. Function is called inside the parallel region.
<span class="lineNum">     609 </span>                :            :      * \param min_coord minimum coordinate in the range.
<span class="lineNum">     610 </span>                :            :      * \param max_coord maximum coordinate in the range.
<span class="lineNum">     611 </span>                :            :      *
<span class="lineNum">     612 </span>                :            :      * \param num_cuts holds the number of cuts in the current partitioning dimension.
<span class="lineNum">     613 </span>                :            :      * \param global_weight holds the global total weight in the current part.
<span class="lineNum">     614 </span>                :            :      *
<span class="lineNum">     615 </span>                :            :      * \param initial_cut_coords is the output array for the initial cut lines.
<span class="lineNum">     616 </span>                :            :      * \param target_part_weights is the output array holding the cumulative ratios of parts in current partitioning.
<span class="lineNum">     617 </span>                :            :      * For partitioning to 4 uniformly, target_part_weights will be (0.25 * globalTotalWeight, 0.5 *globalTotalWeight , 0.75 * globalTotalWeight, globalTotalWeight).
<span class="lineNum">     618 </span>                :            :      *
<span class="lineNum">     619 </span>                :            :      * \param future_num_part_in_parts is the vector that holds how many more parts each part will be divided into more
<span class="lineNum">     620 </span>                :            :      * for the parts at the beginning of this coordinate partitioning
<span class="lineNum">     621 </span>                :            :      * \param next_future_num_parts_in_parts is the vector that holds how many more parts each part will be divided into more
<span class="lineNum">     622 </span>                :            :      * for the parts that will be obtained at the end of this coordinate partitioning.
<span class="lineNum">     623 </span>                :            :      * \param concurrent_current_part is the index of the part in the future_num_part_in_parts vector.
<span class="lineNum">     624 </span>                :            :      * \param obtained_part_index holds the amount of shift in the next_future_num_parts_in_parts for the output parts.
<span class="lineNum">     625 </span>                :            :      */
<span class="lineNum">     626 </span>                :            :     void mj_get_initial_cut_coords_target_weights(
<span class="lineNum">     627 </span>                :            :         mj_scalar_t min_coord,
<span class="lineNum">     628 </span>                :            :         mj_scalar_t max_coord,
<span class="lineNum">     629 </span>                :            :         mj_part_t num_cuts/*p-1*/ ,
<span class="lineNum">     630 </span>                :            :         mj_scalar_t global_weight,
<span class="lineNum">     631 </span>                :            :         mj_scalar_t *initial_cut_coords /*p - 1 sized, coordinate of each cut line*/,
<span class="lineNum">     632 </span>                :            :         mj_scalar_t *target_part_weights /*cumulative weights, at left side of each cut line. p-1 sized*/,
<span class="lineNum">     633 </span>                :            : 
<span class="lineNum">     634 </span>                :            :         std::vector &lt;mj_part_t&gt; *future_num_part_in_parts, //the vecto
<span class="lineNum">     635 </span>                :            :         std::vector &lt;mj_part_t&gt; *next_future_num_parts_in_parts,
<span class="lineNum">     636 </span>                :            :         mj_part_t concurrent_current_part,
<span class="lineNum">     637 </span>                :            :         mj_part_t obtained_part_index);
<span class="lineNum">     638 </span>                :            : 
<span class="lineNum">     639 </span>                :            :     /*! \brief Function that calculates the new coordinates for the cut lines. Function is called inside the parallel region.
<span class="lineNum">     640 </span>                :            :      * \param max_coordinate maximum coordinate in the range.
<span class="lineNum">     641 </span>                :            :      * \param min_coordinate minimum coordinate in the range.
<span class="lineNum">     642 </span>                :            :      *
<span class="lineNum">     643 </span>                :            :      * \param concurrent_current_part_index is the index of the part in the inTotalCounts vector.
<span class="lineNum">     644 </span>                :            :      * \param coordinate_begin_index holds the beginning of the coordinates in current part.
<span class="lineNum">     645 </span>                :            :      * \param coordinate_end_index holds end of the coordinates in current part.
<span class="lineNum">     646 </span>                :            :      * \param mj_current_coordinate_permutations is the permutation array, holds the real indices of coordinates on mj_current_dim_coords array.
<span class="lineNum">     647 </span>                :            :      * \param mj_current_dim_coords is the 1D array holding the coordinates.
<span class="lineNum">     648 </span>                :            :      * \param mj_part_ids is the array holding the partIds of each coordinate.
<span class="lineNum">     649 </span>                :            :      * \param partition_count is the number of parts that the current part will be partitioned into.
<span class="lineNum">     650 </span>                :            :      */
<span class="lineNum">     651 </span>                :            :     void set_initial_coordinate_parts(
<span class="lineNum">     652 </span>                :            :         mj_scalar_t &amp;max_coordinate,
<span class="lineNum">     653 </span>                :            :         mj_scalar_t &amp;min_coordinate,
<span class="lineNum">     654 </span>                :            :         mj_part_t &amp;concurrent_current_part_index,
<span class="lineNum">     655 </span>                :            :         mj_lno_t coordinate_begin_index,
<span class="lineNum">     656 </span>                :            :         mj_lno_t coordinate_end_index,
<span class="lineNum">     657 </span>                :            :         mj_lno_t *mj_current_coordinate_permutations,
<span class="lineNum">     658 </span>                :            :         mj_scalar_t *mj_current_dim_coords,
<span class="lineNum">     659 </span>                :            :         mj_part_t *mj_part_ids,
<span class="lineNum">     660 </span>                :            :         mj_part_t &amp;partition_count);
<span class="lineNum">     661 </span>                :            : 
<span class="lineNum">     662 </span>                :            :     /*! \brief Function that is responsible from 1D partitioning of the given range of coordinates.
<span class="lineNum">     663 </span>                :            :      * \param mj_current_dim_coords is 1 dimensional array holding coordinate values.
<span class="lineNum">     664 </span>                :            :      * \param imbalanceTolerance is the maximum allowed imbalance ratio.
<span class="lineNum">     665 </span>                :            :      * \param current_work_part is the beginning index of concurrentPartCount parts.
<span class="lineNum">     666 </span>                :            :      * \param current_concurrent_num_parts is the number of parts whose cut lines will be calculated concurrently.
<span class="lineNum">     667 </span>                :            :      * \param current_cut_coordinates is the array holding the coordinates of the cut.
<span class="lineNum">     668 </span>                :            :      * \param total_incomplete_cut_count is the number of cut lines whose positions should be calculated.
<span class="lineNum">     669 </span>                :            :      * \param num_partitioning_in_current_dim is the vector that holds how many parts each part will be divided into.
<span class="lineNum">     670 </span>                :            :      *
<span class="lineNum">     671 </span>                :            :      */
<span class="lineNum">     672 </span>                :            :     void mj_1D_part(
<span class="lineNum">     673 </span>                :            :         mj_scalar_t *mj_current_dim_coords,
<span class="lineNum">     674 </span>                :            :         mj_scalar_t imbalanceTolerance,
<span class="lineNum">     675 </span>                :            :         mj_part_t current_work_part,
<span class="lineNum">     676 </span>                :            :         mj_part_t current_concurrent_num_parts,
<span class="lineNum">     677 </span>                :            :         mj_scalar_t *current_cut_coordinates,
<span class="lineNum">     678 </span>                :            :         mj_part_t total_incomplete_cut_count,
<span class="lineNum">     679 </span>                :            :         std::vector &lt;mj_part_t&gt; &amp;num_partitioning_in_current_dim);
<span class="lineNum">     680 </span>                :            : 
<span class="lineNum">     681 </span>                :            :     /*! \brief Function that calculates the weights of each part according to given part cut coordinates.
<span class="lineNum">     682 </span>                :            :      * Function is called inside the parallel region. Thread specific work arrays are provided
<span class="lineNum">     683 </span>                :            :      * as function parameter.
<span class="lineNum">     684 </span>                :            :      *
<span class="lineNum">     685 </span>                :            :      * \param total_part_count is the sum of number of cutlines and number of parts. Simply it is 2*P - 1.
<span class="lineNum">     686 </span>                :            :      * \param num_cuts is the number of cut lines. P - 1.
<span class="lineNum">     687 </span>                :            :      * \param max_coord is the maximum coordinate in the part.
<span class="lineNum">     688 </span>                :            :      * \param min_coord is the min coordinate in the part.
<span class="lineNum">     689 </span>                :            :      * \param coordinate_begin_index is the index of the first coordinate in current part.
<span class="lineNum">     690 </span>                :            :      * \param coordinate_end_index is the index of the last coordinate in current part.
<span class="lineNum">     691 </span>                :            :      * \param mj_current_dim_coords is 1 dimensional array holding coordinate values.
<span class="lineNum">     692 </span>                :            :      *
<span class="lineNum">     693 </span>                :            :      * \param temp_current_cut_coords is the array holding the coordinates of each cut line. Sized P - 1.
<span class="lineNum">     694 </span>                :            :      * \param current_cut_status is the boolean array to determine if the correct position for a cut line is found.
<span class="lineNum">     695 </span>                :            :      * \param my_current_part_weights is the array holding the part weights for the calling thread.
<span class="lineNum">     696 </span>                :            :      * \param my_current_left_closest is the array holding the coordinate of the closest points to the cut lines from left for the calling thread..
<span class="lineNum">     697 </span>                :            :      * \param my_current_right_closest is the array holding the coordinate of the closest points to the cut lines from right for the calling thread.
<span class="lineNum">     698 </span>                :            :      * \param partIds is the array that holds the part ids of the coordinates
<span class="lineNum">     699 </span>                :            :      */
<span class="lineNum">     700 </span>                :            :     void mj_1D_part_get_thread_part_weights(
<span class="lineNum">     701 </span>                :            :         size_t total_part_count,
<span class="lineNum">     702 </span>                :            :         mj_part_t num_cuts,
<span class="lineNum">     703 </span>                :            :         mj_scalar_t max_coord,
<span class="lineNum">     704 </span>                :            :         mj_scalar_t min_coord,
<span class="lineNum">     705 </span>                :            :         mj_lno_t coordinate_begin_index,
<span class="lineNum">     706 </span>                :            :         mj_lno_t coordinate_end_index,
<span class="lineNum">     707 </span>                :            :         mj_scalar_t *mj_current_dim_coords,
<span class="lineNum">     708 </span>                :            :         mj_scalar_t *temp_current_cut_coords,
<span class="lineNum">     709 </span>                :            :         bool *current_cut_status,
<span class="lineNum">     710 </span>                :            :         double *my_current_part_weights,
<span class="lineNum">     711 </span>                :            :         mj_scalar_t *my_current_left_closest,
<span class="lineNum">     712 </span>                :            :         mj_scalar_t *my_current_right_closest);
<span class="lineNum">     713 </span>                :            : 
<span class="lineNum">     714 </span>                :            :     /*! \brief Function that reduces the result of multiple threads
<span class="lineNum">     715 </span>                :            :      * for left and right closest points and part weights in a single mpi process.
<span class="lineNum">     716 </span>                :            :      *
<span class="lineNum">     717 </span>                :            :      * \param num_partitioning_in_current_dim is the vector that holds the number of cut lines in current dimension for each part.
<span class="lineNum">     718 </span>                :            :      * \param current_work_part holds the index of the first part (important when concurrent parts are used.)
<span class="lineNum">     719 </span>                :            :      * \param current_concurrent_num_parts is the number of parts whose cut lines will be calculated concurrently.
<span class="lineNum">     720 </span>                :            :      */
<span class="lineNum">     721 </span>                :            :     void mj_accumulate_thread_results(
<span class="lineNum">     722 </span>                :            :         const std::vector &lt;mj_part_t&gt; &amp;num_partitioning_in_current_dim,
<span class="lineNum">     723 </span>                :            :         mj_part_t current_work_part,
<span class="lineNum">     724 </span>                :            :         mj_part_t current_concurrent_num_parts);
<span class="lineNum">     725 </span>                :            : 
<span class="lineNum">     726 </span>                :            :     /*! \brief Function that calculates the new coordinates for the cut lines.
<span class="lineNum">     727 </span>                :            :      * Function is called inside the parallel region. Write the new cut coordinates
<span class="lineNum">     728 </span>                :            :      * to new_current_cut_coordinates, and determines if the final position of a cut is found.
<span class="lineNum">     729 </span>                :            :      *
<span class="lineNum">     730 </span>                :            :      * \param num_total_part is the sum of number of cutlines and number of parts. Simply it is 2*P - 1.
<span class="lineNum">     731 </span>                :            :      * \param num_cuts is the number of cut lines. P - 1.
<span class="lineNum">     732 </span>                :            :      * \param max_coordinate is the maximum coordinate in the current range of coordinates and in the current dimension.
<span class="lineNum">     733 </span>                :            :      * \param min_coordinate is the maximum coordinate in the current range of coordinates and in the current dimension.
<span class="lineNum">     734 </span>                :            :      * \param global_total_weight is the global total weight in the current range of coordinates.
<span class="lineNum">     735 </span>                :            :      * \param used_imbalance_tolerance is the maximum allowed imbalance ratio.
<span class="lineNum">     736 </span>                :            :      *
<span class="lineNum">     737 </span>                :            :      *
<span class="lineNum">     738 </span>                :            :      * \param current_global_part_weights is the array holding the weight of parts. Assumes there are 2*P - 1 parts (cut lines are seperate parts).
<span class="lineNum">     739 </span>                :            :      * \param current_local_part_weights is the local totalweight of the processor.
<span class="lineNum">     740 </span>                :            :      * \param current_part_target_weights are the desired cumulative part ratios, sized P.
<span class="lineNum">     741 </span>                :            :      * \param current_cut_line_determined is the boolean array to determine if the correct position for a cut line is found.
<span class="lineNum">     742 </span>                :            :      *
<span class="lineNum">     743 </span>                :            :      * \param current_cut_coordinates is the array holding the coordinates of each cut line. Sized P - 1.
<span class="lineNum">     744 </span>                :            :      * \param current_cut_upper_bounds is the array holding the upper bound coordinate for each cut line. Sized P - 1.
<span class="lineNum">     745 </span>                :            :      * \param current_cut_lower_bounds is the array holding the lower bound coordinate for each cut line. Sized P - 1.
<span class="lineNum">     746 </span>                :            :      * \param current_global_left_closest_points is the array holding the closest points to the cut lines from left.
<span class="lineNum">     747 </span>                :            :      * \param current_global_right_closest_points is the array holding the closest points to the cut lines from right.
<span class="lineNum">     748 </span>                :            :      * \param current_cut_lower_bound_weights is the array holding the weight of the parts at the left of lower bound coordinates.
<span class="lineNum">     749 </span>                :            :      * \param current_cut_upper_weights is the array holding the weight of the parts at the left of upper bound coordinates.
<span class="lineNum">     750 </span>                :            :      * \param new_current_cut_coordinates is the work array, sized P - 1.
<span class="lineNum">     751 </span>                :            :      *
<span class="lineNum">     752 </span>                :            :      * \param current_part_cut_line_weight_ratio holds how much weight of the coordinates on the cutline should be put on left side.
<span class="lineNum">     753 </span>                :            :      * \param rectilinear_cut_count is the count of cut lines whose balance can be achived via distributing the points in same coordinate to different parts.
<span class="lineNum">     754 </span>                :            :      * \param my_num_incomplete_cut is the number of cutlines whose position has not been determined yet. For K &gt; 1 it is the count in a single part (whose cut lines are determined).
<span class="lineNum">     755 </span>                :            :      */
<span class="lineNum">     756 </span>                :            :     void mj_get_new_cut_coordinates(
<span class="lineNum">     757 </span>                :            :         const size_t &amp;num_total_part,
<span class="lineNum">     758 </span>                :            :         const mj_part_t &amp;num_cuts,
<span class="lineNum">     759 </span>                :            :         const mj_scalar_t &amp;max_coordinate,
<span class="lineNum">     760 </span>                :            :         const mj_scalar_t &amp;min_coordinate,
<span class="lineNum">     761 </span>                :            :         const mj_scalar_t &amp;global_total_weight,
<span class="lineNum">     762 </span>                :            :         const mj_scalar_t &amp;used_imbalance_tolerance,
<span class="lineNum">     763 </span>                :            :         mj_scalar_t * current_global_part_weights,
<span class="lineNum">     764 </span>                :            :         const mj_scalar_t * current_local_part_weights,
<span class="lineNum">     765 </span>                :            :         const mj_scalar_t *current_part_target_weights,
<span class="lineNum">     766 </span>                :            :         bool *current_cut_line_determined,
<span class="lineNum">     767 </span>                :            :         mj_scalar_t *current_cut_coordinates,
<span class="lineNum">     768 </span>                :            :         mj_scalar_t *current_cut_upper_bounds,
<span class="lineNum">     769 </span>                :            :         mj_scalar_t *current_cut_lower_bounds,
<span class="lineNum">     770 </span>                :            :         mj_scalar_t *current_global_left_closest_points,
<span class="lineNum">     771 </span>                :            :         mj_scalar_t *current_global_right_closest_points,
<span class="lineNum">     772 </span>                :            :         mj_scalar_t * current_cut_lower_bound_weights,
<span class="lineNum">     773 </span>                :            :         mj_scalar_t * current_cut_upper_weights,
<span class="lineNum">     774 </span>                :            :         mj_scalar_t *new_current_cut_coordinates,
<span class="lineNum">     775 </span>                :            :         mj_scalar_t *current_part_cut_line_weight_to_put_left,
<span class="lineNum">     776 </span>                :            :         mj_part_t *rectilinear_cut_count,
<span class="lineNum">     777 </span>                :            :         mj_part_t &amp;my_num_incomplete_cut);
<span class="lineNum">     778 </span>                :            : 
<span class="lineNum">     779 </span>                :            :     /*! \brief
<span class="lineNum">     780 </span>                :            :      * Function that calculates the next pivot position,
<span class="lineNum">     781 </span>                :            :      * according to given coordinates of upper bound and lower bound, the weights at upper and lower bounds, and the expected weight.
<span class="lineNum">     782 </span>                :            :      * \param cut_upper_bound is the upper bound coordinate of the cut.
<span class="lineNum">     783 </span>                :            :      * \param cut_lower_bound is the lower bound coordinate of the cut.
<span class="lineNum">     784 </span>                :            :      * \param cut_upper_weight is the weights at the upper bound of the cut.
<span class="lineNum">     785 </span>                :            :      * \param cut_lower_weight is the weights at the lower bound of the cut.
<span class="lineNum">     786 </span>                :            :      * \param expected_weight is the expected weight that should be placed on the left of the cut line.
<span class="lineNum">     787 </span>                :            :      */
<span class="lineNum">     788 </span>                :            :     void mj_calculate_new_cut_position (
<span class="lineNum">     789 </span>                :            :         mj_scalar_t cut_upper_bound,
<span class="lineNum">     790 </span>                :            :         mj_scalar_t cut_lower_bound,
<span class="lineNum">     791 </span>                :            :         mj_scalar_t cut_upper_weight,
<span class="lineNum">     792 </span>                :            :         mj_scalar_t cut_lower_weight,
<span class="lineNum">     793 </span>                :            :         mj_scalar_t expected_weight,
<span class="lineNum">     794 </span>                :            :         mj_scalar_t &amp;new_cut_position);
<span class="lineNum">     795 </span>                :            : 
<span class="lineNum">     796 </span>                :            :     /*! \brief Function that determines the permutation indices of the coordinates.
<span class="lineNum">     797 </span>                :            :      * \param num_parts is the number of parts.
<span class="lineNum">     798 </span>                :            :      * \param mj_current_dim_coords is 1 dimensional array holding the coordinate values.
<span class="lineNum">     799 </span>                :            :      * \param current_concurrent_cut_coordinate is 1 dimensional array holding the cut coordinates.
<span class="lineNum">     800 </span>                :            :      * \param coordinate_begin is the start index of the given partition on partitionedPointPermutations.
<span class="lineNum">     801 </span>                :            :      * \param coordinate_end is the end index of the given partition on partitionedPointPermutations.
<span class="lineNum">     802 </span>                :            :      * \param used_local_cut_line_weight_to_left holds how much weight of the coordinates on the cutline should be put on left side.
<span class="lineNum">     803 </span>                :            :      * \param used_thread_part_weight_work is the two dimensional array holding the weight of parts for each thread. Assumes there are 2*P - 1 parts (cut lines are seperate parts).
<span class="lineNum">     804 </span>                :            :      * \param out_part_xadj is the indices of coordinates calculated for the partition on next dimension.
<span class="lineNum">     805 </span>                :            :      */
<span class="lineNum">     806 </span>                :            :     void mj_create_new_partitions(
<span class="lineNum">     807 </span>                :            :         mj_part_t num_parts,
<span class="lineNum">     808 </span>                :            :         mj_scalar_t *mj_current_dim_coords,
<span class="lineNum">     809 </span>                :            :         mj_scalar_t *current_concurrent_cut_coordinate,
<span class="lineNum">     810 </span>                :            :         mj_lno_t coordinate_begin,
<span class="lineNum">     811 </span>                :            :         mj_lno_t coordinate_end,
<span class="lineNum">     812 </span>                :            :         mj_scalar_t *used_local_cut_line_weight_to_left,
<span class="lineNum">     813 </span>                :            :         double **used_thread_part_weight_work,
<span class="lineNum">     814 </span>                :            :         mj_lno_t *out_part_xadj);
<span class="lineNum">     815 </span>                :            : 
<span class="lineNum">     816 </span>                :            :     /*! \brief Function checks if should do migration or not.
<span class="lineNum">     817 </span>                :            :      * It returns true to point that migration should be done when
<span class="lineNum">     818 </span>                :            :      * -migration_reduce_all_population are higher than a predetermined value
<span class="lineNum">     819 </span>                :            :      * -num_coords_for_last_dim_part that left for the last dimension partitioning is less than a predetermined value
<span class="lineNum">     820 </span>                :            :      * -the imbalance of the processors on the parts are higher than given threshold.
<span class="lineNum">     821 </span>                :            : 
<span class="lineNum">     822 </span>                :            :      * \param input_num_parts is the number of parts when migration is called.
<span class="lineNum">     823 </span>                :            :      * \param output_num_parts is the output number of parts after migration.
<span class="lineNum">     824 </span>                :            :      * \param next_future_num_parts_in_parts is the number of total future parts each
<span class="lineNum">     825 </span>                :            :      * part is partitioned into. This will be updated when migration is performed.
<span class="lineNum">     826 </span>                :            :      * \param output_part_begin_index is the number that will be used as beginning part number
<span class="lineNum">     827 </span>                :            :      * when final solution part numbers are assigned.
<span class="lineNum">     828 </span>                :            :      * \param migration_reduce_all_population is the estimated total number of reduceall operations
<span class="lineNum">     829 </span>                :            :      * multiplied with number of processors to be used for determining migration.
<span class="lineNum">     830 </span>                :            :      *
<span class="lineNum">     831 </span>                :            :      * \param num_coords_for_last_dim_part is the estimated number of points in each part,
<span class="lineNum">     832 </span>                :            :      * when last dimension partitioning is performed.
<span class="lineNum">     833 </span>                :            :      * \param iteration is the string that gives information about the dimension for printing purposes.
<span class="lineNum">     834 </span>                :            :      * \param input_part_boxes is the array that holds the part boxes after the migration. (swapped)
<span class="lineNum">     835 </span>                :            :      * \param output_part_boxes is the array that holds the part boxes before the migration. (swapped)
<span class="lineNum">     836 </span>                :            :      *
<span class="lineNum">     837 </span>                :            :      */
<span class="lineNum">     838 </span>                :            :     bool mj_perform_migration(
<span class="lineNum">     839 </span>                :            :         mj_part_t in_num_parts, //current umb parts
<span class="lineNum">     840 </span>                :            :         mj_part_t &amp;out_num_parts, //output umb parts.
<span class="lineNum">     841 </span>                :            :         std::vector&lt;mj_part_t&gt; *next_future_num_parts_in_parts,
<span class="lineNum">     842 </span>                :            :         mj_part_t &amp;output_part_begin_index,
<span class="lineNum">     843 </span>                :            :         size_t migration_reduce_all_population,
<span class="lineNum">     844 </span>                :            :         mj_lno_t num_coords_for_last_dim_part,
<span class="lineNum">     845 </span>                :            :         std::string iteration,
<span class="lineNum">     846 </span>                :            :         RCP&lt;mj_partBoxVector_t&gt; &amp;input_part_boxes,
<span class="lineNum">     847 </span>                :            :         RCP&lt;mj_partBoxVector_t&gt; &amp;output_part_boxes);
<span class="lineNum">     848 </span>                :            : 
<span class="lineNum">     849 </span>                :            :     /*! \brief Function fills up the num_points_in_all_processor_parts, so that
<span class="lineNum">     850 </span>                :            :      * it has the number of coordinates in each processor of each part.
<span class="lineNum">     851 </span>                :            :      * to access how many points processor i has on part j, num_points_in_all_processor_parts[i * num_parts + j].
<span class="lineNum">     852 </span>                :            :      *
<span class="lineNum">     853 </span>                :            :      * \param num_procs is the number of processor attending to migration operation.
<span class="lineNum">     854 </span>                :            :      * \param num_parts is the number of parts that exist in the current partitioning.
<span class="lineNum">     855 </span>                :            :      * \param num_points_in_all_processor_parts is the output array that holds
<span class="lineNum">     856 </span>                :            :      * the number of coordinates in each part in each processor.
<span class="lineNum">     857 </span>                :            :      */
<span class="lineNum">     858 </span>                :            :     void get_processor_num_points_in_parts(
<span class="lineNum">     859 </span>                :            :                 mj_part_t num_procs,
<span class="lineNum">     860 </span>                :            :                 mj_part_t num_parts,
<span class="lineNum">     861 </span>                :            :                 mj_gno_t *&amp;num_points_in_all_processor_parts);
<span class="lineNum">     862 </span>                :            : 
<span class="lineNum">     863 </span>                :            :     /*! \brief Function checks if should do migration or not.
<span class="lineNum">     864 </span>                :            :      * It returns true to point that migration should be done when
<span class="lineNum">     865 </span>                :            :      * -migration_reduce_all_population are higher than a predetermined value
<span class="lineNum">     866 </span>                :            :      * -num_coords_for_last_dim_part that left for the last dimension partitioning is less than a predetermined value
<span class="lineNum">     867 </span>                :            :      * -the imbalance of the processors on the parts are higher than given threshold.
<span class="lineNum">     868 </span>                :            :      * \param migration_reduce_all_population is the multiplication of the number of reduceall operations estimated and the number of processors.
<span class="lineNum">     869 </span>                :            :      * \param num_coords_for_last_dim_part is the estimated number of coordinates in a part per processor in the last dimension partitioning.
<span class="lineNum">     870 </span>                :            :      * \param num_procs is the number of processor attending to migration operation.
<span class="lineNum">     871 </span>                :            :      * \param num_parts is the number of parts that exist in the current partitioning.
<span class="lineNum">     872 </span>                :            :      * \param num_points_in_all_processor_parts is the input array that holds
<span class="lineNum">     873 </span>                :            :      * the number of coordinates in each part in each processor.
<span class="lineNum">     874 </span>                :            :      */
<span class="lineNum">     875 </span>                :            :     bool mj_check_to_migrate(
<span class="lineNum">     876 </span>                :            :                 size_t migration_reduce_all_population,
<span class="lineNum">     877 </span>                :            :                 mj_lno_t num_coords_for_last_dim_part,
<span class="lineNum">     878 </span>                :            :                 mj_part_t num_procs,
<span class="lineNum">     879 </span>                :            :                 mj_part_t num_parts,
<span class="lineNum">     880 </span>                :            :                 mj_gno_t *num_points_in_all_processor_parts);
<span class="lineNum">     881 </span>                :            : 
<span class="lineNum">     882 </span>                :            : 
<span class="lineNum">     883 </span>                :            :     /*! \brief Function fills up coordinate_destinations is the output array
<span class="lineNum">     884 </span>                :            :      * that holds which part each coordinate should be sent. In addition it calculates
<span class="lineNum">     885 </span>                :            :      * the shift amount (output_part_numbering_begin_index) to be done when
<span class="lineNum">     886 </span>                :            :      * final numberings of the parts are performed.
<span class="lineNum">     887 </span>                :            :      *
<span class="lineNum">     888 </span>                :            :      * \param num_points_in_all_processor_parts is the array holding the num points in each part in each proc.
<span class="lineNum">     889 </span>                :            :      * \param num_parts is the number of parts that exist in the current partitioning.
<span class="lineNum">     890 </span>                :            :      * \param num_procs is the number of processor attending to migration operation.
<span class="lineNum">     891 </span>                :            : 
<span class="lineNum">     892 </span>                :            :      * \param send_count_to_each_proc array array storing the number of points to be sent to each part.
<span class="lineNum">     893 </span>                :            :      * \param processor_ranks_for_subcomm is the ranks of the processors that will be in the subcommunicator with me.
<span class="lineNum">     894 </span>                :            :      * \param next_future_num_parts_in_parts is the vector, how many more parts each part will be divided into in the future.
<span class="lineNum">     895 </span>                :            :      * \param out_num_part is the number of parts assigned to the process.
<span class="lineNum">     896 </span>                :            :      * \param out_part_indices is the indices of the part to which the processor is assigned.
<span class="lineNum">     897 </span>                :            :      * \param output_part_numbering_begin_index is how much the numbers should be shifted when numbering the result parts.
<span class="lineNum">     898 </span>                :            :      * \param coordinate_destinations is the output array that holds which part each coordinate should be sent.
<span class="lineNum">     899 </span>                :            :      */
<span class="lineNum">     900 </span>                :            :     void mj_migration_part_proc_assignment(
<span class="lineNum">     901 </span>                :            :                 mj_gno_t * num_points_in_all_processor_parts,
<span class="lineNum">     902 </span>                :            :                 mj_part_t num_parts,
<span class="lineNum">     903 </span>                :            :                 mj_part_t num_procs,
<span class="lineNum">     904 </span>                :            :                 mj_lno_t *send_count_to_each_proc,
<span class="lineNum">     905 </span>                :            :                 std::vector&lt;mj_part_t&gt; &amp;processor_ranks_for_subcomm,
<span class="lineNum">     906 </span>                :            :                 std::vector&lt;mj_part_t&gt; *next_future_num_parts_in_parts,
<span class="lineNum">     907 </span>                :            :                 mj_part_t &amp;out_num_part,
<span class="lineNum">     908 </span>                :            :                 std::vector&lt;mj_part_t&gt; &amp;out_part_indices,
<span class="lineNum">     909 </span>                :            :                 mj_part_t &amp;output_part_numbering_begin_index,
<span class="lineNum">     910 </span>                :            :                 int *coordinate_destinations);
<span class="lineNum">     911 </span>                :            : 
<span class="lineNum">     912 </span>                :            :     /*! \brief Function that assigned the processors to parts, when there are more processors then parts.
<span class="lineNum">     913 </span>                :            :      *  sets the destination of each coordinate in coordinate_destinations, also edits output_part_numbering_begin_index,
<span class="lineNum">     914 </span>                :            :      *  and out_part_index, and returns the processor_ranks_for_subcomm which represents the ranks of the processors
<span class="lineNum">     915 </span>                :            :      *  that will be used for creating the subcommunicator.
<span class="lineNum">     916 </span>                :            :      *
<span class="lineNum">     917 </span>                :            :      * \param num_points_in_all_processor_parts is the array holding the num points in each part in each proc.
<span class="lineNum">     918 </span>                :            :      * \param num_parts is the number of parts that exist in the current partitioning.
<span class="lineNum">     919 </span>                :            :      * \param num_procs is the number of processor attending to migration operation.
<span class="lineNum">     920 </span>                :            : 
<span class="lineNum">     921 </span>                :            :      * \param send_count_to_each_proc array array storing the number of points to be sent to each part.
<span class="lineNum">     922 </span>                :            :      * \param processor_ranks_for_subcomm is the ranks of the processors that will be in the subcommunicator with me.
<span class="lineNum">     923 </span>                :            :      * \param next_future_num_parts_in_parts is the vector, how many more parts each part will be divided into in the future.
<span class="lineNum">     924 </span>                :            :      * \param out_part_index is the index of the part to which the processor is assigned.
<span class="lineNum">     925 </span>                :            :      * \param output_part_numbering_begin_index is how much the numbers should be shifted when numbering the result parts.
<span class="lineNum">     926 </span>                :            :      * \param coordinate_destinations is the output array that holds which part each coordinate should be sent.
<span class="lineNum">     927 </span>                :            :      */
<span class="lineNum">     928 </span>                :            :     void mj_assign_proc_to_parts(
<span class="lineNum">     929 </span>                :            :                 mj_gno_t * num_points_in_all_processor_parts,
<span class="lineNum">     930 </span>                :            :                 mj_part_t num_parts,
<span class="lineNum">     931 </span>                :            :                 mj_part_t num_procs,
<span class="lineNum">     932 </span>                :            :                 mj_lno_t *send_count_to_each_proc,
<span class="lineNum">     933 </span>                :            :                 std::vector&lt;mj_part_t&gt; &amp;processor_ranks_for_subcomm,
<span class="lineNum">     934 </span>                :            :                 std::vector&lt;mj_part_t&gt; *next_future_num_parts_in_parts,
<span class="lineNum">     935 </span>                :            :                 mj_part_t &amp;out_part_index,
<span class="lineNum">     936 </span>                :            :                 mj_part_t &amp;output_part_numbering_begin_index,
<span class="lineNum">     937 </span>                :            :                 int *coordinate_destinations);
<span class="lineNum">     938 </span>                :            : 
<span class="lineNum">     939 </span>                :            :     /*! \brief Function fills up coordinate_destinations is the output array
<span class="lineNum">     940 </span>                :            :      * that holds which part each coordinate should be sent.
<span class="lineNum">     941 </span>                :            :      *
<span class="lineNum">     942 </span>                :            :      * \param num_parts is the number of parts that exist in the current partitioning.
<span class="lineNum">     943 </span>                :            :      * \param num_procs is the number of processor attending to migration operation.
<span class="lineNum">     944 </span>                :            :      * \param part_assignment_proc_begin_indices ([i]) points to the first processor index that part i will be sent to.
<span class="lineNum">     945 </span>                :            :      * \param processor_chains_in_parts the array that holds the linked list structure, started from part_assignment_proc_begin_indices ([i]).
<span class="lineNum">     946 </span>                :            :      * \param send_count_to_each_proc array array storing the number of points to be sent to each part.
<span class="lineNum">     947 </span>                :            :      * \param coordinate_destinations is the output array that holds which part each coordinate should be sent.
<span class="lineNum">     948 </span>                :            :      */
<span class="lineNum">     949 </span>                :            :     void assign_send_destinations(
<span class="lineNum">     950 </span>                :            :                 mj_part_t num_parts,
<span class="lineNum">     951 </span>                :            :                 mj_part_t *part_assignment_proc_begin_indices,
<span class="lineNum">     952 </span>                :            :                 mj_part_t *processor_chains_in_parts,
<span class="lineNum">     953 </span>                :            :                 mj_lno_t *send_count_to_each_proc,
<span class="lineNum">     954 </span>                :            :                 int *coordinate_destinations);
<span class="lineNum">     955 </span>                :            : 
<span class="lineNum">     956 </span>                :            :     /*! \brief Function fills up coordinate_destinations is the output array
<span class="lineNum">     957 </span>                :            :      * that holds which part each coordinate should be sent. In addition it calculates
<span class="lineNum">     958 </span>                :            :      * the shift amount (output_part_numbering_begin_index) to be done when
<span class="lineNum">     959 </span>                :            :      * final numberings of the parts are performed.
<span class="lineNum">     960 </span>                :            :      *
<span class="lineNum">     961 </span>                :            :      * \param num_parts is the number of parts that exist in the current partitioning.
<span class="lineNum">     962 </span>                :            :      * \param sort_item_part_to_proc_assignment is the sorted parts with respect to the assigned processors.
<span class="lineNum">     963 </span>                :            :      * \param coordinate_destinations is the output array that holds which part each coordinate should be sent.
<span class="lineNum">     964 </span>                :            :      * \param output_part_numbering_begin_index is how much the numbers should be shifted when numbering the result parts.
<span class="lineNum">     965 </span>                :            :      * \param next_future_num_parts_in_parts is the vector, how many more parts each part will be divided into in the future.
<span class="lineNum">     966 </span>                :            :      *
<span class="lineNum">     967 </span>                :            :      */
<span class="lineNum">     968 </span>                :            :     void assign_send_destinations2(
<span class="lineNum">     969 </span>                :            :         mj_part_t num_parts,
<span class="lineNum">     970 </span>                :            :         uSortItem&lt;mj_part_t, mj_part_t&gt; * sort_item_part_to_proc_assignment, //input sorted wrt processors
<span class="lineNum">     971 </span>                :            :         int *coordinate_destinations,
<span class="lineNum">     972 </span>                :            :         mj_part_t &amp;output_part_numbering_begin_index,
<span class="lineNum">     973 </span>                :            :         std::vector&lt;mj_part_t&gt; *next_future_num_parts_in_parts);
<span class="lineNum">     974 </span>                :            : 
<span class="lineNum">     975 </span>                :            :     /*! \brief Function fills up coordinate_destinations is the output array
<span class="lineNum">     976 </span>                :            :      * that holds which part each coordinate should be sent. In addition it calculates
<span class="lineNum">     977 </span>                :            :      * the shift amount (output_part_numbering_begin_index) to be done when
<span class="lineNum">     978 </span>                :            :      * final numberings of the parts are performed.
<span class="lineNum">     979 </span>                :            :      *
<span class="lineNum">     980 </span>                :            :      * \param num_points_in_all_processor_parts is the array holding the num points in each part in each proc.
<span class="lineNum">     981 </span>                :            :      * \param num_parts is the number of parts that exist in the current partitioning.
<span class="lineNum">     982 </span>                :            :      * \param num_procs is the number of processor attending to migration operation.
<span class="lineNum">     983 </span>                :            : 
<span class="lineNum">     984 </span>                :            :      * \param send_count_to_each_proc array array storing the number of points to be sent to each part.
<span class="lineNum">     985 </span>                :            :      * \param next_future_num_parts_in_parts is the vector, how many more parts each part will be divided into in the future.
<span class="lineNum">     986 </span>                :            :      * \param out_num_part is the number of parts assigned to the process.
<span class="lineNum">     987 </span>                :            :      * \param out_part_indices is the indices of the part to which the processor is assigned.
<span class="lineNum">     988 </span>                :            :      * \param output_part_numbering_begin_index is how much the numbers should be shifted when numbering the result parts.
<span class="lineNum">     989 </span>                :            :      * \param coordinate_destinations is the output array that holds which part each coordinate should be sent.
<span class="lineNum">     990 </span>                :            :      */
<span class="lineNum">     991 </span>                :            :     void mj_assign_parts_to_procs(
<span class="lineNum">     992 </span>                :            :         mj_gno_t * num_points_in_all_processor_parts,
<span class="lineNum">     993 </span>                :            :         mj_part_t num_parts,
<span class="lineNum">     994 </span>                :            :         mj_part_t num_procs,
<span class="lineNum">     995 </span>                :            :         mj_lno_t *send_count_to_each_proc, //output: sized nprocs, show the number of send point counts to each proc.
<span class="lineNum">     996 </span>                :            :         std::vector&lt;mj_part_t&gt; *next_future_num_parts_in_parts,//input how many more partitions the part will be partitioned into.
<span class="lineNum">     997 </span>                :            :         mj_part_t &amp;out_num_part, //output, how many parts the processor will have. this is always 1 for this function.
<span class="lineNum">     998 </span>                :            :         std::vector&lt;mj_part_t&gt; &amp;out_part_indices, //output: the part indices which the processor is assigned to.
<span class="lineNum">     999 </span>                :            :         mj_part_t &amp;output_part_numbering_begin_index, //output: how much the part number should be shifted when setting the solution
<span class="lineNum">    1000 </span>                :            :         int *coordinate_destinations);
<span class="lineNum">    1001 </span>                :            : 
<span class="lineNum">    1002 </span>                :            :     /*! \brief Function fills up coordinate_destinations is the output array
<span class="lineNum">    1003 </span>                :            :      * that holds which part each coordinate should be sent. In addition it calculates
<span class="lineNum">    1004 </span>                :            :      * the shift amount (output_part_numbering_begin_index) to be done when
<span class="lineNum">    1005 </span>                :            :      * final numberings of the parts are performed.
<span class="lineNum">    1006 </span>                :            :      *
<span class="lineNum">    1007 </span>                :            :      *
<span class="lineNum">    1008 </span>                :            :      * \param num_procs is the number of processor attending to migration operation.
<span class="lineNum">    1009 </span>                :            :      * \param num_new_local_points is the output to represent the new number of local points.
<span class="lineNum">    1010 </span>                :            :      * \param iteration is the string for the current iteration.
<span class="lineNum">    1011 </span>                :            :      * \param coordinate_destinations is the output array that holds which part each coordinate should be sent.
<span class="lineNum">    1012 </span>                :            :      * \param num_parts is the number of parts that exist in the current partitioning.
<span class="lineNum">    1013 </span>                :            :      */
<span class="lineNum">    1014 </span>                :            :     void mj_migrate_coords(
<span class="lineNum">    1015 </span>                :            :         mj_part_t num_procs,
<span class="lineNum">    1016 </span>                :            :         mj_lno_t &amp;num_new_local_points,
<span class="lineNum">    1017 </span>                :            :         std::string iteration,
<span class="lineNum">    1018 </span>                :            :         int *coordinate_destinations,
<span class="lineNum">    1019 </span>                :            :         mj_part_t num_parts);
<span class="lineNum">    1020 </span>                :            : 
<span class="lineNum">    1021 </span>                :            :     /*! \brief Function creates the new subcomminicator for the processors
<span class="lineNum">    1022 </span>                :            :      * given in processor_ranks_for_subcomm.
<span class="lineNum">    1023 </span>                :            :      *
<span class="lineNum">    1024 </span>                :            :      * \param processor_ranks_for_subcomm is the vector that has the ranks of
<span class="lineNum">    1025 </span>                :            :      * the processors that will be in the same group.
<span class="lineNum">    1026 </span>                :            :      */
<span class="lineNum">    1027 </span>                :            :     void create_sub_communicator(std::vector&lt;mj_part_t&gt; &amp;processor_ranks_for_subcomm);
<span class="lineNum">    1028 </span>                :            : 
<span class="lineNum">    1029 </span>                :            : 
<span class="lineNum">    1030 </span>                :            :     /*! \brief Function writes the new permutation arrays after the migration.
<span class="lineNum">    1031 </span>                :            :      *
<span class="lineNum">    1032 </span>                :            :      * \param output_num_parts is the number of parts that is assigned to the processor.
<span class="lineNum">    1033 </span>                :            :      * \param num_parts is the number of parts right before migration.
<span class="lineNum">    1034 </span>                :            :      */
<span class="lineNum">    1035 </span>                :            :     void fill_permutation_array(
<span class="lineNum">    1036 </span>                :            :         mj_part_t output_num_parts,
<span class="lineNum">    1037 </span>                :            :         mj_part_t num_parts);
<span class="lineNum">    1038 </span>                :            : 
<span class="lineNum">    1039 </span>                :            :     /*! \brief Function checks if should do migration or not.
<span class="lineNum">    1040 </span>                :            :      * \param current_num_parts is the number of parts in the process.
<span class="lineNum">    1041 </span>                :            :      * \param output_part_begin_index is the number that will be used as beginning part number
<span class="lineNum">    1042 </span>                :            :      * \param output_part_boxes is the array that holds the part boxes
<span class="lineNum">    1043 </span>                :            :      * \param is_data_ever_migrated is the boolean value which is true
<span class="lineNum">    1044 </span>                :            :      * if the data is ever migrated during the partitioning.
<span class="lineNum">    1045 </span>                :            :      *
<span class="lineNum">    1046 </span>                :            :      */
<span class="lineNum">    1047 </span>                :            :     void set_final_parts(
<span class="lineNum">    1048 </span>                :            :                 mj_part_t current_num_parts,
<span class="lineNum">    1049 </span>                :            :                 mj_part_t output_part_begin_index,
<span class="lineNum">    1050 </span>                :            :                 RCP&lt;mj_partBoxVector_t&gt; &amp;output_part_boxes,
<span class="lineNum">    1051 </span>                :            :                 bool is_data_ever_migrated);
<span class="lineNum">    1052 </span>                :            :     /*! \brief Function frees all allocated work memory.
<span class="lineNum">    1053 </span>                :            :      */
<span class="lineNum">    1054 </span>                :            :     void free_work_memory();
<span class="lineNum">    1055 </span>                :            :     /*! \brief Function creates consistent chunks for task partitioning. Used only in the case of
<span class="lineNum">    1056 </span>                :            :      * sequential task partitioning, where consistent handle of the points on the cuts are required.
<span class="lineNum">    1057 </span>                :            :      *
<span class="lineNum">    1058 </span>                :            :      * \param num_parts is the number of parts.
<span class="lineNum">    1059 </span>                :            :      * \param mj_current_dim_coords is 1 dimensional array holding the coordinate values.
<span class="lineNum">    1060 </span>                :            :      * \param current_concurrent_cut_coordinate is 1 dimensional array holding the cut coordinates.
<span class="lineNum">    1061 </span>                :            :      * \param coordinate_begin is the start index of the given partition on partitionedPointPermutations.
<span class="lineNum">    1062 </span>                :            :      * \param coordinate_end is the end index of the given partition on partitionedPointPermutations.
<span class="lineNum">    1063 </span>                :            :      * \param used_local_cut_line_weight_to_left holds how much weight of the coordinates on the cutline should be put on left side.
<span class="lineNum">    1064 </span>                :            :      *
<span class="lineNum">    1065 </span>                :            :      * \param out_part_xadj is the indices of begginning and end of the parts in the output partition.
<span class="lineNum">    1066 </span>                :            :      * \param coordInd is the index according to which the partitioning is done.
<span class="lineNum">    1067 </span>                :            :      */
<span class="lineNum">    1068 </span>                :            :     void create_consistent_chunks(
<span class="lineNum">    1069 </span>                :            :         mj_part_t num_parts,
<span class="lineNum">    1070 </span>                :            :         mj_scalar_t *mj_current_dim_coords,
<span class="lineNum">    1071 </span>                :            :         mj_scalar_t *current_concurrent_cut_coordinate,
<span class="lineNum">    1072 </span>                :            :         mj_lno_t coordinate_begin,
<span class="lineNum">    1073 </span>                :            :         mj_lno_t coordinate_end,
<span class="lineNum">    1074 </span>                :            :         mj_scalar_t *used_local_cut_line_weight_to_left,
<span class="lineNum">    1075 </span>                :            :         mj_lno_t *out_part_xadj,
<span class="lineNum">    1076 </span>                :            :         int coordInd);
<span class="lineNum">    1077 </span>                :            : public:
<span class="lineNum">    1078 </span>                :            :     AlgMJ();
<span class="lineNum">    1079 </span>                :            : 
<span class="lineNum">    1080 </span>                :            :     /*! \brief Multi Jagged  coordinate partitioning algorithm.
<span class="lineNum">    1081 </span>                :            :      *
<span class="lineNum">    1082 </span>                :            :      *  \param env   library configuration and problem parameters
<span class="lineNum">    1083 </span>                :            :      *  \param problemComm the communicator for the problem
<span class="lineNum">    1084 </span>                :            :      *  \param imbalance_tolerance : the input provided imbalance tolerance.
<span class="lineNum">    1085 </span>                :            :      *  \param num_global_parts: number of target global parts.
<span class="lineNum">    1086 </span>                :            :      *  \param part_no_array: part no array, if provided this will be used for partitioning.
<span class="lineNum">    1087 </span>                :            :      *  \param recursion_depth: if part no array is provided, it is the length of part no array,
<span class="lineNum">    1088 </span>                :            :      *                                                  if part no is not provided than it is the number of steps that algorithm will divide into num_global_parts parts.
<span class="lineNum">    1089 </span>                :            :      *
<span class="lineNum">    1090 </span>                :            :      *  \param coord_dim: coordinate dimension
<span class="lineNum">    1091 </span>                :            :      *  \param num_local_coords: number of local coordinates
<span class="lineNum">    1092 </span>                :            :      *  \param num_global_coords: number of global coordinates
<span class="lineNum">    1093 </span>                :            :      *  \param initial_mj_gnos: the list of initial global id's
<span class="lineNum">    1094 </span>                :            :      *  \param mj_coordinates: the two dimensional coordinate array.
<span class="lineNum">    1095 </span>                :            :      *
<span class="lineNum">    1096 </span>                :            :      *  \param num_weights_per_coord: number of weights per coordinate
<span class="lineNum">    1097 </span>                :            :      *  \param mj_uniform_weights: if weight index [i] has uniform weight or not.
<span class="lineNum">    1098 </span>                :            :      *  \param mj_weights: the two dimensional array for weights
<span class="lineNum">    1099 </span>                :            :      *  \param mj_uniform_parts: if the target partitioning aims uniform parts
<span class="lineNum">    1100 </span>                :            :      *  \param mj_part_sizes: if the target partitioning does not aim uniform parts, then weight of each part.
<span class="lineNum">    1101 </span>                :            :      *
<span class="lineNum">    1102 </span>                :            :      *  \param result_assigned_part_ids: Output - 1D pointer, should be provided as null.
<span class="lineNum">    1103 </span>                :            :      *                          the result partids corresponding to the coordinates given in result_mj_gnos.
<span class="lineNum">    1104 </span>                :            :      *  \param result_mj_gnos: Output - 1D pointer, should be provided as null.
<span class="lineNum">    1105 </span>                :            :      *                          the result coordinate global id's corresponding to the part_ids array.
<span class="lineNum">    1106 </span>                :            :      *
<span class="lineNum">    1107 </span>                :            :      */
<span class="lineNum">    1108 </span>                :            :     void multi_jagged_part(
<span class="lineNum">    1109 </span>                :            :                 const RCP&lt;const Environment&gt; &amp;env,
<span class="lineNum">    1110 </span>                :            :                 RCP&lt;Comm&lt;int&gt; &gt; &amp;problemComm,
<span class="lineNum">    1111 </span>                :            : 
<span class="lineNum">    1112 </span>                :            :                 double imbalance_tolerance,
<span class="lineNum">    1113 </span>                :            :                 size_t num_global_parts,
<span class="lineNum">    1114 </span>                :            :                 mj_part_t *part_no_array,
<span class="lineNum">    1115 </span>                :            :                 int recursion_depth,
<span class="lineNum">    1116 </span>                :            : 
<span class="lineNum">    1117 </span>                :            :                 int coord_dim,
<span class="lineNum">    1118 </span>                :            :                 mj_lno_t num_local_coords,
<span class="lineNum">    1119 </span>                :            :                 mj_gno_t num_global_coords,
<span class="lineNum">    1120 </span>                :            :                 const mj_gno_t *initial_mj_gnos,
<span class="lineNum">    1121 </span>                :            :                 mj_scalar_t **mj_coordinates,
<span class="lineNum">    1122 </span>                :            : 
<span class="lineNum">    1123 </span>                :            :                 int num_weights_per_coord,
<span class="lineNum">    1124 </span>                :            :                 bool *mj_uniform_weights,
<span class="lineNum">    1125 </span>                :            :                 mj_scalar_t **mj_weights,
<span class="lineNum">    1126 </span>                :            :                 bool *mj_uniform_parts,
<span class="lineNum">    1127 </span>                :            :                 mj_scalar_t **mj_part_sizes,
<span class="lineNum">    1128 </span>                :            : 
<span class="lineNum">    1129 </span>                :            :                 mj_part_t *&amp;result_assigned_part_ids,
<span class="lineNum">    1130 </span>                :            :                 mj_gno_t *&amp;result_mj_gnos
<span class="lineNum">    1131 </span>                :            : 
<span class="lineNum">    1132 </span>                :            :                 );
<span class="lineNum">    1133 </span>                :            :     /*! \brief Multi Jagged  coordinate partitioning algorithm.
<span class="lineNum">    1134 </span>                :            :      *
<span class="lineNum">    1135 </span>                :            :      *  \param distribute_points_on_cut_lines_ :  if partitioning can distribute points on same coordinate to different parts.
<span class="lineNum">    1136 </span>                :            :      *  \param max_concurrent_part_calculation_ : how many parts we can calculate concurrently.
<span class="lineNum">    1137 </span>                :            :      *  \param check_migrate_avoid_migration_option_ : whether to migrate=1, avoid migrate=2, or leave decision to MJ=0
<span class="lineNum">    1138 </span>                :            :      *  \param minimum_migration_imbalance_  : when MJ decides whether to migrate, the minimum imbalance for migration.
<span class="lineNum">    1139 </span>                :            :      */
<span class="lineNum">    1140 </span>                :            :     void set_partitioning_parameters(
<span class="lineNum">    1141 </span>                :            :                 bool distribute_points_on_cut_lines_,
<span class="lineNum">    1142 </span>                :            :                 int max_concurrent_part_calculation_,
<span class="lineNum">    1143 </span>                :            :                 int check_migrate_avoid_migration_option_,
<span class="lineNum">    1144 </span>                :            :                 mj_scalar_t minimum_migration_imbalance_);
<span class="lineNum">    1145 </span>                :            :     /*! \brief Function call, if the part boxes are intended to be kept.
<span class="lineNum">    1146 </span>                :            :      *
<span class="lineNum">    1147 </span>                :            :      */
<span class="lineNum">    1148 </span>                :            :     void set_to_keep_part_boxes();
<span class="lineNum">    1149 </span>                :            : 
<span class="lineNum">    1150 </span>                :            :     /*! \brief Return the global bounding box: min/max coords of global domain
<span class="lineNum">    1151 </span>                :            :      */
<span class="lineNum">    1152 </span>                :            :     RCP&lt;mj_partBox_t&gt; get_global_box() const;
<span class="lineNum">    1153 </span>                :            : 
<span class="lineNum">    1154 </span>                :            :     RCP&lt;mj_partBoxVector_t&gt; get_kept_boxes() const;
<span class="lineNum">    1155 </span>                :            : 
<span class="lineNum">    1156 </span>                :            :     RCP&lt;mj_partBoxVector_t&gt; compute_global_box_boundaries(
<span class="lineNum">    1157 </span>                :            :         RCP&lt;mj_partBoxVector_t&gt; &amp;localPartBoxes) const;
<span class="lineNum">    1158 </span>                :            : 
<span class="lineNum">    1159 </span>                :            :     /*! \brief Special function for partitioning for task mapping.
<span class="lineNum">    1160 </span>                :            :      * Runs sequential, and performs deterministic partitioning for the
<span class="lineNum">    1161 </span>                :            :      * partitioning the points along a cutline.
<span class="lineNum">    1162 </span>                :            :      *
<span class="lineNum">    1163 </span>                :            :      *  \param env library configuration and problem parameters
<span class="lineNum">    1164 </span>                :            :      *  \param num_total_coords number of total coordinates
<span class="lineNum">    1165 </span>                :            :      *  \param num_selected_coords : the number of selected coordinates. This is to set,
<span class="lineNum">    1166 </span>                :            :      *                                                          if there are n processors, but only m&lt;n processors
<span class="lineNum">    1167 </span>                :            :      *                                                          are selected for mapping.
<span class="lineNum">    1168 </span>                :            :      *
<span class="lineNum">    1169 </span>                :            :      *  \param num_target_part: number of target global parts.
<span class="lineNum">    1170 </span>                :            :      *  \param coord_dim_: coordinate dimension for coordinates
<span class="lineNum">    1171 </span>                :            :      *  \param mj_coordinates_: the coordinates
<span class="lineNum">    1172 </span>                :            :      *
<span class="lineNum">    1173 </span>                :            :      *  \param inital_adjList_output_adjlist: Array allocated by caller, in the size of num_total_coords,
<span class="lineNum">    1174 </span>                :            :      *                                                  first num_selected_coords elements should list the indices of the selected processors.
<span class="lineNum">    1175 </span>                :            :      *                                                  This is output for output permutation array.
<span class="lineNum">    1176 </span>                :            :      *  \param output_xadj: The output part xadj array, pointing beginning and end of each part on
<span class="lineNum">    1177 </span>                :            :      *          output permutation array (inital_adjList_output_adjlist).
<span class="lineNum">    1178 </span>                :            :      *          Returned in CSR format: part i's info in output_xadj[i] : output_xadj[i+1]
<span class="lineNum">    1179 </span>                :            :      *
<span class="lineNum">    1180 </span>                :            :      *  \param rd: recursion depth
<span class="lineNum">    1181 </span>                :            :      *  \param part_no_array_: possibly null part_no_array, specifying how many parts each should be divided during partitioning.
<span class="lineNum">    1182 </span>                :            :      */
<span class="lineNum">    1183 </span>                :            :     void sequential_task_partitioning(
<span class="lineNum">    1184 </span>                :            :         const RCP&lt;const Environment&gt; &amp;env,
<span class="lineNum">    1185 </span>                :            :         mj_lno_t num_total_coords,
<span class="lineNum">    1186 </span>                :            :         mj_lno_t num_selected_coords,
<span class="lineNum">    1187 </span>                :            :         size_t num_target_part,
<span class="lineNum">    1188 </span>                :            :         int coord_dim,
<span class="lineNum">    1189 </span>                :            :         mj_scalar_t **mj_coordinates,
<span class="lineNum">    1190 </span>                :            :         mj_lno_t *initial_selected_coords_output_permutation,
<span class="lineNum">    1191 </span>                :            :         mj_lno_t *output_xadj,
<span class="lineNum">    1192 </span>                :            :         int recursion_depth,
<span class="lineNum">    1193 </span>                :            :         const mj_part_t *part_no_array);
<span class="lineNum">    1194 </span>                :            : 
<span class="lineNum">    1195 </span>                :            : };
<span class="lineNum">    1196 </span>                :            : 
<span class="lineNum">    1197 </span>                :            : /*! \brief Special function for partitioning for task mapping.
<span class="lineNum">    1198 </span>                :            :  * Runs sequential, and performs deterministic partitioning for the
<span class="lineNum">    1199 </span>                :            :  * partitioning the points along a cutline.
<span class="lineNum">    1200 </span>                :            :  *
<span class="lineNum">    1201 </span>                :            :  *  \param env library configuration and problem parameters
<span class="lineNum">    1202 </span>                :            :  *  \param num_total_coords number of total coordinates
<span class="lineNum">    1203 </span>                :            :  *  \param num_selected_coords : the number of selected coordinates. This is to set,
<span class="lineNum">    1204 </span>                :            :  *                                                      if there are n processors, but only m&lt;n processors
<span class="lineNum">    1205 </span>                :            :  *                                                      are selected for mapping.
<span class="lineNum">    1206 </span>                :            :  *
<span class="lineNum">    1207 </span>                :            :  *  \param num_target_part: number of target global parts.
<span class="lineNum">    1208 </span>                :            :  *  \param coord_dim_: coordinate dimension for coordinates
<span class="lineNum">    1209 </span>                :            :  *  \param mj_coordinates_: the coordinates
<span class="lineNum">    1210 </span>                :            :  *
<span class="lineNum">    1211 </span>                :            :  *  \param inital_adjList_output_adjlist: Array allocated by caller, in the size of num_total_coords,
<span class="lineNum">    1212 </span>                :            :  *                                              first num_selected_coords elements should list the indices of the selected processors.
<span class="lineNum">    1213 </span>                :            :  *                                              This is output for output permutation array.
<span class="lineNum">    1214 </span>                :            :  *  \param output_xadj: The output part xadj array, pointing beginning and end of each part on
<span class="lineNum">    1215 </span>                :            :  *      output permutation array (inital_adjList_output_adjlist).
<span class="lineNum">    1216 </span>                :            :  *      Returned in CSR format: part i's info in output_xadj[i] : output_xadj[i+1]
<span class="lineNum">    1217 </span>                :            :  *
<span class="lineNum">    1218 </span>                :            :  *  \param rd: recursion depth
<span class="lineNum">    1219 </span>                :            :  *  \param part_no_array_: possibly null part_no_array, specifying how many parts each should be divided during partitioning.
<span class="lineNum">    1220 </span>                :            :  */
<a name="1221"><span class="lineNum">    1221 </span>                :            : template &lt;typename mj_scalar_t, typename mj_lno_t, typename mj_gno_t,</a>
<span class="lineNum">    1222 </span>                :            :           typename mj_part_t&gt;
<span class="lineNum">    1223 </span>                :<span class="lineNoCov">          0 : void AlgMJ&lt;mj_scalar_t, mj_lno_t, mj_gno_t, mj_part_t&gt;::sequential_task_partitioning(</span>
<span class="lineNum">    1224 </span>                :            :     const RCP&lt;const Environment&gt; &amp;env,
<span class="lineNum">    1225 </span>                :            :     mj_lno_t num_total_coords,
<span class="lineNum">    1226 </span>                :            :     mj_lno_t num_selected_coords,
<span class="lineNum">    1227 </span>                :            :     size_t num_target_part,
<span class="lineNum">    1228 </span>                :            :     int coord_dim_,
<span class="lineNum">    1229 </span>                :            :     mj_scalar_t **mj_coordinates_,
<span class="lineNum">    1230 </span>                :            :     mj_lno_t *inital_adjList_output_adjlist,
<span class="lineNum">    1231 </span>                :            :     mj_lno_t *output_xadj,
<span class="lineNum">    1232 </span>                :            :     int rd,
<span class="lineNum">    1233 </span>                :            :     const mj_part_t *part_no_array_
<span class="lineNum">    1234 </span>                :            : ){
<span class="lineNum">    1235 </span>                :            : 
<span class="lineNum">    1236 </span>                :<span class="lineNoCov">          0 :         this-&gt;mj_env = env;</span>
<span class="lineNum">    1237 </span>                :<span class="lineNoCov">          0 :         const RCP&lt;Comm&lt;int&gt; &gt; commN;</span>
<span class="lineNum">    1238 </span>                :<span class="lineNoCov">          0 :         this-&gt;comm = this-&gt;mj_problemComm =  Teuchos::rcp_const_cast&lt;Comm&lt;int&gt; &gt;</span>
<span class="lineNum">    1239 </span>                :            :         (Teuchos::DefaultComm&lt;int&gt;::getDefaultSerialComm(commN));
<span class="lineNum">    1240 </span>                :<span class="lineNoCov">          0 :         this-&gt;myActualRank = this-&gt;myRank = 1;</span>
<span class="lineNum">    1241 </span>                :            : 
<span class="lineNum">    1242 </span>                :            : #ifdef HAVE_ZOLTAN2_OMP
<span class="lineNum">    1243 </span>                :            :         int actual_num_threads = omp_get_num_threads();
<span class="lineNum">    1244 </span>                :            :         omp_set_num_threads(1);
<span class="lineNum">    1245 </span>                :            : #endif
<span class="lineNum">    1246 </span>                :            : 
<span class="lineNum">    1247 </span>                :            :     //weights are uniform for task mapping
<span class="lineNum">    1248 </span>                :            : 
<span class="lineNum">    1249 </span>                :            :     //parts are uniform for task mapping
<span class="lineNum">    1250 </span>                :            :     //as input indices.
<span class="lineNum">    1251 </span>                :            : 
<span class="lineNum">    1252 </span>                :<span class="lineNoCov">          0 :     this-&gt;imbalance_tolerance = 0;</span>
<span class="lineNum">    1253 </span>                :<span class="lineNoCov">          0 :     this-&gt;num_global_parts = num_target_part;</span>
<span class="lineNum">    1254 </span>                :<span class="lineNoCov">          0 :     this-&gt;part_no_array = (mj_part_t *)part_no_array_;</span>
<span class="lineNum">    1255 </span>                :<span class="lineNoCov">          0 :     this-&gt;recursion_depth = rd;</span>
<span class="lineNum">    1256 </span>                :            : 
<span class="lineNum">    1257 </span>                :<span class="lineNoCov">          0 :     this-&gt;coord_dim = coord_dim_;</span>
<span class="lineNum">    1258 </span>                :<span class="lineNoCov">          0 :     this-&gt;num_local_coords = num_total_coords;</span>
<span class="lineNum">    1259 </span>                :<span class="lineNoCov">          0 :     this-&gt;num_global_coords = num_total_coords;</span>
<span class="lineNum">    1260 </span>                :<span class="lineNoCov">          0 :     this-&gt;mj_coordinates = mj_coordinates_;  //will copy the memory to this-&gt;mj_coordinates.</span>
<span class="lineNum">    1261 </span>                :            : 
<span class="lineNum">    1262 </span>                :            :     ////temporary memory. It is not used here, but the functions require these to be allocated.
<span class="lineNum">    1263 </span>                :            :     ////will copy the memory to this-&gt;current_mj_gnos[j].
<span class="lineNum">    1264 </span>                :<span class="lineNoCov">          0 :     this-&gt;initial_mj_gnos = allocMemory&lt;mj_gno_t&gt;(this-&gt;num_local_coords);</span>
<span class="lineNum">    1265 </span>                :            : 
<span class="lineNum">    1266 </span>                :<span class="lineNoCov">          0 :     this-&gt;num_weights_per_coord = 0;</span>
<span class="lineNum">    1267 </span>                :<span class="lineNoCov">          0 :     bool *tmp_mj_uniform_weights = new bool[1];</span>
<span class="lineNum">    1268 </span>                :<span class="lineNoCov">          0 :     this-&gt;mj_uniform_weights = tmp_mj_uniform_weights ;</span>
<span class="lineNum">    1269 </span>                :<span class="lineNoCov">          0 :     this-&gt;mj_uniform_weights[0] = true;</span>
<span class="lineNum">    1270 </span>                :            : 
<span class="lineNum">    1271 </span>                :<span class="lineNoCov">          0 :     mj_scalar_t **tmp_mj_weights = new mj_scalar_t *[1];</span>
<span class="lineNum">    1272 </span>                :<span class="lineNoCov">          0 :     this-&gt;mj_weights = tmp_mj_weights; //will copy the memory to this-&gt;mj_weights</span>
<span class="lineNum">    1273 </span>                :            : 
<span class="lineNum">    1274 </span>                :<span class="lineNoCov">          0 :     bool *tmp_mj_uniform_parts = new bool[1];</span>
<span class="lineNum">    1275 </span>                :<span class="lineNoCov">          0 :     this-&gt;mj_uniform_parts = tmp_mj_uniform_parts;</span>
<span class="lineNum">    1276 </span>                :<span class="lineNoCov">          0 :     this-&gt;mj_uniform_parts[0] = true;</span>
<span class="lineNum">    1277 </span>                :            : 
<span class="lineNum">    1278 </span>                :<span class="lineNoCov">          0 :     mj_scalar_t **tmp_mj_part_sizes = new mj_scalar_t * [1];</span>
<span class="lineNum">    1279 </span>                :<span class="lineNoCov">          0 :     this-&gt;mj_part_sizes = tmp_mj_part_sizes;</span>
<span class="lineNum">    1280 </span>                :<span class="lineNoCov">          0 :     this-&gt;mj_part_sizes[0] = NULL;</span>
<span class="lineNum">    1281 </span>                :            : 
<span class="lineNum">    1282 </span>                :<span class="lineNoCov">          0 :     this-&gt;num_threads = 1;</span>
<span class="lineNum">    1283 </span>                :<span class="lineNoCov">          0 :     this-&gt;set_part_specifications();</span>
<span class="lineNum">    1284 </span>                :            : 
<span class="lineNum">    1285 </span>                :<span class="lineNoCov">          0 :     this-&gt;allocate_set_work_memory();</span>
<span class="lineNum">    1286 </span>                :            :     //the end of the initial partition is the end of coordinates.
<span class="lineNum">    1287 </span>                :<span class="lineNoCov">          0 :     this-&gt;part_xadj[0] = static_cast&lt;mj_lno_t&gt;(num_selected_coords);</span>
<span class="lineNum">    1288 </span>                :<span class="lineNoCov">          0 :     for(size_t i = 0; i &lt; static_cast&lt;size_t&gt;(num_total_coords); ++i){</span>
<span class="lineNum">    1289 </span>                :<span class="lineNoCov">          0 :         this-&gt;coordinate_permutations[i] = inital_adjList_output_adjlist[i];</span>
<span class="lineNum">    1290 </span>                :            :     }
<span class="lineNum">    1291 </span>                :            : 
<span class="lineNum">    1292 </span>                :<span class="lineNoCov">          0 :     mj_part_t current_num_parts = 1;</span>
<span class="lineNum">    1293 </span>                :            : 
<span class="lineNum">    1294 </span>                :<span class="lineNoCov">          0 :     mj_scalar_t *current_cut_coordinates =  this-&gt;all_cut_coordinates;</span>
<span class="lineNum">    1295 </span>                :            : 
<span class="lineNum">    1296 </span>                :<span class="lineNoCov">          0 :     mj_part_t future_num_parts = this-&gt;total_num_part;</span>
<span class="lineNum">    1297 </span>                :            : 
<span class="lineNum">    1298 </span>                :<span class="lineNoCov">          0 :     std::vector&lt;mj_part_t&gt; *future_num_part_in_parts = new std::vector&lt;mj_part_t&gt; ();</span>
<span class="lineNum">    1299 </span>                :<span class="lineNoCov">          0 :     std::vector&lt;mj_part_t&gt; *next_future_num_parts_in_parts = new std::vector&lt;mj_part_t&gt; ();</span>
<span class="lineNum">    1300 </span>                :<span class="lineNoCov">          0 :     next_future_num_parts_in_parts-&gt;push_back(this-&gt;num_global_parts);</span>
<span class="lineNum">    1301 </span>                :<span class="lineNoCov">          0 :     RCP&lt;mj_partBoxVector_t&gt; t1;</span>
<span class="lineNum">    1302 </span>                :<span class="lineNoCov">          0 :     RCP&lt;mj_partBoxVector_t&gt; t2;</span>
<span class="lineNum">    1303 </span>                :            : 
<span class="lineNum">    1304 </span>                :<span class="lineNoCov">          0 :     for (int i = 0; i &lt; this-&gt;recursion_depth; ++i){</span>
<span class="lineNum">    1305 </span>                :            : 
<span class="lineNum">    1306 </span>                :            :         //partitioning array. size will be as the number of current partitions and this
<span class="lineNum">    1307 </span>                :            :         //holds how many parts that each part will be in the current dimension partitioning.
<span class="lineNum">    1308 </span>                :<span class="lineNoCov">          0 :         std::vector &lt;mj_part_t&gt; num_partitioning_in_current_dim;</span>
<span class="lineNum">    1309 </span>                :            : 
<span class="lineNum">    1310 </span>                :            :         //number of parts that will be obtained at the end of this partitioning.
<span class="lineNum">    1311 </span>                :            :         //future_num_part_in_parts is as the size of current number of parts.
<span class="lineNum">    1312 </span>                :            :         //holds how many more parts each should be divided in the further
<span class="lineNum">    1313 </span>                :            :         //iterations. this will be used to calculate num_partitioning_in_current_dim,
<span class="lineNum">    1314 </span>                :            :         //as the number of parts that the part will be partitioned
<span class="lineNum">    1315 </span>                :            :         //in the current dimension partitioning.
<span class="lineNum">    1316 </span>                :            : 
<span class="lineNum">    1317 </span>                :            :         //next_future_num_parts_in_parts will be as the size of outnumParts,
<span class="lineNum">    1318 </span>                :            :         //and this will hold how many more parts that each output part
<span class="lineNum">    1319 </span>                :            :         //should be divided. this array will also be used to determine the weight ratios
<span class="lineNum">    1320 </span>                :            :         //of the parts.
<span class="lineNum">    1321 </span>                :            :         //swap the arrays to use iteratively..
<span class="lineNum">    1322 </span>                :<span class="lineNoCov">          0 :         std::vector&lt;mj_part_t&gt; *tmpPartVect= future_num_part_in_parts;</span>
<span class="lineNum">    1323 </span>                :<span class="lineNoCov">          0 :         future_num_part_in_parts = next_future_num_parts_in_parts;</span>
<span class="lineNum">    1324 </span>                :<span class="lineNoCov">          0 :         next_future_num_parts_in_parts = tmpPartVect;</span>
<span class="lineNum">    1325 </span>                :            : 
<span class="lineNum">    1326 </span>                :            :         //clear next_future_num_parts_in_parts array as
<span class="lineNum">    1327 </span>                :            :         //getPartitionArrays expects it to be empty.
<span class="lineNum">    1328 </span>                :            :         //it also expects num_partitioning_in_current_dim to be empty as well.
<span class="lineNum">    1329 </span>                :<span class="lineNoCov">          0 :         next_future_num_parts_in_parts-&gt;clear();</span>
<span class="lineNum">    1330 </span>                :            : 
<span class="lineNum">    1331 </span>                :            : 
<span class="lineNum">    1332 </span>                :            :         //returns the total number of output parts for this dimension partitioning.
<span class="lineNum">    1333 </span>                :            :         mj_part_t output_part_count_in_dimension =
<span class="lineNum">    1334 </span>                :            :                         this-&gt;update_part_num_arrays(
<span class="lineNum">    1335 </span>                :            :                                         num_partitioning_in_current_dim,
<span class="lineNum">    1336 </span>                :            :                                         future_num_part_in_parts,
<span class="lineNum">    1337 </span>                :            :                                         next_future_num_parts_in_parts,
<span class="lineNum">    1338 </span>                :            :                                         future_num_parts,
<span class="lineNum">    1339 </span>                :            :                                         current_num_parts,
<span class="lineNum">    1340 </span>                :            :                                         i,
<span class="lineNum">    1341 </span>                :            :                                         t1,
<span class="lineNum">    1342 </span>                :<span class="lineNoCov">          0 :                                         t2);</span>
<span class="lineNum">    1343 </span>                :            : 
<span class="lineNum">    1344 </span>                :            :         //if the number of obtained parts equal to current number of parts,
<span class="lineNum">    1345 </span>                :            :         //skip this dimension. For example, this happens when 1 is given in the input
<span class="lineNum">    1346 </span>                :            :         //part array is given. P=4,5,1,2
<span class="lineNum">    1347 </span>                :<span class="lineNoCov">          0 :         if(output_part_count_in_dimension == current_num_parts) {</span>
<span class="lineNum">    1348 </span>                :<span class="lineNoCov">          0 :             tmpPartVect= future_num_part_in_parts;</span>
<span class="lineNum">    1349 </span>                :<span class="lineNoCov">          0 :             future_num_part_in_parts = next_future_num_parts_in_parts;</span>
<span class="lineNum">    1350 </span>                :<span class="lineNoCov">          0 :             next_future_num_parts_in_parts = tmpPartVect;</span>
<span class="lineNum">    1351 </span>                :<span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">    1352 </span>                :            :         }
<span class="lineNum">    1353 </span>                :            : 
<span class="lineNum">    1354 </span>                :            :         //get the coordinate axis along which the partitioning will be done.
<span class="lineNum">    1355 </span>                :<span class="lineNoCov">          0 :         int coordInd = i % this-&gt;coord_dim;</span>
<span class="lineNum">    1356 </span>                :<span class="lineNoCov">          0 :         mj_scalar_t * mj_current_dim_coords = this-&gt;mj_coordinates[coordInd];</span>
<span class="lineNum">    1357 </span>                :            :         //convert i to string to be used for debugging purposes.
<span class="lineNum">    1358 </span>                :<span class="lineNoCov">          0 :         std::string istring = toString&lt;int&gt;(i);</span>
<span class="lineNum">    1359 </span>                :            : 
<span class="lineNum">    1360 </span>                :            :         //alloc Memory to point the indices
<span class="lineNum">    1361 </span>                :            :         //of the parts in the permutation array.
<span class="lineNum">    1362 </span>                :<span class="lineNoCov">          0 :         this-&gt;new_part_xadj = allocMemory&lt;mj_lno_t&gt;(output_part_count_in_dimension);</span>
<span class="lineNum">    1363 </span>                :            : 
<span class="lineNum">    1364 </span>                :            :         //the index where in the outtotalCounts will be written.
<span class="lineNum">    1365 </span>                :<span class="lineNoCov">          0 :         mj_part_t output_part_index = 0;</span>
<span class="lineNum">    1366 </span>                :            :         //whatever is written to outTotalCounts will be added with previousEnd
<span class="lineNum">    1367 </span>                :            :         //so that the points will be shifted.
<span class="lineNum">    1368 </span>                :<span class="lineNoCov">          0 :         mj_part_t output_coordinate_end_index = 0;</span>
<span class="lineNum">    1369 </span>                :            : 
<span class="lineNum">    1370 </span>                :<span class="lineNoCov">          0 :         mj_part_t current_work_part = 0;</span>
<span class="lineNum">    1371 </span>                :<span class="lineNoCov">          0 :         mj_part_t current_concurrent_num_parts = std::min(current_num_parts - current_work_part,</span>
<span class="lineNum">    1372 </span>                :<span class="lineNoCov">          0 :                                          this-&gt;max_concurrent_part_calculation);</span>
<span class="lineNum">    1373 </span>                :            : 
<span class="lineNum">    1374 </span>                :<span class="lineNoCov">          0 :         mj_part_t obtained_part_index = 0;</span>
<span class="lineNum">    1375 </span>                :            : 
<span class="lineNum">    1376 </span>                :            :         //run for all available parts.
<span class="lineNum">    1377 </span>                :<span class="lineNoCov">          0 :         for (; current_work_part &lt; current_num_parts;</span>
<span class="lineNum">    1378 </span>                :            :                      current_work_part += current_concurrent_num_parts){
<span class="lineNum">    1379 </span>                :            : 
<span class="lineNum">    1380 </span>                :<span class="lineNoCov">          0 :             current_concurrent_num_parts = std::min(current_num_parts - current_work_part,</span>
<span class="lineNum">    1381 </span>                :            :             this-&gt;max_concurrent_part_calculation);
<span class="lineNum">    1382 </span>                :            : 
<span class="lineNum">    1383 </span>                :<span class="lineNoCov">          0 :             mj_part_t actual_work_part_count = 0;</span>
<span class="lineNum">    1384 </span>                :            :             //initialization for 1D partitioning.
<span class="lineNum">    1385 </span>                :            :             //get the min and max coordinates of each part
<span class="lineNum">    1386 </span>                :            :             //together with the part weights of each part.
<span class="lineNum">    1387 </span>                :<span class="lineNoCov">          0 :             for(int kk = 0; kk &lt; current_concurrent_num_parts; ++kk){</span>
<span class="lineNum">    1388 </span>                :<span class="lineNoCov">          0 :                 mj_part_t current_work_part_in_concurrent_parts = current_work_part + kk;</span>
<span class="lineNum">    1389 </span>                :            : 
<span class="lineNum">    1390 </span>                :            :                 //if this part wont be partitioned any further
<span class="lineNum">    1391 </span>                :            :                 //dont do any work for this part.
<span class="lineNum">    1392 </span>                :<span class="lineNoCov">          0 :                 if (num_partitioning_in_current_dim[current_work_part_in_concurrent_parts] == 1){</span>
<span class="lineNum">    1393 </span>                :<span class="lineNoCov">          0 :                     continue;</span>
<span class="lineNum">    1394 </span>                :            :                 }
<span class="lineNum">    1395 </span>                :<span class="lineNoCov">          0 :                 ++actual_work_part_count;</span>
<span class="lineNum">    1396 </span>                :<span class="lineNoCov">          0 :                 mj_lno_t coordinate_end_index= this-&gt;part_xadj[current_work_part_in_concurrent_parts];</span>
<span class="lineNum">    1397 </span>                :<span class="lineNoCov">          0 :                 mj_lno_t coordinate_begin_index = current_work_part_in_concurrent_parts==0 ? 0: this-&gt;part_xadj[current_work_part_in_concurrent_parts -1];</span>
<span class="lineNum">    1398 </span>                :            : 
<span class="lineNum">    1399 </span>                :            :                 /*
<span class="lineNum">    1400 </span>                :            :                 std::cout &lt;&lt; &quot;i:&quot; &lt;&lt; i &lt;&lt; &quot; j:&quot; &lt;&lt; current_work_part + kk
<span class="lineNum">    1401 </span>                :            :                                 &lt;&lt; &quot; coordinate_begin_index:&quot; &lt;&lt; coordinate_begin_index
<span class="lineNum">    1402 </span>                :            :                                 &lt;&lt; &quot; coordinate_end_index:&quot; &lt;&lt; coordinate_end_index
<span class="lineNum">    1403 </span>                :            :                                 &lt;&lt; &quot; total:&quot; &lt;&lt; coordinate_end_index - coordinate_begin_index&lt;&lt; std::endl;
<span class="lineNum">    1404 </span>                :            :                                 */
<span class="lineNum">    1405 </span>                :<span class="lineNoCov">          0 :                 this-&gt;mj_get_local_min_max_coord_totW(</span>
<span class="lineNum">    1406 </span>                :            :                                 coordinate_begin_index,
<span class="lineNum">    1407 </span>                :            :                                 coordinate_end_index,
<span class="lineNum">    1408 </span>                :            :                                 this-&gt;coordinate_permutations,
<span class="lineNum">    1409 </span>                :            :                                 mj_current_dim_coords,
<span class="lineNum">    1410 </span>                :<span class="lineNoCov">          0 :                                 this-&gt;process_local_min_max_coord_total_weight[kk], //min coordinate</span>
<span class="lineNum">    1411 </span>                :<span class="lineNoCov">          0 :                         this-&gt;process_local_min_max_coord_total_weight[kk + current_concurrent_num_parts], //max coordinate</span>
<span class="lineNum">    1412 </span>                :<span class="lineNoCov">          0 :                         this-&gt;process_local_min_max_coord_total_weight[kk + 2*current_concurrent_num_parts] //total weight);</span>
<span class="lineNum">    1413 </span>                :            :                 );
<span class="lineNum">    1414 </span>                :            :             }
<span class="lineNum">    1415 </span>                :            : 
<span class="lineNum">    1416 </span>                :            :             //1D partitioning
<span class="lineNum">    1417 </span>                :<span class="lineNoCov">          0 :             if (actual_work_part_count &gt; 0){</span>
<span class="lineNum">    1418 </span>                :            :                 //obtain global Min max of the part.
<span class="lineNum">    1419 </span>                :<span class="lineNoCov">          0 :                 this-&gt;mj_get_global_min_max_coord_totW(</span>
<span class="lineNum">    1420 </span>                :            :                                 current_concurrent_num_parts,
<span class="lineNum">    1421 </span>                :            :                                 this-&gt;process_local_min_max_coord_total_weight,
<span class="lineNum">    1422 </span>                :            :                                 this-&gt;global_min_max_coord_total_weight);
<span class="lineNum">    1423 </span>                :            : 
<span class="lineNum">    1424 </span>                :            :                 //represents the total number of cutlines
<span class="lineNum">    1425 </span>                :            :                 //whose coordinate should be determined.
<span class="lineNum">    1426 </span>                :<span class="lineNoCov">          0 :                 mj_part_t total_incomplete_cut_count = 0;</span>
<span class="lineNum">    1427 </span>                :            : 
<span class="lineNum">    1428 </span>                :            :                 //Compute weight ratios for parts &amp; cuts:
<span class="lineNum">    1429 </span>                :            :                 //e.g., 0.25  0.25  0.5    0.5  0.75 0.75  1
<span class="lineNum">    1430 </span>                :            :                 //part0  cut0  part1 cut1 part2 cut2 part3
<span class="lineNum">    1431 </span>                :<span class="lineNoCov">          0 :                 mj_part_t concurrent_part_cut_shift = 0;</span>
<span class="lineNum">    1432 </span>                :<span class="lineNoCov">          0 :                 mj_part_t concurrent_part_part_shift = 0;</span>
<span class="lineNum">    1433 </span>                :<span class="lineNoCov">          0 :                 for(int kk = 0; kk &lt; current_concurrent_num_parts; ++kk){</span>
<span class="lineNum">    1434 </span>                :<span class="lineNoCov">          0 :                     mj_scalar_t min_coordinate = this-&gt;global_min_max_coord_total_weight[kk];</span>
<span class="lineNum">    1435 </span>                :<span class="lineNoCov">          0 :                     mj_scalar_t max_coordinate = this-&gt;global_min_max_coord_total_weight[kk +</span>
<span class="lineNum">    1436 </span>                :<span class="lineNoCov">          0 :                                                      current_concurrent_num_parts];</span>
<span class="lineNum">    1437 </span>                :            :                     mj_scalar_t global_total_weight =
<span class="lineNum">    1438 </span>                :<span class="lineNoCov">          0 :                                                         this-&gt;global_min_max_coord_total_weight[kk +</span>
<span class="lineNum">    1439 </span>                :<span class="lineNoCov">          0 :                                                      2 * current_concurrent_num_parts];</span>
<span class="lineNum">    1440 </span>                :            : 
<span class="lineNum">    1441 </span>                :<span class="lineNoCov">          0 :                     mj_part_t concurrent_current_part_index = current_work_part + kk;</span>
<span class="lineNum">    1442 </span>                :            : 
<span class="lineNum">    1443 </span>                :<span class="lineNoCov">          0 :                     mj_part_t partition_count = num_partitioning_in_current_dim[concurrent_current_part_index];</span>
<span class="lineNum">    1444 </span>                :            : 
<span class="lineNum">    1445 </span>                :<span class="lineNoCov">          0 :                     mj_scalar_t *usedCutCoordinate = current_cut_coordinates + concurrent_part_cut_shift;</span>
<span class="lineNum">    1446 </span>                :<span class="lineNoCov">          0 :                     mj_scalar_t *current_target_part_weights = this-&gt;target_part_weights +</span>
<span class="lineNum">    1447 </span>                :<span class="lineNoCov">          0 :                                                                      concurrent_part_part_shift;</span>
<span class="lineNum">    1448 </span>                :            :                     //shift the usedCutCoordinate array as noCuts.
<span class="lineNum">    1449 </span>                :<span class="lineNoCov">          0 :                     concurrent_part_cut_shift += partition_count - 1;</span>
<span class="lineNum">    1450 </span>                :            :                     //shift the partRatio array as noParts.
<span class="lineNum">    1451 </span>                :<span class="lineNoCov">          0 :                     concurrent_part_part_shift += partition_count;</span>
<span class="lineNum">    1452 </span>                :            : 
<span class="lineNum">    1453 </span>                :            :                     //calculate only if part is not empty,
<span class="lineNum">    1454 </span>                :            :                     //and part will be further partitioend.
<span class="lineNum">    1455 </span>                :<span class="lineNoCov">          0 :                     if(partition_count &gt; 1 &amp;&amp; min_coordinate &lt;= max_coordinate){</span>
<span class="lineNum">    1456 </span>                :            : 
<span class="lineNum">    1457 </span>                :            :                         //increase allDone by the number of cuts of the current
<span class="lineNum">    1458 </span>                :            :                         //part's cut line number.
<span class="lineNum">    1459 </span>                :<span class="lineNoCov">          0 :                         total_incomplete_cut_count += partition_count - 1;</span>
<span class="lineNum">    1460 </span>                :            :                         //set the number of cut lines that should be determined
<span class="lineNum">    1461 </span>                :            :                         //for this part.
<span class="lineNum">    1462 </span>                :<span class="lineNoCov">          0 :                         this-&gt;my_incomplete_cut_count[kk] = partition_count - 1;</span>
<span class="lineNum">    1463 </span>                :            : 
<span class="lineNum">    1464 </span>                :            :                         //get the target weights of the parts.
<span class="lineNum">    1465 </span>                :<span class="lineNoCov">          0 :                         this-&gt;mj_get_initial_cut_coords_target_weights(</span>
<span class="lineNum">    1466 </span>                :            :                             min_coordinate,
<span class="lineNum">    1467 </span>                :            :                             max_coordinate,
<span class="lineNum">    1468 </span>                :            :                             partition_count - 1,
<span class="lineNum">    1469 </span>                :            :                             global_total_weight,
<span class="lineNum">    1470 </span>                :            :                             usedCutCoordinate,
<span class="lineNum">    1471 </span>                :            :                             current_target_part_weights,
<span class="lineNum">    1472 </span>                :            :                             future_num_part_in_parts,
<span class="lineNum">    1473 </span>                :            :                             next_future_num_parts_in_parts,
<span class="lineNum">    1474 </span>                :            :                             concurrent_current_part_index,
<span class="lineNum">    1475 </span>                :            :                             obtained_part_index);
<span class="lineNum">    1476 </span>                :            : 
<span class="lineNum">    1477 </span>                :<span class="lineNoCov">          0 :                         mj_lno_t coordinate_end_index= this-&gt;part_xadj[concurrent_current_part_index];</span>
<span class="lineNum">    1478 </span>                :<span class="lineNoCov">          0 :                         mj_lno_t coordinate_begin_index = concurrent_current_part_index==0 ? 0: this-&gt;part_xadj[concurrent_current_part_index -1];</span>
<span class="lineNum">    1479 </span>                :            : 
<span class="lineNum">    1480 </span>                :            :                         //get the initial estimated part assignments of the coordinates.
<span class="lineNum">    1481 </span>                :<span class="lineNoCov">          0 :                         this-&gt;set_initial_coordinate_parts(</span>
<span class="lineNum">    1482 </span>                :            :                             max_coordinate,
<span class="lineNum">    1483 </span>                :            :                             min_coordinate,
<span class="lineNum">    1484 </span>                :            :                             concurrent_current_part_index,
<span class="lineNum">    1485 </span>                :            :                             coordinate_begin_index, coordinate_end_index,
<span class="lineNum">    1486 </span>                :            :                             this-&gt;coordinate_permutations,
<span class="lineNum">    1487 </span>                :            :                             mj_current_dim_coords,
<span class="lineNum">    1488 </span>                :            :                             this-&gt;assigned_part_ids,
<span class="lineNum">    1489 </span>                :<span class="lineNoCov">          0 :                             partition_count);</span>
<span class="lineNum">    1490 </span>                :            :                     }
<span class="lineNum">    1491 </span>                :            :                     else {
<span class="lineNum">    1492 </span>                :            :                         // e.g., if have fewer coordinates than parts, don't need to do next dim.
<span class="lineNum">    1493 </span>                :<span class="lineNoCov">          0 :                         this-&gt;my_incomplete_cut_count[kk] = 0;</span>
<span class="lineNum">    1494 </span>                :            :                     }
<span class="lineNum">    1495 </span>                :<span class="lineNoCov">          0 :                     obtained_part_index += partition_count;</span>
<span class="lineNum">    1496 </span>                :            :                 }
<span class="lineNum">    1497 </span>                :            : 
<span class="lineNum">    1498 </span>                :            :                 //used imbalance, it is always 0, as it is difficult to estimate a range.
<span class="lineNum">    1499 </span>                :<span class="lineNoCov">          0 :                 mj_scalar_t used_imbalance = 0;</span>
<span class="lineNum">    1500 </span>                :            : 
<span class="lineNum">    1501 </span>                :            :                 // Determine cut lines for k parts here.
<span class="lineNum">    1502 </span>                :<span class="lineNoCov">          0 :                 this-&gt;mj_1D_part(</span>
<span class="lineNum">    1503 </span>                :            :                     mj_current_dim_coords,
<span class="lineNum">    1504 </span>                :            :                     used_imbalance,
<span class="lineNum">    1505 </span>                :            :                     current_work_part,
<span class="lineNum">    1506 </span>                :            :                     current_concurrent_num_parts,
<span class="lineNum">    1507 </span>                :            :                     current_cut_coordinates,
<span class="lineNum">    1508 </span>                :            :                     total_incomplete_cut_count,
<span class="lineNum">    1509 </span>                :            :                     num_partitioning_in_current_dim);
<span class="lineNum">    1510 </span>                :            :             }
<span class="lineNum">    1511 </span>                :            : 
<span class="lineNum">    1512 </span>                :            :             //create part chunks
<span class="lineNum">    1513 </span>                :            :             {
<span class="lineNum">    1514 </span>                :            : 
<span class="lineNum">    1515 </span>                :<span class="lineNoCov">          0 :                 mj_part_t output_array_shift = 0;</span>
<span class="lineNum">    1516 </span>                :<span class="lineNoCov">          0 :                 mj_part_t cut_shift = 0;</span>
<span class="lineNum">    1517 </span>                :<span class="lineNoCov">          0 :                 size_t tlr_shift = 0;</span>
<span class="lineNum">    1518 </span>                :<span class="lineNoCov">          0 :                 size_t partweight_array_shift = 0;</span>
<span class="lineNum">    1519 </span>                :            : 
<span class="lineNum">    1520 </span>                :<span class="lineNoCov">          0 :                 for(int kk = 0; kk &lt; current_concurrent_num_parts; ++kk){</span>
<span class="lineNum">    1521 </span>                :<span class="lineNoCov">          0 :                     mj_part_t current_concurrent_work_part = current_work_part + kk;</span>
<span class="lineNum">    1522 </span>                :<span class="lineNoCov">          0 :                     mj_part_t num_parts = num_partitioning_in_current_dim[current_concurrent_work_part];</span>
<span class="lineNum">    1523 </span>                :            : 
<span class="lineNum">    1524 </span>                :            :                     //if the part is empty, skip the part.
<span class="lineNum">    1525 </span>                :<span class="lineNoCov">          0 :                     if((num_parts != 1  ) &amp;&amp; this-&gt;global_min_max_coord_total_weight[kk] &gt;</span>
<span class="lineNum">    1526 </span>                :<span class="lineNoCov">          0 :                              this-&gt;global_min_max_coord_total_weight[kk + current_concurrent_num_parts]) {</span>
<span class="lineNum">    1527 </span>                :            : 
<span class="lineNum">    1528 </span>                :<span class="lineNoCov">          0 :                         for(mj_part_t jj = 0; jj &lt; num_parts; ++jj){</span>
<span class="lineNum">    1529 </span>                :<span class="lineNoCov">          0 :                             this-&gt;new_part_xadj[output_part_index + output_array_shift + jj] = 0;</span>
<span class="lineNum">    1530 </span>                :            :                         }
<span class="lineNum">    1531 </span>                :<span class="lineNoCov">          0 :                         cut_shift += num_parts - 1;</span>
<span class="lineNum">    1532 </span>                :<span class="lineNoCov">          0 :                         tlr_shift += (4 *(num_parts - 1) + 1);</span>
<span class="lineNum">    1533 </span>                :<span class="lineNoCov">          0 :                         output_array_shift += num_parts;</span>
<span class="lineNum">    1534 </span>                :<span class="lineNoCov">          0 :                         partweight_array_shift += (2 * (num_parts - 1) + 1);</span>
<span class="lineNum">    1535 </span>                :<span class="lineNoCov">          0 :                         continue;</span>
<span class="lineNum">    1536 </span>                :            :                     }
<span class="lineNum">    1537 </span>                :            : 
<span class="lineNum">    1538 </span>                :<span class="lineNoCov">          0 :                     mj_lno_t coordinate_end = this-&gt;part_xadj[current_concurrent_work_part];</span>
<span class="lineNum">    1539 </span>                :<span class="lineNoCov">          0 :                     mj_lno_t coordinate_begin = current_concurrent_work_part==0 ? 0: this-&gt;part_xadj[current_concurrent_work_part</span>
<span class="lineNum">    1540 </span>                :<span class="lineNoCov">          0 :                                                              -1];</span>
<span class="lineNum">    1541 </span>                :<span class="lineNoCov">          0 :                     mj_scalar_t *current_concurrent_cut_coordinate = current_cut_coordinates + cut_shift;</span>
<span class="lineNum">    1542 </span>                :<span class="lineNoCov">          0 :                     mj_scalar_t *used_local_cut_line_weight_to_left = this-&gt;process_cut_line_weight_to_put_left +</span>
<span class="lineNum">    1543 </span>                :<span class="lineNoCov">          0 :                                                          cut_shift;</span>
<span class="lineNum">    1544 </span>                :            : 
<span class="lineNum">    1545 </span>                :<span class="lineNoCov">          0 :                     for(int ii = 0; ii &lt; this-&gt;num_threads; ++ii){</span>
<span class="lineNum">    1546 </span>                :<span class="lineNoCov">          0 :                         this-&gt;thread_part_weight_work[ii] = this-&gt;thread_part_weights[ii] +  partweight_array_shift;</span>
<span class="lineNum">    1547 </span>                :            :                     }
<span class="lineNum">    1548 </span>                :            : 
<span class="lineNum">    1549 </span>                :<span class="lineNoCov">          0 :                     if(num_parts &gt; 1){</span>
<span class="lineNum">    1550 </span>                :            :                         // Rewrite the indices based on the computed cuts.
<span class="lineNum">    1551 </span>                :<span class="lineNoCov">          0 :                         this-&gt;create_consistent_chunks(</span>
<span class="lineNum">    1552 </span>                :            :                             num_parts,
<span class="lineNum">    1553 </span>                :            :                             mj_current_dim_coords,
<span class="lineNum">    1554 </span>                :            :                             current_concurrent_cut_coordinate,
<span class="lineNum">    1555 </span>                :            :                             coordinate_begin,
<span class="lineNum">    1556 </span>                :            :                             coordinate_end,
<span class="lineNum">    1557 </span>                :            :                             used_local_cut_line_weight_to_left,
<span class="lineNum">    1558 </span>                :<span class="lineNoCov">          0 :                             this-&gt;new_part_xadj + output_part_index + output_array_shift,</span>
<span class="lineNum">    1559 </span>                :            :                             coordInd );
<span class="lineNum">    1560 </span>                :            :                     }
<span class="lineNum">    1561 </span>                :            :                     else {
<span class="lineNum">    1562 </span>                :            :                         //if this part is partitioned into 1 then just copy
<span class="lineNum">    1563 </span>                :            :                         //the old values.
<span class="lineNum">    1564 </span>                :<span class="lineNoCov">          0 :                         mj_lno_t part_size = coordinate_end - coordinate_begin;</span>
<span class="lineNum">    1565 </span>                :<span class="lineNoCov">          0 :                         *(this-&gt;new_part_xadj + output_part_index + output_array_shift) = part_size;</span>
<span class="lineNum">    1566 </span>                :<span class="lineNoCov">          0 :                         memcpy(this-&gt;new_coordinate_permutations + coordinate_begin,</span>
<span class="lineNum">    1567 </span>                :<span class="lineNoCov">          0 :                         this-&gt;coordinate_permutations + coordinate_begin,</span>
<span class="lineNum">    1568 </span>                :            :                         part_size * sizeof(mj_lno_t));
<span class="lineNum">    1569 </span>                :            :                     }
<span class="lineNum">    1570 </span>                :<span class="lineNoCov">          0 :                     cut_shift += num_parts - 1;</span>
<span class="lineNum">    1571 </span>                :<span class="lineNoCov">          0 :                     tlr_shift += (4 *(num_parts - 1) + 1);</span>
<span class="lineNum">    1572 </span>                :<span class="lineNoCov">          0 :                     output_array_shift += num_parts;</span>
<span class="lineNum">    1573 </span>                :<span class="lineNoCov">          0 :                     partweight_array_shift += (2 * (num_parts - 1) + 1);</span>
<span class="lineNum">    1574 </span>                :            :                 }
<span class="lineNum">    1575 </span>                :            : 
<span class="lineNum">    1576 </span>                :            :                 //shift cut coordinates so that all cut coordinates are stored.
<span class="lineNum">    1577 </span>                :            :                 //current_cut_coordinates += cutShift;
<span class="lineNum">    1578 </span>                :            : 
<span class="lineNum">    1579 </span>                :            :                 //getChunks from coordinates partitioned the parts and
<span class="lineNum">    1580 </span>                :            :                 //wrote the indices as if there were a single part.
<span class="lineNum">    1581 </span>                :            :                 //now we need to shift the beginning indices.
<span class="lineNum">    1582 </span>                :<span class="lineNoCov">          0 :                 for(mj_part_t kk = 0; kk &lt; current_concurrent_num_parts; ++kk){</span>
<span class="lineNum">    1583 </span>                :<span class="lineNoCov">          0 :                     mj_part_t num_parts = num_partitioning_in_current_dim[ current_work_part + kk];</span>
<span class="lineNum">    1584 </span>                :<span class="lineNoCov">          0 :                     for (mj_part_t ii = 0;ii &lt; num_parts ; ++ii){</span>
<span class="lineNum">    1585 </span>                :            :                         //shift it by previousCount
<span class="lineNum">    1586 </span>                :<span class="lineNoCov">          0 :                         this-&gt;new_part_xadj[output_part_index+ii] += output_coordinate_end_index;</span>
<span class="lineNum">    1587 </span>                :            :                     }
<span class="lineNum">    1588 </span>                :            :                     //increase the previous count by current end.
<span class="lineNum">    1589 </span>                :<span class="lineNoCov">          0 :                     output_coordinate_end_index = this-&gt;new_part_xadj[output_part_index + num_parts - 1];</span>
<span class="lineNum">    1590 </span>                :            :                     //increase the current out.
<span class="lineNum">    1591 </span>                :<span class="lineNoCov">          0 :                     output_part_index += num_parts ;</span>
<span class="lineNum">    1592 </span>                :            :                 }
<span class="lineNum">    1593 </span>                :            :             }
<span class="lineNum">    1594 </span>                :            :         }
<span class="lineNum">    1595 </span>                :            :         // end of this partitioning dimension
<span class="lineNum">    1596 </span>                :            : 
<span class="lineNum">    1597 </span>                :            :         //set the current num parts for next dim partitioning
<span class="lineNum">    1598 </span>                :<span class="lineNoCov">          0 :         current_num_parts = output_part_count_in_dimension;</span>
<span class="lineNum">    1599 </span>                :            : 
<span class="lineNum">    1600 </span>                :            :         //swap the coordinate permutations for the next dimension.
<span class="lineNum">    1601 </span>                :<span class="lineNoCov">          0 :         mj_lno_t * tmp = this-&gt;coordinate_permutations;</span>
<span class="lineNum">    1602 </span>                :<span class="lineNoCov">          0 :         this-&gt;coordinate_permutations = this-&gt;new_coordinate_permutations;</span>
<span class="lineNum">    1603 </span>                :<span class="lineNoCov">          0 :         this-&gt;new_coordinate_permutations = tmp;</span>
<span class="lineNum">    1604 </span>                :            : 
<span class="lineNum">    1605 </span>                :<span class="lineNoCov">          0 :         freeArray&lt;mj_lno_t&gt;(this-&gt;part_xadj);</span>
<span class="lineNum">    1606 </span>                :<span class="lineNoCov">          0 :         this-&gt;part_xadj = this-&gt;new_part_xadj;</span>
<span class="lineNum">    1607 </span>                :            :     }
<span class="lineNum">    1608 </span>                :            : 
<span class="lineNum">    1609 </span>                :<span class="lineNoCov">          0 :     for(mj_lno_t i = 0; i &lt; num_total_coords; ++i){</span>
<span class="lineNum">    1610 </span>                :<span class="lineNoCov">          0 :         inital_adjList_output_adjlist[i] = this-&gt;coordinate_permutations[i];</span>
<span class="lineNum">    1611 </span>                :            :     }
<span class="lineNum">    1612 </span>                :            : 
<span class="lineNum">    1613 </span>                :            :     // Return output_xadj in CSR format
<span class="lineNum">    1614 </span>                :<span class="lineNoCov">          0 :     output_xadj[0] = 0;</span>
<span class="lineNum">    1615 </span>                :<span class="lineNoCov">          0 :     for(size_t i = 0; i &lt; this-&gt;num_global_parts ; ++i){</span>
<span class="lineNum">    1616 </span>                :<span class="lineNoCov">          0 :         output_xadj[i+1] = this-&gt;part_xadj[i];</span>
<span class="lineNum">    1617 </span>                :            :     }
<span class="lineNum">    1618 </span>                :            : 
<span class="lineNum">    1619 </span>                :<span class="lineNoCov">          0 :     delete future_num_part_in_parts;</span>
<span class="lineNum">    1620 </span>                :<span class="lineNoCov">          0 :     delete next_future_num_parts_in_parts;</span>
<span class="lineNum">    1621 </span>                :            : 
<span class="lineNum">    1622 </span>                :            :     //free the extra memory that we allocated.
<span class="lineNum">    1623 </span>                :<span class="lineNoCov">          0 :     freeArray&lt;mj_part_t&gt;(this-&gt;assigned_part_ids);</span>
<span class="lineNum">    1624 </span>                :<span class="lineNoCov">          0 :     freeArray&lt;mj_gno_t&gt;(this-&gt;initial_mj_gnos);</span>
<span class="lineNum">    1625 </span>                :<span class="lineNoCov">          0 :     freeArray&lt;mj_gno_t&gt;(this-&gt;current_mj_gnos);</span>
<span class="lineNum">    1626 </span>                :<span class="lineNoCov">          0 :     freeArray&lt;bool&gt;(tmp_mj_uniform_weights);</span>
<span class="lineNum">    1627 </span>                :<span class="lineNoCov">          0 :     freeArray&lt;bool&gt;(tmp_mj_uniform_parts);</span>
<span class="lineNum">    1628 </span>                :<span class="lineNoCov">          0 :     freeArray&lt;mj_scalar_t *&gt;(tmp_mj_weights);</span>
<span class="lineNum">    1629 </span>                :<span class="lineNoCov">          0 :     freeArray&lt;mj_scalar_t *&gt;(tmp_mj_part_sizes);</span>
<span class="lineNum">    1630 </span>                :            : 
<span class="lineNum">    1631 </span>                :<span class="lineNoCov">          0 :     this-&gt;free_work_memory();</span>
<span class="lineNum">    1632 </span>                :            : 
<span class="lineNum">    1633 </span>                :            : #ifdef HAVE_ZOLTAN2_OMP
<span class="lineNum">    1634 </span>                :            :     omp_set_num_threads(actual_num_threads);
<span class="lineNum">    1635 </span>                :            : #endif
<span class="lineNum">    1636 </span>                :<span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1637 </span>                :            : 
<span class="lineNum">    1638 </span>                :            : /*! \brief Multi Jagged  coordinate partitioning algorithm default constructor.
<span class="lineNum">    1639 </span>                :            :  *
<span class="lineNum">    1640 </span>                :            :  */
<a name="1641"><span class="lineNum">    1641 </span>                :            : template &lt;typename mj_scalar_t, typename mj_lno_t, typename mj_gno_t,</a>
<span class="lineNum">    1642 </span>                :            :           typename mj_part_t&gt;
<span class="lineNum">    1643 </span>                :<span class="lineNoCov">          0 : AlgMJ&lt;mj_scalar_t, mj_lno_t, mj_gno_t, mj_part_t&gt;::AlgMJ():</span>
<span class="lineNum">    1644 </span>                :            :         mj_env(), mj_problemComm(), imbalance_tolerance(0),
<span class="lineNum">    1645 </span>                :            :         part_no_array(NULL), recursion_depth(0), coord_dim(0),
<span class="lineNum">    1646 </span>                :            :         num_weights_per_coord(0), initial_num_loc_coords(0),
<span class="lineNum">    1647 </span>                :            :         initial_num_glob_coords(0),
<span class="lineNum">    1648 </span>                :            :         num_local_coords(0), num_global_coords(0), mj_coordinates(NULL),
<span class="lineNum">    1649 </span>                :            :         mj_weights(NULL), mj_uniform_parts(NULL), mj_part_sizes(NULL),
<span class="lineNum">    1650 </span>                :            :         mj_uniform_weights(NULL), mj_gnos(), num_global_parts(1),
<span class="lineNum">    1651 </span>                :            :         initial_mj_gnos(NULL), current_mj_gnos(NULL), owner_of_coordinate(NULL),
<span class="lineNum">    1652 </span>                :            :         coordinate_permutations(NULL), new_coordinate_permutations(NULL),
<span class="lineNum">    1653 </span>                :            :         assigned_part_ids(NULL), part_xadj(NULL), new_part_xadj(NULL),
<span class="lineNum">    1654 </span>                :            :         distribute_points_on_cut_lines(true), max_concurrent_part_calculation(1),
<span class="lineNum">    1655 </span>                :            :         mj_run_as_rcb(0), mj_user_recursion_depth(0), mj_keep_part_boxes(0),
<span class="lineNum">    1656 </span>                :            :         check_migrate_avoid_migration_option(0), minimum_migration_imbalance(0.30),
<span class="lineNum">    1657 </span>                :            :         num_threads(1), total_num_cut(0), total_num_part(0), max_num_part_along_dim(0),
<span class="lineNum">    1658 </span>                :            :         max_num_cut_along_dim(0), max_num_total_part_along_dim(0), total_dim_num_reduce_all(0),
<span class="lineNum">    1659 </span>                :            :         last_dim_num_part(0), comm(), fEpsilon(0), sEpsilon(0), maxScalar_t(0), minScalar_t(0),
<span class="lineNum">    1660 </span>                :            :         all_cut_coordinates(NULL), max_min_coords(NULL), process_cut_line_weight_to_put_left(NULL),
<span class="lineNum">    1661 </span>                :            :         thread_cut_line_weight_to_put_left(NULL), cut_coordinates_work_array(NULL),
<span class="lineNum">    1662 </span>                :            :         target_part_weights(NULL), cut_upper_bound_coordinates(NULL), cut_lower_bound_coordinates(NULL),
<span class="lineNum">    1663 </span>                :            :         cut_lower_bound_weights(NULL), cut_upper_bound_weights(NULL),
<span class="lineNum">    1664 </span>                :            :         process_local_min_max_coord_total_weight(NULL), global_min_max_coord_total_weight(NULL),
<span class="lineNum">    1665 </span>                :            :         is_cut_line_determined(NULL), my_incomplete_cut_count(NULL),
<span class="lineNum">    1666 </span>                :            :         thread_part_weights(NULL), thread_part_weight_work(NULL),
<span class="lineNum">    1667 </span>                :            :         thread_cut_left_closest_point(NULL), thread_cut_right_closest_point(NULL),
<span class="lineNum">    1668 </span>                :            :         thread_point_counts(NULL), process_rectilinear_cut_weight(NULL),
<span class="lineNum">    1669 </span>                :            :         global_rectilinear_cut_weight(NULL),total_part_weight_left_right_closests(NULL),
<span class="lineNum">    1670 </span>                :            :         global_total_part_weight_left_right_closests(NULL),
<span class="lineNum">    1671 </span>                :            :         kept_boxes(),global_box(),
<span class="lineNum">    1672 </span>                :<span class="lineNoCov">          0 :         myRank(0), myActualRank(0)</span>
<span class="lineNum">    1673 </span>                :            : {
<span class="lineNum">    1674 </span>                :<span class="lineNoCov">          0 :     this-&gt;fEpsilon = std::numeric_limits&lt;float&gt;::epsilon();</span>
<span class="lineNum">    1675 </span>                :<span class="lineNoCov">          0 :     this-&gt;sEpsilon = std::numeric_limits&lt;mj_scalar_t&gt;::epsilon() * 100;</span>
<span class="lineNum">    1676 </span>                :            : 
<span class="lineNum">    1677 </span>                :<span class="lineNoCov">          0 :     this-&gt;maxScalar_t = std::numeric_limits&lt;mj_scalar_t&gt;::max();</span>
<span class="lineNum">    1678 </span>                :<span class="lineNoCov">          0 :     this-&gt;minScalar_t = -std::numeric_limits&lt;mj_scalar_t&gt;::max();</span>
<span class="lineNum">    1679 </span>                :            : 
<span class="lineNum">    1680 </span>                :<span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1681 </span>                :            : 
<span class="lineNum">    1682 </span>                :            : 
<span class="lineNum">    1683 </span>                :            : /*! \brief Function returns the part boxes stored
<span class="lineNum">    1684 </span>                :            :  * returns null if boxes are not stored, and prints warning mesage.
<span class="lineNum">    1685 </span>                :            :  */
<span class="lineNum">    1686 </span>                :            : template &lt;typename mj_scalar_t, typename mj_lno_t, typename mj_gno_t,
<a name="1687"><span class="lineNum">    1687 </span>                :            :           typename mj_part_t&gt;</a>
<span class="lineNum">    1688 </span>                :            : RCP&lt;typename AlgMJ&lt;mj_scalar_t,mj_lno_t,mj_gno_t,mj_part_t&gt;::mj_partBox_t&gt;
<span class="lineNum">    1689 </span>                :<span class="lineNoCov">          0 : AlgMJ&lt;mj_scalar_t,mj_lno_t,mj_gno_t,mj_part_t&gt;::get_global_box() const</span>
<span class="lineNum">    1690 </span>                :            : {
<span class="lineNum">    1691 </span>                :<span class="lineNoCov">          0 :   return this-&gt;global_box;</span>
<span class="lineNum">    1692 </span>                :            : }
<span class="lineNum">    1693 </span>                :            : 
<span class="lineNum">    1694 </span>                :            : /*! \brief Function call, if the part boxes are intended to be kept.
<span class="lineNum">    1695 </span>                :            :  *
<span class="lineNum">    1696 </span>                :            :  */
<a name="1697"><span class="lineNum">    1697 </span>                :            : template &lt;typename mj_scalar_t, typename mj_lno_t, typename mj_gno_t,</a>
<span class="lineNum">    1698 </span>                :            :           typename mj_part_t&gt;
<span class="lineNum">    1699 </span>                :<span class="lineNoCov">          0 : void AlgMJ&lt;mj_scalar_t, mj_lno_t, mj_gno_t, mj_part_t&gt;::set_to_keep_part_boxes(){</span>
<span class="lineNum">    1700 </span>                :<span class="lineNoCov">          0 :   this-&gt;mj_keep_part_boxes = 1;</span>
<span class="lineNum">    1701 </span>                :<span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1702 </span>                :            : 
<span class="lineNum">    1703 </span>                :            : 
<span class="lineNum">    1704 </span>                :            : /* \brief Either the mj array (part_no_array) or num_global_parts should be provided in
<span class="lineNum">    1705 </span>                :            :  * the input. part_no_array takes
<span class="lineNum">    1706 </span>                :            :  * precedence if both are provided.
<span class="lineNum">    1707 </span>                :            :  * Depending on these parameters, total cut/part number,
<span class="lineNum">    1708 </span>                :            :  * maximum part/cut number along a dimension, estimated number of reduceAlls,
<span class="lineNum">    1709 </span>                :            :  * and the number of parts before the last dimension is calculated.
<span class="lineNum">    1710 </span>                :            :  * */
<a name="1711"><span class="lineNum">    1711 </span>                :            : template &lt;typename mj_scalar_t, typename mj_lno_t, typename mj_gno_t,</a>
<span class="lineNum">    1712 </span>                :            :           typename mj_part_t&gt;
<span class="lineNum">    1713 </span>                :<span class="lineNoCov">          0 : void AlgMJ&lt;mj_scalar_t, mj_lno_t, mj_gno_t, mj_part_t&gt;::set_part_specifications(){</span>
<span class="lineNum">    1714 </span>                :            : 
<span class="lineNum">    1715 </span>                :<span class="lineNoCov">          0 :         this-&gt;total_num_cut = 0; //how many cuts will be totally</span>
<span class="lineNum">    1716 </span>                :<span class="lineNoCov">          0 :         this-&gt;total_num_part = 1;    //how many parts will be totally</span>
<span class="lineNum">    1717 </span>                :<span class="lineNoCov">          0 :         this-&gt;max_num_part_along_dim = 0;         //maximum part count along a dimension.</span>
<span class="lineNum">    1718 </span>                :<span class="lineNoCov">          0 :         this-&gt;total_dim_num_reduce_all = 0;    //estimate on #reduceAlls can be done.</span>
<span class="lineNum">    1719 </span>                :<span class="lineNoCov">          0 :         this-&gt;last_dim_num_part = 1; //max no of parts that might occur</span>
<span class="lineNum">    1720 </span>                :            :         //during the partition before the
<span class="lineNum">    1721 </span>                :            :         //last partitioning dimension.
<span class="lineNum">    1722 </span>                :<span class="lineNoCov">          0 :         this-&gt;max_num_cut_along_dim = 0;</span>
<span class="lineNum">    1723 </span>                :<span class="lineNoCov">          0 :         this-&gt;max_num_total_part_along_dim = 0;</span>
<span class="lineNum">    1724 </span>                :            : 
<span class="lineNum">    1725 </span>                :<span class="lineNoCov">          0 :         if (this-&gt;part_no_array){</span>
<span class="lineNum">    1726 </span>                :            :                 //if user provided part array, traverse the array and set variables.
<span class="lineNum">    1727 </span>                :<span class="lineNoCov">          0 :                 for (int i = 0; i &lt; this-&gt;recursion_depth; ++i){</span>
<span class="lineNum">    1728 </span>                :<span class="lineNoCov">          0 :                         this-&gt;total_dim_num_reduce_all += this-&gt;total_num_part;</span>
<span class="lineNum">    1729 </span>                :<span class="lineNoCov">          0 :                         this-&gt;total_num_part *= this-&gt;part_no_array[i];</span>
<span class="lineNum">    1730 </span>                :<span class="lineNoCov">          0 :                         if(this-&gt;part_no_array[i] &gt; this-&gt;max_num_part_along_dim) {</span>
<span class="lineNum">    1731 </span>                :<span class="lineNoCov">          0 :                                 this-&gt;max_num_part_along_dim = this-&gt;part_no_array[i];</span>
<span class="lineNum">    1732 </span>                :            :                         }
<span class="lineNum">    1733 </span>                :            :                 }
<span class="lineNum">    1734 </span>                :<span class="lineNoCov">          0 :                 this-&gt;last_dim_num_part = this-&gt;total_num_part / this-&gt;part_no_array[recursion_depth-1];</span>
<span class="lineNum">    1735 </span>                :<span class="lineNoCov">          0 :                 this-&gt;num_global_parts = this-&gt;total_num_part;</span>
<span class="lineNum">    1736 </span>                :            :         } else {
<span class="lineNum">    1737 </span>                :<span class="lineNoCov">          0 :                 mj_part_t future_num_parts = this-&gt;num_global_parts;</span>
<span class="lineNum">    1738 </span>                :            : 
<span class="lineNum">    1739 </span>                :            :                 //we need to calculate the part numbers now, to determine the maximum along the dimensions.
<span class="lineNum">    1740 </span>                :<span class="lineNoCov">          0 :                 for (int i = 0; i &lt; this-&gt;recursion_depth; ++i){</span>
<span class="lineNum">    1741 </span>                :            : 
<span class="lineNum">    1742 </span>                :            :                         mj_part_t maxNoPartAlongI = this-&gt;get_part_count(
<span class="lineNum">    1743 </span>                :<span class="lineNoCov">          0 :                                         future_num_parts, 1.0f / (this-&gt;recursion_depth - i));</span>
<span class="lineNum">    1744 </span>                :            : 
<span class="lineNum">    1745 </span>                :<span class="lineNoCov">          0 :                         if (maxNoPartAlongI &gt; this-&gt;max_num_part_along_dim){</span>
<span class="lineNum">    1746 </span>                :<span class="lineNoCov">          0 :                                 this-&gt;max_num_part_along_dim = maxNoPartAlongI;</span>
<span class="lineNum">    1747 </span>                :            :                         }
<span class="lineNum">    1748 </span>                :            : 
<span class="lineNum">    1749 </span>                :<span class="lineNoCov">          0 :                         mj_part_t nfutureNumParts = future_num_parts / maxNoPartAlongI;</span>
<span class="lineNum">    1750 </span>                :<span class="lineNoCov">          0 :                         if (future_num_parts % maxNoPartAlongI){</span>
<span class="lineNum">    1751 </span>                :<span class="lineNoCov">          0 :                                 ++nfutureNumParts;</span>
<span class="lineNum">    1752 </span>                :            :                         }
<span class="lineNum">    1753 </span>                :<span class="lineNoCov">          0 :                         future_num_parts = nfutureNumParts;</span>
<span class="lineNum">    1754 </span>                :            :                 }
<span class="lineNum">    1755 </span>                :<span class="lineNoCov">          0 :                 this-&gt;total_num_part = this-&gt;num_global_parts;</span>
<span class="lineNum">    1756 </span>                :            :                 //estimate reduceAll Count here.
<span class="lineNum">    1757 </span>                :            :                 //we find the upperbound instead.
<span class="lineNum">    1758 </span>                :<span class="lineNoCov">          0 :                 mj_part_t p = 1;</span>
<span class="lineNum">    1759 </span>                :<span class="lineNoCov">          0 :                 for (int i = 0; i &lt; this-&gt;recursion_depth; ++i){</span>
<span class="lineNum">    1760 </span>                :<span class="lineNoCov">          0 :                         this-&gt;total_dim_num_reduce_all += p;</span>
<span class="lineNum">    1761 </span>                :<span class="lineNoCov">          0 :                         p *= this-&gt;max_num_part_along_dim;</span>
<span class="lineNum">    1762 </span>                :            :                 }
<span class="lineNum">    1763 </span>                :            : 
<span class="lineNum">    1764 </span>                :<span class="lineNoCov">          0 :                 this-&gt;last_dim_num_part  = p / this-&gt;max_num_part_along_dim;</span>
<span class="lineNum">    1765 </span>                :            :         }
<span class="lineNum">    1766 </span>                :            : 
<span class="lineNum">    1767 </span>                :<span class="lineNoCov">          0 :         this-&gt;total_num_cut = this-&gt;total_num_part - 1;</span>
<span class="lineNum">    1768 </span>                :<span class="lineNoCov">          0 :         this-&gt;max_num_cut_along_dim = this-&gt;max_num_part_along_dim - 1;</span>
<span class="lineNum">    1769 </span>                :<span class="lineNoCov">          0 :         this-&gt;max_num_total_part_along_dim = this-&gt;max_num_part_along_dim + size_t(this-&gt;max_num_cut_along_dim);</span>
<span class="lineNum">    1770 </span>                :            :         //maxPartNo is P, maxCutNo = P-1, matTotalPartcount = 2P-1
<span class="lineNum">    1771 </span>                :            : 
<span class="lineNum">    1772 </span>                :            :         //refine the concurrent part count, if it is given bigger than the maximum possible part count.
<span class="lineNum">    1773 </span>                :<span class="lineNoCov">          0 :     if(this-&gt;max_concurrent_part_calculation &gt; this-&gt;last_dim_num_part){</span>
<span class="lineNum">    1774 </span>                :<span class="lineNoCov">          0 :         if(this-&gt;mj_problemComm-&gt;getRank() == 0){</span>
<span class="lineNum">    1775 </span>                :<span class="lineNoCov">          0 :             std::cerr &lt;&lt; &quot;Warning: Concurrent part count (&quot;&lt;&lt; this-&gt;max_concurrent_part_calculation &lt;&lt;</span>
<span class="lineNum">    1776 </span>                :<span class="lineNoCov">          0 :             &quot;) has been set bigger than maximum amount that can be used.&quot; &lt;&lt;</span>
<span class="lineNum">    1777 </span>                :<span class="lineNoCov">          0 :             &quot; Setting to:&quot; &lt;&lt; this-&gt;last_dim_num_part &lt;&lt; &quot;.&quot; &lt;&lt; std::endl;</span>
<span class="lineNum">    1778 </span>                :            :         }
<span class="lineNum">    1779 </span>                :<span class="lineNoCov">          0 :         this-&gt;max_concurrent_part_calculation = this-&gt;last_dim_num_part;</span>
<span class="lineNum">    1780 </span>                :            :     }
<span class="lineNum">    1781 </span>                :            : 
<span class="lineNum">    1782 </span>                :<span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1783 </span>                :            : /* \brief Tries to determine the part number for current dimension,
<span class="lineNum">    1784 </span>                :            :  * by trying to make the partitioning as square as possible.
<span class="lineNum">    1785 </span>                :            :  * \param num_total_future how many more partitionings are required.
<span class="lineNum">    1786 </span>                :            :  * \param root how many more recursion depth is left.
<span class="lineNum">    1787 </span>                :            :  */
<a name="1788"><span class="lineNum">    1788 </span>                :            : template &lt;typename mj_scalar_t, typename mj_lno_t, typename mj_gno_t,</a>
<span class="lineNum">    1789 </span>                :            :           typename mj_part_t&gt;
<span class="lineNum">    1790 </span>                :<span class="lineNoCov">          0 : inline mj_part_t AlgMJ&lt;mj_scalar_t, mj_lno_t, mj_gno_t, mj_part_t&gt;::get_part_count(</span>
<span class="lineNum">    1791 </span>                :            :                 mj_part_t num_total_future,
<span class="lineNum">    1792 </span>                :            :                 double root)
<span class="lineNum">    1793 </span>                :            : {
<span class="lineNum">    1794 </span>                :<span class="lineNoCov">          0 :         double fp = pow(num_total_future, root);</span>
<span class="lineNum">    1795 </span>                :<span class="lineNoCov">          0 :         mj_part_t ip = mj_part_t (fp);</span>
<span class="lineNum">    1796 </span>                :<span class="lineNoCov">          0 :         if (fp - ip &lt; this-&gt;fEpsilon * 100){</span>
<span class="lineNum">    1797 </span>                :<span class="lineNoCov">          0 :                 return ip;</span>
<span class="lineNum">    1798 </span>                :            :         }
<span class="lineNum">    1799 </span>                :            :         else {
<span class="lineNum">    1800 </span>                :<span class="lineNoCov">          0 :                 return ip  + 1;</span>
<span class="lineNum">    1801 </span>                :            :         }
<span class="lineNum">    1802 </span>                :            : }
<span class="lineNum">    1803 </span>                :            : 
<span class="lineNum">    1804 </span>                :            : /* \brief Function returns how many parts that will be obtained after this dimension partitioning.
<span class="lineNum">    1805 </span>                :            :  * It sets how many parts each current part will be partitioned into in this dimension to num_partitioning_in_current_dim vector,
<span class="lineNum">    1806 </span>                :            :  * sets how many total future parts each obtained part will be partitioned into in next_future_num_parts_in_parts vector,
<span class="lineNum">    1807 </span>                :            :  * If part boxes are kept, then sets initializes the output_part_boxes as its ancestor.
<span class="lineNum">    1808 </span>                :            :  *
<span class="lineNum">    1809 </span>                :            :  *  \param num_partitioning_in_current_dim: output. How many parts each current part will be partitioned into.
<span class="lineNum">    1810 </span>                :            :  *  \param future_num_part_in_parts: input, how many future parts each current part will be partitioned into.
<span class="lineNum">    1811 </span>                :            :  *  \param next_future_num_parts_in_parts: output, how many future parts each obtained part will be partitioned into.
<span class="lineNum">    1812 </span>                :            :  *  \param future_num_parts: output, max number of future parts that will be obtained from a single
<span class="lineNum">    1813 </span>                :            :  *  \param current_num_parts: input, how many parts are there currently.
<span class="lineNum">    1814 </span>                :            :  *  \param current_iteration: input, current dimension iteration number.
<span class="lineNum">    1815 </span>                :            :  *  \param input_part_boxes: input, if boxes are kept, current boxes.
<span class="lineNum">    1816 </span>                :            :  *  \param output_part_boxes: output, if boxes are kept, the initial box boundaries for obtained parts.
<span class="lineNum">    1817 </span>                :            :  */
<a name="1818"><span class="lineNum">    1818 </span>                :            : template &lt;typename mj_scalar_t, typename mj_lno_t, typename mj_gno_t,</a>
<span class="lineNum">    1819 </span>                :            :           typename mj_part_t&gt;
<span class="lineNum">    1820 </span>                :<span class="lineNoCov">          0 : mj_part_t AlgMJ&lt;mj_scalar_t, mj_lno_t, mj_gno_t, mj_part_t&gt;::update_part_num_arrays(</span>
<span class="lineNum">    1821 </span>                :            :         std::vector &lt;mj_part_t&gt; &amp;num_partitioning_in_current_dim, //assumes this vector is empty.
<span class="lineNum">    1822 </span>                :            :     std::vector&lt;mj_part_t&gt; *future_num_part_in_parts,
<span class="lineNum">    1823 </span>                :            :     std::vector&lt;mj_part_t&gt; *next_future_num_parts_in_parts, //assumes this vector is empty.
<span class="lineNum">    1824 </span>                :            :     mj_part_t &amp;future_num_parts,
<span class="lineNum">    1825 </span>                :            :     mj_part_t current_num_parts,
<span class="lineNum">    1826 </span>                :            :     int current_iteration,
<span class="lineNum">    1827 </span>                :            :     RCP&lt;mj_partBoxVector_t&gt; input_part_boxes,
<span class="lineNum">    1828 </span>                :            :     RCP&lt;mj_partBoxVector_t&gt; output_part_boxes
<span class="lineNum">    1829 </span>                :            : ){
<span class="lineNum">    1830 </span>                :            :         //how many parts that will be obtained after this dimension.
<span class="lineNum">    1831 </span>                :<span class="lineNoCov">          0 :     mj_part_t output_num_parts = 0;</span>
<span class="lineNum">    1832 </span>                :<span class="lineNoCov">          0 :     if(this-&gt;part_no_array){</span>
<span class="lineNum">    1833 </span>                :            :         //when the partNo array is provided as input,
<span class="lineNum">    1834 </span>                :            :         //each current partition will be partition to the same number of parts.
<span class="lineNum">    1835 </span>                :            :         //we dont need to use the future_num_part_in_parts vector in this case.
<span class="lineNum">    1836 </span>                :            : 
<span class="lineNum">    1837 </span>                :<span class="lineNoCov">          0 :         mj_part_t p = this-&gt;part_no_array[current_iteration];</span>
<span class="lineNum">    1838 </span>                :<span class="lineNoCov">          0 :         if (p &lt; 1){</span>
<span class="lineNum">    1839 </span>                :<span class="lineNoCov">          0 :             std::cout &lt;&lt; &quot;i:&quot; &lt;&lt; current_iteration &lt;&lt; &quot; p is given as:&quot; &lt;&lt; p &lt;&lt; std::endl;</span>
<span class="lineNum">    1840 </span>                :<span class="lineNoCov">          0 :             exit(1);</span>
<span class="lineNum">    1841 </span>                :            :         }
<span class="lineNum">    1842 </span>                :<span class="lineNoCov">          0 :         if (p == 1){</span>
<span class="lineNum">    1843 </span>                :<span class="lineNoCov">          0 :             return current_num_parts;</span>
<span class="lineNum">    1844 </span>                :            :         }
<span class="lineNum">    1845 </span>                :            : 
<span class="lineNum">    1846 </span>                :<span class="lineNoCov">          0 :         for (mj_part_t ii = 0; ii &lt; current_num_parts; ++ii){</span>
<span class="lineNum">    1847 </span>                :<span class="lineNoCov">          0 :             num_partitioning_in_current_dim.push_back(p);</span>
<span class="lineNum">    1848 </span>                :            : 
<span class="lineNum">    1849 </span>                :            :         }
<span class="lineNum">    1850 </span>                :            :         //cout &lt;&lt; &quot;me:&quot; &lt;&lt; this-&gt;myRank &lt;&lt; &quot; current_iteration&quot; &lt;&lt; current_iteration &lt;&lt;
<span class="lineNum">    1851 </span>                :            :         //&quot; current_num_parts:&quot; &lt;&lt; current_num_parts &lt;&lt; std::endl;
<span class="lineNum">    1852 </span>                :            :         //cout &lt;&lt; &quot;num_partitioning_in_current_dim[0]:&quot; &lt;&lt; num_partitioning_in_current_dim[0] &lt;&lt; std::endl;
<span class="lineNum">    1853 </span>                :            :         //set the new value of future_num_parts.
<span class="lineNum">    1854 </span>                :            : 
<span class="lineNum">    1855 </span>                :            :         /*
<span class="lineNum">    1856 </span>                :            :         cout &lt;&lt; &quot;\tfuture_num_parts:&quot; &lt;&lt; future_num_parts
<span class="lineNum">    1857 </span>                :            :                         &lt;&lt; &quot; num_partitioning_in_current_dim[0]:&quot; &lt;&lt; num_partitioning_in_current_dim[0]
<span class="lineNum">    1858 </span>                :            :                         &lt;&lt; future_num_parts/ num_partitioning_in_current_dim[0] &lt;&lt; std::endl;
<span class="lineNum">    1859 </span>                :            :         */
<span class="lineNum">    1860 </span>                :            : 
<span class="lineNum">    1861 </span>                :<span class="lineNoCov">          0 :         future_num_parts /= num_partitioning_in_current_dim[0];</span>
<span class="lineNum">    1862 </span>                :<span class="lineNoCov">          0 :         output_num_parts = current_num_parts * num_partitioning_in_current_dim[0];</span>
<span class="lineNum">    1863 </span>                :            : 
<span class="lineNum">    1864 </span>                :<span class="lineNoCov">          0 :         if (this-&gt;mj_keep_part_boxes){</span>
<span class="lineNum">    1865 </span>                :<span class="lineNoCov">          0 :             for (mj_part_t k = 0; k &lt; current_num_parts; ++k){</span>
<span class="lineNum">    1866 </span>                :            :                 //initialized the output boxes as its ancestor.
<span class="lineNum">    1867 </span>                :<span class="lineNoCov">          0 :                 for (mj_part_t j = 0; j &lt; num_partitioning_in_current_dim[0]; ++j){</span>
<span class="lineNum">    1868 </span>                :<span class="lineNoCov">          0 :                     output_part_boxes-&gt;push_back((*input_part_boxes)[k]);</span>
<span class="lineNum">    1869 </span>                :            :                 }
<span class="lineNum">    1870 </span>                :            :             }
<span class="lineNum">    1871 </span>                :            :         }
<span class="lineNum">    1872 </span>                :            : 
<span class="lineNum">    1873 </span>                :            :         //set the how many more parts each part will be divided.
<span class="lineNum">    1874 </span>                :            :         //this is obvious when partNo array is provided as input.
<span class="lineNum">    1875 </span>                :            :         //however, fill this so that weights will be calculated according to this array.
<span class="lineNum">    1876 </span>                :<span class="lineNoCov">          0 :         for (mj_part_t ii = 0; ii &lt; output_num_parts; ++ii){</span>
<span class="lineNum">    1877 </span>                :<span class="lineNoCov">          0 :             next_future_num_parts_in_parts-&gt;push_back(future_num_parts);</span>
<span class="lineNum">    1878 </span>                :            :         }
<span class="lineNum">    1879 </span>                :            :     }
<span class="lineNum">    1880 </span>                :            :     else {
<span class="lineNum">    1881 </span>                :            :         //if partNo array is not provided as input,
<span class="lineNum">    1882 </span>                :            :         //future_num_part_in_parts  holds how many parts each part should be divided.
<span class="lineNum">    1883 </span>                :            :         //initially it holds a single number equal to the total number of global parts.
<span class="lineNum">    1884 </span>                :            : 
<span class="lineNum">    1885 </span>                :            :         //calculate the future_num_parts from beginning,
<span class="lineNum">    1886 </span>                :            :         //since each part might be divided into different number of parts.
<span class="lineNum">    1887 </span>                :<span class="lineNoCov">          0 :         future_num_parts = 1;</span>
<span class="lineNum">    1888 </span>                :            : 
<span class="lineNum">    1889 </span>                :            :         //cout &lt;&lt; &quot;i:&quot; &lt;&lt; i &lt;&lt; std::endl;
<span class="lineNum">    1890 </span>                :            : 
<span class="lineNum">    1891 </span>                :<span class="lineNoCov">          0 :         for (mj_part_t ii = 0; ii &lt; current_num_parts; ++ii){</span>
<span class="lineNum">    1892 </span>                :            :             //get how many parts a part should be divided.
<span class="lineNum">    1893 </span>                :<span class="lineNoCov">          0 :             mj_part_t future_num_parts_of_part_ii = (*future_num_part_in_parts)[ii];</span>
<span class="lineNum">    1894 </span>                :            : 
<span class="lineNum">    1895 </span>                :            :             //get the ideal number of parts that is close to the
<span class="lineNum">    1896 </span>                :            :             //(recursion_depth - i) root of the future_num_parts_of_part_ii.
<span class="lineNum">    1897 </span>                :            :             mj_part_t num_partitions_in_current_dim =
<span class="lineNum">    1898 </span>                :            :                                                 this-&gt;get_part_count(
<span class="lineNum">    1899 </span>                :            :                                                                 future_num_parts_of_part_ii,
<span class="lineNum">    1900 </span>                :<span class="lineNoCov">          0 :                                                                 1.0 / (this-&gt;recursion_depth - current_iteration)</span>
<span class="lineNum">    1901 </span>                :<span class="lineNoCov">          0 :                                         );</span>
<span class="lineNum">    1902 </span>                :            : 
<span class="lineNum">    1903 </span>                :<span class="lineNoCov">          0 :             if (num_partitions_in_current_dim &gt; this-&gt;max_num_part_along_dim){</span>
<span class="lineNum">    1904 </span>                :<span class="lineNoCov">          0 :                 std::cerr &lt;&lt; &quot;ERROR: maxPartNo calculation is wrong.&quot; &lt;&lt; std::endl;</span>
<span class="lineNum">    1905 </span>                :<span class="lineNoCov">          0 :                 exit(1);</span>
<span class="lineNum">    1906 </span>                :            :             }
<span class="lineNum">    1907 </span>                :            :             //add this number to num_partitioning_in_current_dim vector.
<span class="lineNum">    1908 </span>                :<span class="lineNoCov">          0 :             num_partitioning_in_current_dim.push_back(num_partitions_in_current_dim);</span>
<span class="lineNum">    1909 </span>                :            : 
<span class="lineNum">    1910 </span>                :            : 
<span class="lineNum">    1911 </span>                :            :             //increase the output number of parts.
<span class="lineNum">    1912 </span>                :<span class="lineNoCov">          0 :             output_num_parts += num_partitions_in_current_dim;</span>
<span class="lineNum">    1913 </span>                :            : 
<span class="lineNum">    1914 </span>                :            :             //ideal number of future partitions for each part.
<span class="lineNum">    1915 </span>                :<span class="lineNoCov">          0 :             mj_part_t ideal_num_future_parts_in_part = future_num_parts_of_part_ii / num_partitions_in_current_dim;</span>
<span class="lineNum">    1916 </span>                :<span class="lineNoCov">          0 :             for (mj_part_t iii = 0; iii &lt; num_partitions_in_current_dim; ++iii){</span>
<span class="lineNum">    1917 </span>                :<span class="lineNoCov">          0 :                 mj_part_t num_future_parts_for_part_iii = ideal_num_future_parts_in_part;</span>
<span class="lineNum">    1918 </span>                :            : 
<span class="lineNum">    1919 </span>                :            :                 //if there is a remainder in the part increase the part weight.
<span class="lineNum">    1920 </span>                :<span class="lineNoCov">          0 :                 if (iii &lt; future_num_parts_of_part_ii % num_partitions_in_current_dim){</span>
<span class="lineNum">    1921 </span>                :            :                     //if not uniform, add 1 for the extra parts.
<span class="lineNum">    1922 </span>                :<span class="lineNoCov">          0 :                     ++num_future_parts_for_part_iii;</span>
<span class="lineNum">    1923 </span>                :            :                 }
<span class="lineNum">    1924 </span>                :<span class="lineNoCov">          0 :                 next_future_num_parts_in_parts-&gt;push_back(num_future_parts_for_part_iii);</span>
<span class="lineNum">    1925 </span>                :            : 
<span class="lineNum">    1926 </span>                :            :                 //if part boxes are stored, initialize the box of the parts as the ancestor.
<span class="lineNum">    1927 </span>                :<span class="lineNoCov">          0 :                 if (this-&gt;mj_keep_part_boxes){</span>
<span class="lineNum">    1928 </span>                :<span class="lineNoCov">          0 :                     output_part_boxes-&gt;push_back((*input_part_boxes)[ii]);</span>
<span class="lineNum">    1929 </span>                :            :                 }
<span class="lineNum">    1930 </span>                :            : 
<span class="lineNum">    1931 </span>                :            :                 //set num future_num_parts to maximum in this part.
<span class="lineNum">    1932 </span>                :<span class="lineNoCov">          0 :                 if (num_future_parts_for_part_iii &gt; future_num_parts) future_num_parts = num_future_parts_for_part_iii;</span>
<span class="lineNum">    1933 </span>                :            :             }
<span class="lineNum">    1934 </span>                :            :         }
<span class="lineNum">    1935 </span>                :            :     }
<span class="lineNum">    1936 </span>                :<span class="lineNoCov">          0 :     return output_num_parts;</span>
<span class="lineNum">    1937 </span>                :            : }
<span class="lineNum">    1938 </span>                :            : 
<span class="lineNum">    1939 </span>                :            : 
<span class="lineNum">    1940 </span>                :            : /* \brief Allocates and initializes the work memory that will be used by MJ.
<span class="lineNum">    1941 </span>                :            :  *
<span class="lineNum">    1942 </span>                :            :  * */
<a name="1943"><span class="lineNum">    1943 </span>                :            : template &lt;typename mj_scalar_t, typename mj_lno_t, typename mj_gno_t,</a>
<span class="lineNum">    1944 </span>                :            :           typename mj_part_t&gt;
<span class="lineNum">    1945 </span>                :<span class="lineNoCov">          0 : void AlgMJ&lt;mj_scalar_t, mj_lno_t, mj_gno_t, mj_part_t&gt;::allocate_set_work_memory(){</span>
<span class="lineNum">    1946 </span>                :            : 
<span class="lineNum">    1947 </span>                :            :         //points to process that initially owns the coordinate.
<span class="lineNum">    1948 </span>                :<span class="lineNoCov">          0 :         this-&gt;owner_of_coordinate  = NULL;</span>
<span class="lineNum">    1949 </span>                :            : 
<span class="lineNum">    1950 </span>                :            :         //Throughout the partitioning execution,
<span class="lineNum">    1951 </span>                :            :         //instead of the moving the coordinates, hold a permutation array for parts.
<span class="lineNum">    1952 </span>                :            :         //coordinate_permutations holds the current permutation.
<span class="lineNum">    1953 </span>                :<span class="lineNoCov">          0 :         this-&gt;coordinate_permutations =  allocMemory&lt; mj_lno_t&gt;(this-&gt;num_local_coords);</span>
<span class="lineNum">    1954 </span>                :            :         //initial configuration, set each pointer-i to i.
<span class="lineNum">    1955 </span>                :            : #ifdef HAVE_ZOLTAN2_OMP
<span class="lineNum">    1956 </span>                :            : #pragma omp parallel for
<span class="lineNum">    1957 </span>                :            : #endif
<span class="lineNum">    1958 </span>                :<span class="lineNoCov">          0 :         for(mj_lno_t i = 0; i &lt; this-&gt;num_local_coords; ++i){</span>
<span class="lineNum">    1959 </span>                :<span class="lineNoCov">          0 :                 this-&gt;coordinate_permutations[i] = i;</span>
<span class="lineNum">    1960 </span>                :            :         }
<span class="lineNum">    1961 </span>                :            : 
<span class="lineNum">    1962 </span>                :            :         //new_coordinate_permutations holds the current permutation.
<span class="lineNum">    1963 </span>                :<span class="lineNoCov">          0 :         this-&gt;new_coordinate_permutations = allocMemory&lt; mj_lno_t&gt;(this-&gt;num_local_coords);</span>
<span class="lineNum">    1964 </span>                :            : 
<span class="lineNum">    1965 </span>                :<span class="lineNoCov">          0 :         this-&gt;assigned_part_ids = NULL;</span>
<span class="lineNum">    1966 </span>                :<span class="lineNoCov">          0 :         if(this-&gt;num_local_coords &gt; 0){</span>
<span class="lineNum">    1967 </span>                :<span class="lineNoCov">          0 :                 this-&gt;assigned_part_ids = allocMemory&lt;mj_part_t&gt;(this-&gt;num_local_coords);</span>
<span class="lineNum">    1968 </span>                :            :         }
<span class="lineNum">    1969 </span>                :            : 
<span class="lineNum">    1970 </span>                :            :         //single partition starts at index-0, and ends at numLocalCoords
<span class="lineNum">    1971 </span>                :            :         //inTotalCounts array holds the end points in coordinate_permutations array
<span class="lineNum">    1972 </span>                :            :         //for each partition. Initially sized 1, and single element is set to numLocalCoords.
<span class="lineNum">    1973 </span>                :<span class="lineNoCov">          0 :         this-&gt;part_xadj = allocMemory&lt;mj_lno_t&gt;(1);</span>
<span class="lineNum">    1974 </span>                :<span class="lineNoCov">          0 :         this-&gt;part_xadj[0] = static_cast&lt;mj_lno_t&gt;(this-&gt;num_local_coords);//the end of the initial partition is the end of coordinates.</span>
<span class="lineNum">    1975 </span>                :            :         //the ends points of the output, this is allocated later.
<span class="lineNum">    1976 </span>                :<span class="lineNoCov">          0 :         this-&gt;new_part_xadj = NULL;</span>
<span class="lineNum">    1977 </span>                :            : 
<span class="lineNum">    1978 </span>                :            :         // only store this much if cuts are needed to be stored.
<span class="lineNum">    1979 </span>                :            :         //this-&gt;all_cut_coordinates = allocMemory&lt; mj_scalar_t&gt;(this-&gt;total_num_cut);
<span class="lineNum">    1980 </span>                :            : 
<span class="lineNum">    1981 </span>                :            : 
<span class="lineNum">    1982 </span>                :<span class="lineNoCov">          0 :         this-&gt;all_cut_coordinates  = allocMemory&lt; mj_scalar_t&gt;(this-&gt;max_num_cut_along_dim * this-&gt;max_concurrent_part_calculation);</span>
<span class="lineNum">    1983 </span>                :            : 
<span class="lineNum">    1984 </span>                :<span class="lineNoCov">          0 :         this-&gt;max_min_coords =  allocMemory&lt; mj_scalar_t&gt;(this-&gt;num_threads * 2);</span>
<span class="lineNum">    1985 </span>                :            : 
<span class="lineNum">    1986 </span>                :<span class="lineNoCov">          0 :         this-&gt;process_cut_line_weight_to_put_left = NULL; //how much weight percentage should a MPI put left side of the each cutline</span>
<span class="lineNum">    1987 </span>                :<span class="lineNoCov">          0 :         this-&gt;thread_cut_line_weight_to_put_left = NULL; //how much weight percentage should each thread in MPI put left side of the each outline</span>
<span class="lineNum">    1988 </span>                :            :         //distribute_points_on_cut_lines = false;
<span class="lineNum">    1989 </span>                :<span class="lineNoCov">          0 :         if(this-&gt;distribute_points_on_cut_lines){</span>
<span class="lineNum">    1990 </span>                :<span class="lineNoCov">          0 :                 this-&gt;process_cut_line_weight_to_put_left = allocMemory&lt;mj_scalar_t&gt;(this-&gt;max_num_cut_along_dim * this-&gt;max_concurrent_part_calculation);</span>
<span class="lineNum">    1991 </span>                :<span class="lineNoCov">          0 :                 this-&gt;thread_cut_line_weight_to_put_left = allocMemory&lt;mj_scalar_t *&gt;(this-&gt;num_threads);</span>
<span class="lineNum">    1992 </span>                :<span class="lineNoCov">          0 :                 for(int i = 0; i &lt; this-&gt;num_threads; ++i){</span>
<span class="lineNum">    1993 </span>                :<span class="lineNoCov">          0 :                         this-&gt;thread_cut_line_weight_to_put_left[i] = allocMemory&lt;mj_scalar_t&gt;(this-&gt;max_num_cut_along_dim);</span>
<span class="lineNum">    1994 </span>                :            :                 }
<span class="lineNum">    1995 </span>                :<span class="lineNoCov">          0 :             this-&gt;process_rectilinear_cut_weight = allocMemory&lt;mj_scalar_t&gt;(this-&gt;max_num_cut_along_dim);</span>
<span class="lineNum">    1996 </span>                :<span class="lineNoCov">          0 :             this-&gt;global_rectilinear_cut_weight = allocMemory&lt;mj_scalar_t&gt;(this-&gt;max_num_cut_along_dim);</span>
<span class="lineNum">    1997 </span>                :            :         }
<span class="lineNum">    1998 </span>                :            : 
<span class="lineNum">    1999 </span>                :            : 
<span class="lineNum">    2000 </span>                :            :         // work array to manipulate coordinate of cutlines in different iterations.
<span class="lineNum">    2001 </span>                :            :         //necessary because previous cut line information is used for determining
<span class="lineNum">    2002 </span>                :            :         //the next cutline information. therefore, cannot update the cut work array
<span class="lineNum">    2003 </span>                :            :         //until all cutlines are determined.
<span class="lineNum">    2004 </span>                :<span class="lineNoCov">          0 :         this-&gt;cut_coordinates_work_array = allocMemory&lt;mj_scalar_t&gt;(this-&gt;max_num_cut_along_dim *</span>
<span class="lineNum">    2005 </span>                :            :                         this-&gt;max_concurrent_part_calculation);
<span class="lineNum">    2006 </span>                :            : 
<span class="lineNum">    2007 </span>                :            : 
<span class="lineNum">    2008 </span>                :            :         //cumulative part weight array.
<span class="lineNum">    2009 </span>                :<span class="lineNoCov">          0 :         this-&gt;target_part_weights = allocMemory&lt;mj_scalar_t&gt;(</span>
<span class="lineNum">    2010 </span>                :<span class="lineNoCov">          0 :                                         this-&gt;max_num_part_along_dim * this-&gt;max_concurrent_part_calculation);</span>
<span class="lineNum">    2011 </span>                :            :         // the weight from left to write.
<span class="lineNum">    2012 </span>                :            : 
<span class="lineNum">    2013 </span>                :<span class="lineNoCov">          0 :     this-&gt;cut_upper_bound_coordinates = allocMemory&lt;mj_scalar_t&gt;(this-&gt;max_num_cut_along_dim * this-&gt;max_concurrent_part_calculation);  //upper bound coordinate of a cut line</span>
<span class="lineNum">    2014 </span>                :<span class="lineNoCov">          0 :     this-&gt;cut_lower_bound_coordinates = allocMemory&lt;mj_scalar_t&gt;(this-&gt;max_num_cut_along_dim* this-&gt;max_concurrent_part_calculation);  //lower bound coordinate of a cut line</span>
<span class="lineNum">    2015 </span>                :<span class="lineNoCov">          0 :     this-&gt;cut_lower_bound_weights = allocMemory&lt;mj_scalar_t&gt;(this-&gt;max_num_cut_along_dim* this-&gt;max_concurrent_part_calculation);  //lower bound weight of a cut line</span>
<span class="lineNum">    2016 </span>                :<span class="lineNoCov">          0 :     this-&gt;cut_upper_bound_weights = allocMemory&lt;mj_scalar_t&gt;(this-&gt;max_num_cut_along_dim* this-&gt;max_concurrent_part_calculation);  //upper bound weight of a cut line</span>
<span class="lineNum">    2017 </span>                :            : 
<span class="lineNum">    2018 </span>                :<span class="lineNoCov">          0 :     this-&gt;process_local_min_max_coord_total_weight = allocMemory&lt;mj_scalar_t&gt;(3 * this-&gt;max_concurrent_part_calculation); //combined array to exchange the min and max coordinate, and total weight of part.</span>
<span class="lineNum">    2019 </span>                :<span class="lineNoCov">          0 :     this-&gt;global_min_max_coord_total_weight = allocMemory&lt;mj_scalar_t&gt;(3 * this-&gt;max_concurrent_part_calculation);//global combined array with the results for min, max and total weight.</span>
<span class="lineNum">    2020 </span>                :            : 
<span class="lineNum">    2021 </span>                :            :     //is_cut_line_determined is used to determine if a cutline is determined already.
<span class="lineNum">    2022 </span>                :            :     //If a cut line is already determined, the next iterations will skip this cut line.
<span class="lineNum">    2023 </span>                :<span class="lineNoCov">          0 :     this-&gt;is_cut_line_determined = allocMemory&lt;bool&gt;(this-&gt;max_num_cut_along_dim * this-&gt;max_concurrent_part_calculation);</span>
<span class="lineNum">    2024 </span>                :            :     //my_incomplete_cut_count count holds the number of cutlines that have not been finalized for each part
<span class="lineNum">    2025 </span>                :            :     //when concurrentPartCount&gt;1, using this information, if my_incomplete_cut_count[x]==0, then no work is done for this part.
<span class="lineNum">    2026 </span>                :<span class="lineNoCov">          0 :     this-&gt;my_incomplete_cut_count =  allocMemory&lt;mj_part_t&gt;(this-&gt;max_concurrent_part_calculation);</span>
<span class="lineNum">    2027 </span>                :            :     //local part weights of each thread.
<span class="lineNum">    2028 </span>                :<span class="lineNoCov">          0 :     this-&gt;thread_part_weights = allocMemory&lt;double *&gt;(this-&gt;num_threads);</span>
<span class="lineNum">    2029 </span>                :            :     //the work manupulation array for partweights.
<span class="lineNum">    2030 </span>                :<span class="lineNoCov">          0 :     this-&gt;thread_part_weight_work = allocMemory&lt;double *&gt;(this-&gt;num_threads);</span>
<span class="lineNum">    2031 </span>                :            : 
<span class="lineNum">    2032 </span>                :            :     //thread_cut_left_closest_point to hold the closest coordinate to a cutline from left (for each thread).
<span class="lineNum">    2033 </span>                :<span class="lineNoCov">          0 :     this-&gt;thread_cut_left_closest_point = allocMemory&lt;mj_scalar_t *&gt;(this-&gt;num_threads);</span>
<span class="lineNum">    2034 </span>                :            :     //thread_cut_right_closest_point to hold the closest coordinate to a cutline from right (for each thread)
<span class="lineNum">    2035 </span>                :<span class="lineNoCov">          0 :     this-&gt;thread_cut_right_closest_point = allocMemory&lt;mj_scalar_t *&gt;(this-&gt;num_threads);</span>
<span class="lineNum">    2036 </span>                :            : 
<span class="lineNum">    2037 </span>                :            :     //to store how many points in each part a thread has.
<span class="lineNum">    2038 </span>                :<span class="lineNoCov">          0 :     this-&gt;thread_point_counts = allocMemory&lt;mj_lno_t *&gt;(this-&gt;num_threads);</span>
<span class="lineNum">    2039 </span>                :            : 
<span class="lineNum">    2040 </span>                :<span class="lineNoCov">          0 :     for(int i = 0; i &lt; this-&gt;num_threads; ++i){</span>
<span class="lineNum">    2041 </span>                :            :         //partWeights[i] = allocMemory&lt;mj_scalar_t&gt;(maxTotalPartCount);
<span class="lineNum">    2042 </span>                :<span class="lineNoCov">          0 :         this-&gt;thread_part_weights[i] = allocMemory &lt; double &gt;(this-&gt;max_num_total_part_along_dim * this-&gt;max_concurrent_part_calculation);</span>
<span class="lineNum">    2043 </span>                :<span class="lineNoCov">          0 :         this-&gt;thread_cut_right_closest_point[i] = allocMemory&lt;mj_scalar_t&gt;(this-&gt;max_num_cut_along_dim * this-&gt;max_concurrent_part_calculation);</span>
<span class="lineNum">    2044 </span>                :<span class="lineNoCov">          0 :         this-&gt;thread_cut_left_closest_point[i] = allocMemory&lt;mj_scalar_t&gt;(this-&gt;max_num_cut_along_dim * this-&gt;max_concurrent_part_calculation);</span>
<span class="lineNum">    2045 </span>                :<span class="lineNoCov">          0 :         this-&gt;thread_point_counts[i] =  allocMemory&lt;mj_lno_t&gt;(this-&gt;max_num_part_along_dim);</span>
<span class="lineNum">    2046 </span>                :            :     }
<span class="lineNum">    2047 </span>                :            :     //for faster communication, concatanation of
<span class="lineNum">    2048 </span>                :            :     //totalPartWeights sized 2P-1, since there are P parts and P-1 cut lines
<span class="lineNum">    2049 </span>                :            :     //leftClosest distances sized P-1, since P-1 cut lines
<span class="lineNum">    2050 </span>                :            :     //rightClosest distances size P-1, since P-1 cut lines.
<span class="lineNum">    2051 </span>                :<span class="lineNoCov">          0 :     this-&gt;total_part_weight_left_right_closests = allocMemory&lt;mj_scalar_t&gt;((this-&gt;max_num_total_part_along_dim + this-&gt;max_num_cut_along_dim * 2) * this-&gt;max_concurrent_part_calculation);</span>
<span class="lineNum">    2052 </span>                :<span class="lineNoCov">          0 :     this-&gt;global_total_part_weight_left_right_closests = allocMemory&lt;mj_scalar_t&gt;((this-&gt;max_num_total_part_along_dim + this-&gt;max_num_cut_along_dim * 2) * this-&gt;max_concurrent_part_calculation);</span>
<span class="lineNum">    2053 </span>                :            : 
<span class="lineNum">    2054 </span>                :            : 
<span class="lineNum">    2055 </span>                :<span class="lineNoCov">          0 :     mj_scalar_t **coord = allocMemory&lt;mj_scalar_t *&gt;(this-&gt;coord_dim);</span>
<span class="lineNum">    2056 </span>                :<span class="lineNoCov">          0 :     for (int i=0; i &lt; this-&gt;coord_dim; i++){</span>
<span class="lineNum">    2057 </span>                :<span class="lineNoCov">          0 :         coord[i] = allocMemory&lt;mj_scalar_t&gt;(this-&gt;num_local_coords);</span>
<span class="lineNum">    2058 </span>                :            : #ifdef HAVE_ZOLTAN2_OMP
<span class="lineNum">    2059 </span>                :            : #pragma omp parallel for
<span class="lineNum">    2060 </span>                :            : #endif
<span class="lineNum">    2061 </span>                :<span class="lineNoCov">          0 :         for (mj_lno_t j=0; j &lt; this-&gt;num_local_coords; j++)</span>
<span class="lineNum">    2062 </span>                :<span class="lineNoCov">          0 :                 coord[i][j] = this-&gt;mj_coordinates[i][j];</span>
<span class="lineNum">    2063 </span>                :            :     }
<span class="lineNum">    2064 </span>                :<span class="lineNoCov">          0 :     this-&gt;mj_coordinates = coord;</span>
<span class="lineNum">    2065 </span>                :            : 
<span class="lineNum">    2066 </span>                :            : 
<span class="lineNum">    2067 </span>                :<span class="lineNoCov">          0 :     int criteria_dim = (this-&gt;num_weights_per_coord ? this-&gt;num_weights_per_coord : 1);</span>
<span class="lineNum">    2068 </span>                :<span class="lineNoCov">          0 :     mj_scalar_t **weights = allocMemory&lt;mj_scalar_t *&gt;(criteria_dim);</span>
<span class="lineNum">    2069 </span>                :            : 
<span class="lineNum">    2070 </span>                :<span class="lineNoCov">          0 :     for (int i=0; i &lt; criteria_dim; i++){</span>
<span class="lineNum">    2071 </span>                :<span class="lineNoCov">          0 :         weights[i] = NULL;</span>
<span class="lineNum">    2072 </span>                :            :     }
<span class="lineNum">    2073 </span>                :<span class="lineNoCov">          0 :     for (int i=0; i &lt; this-&gt;num_weights_per_coord; i++){</span>
<span class="lineNum">    2074 </span>                :<span class="lineNoCov">          0 :         weights[i] = allocMemory&lt;mj_scalar_t&gt;(this-&gt;num_local_coords);</span>
<span class="lineNum">    2075 </span>                :            : #ifdef HAVE_ZOLTAN2_OMP
<span class="lineNum">    2076 </span>                :            : #pragma omp parallel for
<span class="lineNum">    2077 </span>                :            : #endif
<span class="lineNum">    2078 </span>                :<span class="lineNoCov">          0 :         for (mj_lno_t j=0; j &lt; this-&gt;num_local_coords; j++)</span>
<span class="lineNum">    2079 </span>                :<span class="lineNoCov">          0 :                 weights[i][j] = this-&gt;mj_weights[i][j];</span>
<span class="lineNum">    2080 </span>                :            : 
<span class="lineNum">    2081 </span>                :            :     }
<span class="lineNum">    2082 </span>                :<span class="lineNoCov">          0 :         this-&gt;mj_weights = weights;</span>
<span class="lineNum">    2083 </span>                :<span class="lineNoCov">          0 :     this-&gt;current_mj_gnos = allocMemory&lt;mj_gno_t&gt;(this-&gt;num_local_coords);</span>
<span class="lineNum">    2084 </span>                :            : #ifdef HAVE_ZOLTAN2_OMP
<span class="lineNum">    2085 </span>                :            : #pragma omp parallel for
<span class="lineNum">    2086 </span>                :            : #endif
<span class="lineNum">    2087 </span>                :<span class="lineNoCov">          0 :     for (mj_lno_t j=0; j &lt; this-&gt;num_local_coords; j++)</span>
<span class="lineNum">    2088 </span>                :<span class="lineNoCov">          0 :         this-&gt;current_mj_gnos[j] = this-&gt;initial_mj_gnos[j];</span>
<span class="lineNum">    2089 </span>                :            : 
<span class="lineNum">    2090 </span>                :<span class="lineNoCov">          0 :     this-&gt;owner_of_coordinate = allocMemory&lt;int&gt;(this-&gt;num_local_coords);</span>
<span class="lineNum">    2091 </span>                :            : 
<span class="lineNum">    2092 </span>                :            : #ifdef HAVE_ZOLTAN2_OMP
<span class="lineNum">    2093 </span>                :            : #pragma omp parallel for
<span class="lineNum">    2094 </span>                :            : #endif
<span class="lineNum">    2095 </span>                :<span class="lineNoCov">          0 :     for (mj_lno_t j=0; j &lt; this-&gt;num_local_coords; j++)</span>
<span class="lineNum">    2096 </span>                :<span class="lineNoCov">          0 :         this-&gt;owner_of_coordinate[j] = this-&gt;myActualRank;</span>
<span class="lineNum">    2097 </span>                :<span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2098 </span>                :            : 
<span class="lineNum">    2099 </span>                :            : /* \brief compute the global bounding box
<span class="lineNum">    2100 </span>                :            :  */
<a name="2101"><span class="lineNum">    2101 </span>                :            : template &lt;typename mj_scalar_t, typename mj_lno_t, typename mj_gno_t,</a>
<span class="lineNum">    2102 </span>                :            :           typename mj_part_t&gt;
<span class="lineNum">    2103 </span>                :<span class="lineNoCov">          0 : void AlgMJ&lt;mj_scalar_t,mj_lno_t,mj_gno_t,mj_part_t&gt;::compute_global_box()</span>
<span class="lineNum">    2104 </span>                :            : {
<span class="lineNum">    2105 </span>                :            :     //local min coords
<span class="lineNum">    2106 </span>                :<span class="lineNoCov">          0 :     mj_scalar_t *mins = allocMemory&lt;mj_scalar_t&gt;(this-&gt;coord_dim);</span>
<span class="lineNum">    2107 </span>                :            :     //global min coords
<span class="lineNum">    2108 </span>                :<span class="lineNoCov">          0 :     mj_scalar_t *gmins = allocMemory&lt;mj_scalar_t&gt;(this-&gt;coord_dim);</span>
<span class="lineNum">    2109 </span>                :            :     //local max coords
<span class="lineNum">    2110 </span>                :<span class="lineNoCov">          0 :     mj_scalar_t *maxs = allocMemory&lt;mj_scalar_t&gt;(this-&gt;coord_dim);</span>
<span class="lineNum">    2111 </span>                :            :     //global max coords
<span class="lineNum">    2112 </span>                :<span class="lineNoCov">          0 :     mj_scalar_t *gmaxs = allocMemory&lt;mj_scalar_t&gt;(this-&gt;coord_dim);</span>
<span class="lineNum">    2113 </span>                :            : 
<span class="lineNum">    2114 </span>                :<span class="lineNoCov">          0 :     for (int i = 0; i &lt; this-&gt;coord_dim; ++i){</span>
<span class="lineNum">    2115 </span>                :<span class="lineNoCov">          0 :         mj_scalar_t localMin = this-&gt;mj_coordinates[i][0];</span>
<span class="lineNum">    2116 </span>                :<span class="lineNoCov">          0 :         mj_scalar_t localMax = this-&gt;mj_coordinates[i][0];</span>
<span class="lineNum">    2117 </span>                :<span class="lineNoCov">          0 :         for (mj_lno_t j = 1; j &lt; this-&gt;num_local_coords; ++j){</span>
<span class="lineNum">    2118 </span>                :<span class="lineNoCov">          0 :             if (this-&gt;mj_coordinates[i][j] &lt; localMin){</span>
<span class="lineNum">    2119 </span>                :<span class="lineNoCov">          0 :                 localMin = this-&gt;mj_coordinates[i][j];</span>
<span class="lineNum">    2120 </span>                :            :             }
<span class="lineNum">    2121 </span>                :<span class="lineNoCov">          0 :             if (this-&gt;mj_coordinates[i][j] &gt; localMax){</span>
<span class="lineNum">    2122 </span>                :<span class="lineNoCov">          0 :                 localMax = this-&gt;mj_coordinates[i][j];</span>
<span class="lineNum">    2123 </span>                :            :             }
<span class="lineNum">    2124 </span>                :            :         }
<span class="lineNum">    2125 </span>                :            :         //cout &lt;&lt; &quot; localMin:&quot; &lt;&lt; localMin &lt;&lt; endl;
<span class="lineNum">    2126 </span>                :            :         //cout &lt;&lt; &quot; localMax:&quot; &lt;&lt; localMax &lt;&lt; endl;
<span class="lineNum">    2127 </span>                :<span class="lineNoCov">          0 :         mins[i] = localMin;</span>
<span class="lineNum">    2128 </span>                :<span class="lineNoCov">          0 :         maxs[i] = localMax;</span>
<span class="lineNum">    2129 </span>                :            :     }
<span class="lineNum">    2130 </span>                :<span class="lineNoCov">          0 :     reduceAll&lt;int, mj_scalar_t&gt;(*this-&gt;comm, Teuchos::REDUCE_MIN,</span>
<span class="lineNum">    2131 </span>                :            :             this-&gt;coord_dim, mins, gmins
<span class="lineNum">    2132 </span>                :            :     );
<span class="lineNum">    2133 </span>                :            : 
<span class="lineNum">    2134 </span>                :<span class="lineNoCov">          0 :     reduceAll&lt;int, mj_scalar_t&gt;(*this-&gt;comm, Teuchos::REDUCE_MAX,</span>
<span class="lineNum">    2135 </span>                :            :             this-&gt;coord_dim, maxs, gmaxs
<span class="lineNum">    2136 </span>                :            :     );
<span class="lineNum">    2137 </span>                :            : 
<span class="lineNum">    2138 </span>                :            :     //create single box with all areas.
<span class="lineNum">    2139 </span>                :<span class="lineNoCov">          0 :     global_box = rcp(new mj_partBox_t(0,this-&gt;coord_dim,gmins,gmaxs));</span>
<span class="lineNum">    2140 </span>                :            :     //coordinateModelPartBox &lt;mj_scalar_t, mj_part_t&gt; tmpBox (0, coordDim);
<span class="lineNum">    2141 </span>                :<span class="lineNoCov">          0 :     freeArray&lt;mj_scalar_t&gt;(mins);</span>
<span class="lineNum">    2142 </span>                :<span class="lineNoCov">          0 :     freeArray&lt;mj_scalar_t&gt;(gmins);</span>
<span class="lineNum">    2143 </span>                :<span class="lineNoCov">          0 :     freeArray&lt;mj_scalar_t&gt;(maxs);</span>
<span class="lineNum">    2144 </span>                :<span class="lineNoCov">          0 :     freeArray&lt;mj_scalar_t&gt;(gmaxs);</span>
<span class="lineNum">    2145 </span>                :<span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2146 </span>                :            : 
<span class="lineNum">    2147 </span>                :            : /* \brief for part communication we keep track of the box boundaries.
<span class="lineNum">    2148 </span>                :            :  * This is performed when either asked specifically, or when geometric mapping is performed afterwards.
<span class="lineNum">    2149 </span>                :            :  * This function initializes a single box with all global min and max coordinates.
<span class="lineNum">    2150 </span>                :            :  * \param initial_partitioning_boxes the input and output vector for boxes.
<span class="lineNum">    2151 </span>                :            :  */
<a name="2152"><span class="lineNum">    2152 </span>                :            : template &lt;typename mj_scalar_t, typename mj_lno_t, typename mj_gno_t,</a>
<span class="lineNum">    2153 </span>                :            :           typename mj_part_t&gt;
<span class="lineNum">    2154 </span>                :<span class="lineNoCov">          0 : void AlgMJ&lt;mj_scalar_t, mj_lno_t, mj_gno_t, mj_part_t&gt;::init_part_boxes(</span>
<span class="lineNum">    2155 </span>                :            :                 RCP&lt;mj_partBoxVector_t&gt; &amp; initial_partitioning_boxes
<span class="lineNum">    2156 </span>                :            : )
<span class="lineNum">    2157 </span>                :            : {
<span class="lineNum">    2158 </span>                :<span class="lineNoCov">          0 :     mj_partBox_t tmp_box(*global_box);</span>
<span class="lineNum">    2159 </span>                :<span class="lineNoCov">          0 :     initial_partitioning_boxes-&gt;push_back(tmp_box);</span>
<span class="lineNum">    2160 </span>                :<span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2161 </span>                :            : 
<span class="lineNum">    2162 </span>                :            : /*! \brief Function to determine the local minimum and maximum coordinate, and local total weight
<span class="lineNum">    2163 </span>                :            :  *  in the given set of local points.
<span class="lineNum">    2164 </span>                :            :  * \param coordinate_begin_index is the start index of the given partition on partitionedPointPermutations.
<span class="lineNum">    2165 </span>                :            :  * \param coordinate_end_index is the end index of the given partition on partitionedPointPermutations.
<span class="lineNum">    2166 </span>                :            :  * \param mj_current_coordinate_permutations is the permutation array that point to the actual coordinate index. Sized as numLocalCoords.
<span class="lineNum">    2167 </span>                :            :  * \param mj_current_dim_coords float-like array representing the coordinates in a single dimension. Sized as numLocalCoords.
<span class="lineNum">    2168 </span>                :            :  * \param min_coordinate is the output to represent the local minimumCoordinate in  given range of coordinates.
<span class="lineNum">    2169 </span>                :            :  * \param max_coordinate is the output to represent the local maximum coordinate in the given range of coordinates.
<span class="lineNum">    2170 </span>                :            :  * \param total_weight is the output to represent the local total weight in the coordinate in the given range of coordinates.
<span class="lineNum">    2171 </span>                :            :  */
<a name="2172"><span class="lineNum">    2172 </span>                :            : template &lt;typename mj_scalar_t, typename mj_lno_t, typename mj_gno_t,</a>
<span class="lineNum">    2173 </span>                :            :           typename mj_part_t&gt;
<span class="lineNum">    2174 </span>                :<span class="lineNoCov">          0 : void AlgMJ&lt;mj_scalar_t, mj_lno_t, mj_gno_t, mj_part_t&gt;::mj_get_local_min_max_coord_totW(</span>
<span class="lineNum">    2175 </span>                :            :                 mj_lno_t coordinate_begin_index,
<span class="lineNum">    2176 </span>                :            :                 mj_lno_t coordinate_end_index,
<span class="lineNum">    2177 </span>                :            :                 mj_lno_t *mj_current_coordinate_permutations,
<span class="lineNum">    2178 </span>                :            :                 mj_scalar_t *mj_current_dim_coords,
<span class="lineNum">    2179 </span>                :            :                 mj_scalar_t &amp;min_coordinate,
<span class="lineNum">    2180 </span>                :            :                 mj_scalar_t &amp;max_coordinate,
<span class="lineNum">    2181 </span>                :            :                 mj_scalar_t &amp;total_weight){
<span class="lineNum">    2182 </span>                :            : 
<span class="lineNum">    2183 </span>                :            :     //if the part is empty.
<span class="lineNum">    2184 </span>                :            :     //set the min and max coordinates as reverse.
<span class="lineNum">    2185 </span>                :<span class="lineNoCov">          0 :     if(coordinate_begin_index &gt;= coordinate_end_index)</span>
<span class="lineNum">    2186 </span>                :            :     {
<span class="lineNum">    2187 </span>                :<span class="lineNoCov">          0 :         min_coordinate = this-&gt;maxScalar_t;</span>
<span class="lineNum">    2188 </span>                :<span class="lineNoCov">          0 :         max_coordinate = this-&gt;minScalar_t;</span>
<span class="lineNum">    2189 </span>                :<span class="lineNoCov">          0 :         total_weight = 0;</span>
<span class="lineNum">    2190 </span>                :            :     }
<span class="lineNum">    2191 </span>                :            :     else {
<span class="lineNum">    2192 </span>                :<span class="lineNoCov">          0 :         mj_scalar_t my_total_weight = 0;</span>
<span class="lineNum">    2193 </span>                :            : #ifdef HAVE_ZOLTAN2_OMP
<span class="lineNum">    2194 </span>                :            : #pragma omp parallel
<span class="lineNum">    2195 </span>                :            : #endif
<span class="lineNum">    2196 </span>                :            :         {
<span class="lineNum">    2197 </span>                :            :             //if uniform weights are used, then weight is equal to count.
<span class="lineNum">    2198 </span>                :<span class="lineNoCov">          0 :             if (this-&gt;mj_uniform_weights[0]) {</span>
<span class="lineNum">    2199 </span>                :            : #ifdef HAVE_ZOLTAN2_OMP
<span class="lineNum">    2200 </span>                :            : #pragma omp single
<span class="lineNum">    2201 </span>                :            : #endif
<span class="lineNum">    2202 </span>                :            :                 {
<span class="lineNum">    2203 </span>                :<span class="lineNoCov">          0 :                     my_total_weight = coordinate_end_index - coordinate_begin_index;</span>
<span class="lineNum">    2204 </span>                :            :                 }
<span class="lineNum">    2205 </span>                :            : 
<span class="lineNum">    2206 </span>                :            :             }
<span class="lineNum">    2207 </span>                :            :             else {
<span class="lineNum">    2208 </span>                :            :                 //if not uniform, then weights are reducted from threads.
<span class="lineNum">    2209 </span>                :            : #ifdef HAVE_ZOLTAN2_OMP
<span class="lineNum">    2210 </span>                :            : #pragma omp for reduction(+:my_total_weight)
<span class="lineNum">    2211 </span>                :            : #endif
<span class="lineNum">    2212 </span>                :<span class="lineNoCov">          0 :                 for (mj_lno_t ii = coordinate_begin_index; ii &lt; coordinate_end_index; ++ii){</span>
<span class="lineNum">    2213 </span>                :<span class="lineNoCov">          0 :                     int i = mj_current_coordinate_permutations[ii];</span>
<span class="lineNum">    2214 </span>                :<span class="lineNoCov">          0 :                     my_total_weight += this-&gt;mj_weights[0][i];</span>
<span class="lineNum">    2215 </span>                :            :                 }
<span class="lineNum">    2216 </span>                :            :             }
<span class="lineNum">    2217 </span>                :            : 
<span class="lineNum">    2218 </span>                :<span class="lineNoCov">          0 :             int my_thread_id = 0;</span>
<span class="lineNum">    2219 </span>                :            : #ifdef HAVE_ZOLTAN2_OMP
<span class="lineNum">    2220 </span>                :            :             my_thread_id = omp_get_thread_num();
<span class="lineNum">    2221 </span>                :            : #endif
<span class="lineNum">    2222 </span>                :            :             mj_scalar_t my_thread_min_coord, my_thread_max_coord;
<span class="lineNum">    2223 </span>                :<span class="lineNoCov">          0 :             my_thread_min_coord=my_thread_max_coord</span>
<span class="lineNum">    2224 </span>                :<span class="lineNoCov">          0 :                 =mj_current_dim_coords[mj_current_coordinate_permutations[coordinate_begin_index]];</span>
<span class="lineNum">    2225 </span>                :            : 
<span class="lineNum">    2226 </span>                :            : 
<span class="lineNum">    2227 </span>                :            : #ifdef HAVE_ZOLTAN2_OMP
<span class="lineNum">    2228 </span>                :            : #pragma omp for
<span class="lineNum">    2229 </span>                :            : #endif
<span class="lineNum">    2230 </span>                :<span class="lineNoCov">          0 :             for(mj_lno_t j = coordinate_begin_index + 1; j &lt; coordinate_end_index; ++j){</span>
<span class="lineNum">    2231 </span>                :<span class="lineNoCov">          0 :                 int i = mj_current_coordinate_permutations[j];</span>
<span class="lineNum">    2232 </span>                :<span class="lineNoCov">          0 :                 if(mj_current_dim_coords[i] &gt; my_thread_max_coord)</span>
<span class="lineNum">    2233 </span>                :<span class="lineNoCov">          0 :                     my_thread_max_coord = mj_current_dim_coords[i];</span>
<span class="lineNum">    2234 </span>                :<span class="lineNoCov">          0 :                 if(mj_current_dim_coords[i] &lt; my_thread_min_coord)</span>
<span class="lineNum">    2235 </span>                :<span class="lineNoCov">          0 :                     my_thread_min_coord = mj_current_dim_coords[i];</span>
<span class="lineNum">    2236 </span>                :            :             }
<span class="lineNum">    2237 </span>                :<span class="lineNoCov">          0 :             this-&gt;max_min_coords[my_thread_id] = my_thread_min_coord;</span>
<span class="lineNum">    2238 </span>                :<span class="lineNoCov">          0 :             this-&gt;max_min_coords[my_thread_id + this-&gt;num_threads] = my_thread_max_coord;</span>
<span class="lineNum">    2239 </span>                :            : 
<span class="lineNum">    2240 </span>                :            : #ifdef HAVE_ZOLTAN2_OMP
<span class="lineNum">    2241 </span>                :            : //we need a barrier here, because max_min_array might not be filled by some of the threads.
<span class="lineNum">    2242 </span>                :            : #pragma omp barrier
<span class="lineNum">    2243 </span>                :            : #pragma omp single nowait
<span class="lineNum">    2244 </span>                :            : #endif
<span class="lineNum">    2245 </span>                :            :             {
<span class="lineNum">    2246 </span>                :<span class="lineNoCov">          0 :                 min_coordinate = this-&gt;max_min_coords[0];</span>
<span class="lineNum">    2247 </span>                :<span class="lineNoCov">          0 :                 for(int i = 1; i &lt; this-&gt;num_threads; ++i){</span>
<span class="lineNum">    2248 </span>                :<span class="lineNoCov">          0 :                     if(this-&gt;max_min_coords[i] &lt; min_coordinate)</span>
<span class="lineNum">    2249 </span>                :<span class="lineNoCov">          0 :                         min_coordinate = this-&gt;max_min_coords[i];</span>
<span class="lineNum">    2250 </span>                :            :                 }
<span class="lineNum">    2251 </span>                :            :             }
<span class="lineNum">    2252 </span>                :            : 
<span class="lineNum">    2253 </span>                :            : #ifdef HAVE_ZOLTAN2_OMP
<span class="lineNum">    2254 </span>                :            : #pragma omp single nowait
<span class="lineNum">    2255 </span>                :            : #endif
<span class="lineNum">    2256 </span>                :            :             {
<span class="lineNum">    2257 </span>                :<span class="lineNoCov">          0 :                 max_coordinate = this-&gt;max_min_coords[this-&gt;num_threads];</span>
<span class="lineNum">    2258 </span>                :<span class="lineNoCov">          0 :                 for(int i = this-&gt;num_threads + 1; i &lt; this-&gt;num_threads * 2; ++i){</span>
<span class="lineNum">    2259 </span>                :<span class="lineNoCov">          0 :                     if(this-&gt;max_min_coords[i] &gt; max_coordinate)</span>
<span class="lineNum">    2260 </span>                :<span class="lineNoCov">          0 :                         max_coordinate = this-&gt;max_min_coords[i];</span>
<span class="lineNum">    2261 </span>                :            :                 }
<span class="lineNum">    2262 </span>                :            :             }
<span class="lineNum">    2263 </span>                :            :         }
<span class="lineNum">    2264 </span>                :<span class="lineNoCov">          0 :         total_weight = my_total_weight;</span>
<span class="lineNum">    2265 </span>                :            :     }
<span class="lineNum">    2266 </span>                :<span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2267 </span>                :            : 
<span class="lineNum">    2268 </span>                :            : 
<span class="lineNum">    2269 </span>                :            : /*! \brief Function that reduces global minimum and maximum coordinates with global total weight from given local arrays.
<span class="lineNum">    2270 </span>                :            :  * \param current_concurrent_num_parts is the number of parts whose cut lines will be calculated concurrently.
<span class="lineNum">    2271 </span>                :            :  * \param local_min_max_total is the array holding local min and max coordinate values with local total weight.
<span class="lineNum">    2272 </span>                :            :  * First concurrentPartCount entries are minimums of the parts, next concurrentPartCount entries are max, and then the total weights.
<span class="lineNum">    2273 </span>                :            :  * \param global_min_max_total is the output array holding global min and global coordinate values with global total weight.
<span class="lineNum">    2274 </span>                :            :  * The structure is same as localMinMaxTotal.
<span class="lineNum">    2275 </span>                :            :  */
<a name="2276"><span class="lineNum">    2276 </span>                :            : template &lt;typename mj_scalar_t, typename mj_lno_t, typename mj_gno_t,</a>
<span class="lineNum">    2277 </span>                :            :           typename mj_part_t&gt;
<span class="lineNum">    2278 </span>                :<span class="lineNoCov">          0 : void AlgMJ&lt;mj_scalar_t, mj_lno_t, mj_gno_t, mj_part_t&gt;::mj_get_global_min_max_coord_totW(</span>
<span class="lineNum">    2279 </span>                :            :     mj_part_t current_concurrent_num_parts,
<span class="lineNum">    2280 </span>                :            :     mj_scalar_t *local_min_max_total,
<span class="lineNum">    2281 </span>                :            :     mj_scalar_t *global_min_max_total){
<span class="lineNum">    2282 </span>                :            : 
<span class="lineNum">    2283 </span>                :            :         //reduce min for first current_concurrent_num_parts elements, reduce max for next
<span class="lineNum">    2284 </span>                :            :         //concurrentPartCount elements,
<span class="lineNum">    2285 </span>                :            :         //reduce sum for the last concurrentPartCount elements.
<span class="lineNum">    2286 </span>                :<span class="lineNoCov">          0 :         if(this-&gt;comm-&gt;getSize()  &gt; 1){</span>
<span class="lineNum">    2287 </span>                :            :                 Teuchos::MultiJaggedCombinedMinMaxTotalReductionOp&lt;int, mj_scalar_t&gt;
<span class="lineNum">    2288 </span>                :            :                         reductionOp(
<span class="lineNum">    2289 </span>                :            :                                         current_concurrent_num_parts,
<span class="lineNum">    2290 </span>                :            :                                         current_concurrent_num_parts,
<span class="lineNum">    2291 </span>                :<span class="lineNoCov">          0 :                                         current_concurrent_num_parts);</span>
<span class="lineNum">    2292 </span>                :            :                 try{
<span class="lineNum">    2293 </span>                :<span class="lineNoCov">          0 :                         reduceAll&lt;int, mj_scalar_t&gt;(</span>
<span class="lineNum">    2294 </span>                :<span class="lineNoCov">          0 :                                         *(this-&gt;comm),</span>
<span class="lineNum">    2295 </span>                :            :                                         reductionOp,
<span class="lineNum">    2296 </span>                :            :                                         3 * current_concurrent_num_parts,
<span class="lineNum">    2297 </span>                :            :                                         local_min_max_total,
<span class="lineNum">    2298 </span>                :            :                                         global_min_max_total);
<span class="lineNum">    2299 </span>                :            :                 }
<span class="lineNum">    2300 </span>                :<span class="lineNoCov">          0 :                 Z2_THROW_OUTSIDE_ERROR(*(this-&gt;mj_env))</span>
<span class="lineNum">    2301 </span>                :            :         }
<span class="lineNum">    2302 </span>                :            :         else {
<span class="lineNum">    2303 </span>                :<span class="lineNoCov">          0 :                 mj_part_t s = 3 * current_concurrent_num_parts;</span>
<span class="lineNum">    2304 </span>                :<span class="lineNoCov">          0 :                 for (mj_part_t i = 0; i &lt; s; ++i){</span>
<span class="lineNum">    2305 </span>                :<span class="lineNoCov">          0 :                         global_min_max_total[i] = local_min_max_total[i];</span>
<span class="lineNum">    2306 </span>                :            :                 }
<span class="lineNum">    2307 </span>                :            :         }
<span class="lineNum">    2308 </span>                :<span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2309 </span>                :            : 
<span class="lineNum">    2310 </span>                :            : 
<span class="lineNum">    2311 </span>                :            : 
<span class="lineNum">    2312 </span>                :            : /*! \brief Function that calculates the new coordinates for the cut lines. Function is called inside the parallel region.
<span class="lineNum">    2313 </span>                :            :  * \param min_coord minimum coordinate in the range.
<span class="lineNum">    2314 </span>                :            :  * \param max_coord maximum coordinate in the range.
<span class="lineNum">    2315 </span>                :            :  *
<span class="lineNum">    2316 </span>                :            :  * \param num_cuts holds the number of cuts in the current partitioning dimension.
<span class="lineNum">    2317 </span>                :            :  * \param global_weight holds the global total weight in the current part.
<span class="lineNum">    2318 </span>                :            :  *
<span class="lineNum">    2319 </span>                :            :  * \param initial_cut_coords is the output array for the initial cut lines.
<span class="lineNum">    2320 </span>                :            :  * \param target_part_weights is the output array holding the cumulative ratios of parts in current partitioning.
<span class="lineNum">    2321 </span>                :            :  * For partitioning to 4 uniformly, target_part_weights will be (0.25 * globalTotalWeight, 0.5 *globalTotalWeight , 0.75 * globalTotalWeight, globalTotalWeight).
<span class="lineNum">    2322 </span>                :            :  *
<span class="lineNum">    2323 </span>                :            :  * \param future_num_part_in_parts is the vector that holds how many more parts each part will be divided into more
<span class="lineNum">    2324 </span>                :            :  * for the parts at the beginning of this coordinate partitioning
<span class="lineNum">    2325 </span>                :            :  * \param next_future_num_parts_in_parts is the vector that holds how many more parts each part will be divided into more
<span class="lineNum">    2326 </span>                :            :  * for the parts that will be obtained at the end of this coordinate partitioning.
<span class="lineNum">    2327 </span>                :            :  * \param concurrent_current_part is the index of the part in the future_num_part_in_parts vector.
<span class="lineNum">    2328 </span>                :            :  * \param obtained_part_index holds the amount of shift in the next_future_num_parts_in_parts for the output parts.
<span class="lineNum">    2329 </span>                :            :  */
<a name="2330"><span class="lineNum">    2330 </span>                :            : template &lt;typename mj_scalar_t, typename mj_lno_t, typename mj_gno_t,</a>
<span class="lineNum">    2331 </span>                :            :           typename mj_part_t&gt;
<span class="lineNum">    2332 </span>                :<span class="lineNoCov">          0 : void AlgMJ&lt;mj_scalar_t, mj_lno_t, mj_gno_t, mj_part_t&gt;::mj_get_initial_cut_coords_target_weights(</span>
<span class="lineNum">    2333 </span>                :            :     mj_scalar_t min_coord,
<span class="lineNum">    2334 </span>                :            :     mj_scalar_t max_coord,
<span class="lineNum">    2335 </span>                :            :     mj_part_t num_cuts/*p-1*/ ,
<span class="lineNum">    2336 </span>                :            :     mj_scalar_t global_weight,
<span class="lineNum">    2337 </span>                :            :     mj_scalar_t *initial_cut_coords /*p - 1 sized, coordinate of each cut line*/,
<span class="lineNum">    2338 </span>                :            :     mj_scalar_t *current_target_part_weights /*cumulative weights, at left side of each cut line. p-1 sized*/,
<span class="lineNum">    2339 </span>                :            : 
<span class="lineNum">    2340 </span>                :            :     std::vector &lt;mj_part_t&gt; *future_num_part_in_parts, //the vecto
<span class="lineNum">    2341 </span>                :            :     std::vector &lt;mj_part_t&gt; *next_future_num_parts_in_parts,
<span class="lineNum">    2342 </span>                :            :     mj_part_t concurrent_current_part,
<span class="lineNum">    2343 </span>                :            :     mj_part_t obtained_part_index
<span class="lineNum">    2344 </span>                :            : ){
<span class="lineNum">    2345 </span>                :            : 
<span class="lineNum">    2346 </span>                :<span class="lineNoCov">          0 :     mj_scalar_t coord_range = max_coord - min_coord;</span>
<span class="lineNum">    2347 </span>                :<span class="lineNoCov">          0 :     if(this-&gt;mj_uniform_parts[0]){</span>
<span class="lineNum">    2348 </span>                :            :         {
<span class="lineNum">    2349 </span>                :<span class="lineNoCov">          0 :             mj_part_t cumulative = 0;</span>
<span class="lineNum">    2350 </span>                :            :             //how many total future parts the part will be partitioned into.
<span class="lineNum">    2351 </span>                :<span class="lineNoCov">          0 :             mj_scalar_t total_future_part_count_in_part = mj_scalar_t((*future_num_part_in_parts)[concurrent_current_part]);</span>
<span class="lineNum">    2352 </span>                :            : 
<span class="lineNum">    2353 </span>                :            : 
<span class="lineNum">    2354 </span>                :            :             //how much each part should weigh in ideal case.
<span class="lineNum">    2355 </span>                :<span class="lineNoCov">          0 :             mj_scalar_t unit_part_weight = global_weight / total_future_part_count_in_part;</span>
<span class="lineNum">    2356 </span>                :            :             /*
<span class="lineNum">    2357 </span>                :            :             cout &lt;&lt; &quot;total_future_part_count_in_part:&quot; &lt;&lt; total_future_part_count_in_part &lt;&lt; endl;
<span class="lineNum">    2358 </span>                :            :             cout &lt;&lt; &quot;global_weight:&quot; &lt;&lt; global_weight &lt;&lt; endl;
<span class="lineNum">    2359 </span>                :            :             cout &lt;&lt; &quot;unit_part_weight&quot; &lt;&lt; unit_part_weight &lt;&lt;endl;
<span class="lineNum">    2360 </span>                :            :             */
<span class="lineNum">    2361 </span>                :<span class="lineNoCov">          0 :             for(mj_part_t i = 0; i &lt; num_cuts; ++i){</span>
<span class="lineNum">    2362 </span>                :<span class="lineNoCov">          0 :                 cumulative += (*next_future_num_parts_in_parts)[i + obtained_part_index];</span>
<span class="lineNum">    2363 </span>                :            : 
<span class="lineNum">    2364 </span>                :            :                 /*
<span class="lineNum">    2365 </span>                :            :                 cout &lt;&lt; &quot;obtained_part_index:&quot; &lt;&lt; obtained_part_index &lt;&lt;
<span class="lineNum">    2366 </span>                :            :                                 &quot; (*next_future_num_parts_in_parts)[i + obtained_part_index]:&quot; &lt;&lt; (*next_future_num_parts_in_parts)[i + obtained_part_index] &lt;&lt;
<span class="lineNum">    2367 </span>                :            :                                 &quot; cumulative:&quot; &lt;&lt; cumulative &lt;&lt; endl;
<span class="lineNum">    2368 </span>                :            :                 */
<span class="lineNum">    2369 </span>                :            :                 //set target part weight.
<span class="lineNum">    2370 </span>                :<span class="lineNoCov">          0 :                 current_target_part_weights[i] = cumulative * unit_part_weight;</span>
<span class="lineNum">    2371 </span>                :            :                 //cout &lt;&lt;&quot;i:&quot; &lt;&lt; i &lt;&lt; &quot; current_target_part_weights:&quot; &lt;&lt; current_target_part_weights[i] &lt;&lt; endl;
<span class="lineNum">    2372 </span>                :            :                 //set initial cut coordinate.
<span class="lineNum">    2373 </span>                :<span class="lineNoCov">          0 :                 initial_cut_coords[i] = min_coord + (coord_range *</span>
<span class="lineNum">    2374 </span>                :            :                                          cumulative) / total_future_part_count_in_part;
<span class="lineNum">    2375 </span>                :            :             }
<span class="lineNum">    2376 </span>                :<span class="lineNoCov">          0 :             current_target_part_weights[num_cuts] = 1;</span>
<span class="lineNum">    2377 </span>                :            :         }
<span class="lineNum">    2378 </span>                :            : 
<span class="lineNum">    2379 </span>                :            :         //round the target part weights.
<span class="lineNum">    2380 </span>                :<span class="lineNoCov">          0 :         if (this-&gt;mj_uniform_weights[0]){</span>
<span class="lineNum">    2381 </span>                :<span class="lineNoCov">          0 :                 for(mj_part_t i = 0; i &lt; num_cuts + 1; ++i){</span>
<span class="lineNum">    2382 </span>                :<span class="lineNoCov">          0 :                 current_target_part_weights[i] = long(current_target_part_weights[i] + 0.5);</span>
<span class="lineNum">    2383 </span>                :            :             }
<span class="lineNum">    2384 </span>                :            :         }
<span class="lineNum">    2385 </span>                :            :     }
<span class="lineNum">    2386 </span>                :            :     else {
<span class="lineNum">    2387 </span>                :<span class="lineNoCov">          0 :         std::cerr &lt;&lt; &quot;MJ does not support non uniform part weights&quot; &lt;&lt; std::endl;</span>
<span class="lineNum">    2388 </span>                :<span class="lineNoCov">          0 :         exit(1);</span>
<span class="lineNum">    2389 </span>                :            :     }
<span class="lineNum">    2390 </span>                :<span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2391 </span>                :            : 
<span class="lineNum">    2392 </span>                :            : 
<span class="lineNum">    2393 </span>                :            : /*! \brief Function that calculates the new coordinates for the cut lines. Function is called inside the parallel region.
<span class="lineNum">    2394 </span>                :            :  * \param max_coordinate maximum coordinate in the range.
<span class="lineNum">    2395 </span>                :            :  * \param min_coordinate minimum coordinate in the range.
<span class="lineNum">    2396 </span>                :            :  *
<span class="lineNum">    2397 </span>                :            :  * \param concurrent_current_part_index is the index of the part in the inTotalCounts vector.
<span class="lineNum">    2398 </span>                :            :  * \param coordinate_begin_index holds the beginning of the coordinates in current part.
<span class="lineNum">    2399 </span>                :            :  * \param coordinate_end_index holds end of the coordinates in current part.
<span class="lineNum">    2400 </span>                :            :  * \param mj_current_coordinate_permutations is the permutation array, holds the real indices of coordinates on mj_current_dim_coords array.
<span class="lineNum">    2401 </span>                :            :  * \param mj_current_dim_coords is the 1D array holding the coordinates.
<span class="lineNum">    2402 </span>                :            :  * \param mj_part_ids is the array holding the partIds of each coordinate.
<span class="lineNum">    2403 </span>                :            :  * \param partition_count is the number of parts that the current part will be partitioned into.
<span class="lineNum">    2404 </span>                :            :  */
<a name="2405"><span class="lineNum">    2405 </span>                :            : template &lt;typename mj_scalar_t, typename mj_lno_t, typename mj_gno_t,</a>
<span class="lineNum">    2406 </span>                :            :           typename mj_part_t&gt;
<span class="lineNum">    2407 </span>                :<span class="lineNoCov">          0 : void AlgMJ&lt;mj_scalar_t, mj_lno_t, mj_gno_t, mj_part_t&gt;::set_initial_coordinate_parts(</span>
<span class="lineNum">    2408 </span>                :            :     mj_scalar_t &amp;max_coordinate,
<span class="lineNum">    2409 </span>                :            :     mj_scalar_t &amp;min_coordinate,
<span class="lineNum">    2410 </span>                :            :     mj_part_t &amp;concurrent_current_part_index,
<span class="lineNum">    2411 </span>                :            :     mj_lno_t coordinate_begin_index,
<span class="lineNum">    2412 </span>                :            :     mj_lno_t coordinate_end_index,
<span class="lineNum">    2413 </span>                :            :     mj_lno_t *mj_current_coordinate_permutations,
<span class="lineNum">    2414 </span>                :            :     mj_scalar_t *mj_current_dim_coords,
<span class="lineNum">    2415 </span>                :            :     mj_part_t *mj_part_ids,
<span class="lineNum">    2416 </span>                :            :     mj_part_t &amp;partition_count
<span class="lineNum">    2417 </span>                :            : ){
<span class="lineNum">    2418 </span>                :<span class="lineNoCov">          0 :     mj_scalar_t coordinate_range = max_coordinate - min_coordinate;</span>
<span class="lineNum">    2419 </span>                :            : 
<span class="lineNum">    2420 </span>                :            :     //if there is single point, or if all points are along a line.
<span class="lineNum">    2421 </span>                :            :     //set initial part to 0 for all.
<span class="lineNum">    2422 </span>                :<span class="lineNoCov">          0 :     if(ZOLTAN2_ABS(coordinate_range) &lt; this-&gt;sEpsilon ){</span>
<span class="lineNum">    2423 </span>                :            : #ifdef HAVE_ZOLTAN2_OMP
<span class="lineNum">    2424 </span>                :            : #pragma omp parallel for
<span class="lineNum">    2425 </span>                :            : #endif
<span class="lineNum">    2426 </span>                :<span class="lineNoCov">          0 :         for(mj_lno_t ii = coordinate_begin_index; ii &lt; coordinate_end_index; ++ii){</span>
<span class="lineNum">    2427 </span>                :<span class="lineNoCov">          0 :                 mj_part_ids[mj_current_coordinate_permutations[ii]] = 0;</span>
<span class="lineNum">    2428 </span>                :            :         }
<span class="lineNum">    2429 </span>                :            :     }
<span class="lineNum">    2430 </span>                :            :     else{
<span class="lineNum">    2431 </span>                :            : 
<span class="lineNum">    2432 </span>                :            :         //otherwise estimate an initial part for each coordinate.
<span class="lineNum">    2433 </span>                :            :         //assuming uniform distribution of points.
<span class="lineNum">    2434 </span>                :<span class="lineNoCov">          0 :         mj_scalar_t slice = coordinate_range / partition_count;</span>
<span class="lineNum">    2435 </span>                :            : 
<span class="lineNum">    2436 </span>                :            : #ifdef HAVE_ZOLTAN2_OMP
<span class="lineNum">    2437 </span>                :            : #pragma omp parallel for
<span class="lineNum">    2438 </span>                :            : #endif
<span class="lineNum">    2439 </span>                :<span class="lineNoCov">          0 :         for(mj_lno_t ii = coordinate_begin_index; ii &lt; coordinate_end_index; ++ii){</span>
<span class="lineNum">    2440 </span>                :            : 
<span class="lineNum">    2441 </span>                :<span class="lineNoCov">          0 :             mj_lno_t iii = mj_current_coordinate_permutations[ii];</span>
<span class="lineNum">    2442 </span>                :<span class="lineNoCov">          0 :             mj_part_t pp = mj_part_t((mj_current_dim_coords[iii] - min_coordinate) / slice);</span>
<span class="lineNum">    2443 </span>                :<span class="lineNoCov">          0 :             mj_part_ids[iii] = 2 * pp;</span>
<span class="lineNum">    2444 </span>                :            :         }
<span class="lineNum">    2445 </span>                :            :     }
<span class="lineNum">    2446 </span>                :<span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2447 </span>                :            : 
<span class="lineNum">    2448 </span>                :            : 
<span class="lineNum">    2449 </span>                :            : /*! \brief Function that is responsible from 1D partitioning of the given range of coordinates.
<span class="lineNum">    2450 </span>                :            :  * \param mj_current_dim_coords is 1 dimensional array holding coordinate values.
<span class="lineNum">    2451 </span>                :            :  * \param imbalanceTolerance is the maximum allowed imbalance ratio.
<span class="lineNum">    2452 </span>                :            :  * \param current_work_part is the beginning index of concurrentPartCount parts.
<span class="lineNum">    2453 </span>                :            :  * \param current_concurrent_num_parts is the number of parts whose cut lines will be calculated concurrently.
<span class="lineNum">    2454 </span>                :            :  * \param current_cut_coordinates is the array holding the coordinates of the cut.
<span class="lineNum">    2455 </span>                :            :  * \param total_incomplete_cut_count is the number of cut lines whose positions should be calculated.
<span class="lineNum">    2456 </span>                :            :  * \param num_partitioning_in_current_dim is the vector that holds how many parts each part will be divided into.
<span class="lineNum">    2457 </span>                :            :  *
<span class="lineNum">    2458 </span>                :            :  */
<a name="2459"><span class="lineNum">    2459 </span>                :            : template &lt;typename mj_scalar_t, typename mj_lno_t, typename mj_gno_t,</a>
<span class="lineNum">    2460 </span>                :            :           typename mj_part_t&gt;
<span class="lineNum">    2461 </span>                :<span class="lineNoCov">          0 : void AlgMJ&lt;mj_scalar_t, mj_lno_t, mj_gno_t, mj_part_t&gt;::mj_1D_part(</span>
<span class="lineNum">    2462 </span>                :            :     mj_scalar_t *mj_current_dim_coords,
<span class="lineNum">    2463 </span>                :            :     mj_scalar_t used_imbalance_tolerance,
<span class="lineNum">    2464 </span>                :            :     mj_part_t current_work_part,
<span class="lineNum">    2465 </span>                :            :     mj_part_t current_concurrent_num_parts,
<span class="lineNum">    2466 </span>                :            :     mj_scalar_t *current_cut_coordinates,
<span class="lineNum">    2467 </span>                :            :     mj_part_t total_incomplete_cut_count,
<span class="lineNum">    2468 </span>                :            :     std::vector &lt;mj_part_t&gt; &amp;num_partitioning_in_current_dim
<span class="lineNum">    2469 </span>                :            : ){
<span class="lineNum">    2470 </span>                :            : 
<span class="lineNum">    2471 </span>                :            : 
<span class="lineNum">    2472 </span>                :<span class="lineNoCov">          0 :     mj_part_t rectilinear_cut_count = 0;</span>
<span class="lineNum">    2473 </span>                :<span class="lineNoCov">          0 :     mj_scalar_t *temp_cut_coords = current_cut_coordinates;</span>
<span class="lineNum">    2474 </span>                :            : 
<span class="lineNum">    2475 </span>                :            :     Teuchos::MultiJaggedCombinedReductionOp&lt;mj_part_t, mj_scalar_t&gt;
<span class="lineNum">    2476 </span>                :<span class="lineNoCov">          0 :                  *reductionOp = NULL;</span>
<span class="lineNum">    2477 </span>                :<span class="lineNoCov">          0 :     reductionOp = new Teuchos::MultiJaggedCombinedReductionOp</span>
<span class="lineNum">    2478 </span>                :            :                      &lt;mj_part_t, mj_scalar_t&gt;(
<span class="lineNum">    2479 </span>                :            :                                  &amp;num_partitioning_in_current_dim ,
<span class="lineNum">    2480 </span>                :            :                                  current_work_part ,
<span class="lineNum">    2481 </span>                :            :                                  current_concurrent_num_parts);
<span class="lineNum">    2482 </span>                :            : 
<span class="lineNum">    2483 </span>                :<span class="lineNoCov">          0 :     size_t total_reduction_size = 0;</span>
<span class="lineNum">    2484 </span>                :            : #ifdef HAVE_ZOLTAN2_OMP
<span class="lineNum">    2485 </span>                :            : #pragma omp parallel shared(total_incomplete_cut_count,  rectilinear_cut_count)
<span class="lineNum">    2486 </span>                :            : #endif
<span class="lineNum">    2487 </span>                :            :     {
<span class="lineNum">    2488 </span>                :<span class="lineNoCov">          0 :         int me = 0;</span>
<span class="lineNum">    2489 </span>                :            : #ifdef HAVE_ZOLTAN2_OMP
<span class="lineNum">    2490 </span>                :            :         me = omp_get_thread_num();
<span class="lineNum">    2491 </span>                :            : #endif
<span class="lineNum">    2492 </span>                :<span class="lineNoCov">          0 :         double *my_thread_part_weights = this-&gt;thread_part_weights[me];</span>
<span class="lineNum">    2493 </span>                :<span class="lineNoCov">          0 :         mj_scalar_t *my_thread_left_closest = this-&gt;thread_cut_left_closest_point[me];</span>
<span class="lineNum">    2494 </span>                :<span class="lineNoCov">          0 :         mj_scalar_t *my_thread_right_closest = this-&gt;thread_cut_right_closest_point[me];</span>
<span class="lineNum">    2495 </span>                :            : 
<span class="lineNum">    2496 </span>                :            : #ifdef HAVE_ZOLTAN2_OMP
<span class="lineNum">    2497 </span>                :            : #pragma omp single
<span class="lineNum">    2498 </span>                :            : #endif
<span class="lineNum">    2499 </span>                :            :             {
<span class="lineNum">    2500 </span>                :            :                 //initialize the lower and upper bounds of the cuts.
<span class="lineNum">    2501 </span>                :<span class="lineNoCov">          0 :                 mj_part_t next = 0;</span>
<span class="lineNum">    2502 </span>                :<span class="lineNoCov">          0 :                 for(mj_part_t i = 0; i &lt; current_concurrent_num_parts; ++i){</span>
<span class="lineNum">    2503 </span>                :            : 
<span class="lineNum">    2504 </span>                :<span class="lineNoCov">          0 :                     mj_part_t num_part_in_dim =  num_partitioning_in_current_dim[current_work_part + i];</span>
<span class="lineNum">    2505 </span>                :<span class="lineNoCov">          0 :                     mj_part_t num_cut_in_dim = num_part_in_dim - 1;</span>
<span class="lineNum">    2506 </span>                :<span class="lineNoCov">          0 :                     total_reduction_size += (4 * num_cut_in_dim + 1);</span>
<span class="lineNum">    2507 </span>                :            : 
<span class="lineNum">    2508 </span>                :<span class="lineNoCov">          0 :                     for(mj_part_t ii = 0; ii &lt; num_cut_in_dim; ++ii){</span>
<span class="lineNum">    2509 </span>                :<span class="lineNoCov">          0 :                         this-&gt;is_cut_line_determined[next] = false;</span>
<span class="lineNum">    2510 </span>                :<span class="lineNoCov">          0 :                         this-&gt;cut_lower_bound_coordinates[next] = global_min_max_coord_total_weight[i]; //min coordinate</span>
<span class="lineNum">    2511 </span>                :<span class="lineNoCov">          0 :                         this-&gt;cut_upper_bound_coordinates[next] = global_min_max_coord_total_weight[i + current_concurrent_num_parts]; //max coordinate</span>
<span class="lineNum">    2512 </span>                :            : 
<span class="lineNum">    2513 </span>                :<span class="lineNoCov">          0 :                         this-&gt;cut_upper_bound_weights[next] = global_min_max_coord_total_weight[i + 2 * current_concurrent_num_parts]; //total weight</span>
<span class="lineNum">    2514 </span>                :<span class="lineNoCov">          0 :                         this-&gt;cut_lower_bound_weights[next] = 0;</span>
<span class="lineNum">    2515 </span>                :            : 
<span class="lineNum">    2516 </span>                :<span class="lineNoCov">          0 :                         if(this-&gt;distribute_points_on_cut_lines){</span>
<span class="lineNum">    2517 </span>                :<span class="lineNoCov">          0 :                             this-&gt;process_cut_line_weight_to_put_left[next] = 0;</span>
<span class="lineNum">    2518 </span>                :            :                         }
<span class="lineNum">    2519 </span>                :<span class="lineNoCov">          0 :                         ++next;</span>
<span class="lineNum">    2520 </span>                :            :                     }
<span class="lineNum">    2521 </span>                :            :                 }
<span class="lineNum">    2522 </span>                :            :             }
<span class="lineNum">    2523 </span>                :            : 
<span class="lineNum">    2524 </span>                :            :         //no need to have barrier here.
<span class="lineNum">    2525 </span>                :            :         //pragma omp single have implicit barrier.
<span class="lineNum">    2526 </span>                :            : 
<span class="lineNum">    2527 </span>                :<span class="lineNoCov">          0 :         int iteration = 0;</span>
<span class="lineNum">    2528 </span>                :<span class="lineNoCov">          0 :         while (total_incomplete_cut_count != 0){</span>
<span class="lineNum">    2529 </span>                :<span class="lineNoCov">          0 :             iteration += 1;</span>
<span class="lineNum">    2530 </span>                :            :             //cout &lt;&lt; &quot;\niteration:&quot; &lt;&lt; iteration  &lt;&lt; &quot; &quot;;
<span class="lineNum">    2531 </span>                :<span class="lineNoCov">          0 :             mj_part_t concurrent_cut_shifts = 0;</span>
<span class="lineNum">    2532 </span>                :<span class="lineNoCov">          0 :             size_t total_part_shift = 0;</span>
<span class="lineNum">    2533 </span>                :            : 
<span class="lineNum">    2534 </span>                :<span class="lineNoCov">          0 :             for (mj_part_t kk = 0; kk &lt; current_concurrent_num_parts; ++kk){</span>
<span class="lineNum">    2535 </span>                :<span class="lineNoCov">          0 :                 mj_part_t num_parts =  -1;</span>
<span class="lineNum">    2536 </span>                :<span class="lineNoCov">          0 :                 num_parts =  num_partitioning_in_current_dim[current_work_part + kk];</span>
<span class="lineNum">    2537 </span>                :            : 
<span class="lineNum">    2538 </span>                :<span class="lineNoCov">          0 :                 mj_part_t num_cuts = num_parts - 1;</span>
<span class="lineNum">    2539 </span>                :<span class="lineNoCov">          0 :                 size_t total_part_count = num_parts + size_t (num_cuts) ;</span>
<span class="lineNum">    2540 </span>                :<span class="lineNoCov">          0 :                 if (this-&gt;my_incomplete_cut_count[kk] &gt; 0){</span>
<span class="lineNum">    2541 </span>                :            : 
<span class="lineNum">    2542 </span>                :            :                     //although isDone shared, currentDone is private and same for all.
<span class="lineNum">    2543 </span>                :<span class="lineNoCov">          0 :                     bool *current_cut_status = this-&gt;is_cut_line_determined + concurrent_cut_shifts;</span>
<span class="lineNum">    2544 </span>                :<span class="lineNoCov">          0 :                     double *my_current_part_weights = my_thread_part_weights + total_part_shift;</span>
<span class="lineNum">    2545 </span>                :<span class="lineNoCov">          0 :                     mj_scalar_t *my_current_left_closest = my_thread_left_closest + concurrent_cut_shifts;</span>
<span class="lineNum">    2546 </span>                :<span class="lineNoCov">          0 :                     mj_scalar_t *my_current_right_closest = my_thread_right_closest + concurrent_cut_shifts;</span>
<span class="lineNum">    2547 </span>                :            : 
<span class="lineNum">    2548 </span>                :<span class="lineNoCov">          0 :                     mj_part_t conccurent_current_part = current_work_part + kk;</span>
<span class="lineNum">    2549 </span>                :<span class="lineNoCov">          0 :                     mj_lno_t coordinate_begin_index = conccurent_current_part ==0 ? 0: this-&gt;part_xadj[conccurent_current_part -1];</span>
<span class="lineNum">    2550 </span>                :<span class="lineNoCov">          0 :                     mj_lno_t coordinate_end_index = this-&gt;part_xadj[conccurent_current_part];</span>
<span class="lineNum">    2551 </span>                :<span class="lineNoCov">          0 :                     mj_scalar_t *temp_current_cut_coords = temp_cut_coords + concurrent_cut_shifts;</span>
<span class="lineNum">    2552 </span>                :            : 
<span class="lineNum">    2553 </span>                :<span class="lineNoCov">          0 :                     mj_scalar_t min_coord = global_min_max_coord_total_weight[kk];</span>
<span class="lineNum">    2554 </span>                :<span class="lineNoCov">          0 :                     mj_scalar_t max_coord = global_min_max_coord_total_weight[kk + current_concurrent_num_parts];</span>
<span class="lineNum">    2555 </span>                :            : 
<span class="lineNum">    2556 </span>                :            :                     // compute part weights using existing cuts
<span class="lineNum">    2557 </span>                :<span class="lineNoCov">          0 :                     this-&gt;mj_1D_part_get_thread_part_weights(</span>
<span class="lineNum">    2558 </span>                :            :                         total_part_count,
<span class="lineNum">    2559 </span>                :            :                         num_cuts,
<span class="lineNum">    2560 </span>                :            :                         max_coord,//globalMinMaxTotal[kk + concurrentPartCount],//maxScalar,
<span class="lineNum">    2561 </span>                :            :                         min_coord,//globalMinMaxTotal[kk]//minScalar,
<span class="lineNum">    2562 </span>                :            :                         coordinate_begin_index,
<span class="lineNum">    2563 </span>                :            :                         coordinate_end_index,
<span class="lineNum">    2564 </span>                :            :                         mj_current_dim_coords,
<span class="lineNum">    2565 </span>                :            :                         temp_current_cut_coords,
<span class="lineNum">    2566 </span>                :            :                         current_cut_status,
<span class="lineNum">    2567 </span>                :            :                         my_current_part_weights,
<span class="lineNum">    2568 </span>                :            :                         my_current_left_closest,
<span class="lineNum">    2569 </span>                :            :                         my_current_right_closest);
<span class="lineNum">    2570 </span>                :            : 
<span class="lineNum">    2571 </span>                :            :                 }
<span class="lineNum">    2572 </span>                :            : 
<span class="lineNum">    2573 </span>                :<span class="lineNoCov">          0 :                 concurrent_cut_shifts += num_cuts;</span>
<span class="lineNum">    2574 </span>                :<span class="lineNoCov">          0 :                 total_part_shift += total_part_count;</span>
<span class="lineNum">    2575 </span>                :            :             }
<span class="lineNum">    2576 </span>                :            : 
<span class="lineNum">    2577 </span>                :            :             //sum up the results of threads
<span class="lineNum">    2578 </span>                :<span class="lineNoCov">          0 :             this-&gt;mj_accumulate_thread_results(</span>
<span class="lineNum">    2579 </span>                :            :                 num_partitioning_in_current_dim,
<span class="lineNum">    2580 </span>                :            :                 current_work_part,
<span class="lineNum">    2581 </span>                :            :                 current_concurrent_num_parts);
<span class="lineNum">    2582 </span>                :            : 
<span class="lineNum">    2583 </span>                :            :             //now sum up the results of mpi processors.
<span class="lineNum">    2584 </span>                :            : #ifdef HAVE_ZOLTAN2_OMP
<span class="lineNum">    2585 </span>                :            : #pragma omp single
<span class="lineNum">    2586 </span>                :            : #endif
<span class="lineNum">    2587 </span>                :            :             {
<span class="lineNum">    2588 </span>                :<span class="lineNoCov">          0 :                 if(this-&gt;comm-&gt;getSize() &gt; 1){</span>
<span class="lineNum">    2589 </span>                :<span class="lineNoCov">          0 :                         reduceAll&lt;int, mj_scalar_t&gt;( *(this-&gt;comm), *reductionOp,</span>
<span class="lineNum">    2590 </span>                :            :                                         total_reduction_size,
<span class="lineNum">    2591 </span>                :            :                                         this-&gt;total_part_weight_left_right_closests,
<span class="lineNum">    2592 </span>                :            :                                         this-&gt;global_total_part_weight_left_right_closests);
<span class="lineNum">    2593 </span>                :            : 
<span class="lineNum">    2594 </span>                :            :                 }
<span class="lineNum">    2595 </span>                :            :                 else {
<span class="lineNum">    2596 </span>                :<span class="lineNoCov">          0 :                         memcpy(</span>
<span class="lineNum">    2597 </span>                :            :                                 this-&gt;global_total_part_weight_left_right_closests,
<span class="lineNum">    2598 </span>                :            :                             this-&gt;total_part_weight_left_right_closests,
<span class="lineNum">    2599 </span>                :            :                             total_reduction_size * sizeof(mj_scalar_t));
<span class="lineNum">    2600 </span>                :            :                 }
<span class="lineNum">    2601 </span>                :            :             }
<span class="lineNum">    2602 </span>                :            : 
<span class="lineNum">    2603 </span>                :            :             //how much cut will be shifted for the next part in the concurrent part calculation.
<span class="lineNum">    2604 </span>                :<span class="lineNoCov">          0 :             mj_part_t cut_shift = 0;</span>
<span class="lineNum">    2605 </span>                :            : 
<span class="lineNum">    2606 </span>                :            :             //how much the concantaneted array will be shifted for the next part in concurrent part calculation.
<span class="lineNum">    2607 </span>                :<span class="lineNoCov">          0 :             size_t tlr_shift = 0;</span>
<span class="lineNum">    2608 </span>                :<span class="lineNoCov">          0 :             for (mj_part_t kk = 0; kk &lt; current_concurrent_num_parts; ++kk){</span>
<span class="lineNum">    2609 </span>                :<span class="lineNoCov">          0 :                 mj_part_t num_parts =  num_partitioning_in_current_dim[current_work_part + kk];</span>
<span class="lineNum">    2610 </span>                :<span class="lineNoCov">          0 :                 mj_part_t num_cuts = num_parts - 1;</span>
<span class="lineNum">    2611 </span>                :<span class="lineNoCov">          0 :                 size_t num_total_part = num_parts + size_t (num_cuts) ;</span>
<span class="lineNum">    2612 </span>                :            : 
<span class="lineNum">    2613 </span>                :            :                 //if the cuts of this cut has already been completed.
<span class="lineNum">    2614 </span>                :            :                 //nothing to do for this part.
<span class="lineNum">    2615 </span>                :            :                 //just update the shift amount and proceed.
<span class="lineNum">    2616 </span>                :<span class="lineNoCov">          0 :                 if (this-&gt;my_incomplete_cut_count[kk] == 0) {</span>
<span class="lineNum">    2617 </span>                :<span class="lineNoCov">          0 :                         cut_shift += num_cuts;</span>
<span class="lineNum">    2618 </span>                :<span class="lineNoCov">          0 :                         tlr_shift += (num_total_part + 2 * num_cuts);</span>
<span class="lineNum">    2619 </span>                :<span class="lineNoCov">          0 :                         continue;</span>
<span class="lineNum">    2620 </span>                :            :                 }
<span class="lineNum">    2621 </span>                :            : 
<span class="lineNum">    2622 </span>                :<span class="lineNoCov">          0 :                 mj_scalar_t *current_local_part_weights = this-&gt;total_part_weight_left_right_closests  + tlr_shift ;</span>
<span class="lineNum">    2623 </span>                :<span class="lineNoCov">          0 :                 mj_scalar_t *current_global_tlr = this-&gt;global_total_part_weight_left_right_closests + tlr_shift;</span>
<span class="lineNum">    2624 </span>                :<span class="lineNoCov">          0 :                 mj_scalar_t *current_global_left_closest_points = current_global_tlr + num_total_part; //left closest points</span>
<span class="lineNum">    2625 </span>                :<span class="lineNoCov">          0 :                 mj_scalar_t *current_global_right_closest_points = current_global_tlr + num_total_part + num_cuts; //right closest points</span>
<span class="lineNum">    2626 </span>                :<span class="lineNoCov">          0 :                 mj_scalar_t *current_global_part_weights = current_global_tlr;</span>
<span class="lineNum">    2627 </span>                :<span class="lineNoCov">          0 :                 bool *current_cut_line_determined = this-&gt;is_cut_line_determined + cut_shift;</span>
<span class="lineNum">    2628 </span>                :            : 
<span class="lineNum">    2629 </span>                :<span class="lineNoCov">          0 :                 mj_scalar_t *current_part_target_weights = this-&gt;target_part_weights + cut_shift + kk;</span>
<span class="lineNum">    2630 </span>                :<span class="lineNoCov">          0 :                 mj_scalar_t *current_part_cut_line_weight_to_put_left = this-&gt;process_cut_line_weight_to_put_left + cut_shift;</span>
<span class="lineNum">    2631 </span>                :            : 
<span class="lineNum">    2632 </span>                :<span class="lineNoCov">          0 :                 mj_scalar_t min_coordinate = global_min_max_coord_total_weight[kk];</span>
<span class="lineNum">    2633 </span>                :<span class="lineNoCov">          0 :                 mj_scalar_t max_coordinate = global_min_max_coord_total_weight[kk + current_concurrent_num_parts];</span>
<span class="lineNum">    2634 </span>                :<span class="lineNoCov">          0 :                 mj_scalar_t global_total_weight = global_min_max_coord_total_weight[kk + current_concurrent_num_parts * 2];</span>
<span class="lineNum">    2635 </span>                :<span class="lineNoCov">          0 :                 mj_scalar_t *current_cut_lower_bound_weights = this-&gt;cut_lower_bound_weights + cut_shift;</span>
<span class="lineNum">    2636 </span>                :<span class="lineNoCov">          0 :                 mj_scalar_t *current_cut_upper_weights = this-&gt;cut_upper_bound_weights + cut_shift;</span>
<span class="lineNum">    2637 </span>                :<span class="lineNoCov">          0 :                 mj_scalar_t *current_cut_upper_bounds = this-&gt;cut_upper_bound_coordinates + cut_shift;</span>
<span class="lineNum">    2638 </span>                :<span class="lineNoCov">          0 :                 mj_scalar_t *current_cut_lower_bounds = this-&gt;cut_lower_bound_coordinates + cut_shift;</span>
<span class="lineNum">    2639 </span>                :            : 
<span class="lineNum">    2640 </span>                :<span class="lineNoCov">          0 :                 mj_part_t initial_incomplete_cut_count = this-&gt;my_incomplete_cut_count[kk];</span>
<span class="lineNum">    2641 </span>                :            : 
<span class="lineNum">    2642 </span>                :            :                 // Now compute the new cut coordinates.
<span class="lineNum">    2643 </span>                :<span class="lineNoCov">          0 :                 this-&gt;mj_get_new_cut_coordinates(</span>
<span class="lineNum">    2644 </span>                :            :                                 num_total_part,
<span class="lineNum">    2645 </span>                :            :                                 num_cuts,
<span class="lineNum">    2646 </span>                :            :                                 max_coordinate,
<span class="lineNum">    2647 </span>                :            :                                 min_coordinate,
<span class="lineNum">    2648 </span>                :            :                                 global_total_weight,
<span class="lineNum">    2649 </span>                :            :                                 used_imbalance_tolerance,
<span class="lineNum">    2650 </span>                :            :                                 current_global_part_weights,
<span class="lineNum">    2651 </span>                :            :                                 current_local_part_weights,
<span class="lineNum">    2652 </span>                :            :                                 current_part_target_weights,
<span class="lineNum">    2653 </span>                :            :                                 current_cut_line_determined,
<span class="lineNum">    2654 </span>                :            :                                 temp_cut_coords + cut_shift,
<span class="lineNum">    2655 </span>                :            :                                 current_cut_upper_bounds,
<span class="lineNum">    2656 </span>                :            :                                 current_cut_lower_bounds,
<span class="lineNum">    2657 </span>                :            :                                 current_global_left_closest_points,
<span class="lineNum">    2658 </span>                :            :                                 current_global_right_closest_points,
<span class="lineNum">    2659 </span>                :            :                                 current_cut_lower_bound_weights,
<span class="lineNum">    2660 </span>                :            :                                 current_cut_upper_weights,
<span class="lineNum">    2661 </span>                :<span class="lineNoCov">          0 :                                 this-&gt;cut_coordinates_work_array +cut_shift, //new cut coordinates</span>
<span class="lineNum">    2662 </span>                :            :                                 current_part_cut_line_weight_to_put_left,
<span class="lineNum">    2663 </span>                :            :                                 &amp;rectilinear_cut_count,
<span class="lineNum">    2664 </span>                :<span class="lineNoCov">          0 :                                 this-&gt;my_incomplete_cut_count[kk]);</span>
<span class="lineNum">    2665 </span>                :            : 
<span class="lineNum">    2666 </span>                :<span class="lineNoCov">          0 :                 cut_shift += num_cuts;</span>
<span class="lineNum">    2667 </span>                :<span class="lineNoCov">          0 :                 tlr_shift += (num_total_part + 2 * num_cuts);</span>
<span class="lineNum">    2668 </span>                :<span class="lineNoCov">          0 :                 mj_part_t iteration_complete_cut_count = initial_incomplete_cut_count - this-&gt;my_incomplete_cut_count[kk];</span>
<span class="lineNum">    2669 </span>                :            : #ifdef HAVE_ZOLTAN2_OMP
<span class="lineNum">    2670 </span>                :            : #pragma omp single
<span class="lineNum">    2671 </span>                :            : #endif
<span class="lineNum">    2672 </span>                :            :                 {
<span class="lineNum">    2673 </span>                :<span class="lineNoCov">          0 :                         total_incomplete_cut_count -= iteration_complete_cut_count;</span>
<span class="lineNum">    2674 </span>                :            :                 }
<span class="lineNum">    2675 </span>                :            : 
<span class="lineNum">    2676 </span>                :            :             }
<span class="lineNum">    2677 </span>                :            : #ifdef HAVE_ZOLTAN2_OMP
<span class="lineNum">    2678 </span>                :            : #pragma omp barrier
<span class="lineNum">    2679 </span>                :            : #pragma omp single
<span class="lineNum">    2680 </span>                :            : #endif
<span class="lineNum">    2681 </span>                :            :             {
<span class="lineNum">    2682 </span>                :            :                 //swap the cut coordinates for next iteration.
<span class="lineNum">    2683 </span>                :<span class="lineNoCov">          0 :                 mj_scalar_t *t = temp_cut_coords;</span>
<span class="lineNum">    2684 </span>                :<span class="lineNoCov">          0 :                 temp_cut_coords = this-&gt;cut_coordinates_work_array;</span>
<span class="lineNum">    2685 </span>                :<span class="lineNoCov">          0 :                 this-&gt;cut_coordinates_work_array = t;</span>
<span class="lineNum">    2686 </span>                :            :             }
<span class="lineNum">    2687 </span>                :            :         }
<span class="lineNum">    2688 </span>                :            : 
<span class="lineNum">    2689 </span>                :            :         // Needed only if keep_cuts; otherwise can simply swap array pointers
<span class="lineNum">    2690 </span>                :            :         // cutCoordinates and cutCoordinatesWork.
<span class="lineNum">    2691 </span>                :            :         // (at first iteration, cutCoordinates == cutCoorindates_tmp).
<span class="lineNum">    2692 </span>                :            :         // computed cuts must be in cutCoordinates.
<span class="lineNum">    2693 </span>                :<span class="lineNoCov">          0 :         if (current_cut_coordinates != temp_cut_coords){</span>
<span class="lineNum">    2694 </span>                :            : #ifdef HAVE_ZOLTAN2_OMP
<span class="lineNum">    2695 </span>                :            : #pragma omp single
<span class="lineNum">    2696 </span>                :            : #endif
<span class="lineNum">    2697 </span>                :            :                 {
<span class="lineNum">    2698 </span>                :<span class="lineNoCov">          0 :                         mj_part_t next = 0;</span>
<span class="lineNum">    2699 </span>                :<span class="lineNoCov">          0 :                         for(mj_part_t i = 0; i &lt; current_concurrent_num_parts; ++i){</span>
<span class="lineNum">    2700 </span>                :<span class="lineNoCov">          0 :                                 mj_part_t num_parts = -1;</span>
<span class="lineNum">    2701 </span>                :<span class="lineNoCov">          0 :                                 num_parts = num_partitioning_in_current_dim[current_work_part + i];</span>
<span class="lineNum">    2702 </span>                :<span class="lineNoCov">          0 :                                 mj_part_t num_cuts = num_parts - 1;</span>
<span class="lineNum">    2703 </span>                :            : 
<span class="lineNum">    2704 </span>                :<span class="lineNoCov">          0 :                                 for(mj_part_t ii = 0; ii &lt; num_cuts; ++ii){</span>
<span class="lineNum">    2705 </span>                :<span class="lineNoCov">          0 :                                         current_cut_coordinates[next + ii] = temp_cut_coords[next + ii];</span>
<span class="lineNum">    2706 </span>                :            :                                 }
<span class="lineNum">    2707 </span>                :<span class="lineNoCov">          0 :                                 next += num_cuts;</span>
<span class="lineNum">    2708 </span>                :            :                         }
<span class="lineNum">    2709 </span>                :            :                 }
<span class="lineNum">    2710 </span>                :            : 
<span class="lineNum">    2711 </span>                :            : #ifdef HAVE_ZOLTAN2_OMP
<span class="lineNum">    2712 </span>                :            : #pragma omp single
<span class="lineNum">    2713 </span>                :            : #endif
<span class="lineNum">    2714 </span>                :            :             {
<span class="lineNum">    2715 </span>                :<span class="lineNoCov">          0 :                 this-&gt;cut_coordinates_work_array = temp_cut_coords;</span>
<span class="lineNum">    2716 </span>                :            :             }
<span class="lineNum">    2717 </span>                :            :         }
<span class="lineNum">    2718 </span>                :            :     }
<span class="lineNum">    2719 </span>                :<span class="lineNoCov">          0 :     delete reductionOp;</span>
<span class="lineNum">    2720 </span>                :<span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2721 </span>                :            : 
<span class="lineNum">    2722 </span>                :            : 
<span class="lineNum">    2723 </span>                :            : /*! \brief Function that calculates the weights of each part according to given part cut coordinates.
<span class="lineNum">    2724 </span>                :            :  * Function is called inside the parallel region. Thread specific work arrays are provided
<span class="lineNum">    2725 </span>                :            :  * as function parameter.
<span class="lineNum">    2726 </span>                :            :  *
<span class="lineNum">    2727 </span>                :            :  * \param total_part_count is the sum of number of cutlines and number of parts. Simply it is 2*P - 1.
<span class="lineNum">    2728 </span>                :            :  * \param num_cuts is the number of cut lines. P - 1.
<span class="lineNum">    2729 </span>                :            :  * \param max_coord is the maximum coordinate in the part.
<span class="lineNum">    2730 </span>                :            :  * \param min_coord is the min coordinate in the part.
<span class="lineNum">    2731 </span>                :            :  * \param coordinate_begin_index is the index of the first coordinate in current part.
<span class="lineNum">    2732 </span>                :            :  * \param coordinate_end_index is the index of the last coordinate in current part.
<span class="lineNum">    2733 </span>                :            :  * \param mj_current_dim_coords is 1 dimensional array holding coordinate values.
<span class="lineNum">    2734 </span>                :            :  *
<span class="lineNum">    2735 </span>                :            :  * \param temp_current_cut_coords is the array holding the coordinates of each cut line. Sized P - 1.
<span class="lineNum">    2736 </span>                :            :  * \param current_cut_status is the boolean array to determine if the correct position for a cut line is found.
<span class="lineNum">    2737 </span>                :            :  * \param my_current_part_weights is the array holding the part weights for the calling thread.
<span class="lineNum">    2738 </span>                :            :  * \param my_current_left_closest is the array holding the coordinate of the closest points to the cut lines from left for the calling thread..
<span class="lineNum">    2739 </span>                :            :  * \param my_current_right_closest is the array holding the coordinate of the closest points to the cut lines from right for the calling thread.
<span class="lineNum">    2740 </span>                :            :  * \param partIds is the array that holds the part ids of the coordinates
<span class="lineNum">    2741 </span>                :            :  */
<a name="2742"><span class="lineNum">    2742 </span>                :            : template &lt;typename mj_scalar_t, typename mj_lno_t, typename mj_gno_t,</a>
<span class="lineNum">    2743 </span>                :            :           typename mj_part_t&gt;
<span class="lineNum">    2744 </span>                :<span class="lineNoCov">          0 : void AlgMJ&lt;mj_scalar_t, mj_lno_t, mj_gno_t, mj_part_t&gt;::mj_1D_part_get_thread_part_weights(</span>
<span class="lineNum">    2745 </span>                :            :     size_t total_part_count,
<span class="lineNum">    2746 </span>                :            :     mj_part_t num_cuts,
<span class="lineNum">    2747 </span>                :            :     mj_scalar_t max_coord,
<span class="lineNum">    2748 </span>                :            :     mj_scalar_t min_coord,
<span class="lineNum">    2749 </span>                :            :     mj_lno_t coordinate_begin_index,
<span class="lineNum">    2750 </span>                :            :     mj_lno_t coordinate_end_index,
<span class="lineNum">    2751 </span>                :            :     mj_scalar_t *mj_current_dim_coords,
<span class="lineNum">    2752 </span>                :            :     mj_scalar_t *temp_current_cut_coords,
<span class="lineNum">    2753 </span>                :            :     bool *current_cut_status,
<span class="lineNum">    2754 </span>                :            :     double *my_current_part_weights,
<span class="lineNum">    2755 </span>                :            :     mj_scalar_t *my_current_left_closest,
<span class="lineNum">    2756 </span>                :            :     mj_scalar_t *my_current_right_closest){
<span class="lineNum">    2757 </span>                :            : 
<span class="lineNum">    2758 </span>                :            :         // initializations for part weights, left/right closest
<span class="lineNum">    2759 </span>                :<span class="lineNoCov">          0 :         for (size_t i = 0; i &lt; total_part_count; ++i){</span>
<span class="lineNum">    2760 </span>                :<span class="lineNoCov">          0 :                 my_current_part_weights[i] = 0;</span>
<span class="lineNum">    2761 </span>                :            :         }
<span class="lineNum">    2762 </span>                :            : 
<span class="lineNum">    2763 </span>                :            :         //initialize the left and right closest coordinates
<span class="lineNum">    2764 </span>                :            :         //to their max value.
<span class="lineNum">    2765 </span>                :<span class="lineNoCov">          0 :         for(mj_part_t i = 0; i &lt; num_cuts; ++i){</span>
<span class="lineNum">    2766 </span>                :<span class="lineNoCov">          0 :                 my_current_left_closest[i] = min_coord - 1;</span>
<span class="lineNum">    2767 </span>                :<span class="lineNoCov">          0 :                 my_current_right_closest[i] = max_coord + 1;</span>
<span class="lineNum">    2768 </span>                :            :         }
<span class="lineNum">    2769 </span>                :            :         //mj_lno_t comparison_count = 0;
<span class="lineNum">    2770 </span>                :<span class="lineNoCov">          0 :         mj_scalar_t minus_EPSILON = -this-&gt;sEpsilon;</span>
<span class="lineNum">    2771 </span>                :            : #ifdef HAVE_ZOLTAN2_OMP
<span class="lineNum">    2772 </span>                :            :         //no need for the barrier as all threads uses their local memories.
<span class="lineNum">    2773 </span>                :            :         //dont change the static scheduling here, as it is assumed when the new
<span class="lineNum">    2774 </span>                :            :         //partitions are created later.
<span class="lineNum">    2775 </span>                :            : #pragma omp for
<span class="lineNum">    2776 </span>                :            : #endif
<span class="lineNum">    2777 </span>                :<span class="lineNoCov">          0 :         for (mj_lno_t ii = coordinate_begin_index; ii &lt; coordinate_end_index; ++ii){</span>
<span class="lineNum">    2778 </span>                :<span class="lineNoCov">          0 :                 int i = this-&gt;coordinate_permutations[ii];</span>
<span class="lineNum">    2779 </span>                :            : 
<span class="lineNum">    2780 </span>                :            :                 //the accesses to assigned_part_ids are thread safe
<span class="lineNum">    2781 </span>                :            :                 //since each coordinate is assigned to only a single thread.
<span class="lineNum">    2782 </span>                :<span class="lineNoCov">          0 :                 mj_part_t j = this-&gt;assigned_part_ids[i] / 2;</span>
<span class="lineNum">    2783 </span>                :            : 
<span class="lineNum">    2784 </span>                :<span class="lineNoCov">          0 :                 if(j &gt;= num_cuts){</span>
<span class="lineNum">    2785 </span>                :<span class="lineNoCov">          0 :                         j = num_cuts - 1;</span>
<span class="lineNum">    2786 </span>                :            :                 }
<span class="lineNum">    2787 </span>                :            : 
<span class="lineNum">    2788 </span>                :<span class="lineNoCov">          0 :                 mj_part_t lower_cut_index = 0;</span>
<span class="lineNum">    2789 </span>                :<span class="lineNoCov">          0 :                 mj_part_t upper_cut_index = num_cuts - 1;</span>
<span class="lineNum">    2790 </span>                :            : 
<span class="lineNum">    2791 </span>                :<span class="lineNoCov">          0 :                 mj_scalar_t w = this-&gt;mj_uniform_weights[0]? 1:this-&gt;mj_weights[0][i];</span>
<span class="lineNum">    2792 </span>                :<span class="lineNoCov">          0 :                 bool is_inserted = false;</span>
<span class="lineNum">    2793 </span>                :<span class="lineNoCov">          0 :                 bool is_on_left_of_cut = false;</span>
<span class="lineNum">    2794 </span>                :<span class="lineNoCov">          0 :                 bool is_on_right_of_cut = false;</span>
<span class="lineNum">    2795 </span>                :<span class="lineNoCov">          0 :                 mj_part_t last_compared_part = -1;</span>
<span class="lineNum">    2796 </span>                :            : 
<span class="lineNum">    2797 </span>                :<span class="lineNoCov">          0 :                 mj_scalar_t coord = mj_current_dim_coords[i];</span>
<span class="lineNum">    2798 </span>                :            : 
<span class="lineNum">    2799 </span>                :<span class="lineNoCov">          0 :                 while(upper_cut_index &gt;= lower_cut_index)</span>
<span class="lineNum">    2800 </span>                :            :                 {
<span class="lineNum">    2801 </span>                :            :                         //comparison_count++;
<span class="lineNum">    2802 </span>                :<span class="lineNoCov">          0 :                         last_compared_part = -1;</span>
<span class="lineNum">    2803 </span>                :<span class="lineNoCov">          0 :                         is_on_left_of_cut = false;</span>
<span class="lineNum">    2804 </span>                :<span class="lineNoCov">          0 :                         is_on_right_of_cut = false;</span>
<span class="lineNum">    2805 </span>                :<span class="lineNoCov">          0 :                         mj_scalar_t cut = temp_current_cut_coords[j];</span>
<span class="lineNum">    2806 </span>                :<span class="lineNoCov">          0 :                         mj_scalar_t distance_to_cut = coord - cut;</span>
<span class="lineNum">    2807 </span>                :<span class="lineNoCov">          0 :                         mj_scalar_t abs_distance_to_cut = ZOLTAN2_ABS(distance_to_cut);</span>
<span class="lineNum">    2808 </span>                :            : 
<span class="lineNum">    2809 </span>                :            :                         //if it is on the line.
<span class="lineNum">    2810 </span>                :<span class="lineNoCov">          0 :                         if(abs_distance_to_cut &lt; this-&gt;sEpsilon){</span>
<span class="lineNum">    2811 </span>                :            : 
<span class="lineNum">    2812 </span>                :<span class="lineNoCov">          0 :                                 my_current_part_weights[j * 2 + 1] += w;</span>
<span class="lineNum">    2813 </span>                :<span class="lineNoCov">          0 :                                 this-&gt;assigned_part_ids[i] = j * 2 + 1;</span>
<span class="lineNum">    2814 </span>                :            : 
<span class="lineNum">    2815 </span>                :            :                                 //assign left and right closest point to cut as the point is on the cut.
<span class="lineNum">    2816 </span>                :<span class="lineNoCov">          0 :                                 my_current_left_closest[j] = coord;</span>
<span class="lineNum">    2817 </span>                :<span class="lineNoCov">          0 :                                 my_current_right_closest[j] = coord;</span>
<span class="lineNum">    2818 </span>                :            :                                 //now we need to check if there are other cuts on the same cut coordinate.
<span class="lineNum">    2819 </span>                :            :                                 //if there are, then we add the weight of the cut to all cuts in the same coordinate.
<span class="lineNum">    2820 </span>                :<span class="lineNoCov">          0 :                                 mj_part_t kk = j + 1;</span>
<span class="lineNum">    2821 </span>                :<span class="lineNoCov">          0 :                                 while(kk &lt; num_cuts){</span>
<span class="lineNum">    2822 </span>                :            :                                         // Needed when cuts shared the same position
<span class="lineNum">    2823 </span>                :<span class="lineNoCov">          0 :                                         distance_to_cut =ZOLTAN2_ABS(temp_current_cut_coords[kk] - cut);</span>
<span class="lineNum">    2824 </span>                :<span class="lineNoCov">          0 :                                         if(distance_to_cut &lt; this-&gt;sEpsilon){</span>
<span class="lineNum">    2825 </span>                :<span class="lineNoCov">          0 :                                                 my_current_part_weights[2 * kk + 1] += w;</span>
<span class="lineNum">    2826 </span>                :<span class="lineNoCov">          0 :                                                 my_current_left_closest[kk] = coord;</span>
<span class="lineNum">    2827 </span>                :<span class="lineNoCov">          0 :                                                 my_current_right_closest[kk] = coord;</span>
<span class="lineNum">    2828 </span>                :<span class="lineNoCov">          0 :                                                 kk++;</span>
<span class="lineNum">    2829 </span>                :            :                                         }
<span class="lineNum">    2830 </span>                :            :                                         else{
<span class="lineNum">    2831 </span>                :            :                                                 //cut is far away.
<span class="lineNum">    2832 </span>                :            :                                                 //just check the left closest point for the next cut.
<span class="lineNum">    2833 </span>                :<span class="lineNoCov">          0 :                                                 if(coord - my_current_left_closest[kk] &gt; this-&gt;sEpsilon){</span>
<span class="lineNum">    2834 </span>                :<span class="lineNoCov">          0 :                                                         my_current_left_closest[kk] = coord;</span>
<span class="lineNum">    2835 </span>                :            :                                                 }
<span class="lineNum">    2836 </span>                :<span class="lineNoCov">          0 :                                                 break;</span>
<span class="lineNum">    2837 </span>                :            :                                         }
<span class="lineNum">    2838 </span>                :            :                                 }
<span class="lineNum">    2839 </span>                :            : 
<span class="lineNum">    2840 </span>                :            : 
<span class="lineNum">    2841 </span>                :<span class="lineNoCov">          0 :                                 kk = j - 1;</span>
<span class="lineNum">    2842 </span>                :            :                                 //continue checking for the cuts on the left if they share the same coordinate.
<span class="lineNum">    2843 </span>                :<span class="lineNoCov">          0 :                                 while(kk &gt;= 0){</span>
<span class="lineNum">    2844 </span>                :<span class="lineNoCov">          0 :                                         distance_to_cut =ZOLTAN2_ABS(temp_current_cut_coords[kk] - cut);</span>
<span class="lineNum">    2845 </span>                :<span class="lineNoCov">          0 :                                         if(distance_to_cut &lt; this-&gt;sEpsilon){</span>
<span class="lineNum">    2846 </span>                :<span class="lineNoCov">          0 :                                                 my_current_part_weights[2 * kk + 1] += w;</span>
<span class="lineNum">    2847 </span>                :            :                                                 //try to write the partId as the leftmost cut.
<span class="lineNum">    2848 </span>                :<span class="lineNoCov">          0 :                                                 this-&gt;assigned_part_ids[i] = kk * 2 + 1;</span>
<span class="lineNum">    2849 </span>                :<span class="lineNoCov">          0 :                                                 my_current_left_closest[kk] = coord;</span>
<span class="lineNum">    2850 </span>                :<span class="lineNoCov">          0 :                                                 my_current_right_closest[kk] = coord;</span>
<span class="lineNum">    2851 </span>                :<span class="lineNoCov">          0 :                                                 kk--;</span>
<span class="lineNum">    2852 </span>                :            :                                         }
<span class="lineNum">    2853 </span>                :            :                                         else{
<span class="lineNum">    2854 </span>                :            :                                                 //if cut is far away on the left of the point.
<span class="lineNum">    2855 </span>                :            :                                                 //then just compare for right closest point.
<span class="lineNum">    2856 </span>                :<span class="lineNoCov">          0 :                                                 if(my_current_right_closest[kk] - coord &gt; this-&gt;sEpsilon){</span>
<span class="lineNum">    2857 </span>                :<span class="lineNoCov">          0 :                                                         my_current_right_closest[kk] = coord;</span>
<span class="lineNum">    2858 </span>                :            :                                                 }
<span class="lineNum">    2859 </span>                :<span class="lineNoCov">          0 :                                                 break;</span>
<span class="lineNum">    2860 </span>                :            :                                         }
<span class="lineNum">    2861 </span>                :            :                                 }
<span class="lineNum">    2862 </span>                :            : 
<span class="lineNum">    2863 </span>                :<span class="lineNoCov">          0 :                                 is_inserted = true;</span>
<span class="lineNum">    2864 </span>                :<span class="lineNoCov">          0 :                                 break;</span>
<span class="lineNum">    2865 </span>                :            :                         }
<span class="lineNum">    2866 </span>                :            :                         else {
<span class="lineNum">    2867 </span>                :            :                                 //if point is on the left of the cut.
<span class="lineNum">    2868 </span>                :<span class="lineNoCov">          0 :                                 if (distance_to_cut &lt; 0) {</span>
<span class="lineNum">    2869 </span>                :<span class="lineNoCov">          0 :                                         bool _break = false;</span>
<span class="lineNum">    2870 </span>                :<span class="lineNoCov">          0 :                                         if(j &gt; 0){</span>
<span class="lineNum">    2871 </span>                :            :                                                 //check distance to the cut on the left the current cut compared.
<span class="lineNum">    2872 </span>                :            :                                                 //if point is on the right, then we find the part of the point.
<span class="lineNum">    2873 </span>                :<span class="lineNoCov">          0 :                                                 mj_scalar_t distance_to_next_cut = coord - temp_current_cut_coords[j - 1];</span>
<span class="lineNum">    2874 </span>                :<span class="lineNoCov">          0 :                                                 if(distance_to_next_cut &gt; this-&gt;sEpsilon){</span>
<span class="lineNum">    2875 </span>                :<span class="lineNoCov">          0 :                                                         _break = true;</span>
<span class="lineNum">    2876 </span>                :            :                                                 }
<span class="lineNum">    2877 </span>                :            :                                         }
<span class="lineNum">    2878 </span>                :            :                                         //if point is not on the right of the next cut, then
<span class="lineNum">    2879 </span>                :            :                                         //set the upper bound to this cut.
<span class="lineNum">    2880 </span>                :<span class="lineNoCov">          0 :                                         upper_cut_index = j - 1;</span>
<span class="lineNum">    2881 </span>                :            :                                         //set the last part, and mark it as on the left of the last part.
<span class="lineNum">    2882 </span>                :<span class="lineNoCov">          0 :                                         is_on_left_of_cut = true;</span>
<span class="lineNum">    2883 </span>                :<span class="lineNoCov">          0 :                                         last_compared_part = j;</span>
<span class="lineNum">    2884 </span>                :<span class="lineNoCov">          0 :                                         if(_break) break;</span>
<span class="lineNum">    2885 </span>                :            :                                 }
<span class="lineNum">    2886 </span>                :            :                                 else {
<span class="lineNum">    2887 </span>                :            :                                         //if point is on the right of the cut.
<span class="lineNum">    2888 </span>                :<span class="lineNoCov">          0 :                                         bool _break = false;</span>
<span class="lineNum">    2889 </span>                :<span class="lineNoCov">          0 :                                         if(j &lt; num_cuts - 1){</span>
<span class="lineNum">    2890 </span>                :            :                                                 //check distance to the cut on the left the current cut compared.
<span class="lineNum">    2891 </span>                :            :                                                 //if point is on the right, then we find the part of the point.
<span class="lineNum">    2892 </span>                :<span class="lineNoCov">          0 :                                                 mj_scalar_t distance_to_next_cut = coord - temp_current_cut_coords[j + 1];</span>
<span class="lineNum">    2893 </span>                :<span class="lineNoCov">          0 :                                                 if(distance_to_next_cut &lt; minus_EPSILON){</span>
<span class="lineNum">    2894 </span>                :<span class="lineNoCov">          0 :                          _break = true;</span>
<span class="lineNum">    2895 </span>                :            :                      }
<span class="lineNum">    2896 </span>                :            :                                         }
<span class="lineNum">    2897 </span>                :            : 
<span class="lineNum">    2898 </span>                :            :                                         //if point is not on the left of the next cut, then
<span class="lineNum">    2899 </span>                :            :                                         //set the upper bound to this cut.
<span class="lineNum">    2900 </span>                :<span class="lineNoCov">          0 :                                         lower_cut_index = j + 1;</span>
<span class="lineNum">    2901 </span>                :            :                                         //set the last part, and mark it as on the right of the last part.
<span class="lineNum">    2902 </span>                :<span class="lineNoCov">          0 :                                         is_on_right_of_cut = true;</span>
<span class="lineNum">    2903 </span>                :<span class="lineNoCov">          0 :                                         last_compared_part = j;</span>
<span class="lineNum">    2904 </span>                :<span class="lineNoCov">          0 :                                         if(_break) break;</span>
<span class="lineNum">    2905 </span>                :            :                                 }
<span class="lineNum">    2906 </span>                :            :                         }
<span class="lineNum">    2907 </span>                :            : 
<span class="lineNum">    2908 </span>                :<span class="lineNoCov">          0 :                         j = (upper_cut_index + lower_cut_index) / 2;</span>
<span class="lineNum">    2909 </span>                :            :                 }
<span class="lineNum">    2910 </span>                :<span class="lineNoCov">          0 :                 if(!is_inserted){</span>
<span class="lineNum">    2911 </span>                :<span class="lineNoCov">          0 :                         if(is_on_right_of_cut){</span>
<span class="lineNum">    2912 </span>                :            : 
<span class="lineNum">    2913 </span>                :            :                                 //add it to the right of the last compared part.
<span class="lineNum">    2914 </span>                :<span class="lineNoCov">          0 :                                 my_current_part_weights[2 * last_compared_part + 2] += w;</span>
<span class="lineNum">    2915 </span>                :<span class="lineNoCov">          0 :                                 this-&gt;assigned_part_ids[i] = 2 * last_compared_part + 2;</span>
<span class="lineNum">    2916 </span>                :            : 
<span class="lineNum">    2917 </span>                :            :                                 //update the right closest point of last compared cut.
<span class="lineNum">    2918 </span>                :<span class="lineNoCov">          0 :                                 if(my_current_right_closest[last_compared_part] - coord &gt; this-&gt;sEpsilon){</span>
<span class="lineNum">    2919 </span>                :<span class="lineNoCov">          0 :                                         my_current_right_closest[last_compared_part] = coord;</span>
<span class="lineNum">    2920 </span>                :            :                                 }
<span class="lineNum">    2921 </span>                :            :                                 //update the left closest point of the cut on the right of the last compared cut.
<span class="lineNum">    2922 </span>                :<span class="lineNoCov">          0 :                                 if(last_compared_part+1 &lt; num_cuts){</span>
<span class="lineNum">    2923 </span>                :            : 
<span class="lineNum">    2924 </span>                :<span class="lineNoCov">          0 :                                         if(coord - my_current_left_closest[last_compared_part + 1] &gt; this-&gt;sEpsilon){</span>
<span class="lineNum">    2925 </span>                :<span class="lineNoCov">          0 :                                                 my_current_left_closest[last_compared_part + 1] = coord;</span>
<span class="lineNum">    2926 </span>                :            :                                         }
<span class="lineNum">    2927 </span>                :            :                                 }
<span class="lineNum">    2928 </span>                :            : 
<span class="lineNum">    2929 </span>                :            :                         }
<span class="lineNum">    2930 </span>                :<span class="lineNoCov">          0 :                         else if(is_on_left_of_cut){</span>
<span class="lineNum">    2931 </span>                :            : 
<span class="lineNum">    2932 </span>                :            :                                 //add it to the left of the last compared part.
<span class="lineNum">    2933 </span>                :<span class="lineNoCov">          0 :                                 my_current_part_weights[2 * last_compared_part] += w;</span>
<span class="lineNum">    2934 </span>                :<span class="lineNoCov">          0 :                                 this-&gt;assigned_part_ids[i] = 2 * last_compared_part;</span>
<span class="lineNum">    2935 </span>                :            : 
<span class="lineNum">    2936 </span>                :            : 
<span class="lineNum">    2937 </span>                :            :                                 //update the left closest point of last compared cut.
<span class="lineNum">    2938 </span>                :<span class="lineNoCov">          0 :                                 if(coord - my_current_left_closest[last_compared_part] &gt; this-&gt;sEpsilon){</span>
<span class="lineNum">    2939 </span>                :<span class="lineNoCov">          0 :                                         my_current_left_closest[last_compared_part] = coord;</span>
<span class="lineNum">    2940 </span>                :            :                                 }
<span class="lineNum">    2941 </span>                :            : 
<span class="lineNum">    2942 </span>                :            :                                 //update the right closest point of the cut on the left of the last compared cut.
<span class="lineNum">    2943 </span>                :<span class="lineNoCov">          0 :                                 if(last_compared_part-1 &gt;= 0){</span>
<span class="lineNum">    2944 </span>                :<span class="lineNoCov">          0 :                                         if(my_current_right_closest[last_compared_part -1] - coord &gt; this-&gt;sEpsilon){</span>
<span class="lineNum">    2945 </span>                :<span class="lineNoCov">          0 :                                                 my_current_right_closest[last_compared_part -1] = coord;</span>
<span class="lineNum">    2946 </span>                :            :                                         }
<span class="lineNum">    2947 </span>                :            :                                 }
<span class="lineNum">    2948 </span>                :            :                         }
<span class="lineNum">    2949 </span>                :            :                 }
<span class="lineNum">    2950 </span>                :            :         }
<span class="lineNum">    2951 </span>                :            : 
<span class="lineNum">    2952 </span>                :            :         // prefix sum computation.
<span class="lineNum">    2953 </span>                :            :         //we need prefix sum for each part to determine cut positions.
<span class="lineNum">    2954 </span>                :<span class="lineNoCov">          0 :         for (size_t i = 1; i &lt; total_part_count; ++i){</span>
<span class="lineNum">    2955 </span>                :            :                 // check for cuts sharing the same position; all cuts sharing a position
<span class="lineNum">    2956 </span>                :            :                 // have the same weight == total weight for all cuts sharing the position.
<span class="lineNum">    2957 </span>                :            :                 // don't want to accumulate that total weight more than once.
<span class="lineNum">    2958 </span>                :<span class="lineNoCov">          0 :                 if(i % 2 == 0 &amp;&amp; i &gt; 1 &amp;&amp; i &lt; total_part_count - 1 &amp;&amp;</span>
<span class="lineNum">    2959 </span>                :<span class="lineNoCov">          0 :                                 ZOLTAN2_ABS(temp_current_cut_coords[i / 2] - temp_current_cut_coords[i /2 - 1])</span>
<span class="lineNum">    2960 </span>                :<span class="lineNoCov">          0 :                 &lt; this-&gt;sEpsilon){</span>
<span class="lineNum">    2961 </span>                :            :                         //i % 2 = 0 when part i represents the cut coordinate.
<span class="lineNum">    2962 </span>                :            :                         //if it is a cut, and if the next cut also have the same coordinate, then
<span class="lineNum">    2963 </span>                :            :                         //dont addup.
<span class="lineNum">    2964 </span>                :<span class="lineNoCov">          0 :                         my_current_part_weights[i] = my_current_part_weights[i-2];</span>
<span class="lineNum">    2965 </span>                :<span class="lineNoCov">          0 :                         continue;</span>
<span class="lineNum">    2966 </span>                :            :                 }
<span class="lineNum">    2967 </span>                :            :                 //otherwise do the prefix sum.
<span class="lineNum">    2968 </span>                :<span class="lineNoCov">          0 :                 my_current_part_weights[i] += my_current_part_weights[i-1];</span>
<span class="lineNum">    2969 </span>                :            :         }
<span class="lineNum">    2970 </span>                :<span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2971 </span>                :            : 
<span class="lineNum">    2972 </span>                :            : 
<span class="lineNum">    2973 </span>                :            : /*! \brief Function that reduces the result of multiple threads
<span class="lineNum">    2974 </span>                :            :  * for left and right closest points and part weights in a single mpi process.
<span class="lineNum">    2975 </span>                :            :  *
<span class="lineNum">    2976 </span>                :            :  * \param num_partitioning_in_current_dim is the vector that holds the number of cut lines in current dimension for each part.
<span class="lineNum">    2977 </span>                :            :  * \param current_work_part holds the index of the first part (important when concurrent parts are used.)
<span class="lineNum">    2978 </span>                :            :  * \param current_concurrent_num_parts is the number of parts whose cut lines will be calculated concurrently.
<span class="lineNum">    2979 </span>                :            :  */
<a name="2980"><span class="lineNum">    2980 </span>                :            : template &lt;typename mj_scalar_t, typename mj_lno_t, typename mj_gno_t,</a>
<span class="lineNum">    2981 </span>                :            :           typename mj_part_t&gt;
<span class="lineNum">    2982 </span>                :<span class="lineNoCov">          0 : void AlgMJ&lt;mj_scalar_t, mj_lno_t, mj_gno_t, mj_part_t&gt;::mj_accumulate_thread_results(</span>
<span class="lineNum">    2983 </span>                :            :     const std::vector &lt;mj_part_t&gt; &amp;num_partitioning_in_current_dim,
<span class="lineNum">    2984 </span>                :            :     mj_part_t current_work_part,
<span class="lineNum">    2985 </span>                :            :     mj_part_t current_concurrent_num_parts){
<span class="lineNum">    2986 </span>                :            : 
<span class="lineNum">    2987 </span>                :            : #ifdef HAVE_ZOLTAN2_OMP
<span class="lineNum">    2988 </span>                :            :         //needs barrier here, as it requires all threads to finish mj_1D_part_get_thread_part_weights
<span class="lineNum">    2989 </span>                :            :         //using parallel region here reduces the performance because of the cache invalidates.
<span class="lineNum">    2990 </span>                :            : #pragma omp barrier
<span class="lineNum">    2991 </span>                :            : #pragma omp single
<span class="lineNum">    2992 </span>                :            : #endif
<span class="lineNum">    2993 </span>                :            :         {
<span class="lineNum">    2994 </span>                :<span class="lineNoCov">          0 :                 size_t tlr_array_shift = 0;</span>
<span class="lineNum">    2995 </span>                :<span class="lineNoCov">          0 :                 mj_part_t cut_shift = 0;</span>
<span class="lineNum">    2996 </span>                :            : 
<span class="lineNum">    2997 </span>                :            :                 //iterate for all concurrent parts to find the left and right closest points in the process.
<span class="lineNum">    2998 </span>                :<span class="lineNoCov">          0 :                 for(mj_part_t i = 0; i &lt; current_concurrent_num_parts; ++i){</span>
<span class="lineNum">    2999 </span>                :            : 
<span class="lineNum">    3000 </span>                :<span class="lineNoCov">          0 :                         mj_part_t num_parts_in_part =  num_partitioning_in_current_dim[current_work_part + i];</span>
<span class="lineNum">    3001 </span>                :<span class="lineNoCov">          0 :                         mj_part_t num_cuts_in_part = num_parts_in_part - 1;</span>
<span class="lineNum">    3002 </span>                :<span class="lineNoCov">          0 :                         size_t num_total_part_in_part = num_parts_in_part + size_t (num_cuts_in_part) ;</span>
<span class="lineNum">    3003 </span>                :            : 
<span class="lineNum">    3004 </span>                :            :                         //iterate for cuts in a single part.
<span class="lineNum">    3005 </span>                :<span class="lineNoCov">          0 :                         for(mj_part_t ii = 0; ii &lt; num_cuts_in_part ; ++ii){</span>
<span class="lineNum">    3006 </span>                :<span class="lineNoCov">          0 :                                 mj_part_t next = tlr_array_shift + ii;</span>
<span class="lineNum">    3007 </span>                :<span class="lineNoCov">          0 :                                 mj_part_t cut_index = cut_shift + ii;</span>
<span class="lineNum">    3008 </span>                :<span class="lineNoCov">          0 :                                 if(this-&gt;is_cut_line_determined[cut_index]) continue;</span>
<span class="lineNum">    3009 </span>                :<span class="lineNoCov">          0 :                                 mj_scalar_t left_closest_in_process = this-&gt;thread_cut_left_closest_point[0][cut_index],</span>
<span class="lineNum">    3010 </span>                :<span class="lineNoCov">          0 :                                                 right_closest_in_process = this-&gt;thread_cut_right_closest_point[0][cut_index];</span>
<span class="lineNum">    3011 </span>                :            : 
<span class="lineNum">    3012 </span>                :            :                                 //find the closest points from left and right for the cut in the process.
<span class="lineNum">    3013 </span>                :<span class="lineNoCov">          0 :                                 for (int j = 1; j &lt; this-&gt;num_threads; ++j){</span>
<span class="lineNum">    3014 </span>                :<span class="lineNoCov">          0 :                                         if (this-&gt;thread_cut_right_closest_point[j][cut_index] &lt; right_closest_in_process ){</span>
<span class="lineNum">    3015 </span>                :<span class="lineNoCov">          0 :                                                 right_closest_in_process = this-&gt;thread_cut_right_closest_point[j][cut_index];</span>
<span class="lineNum">    3016 </span>                :            :                                         }
<span class="lineNum">    3017 </span>                :<span class="lineNoCov">          0 :                                         if (this-&gt;thread_cut_left_closest_point[j][cut_index] &gt; left_closest_in_process ){</span>
<span class="lineNum">    3018 </span>                :<span class="lineNoCov">          0 :                                                 left_closest_in_process = this-&gt;thread_cut_left_closest_point[j][cut_index];</span>
<span class="lineNum">    3019 </span>                :            :                                         }
<span class="lineNum">    3020 </span>                :            :                                 }
<span class="lineNum">    3021 </span>                :            :                                 //store the left and right closes points.
<span class="lineNum">    3022 </span>                :<span class="lineNoCov">          0 :                                 this-&gt;total_part_weight_left_right_closests[num_total_part_in_part +</span>
<span class="lineNum">    3023 </span>                :            :                                                                             next] = left_closest_in_process;
<span class="lineNum">    3024 </span>                :<span class="lineNoCov">          0 :                                 this-&gt;total_part_weight_left_right_closests[num_total_part_in_part +</span>
<span class="lineNum">    3025 </span>                :            :                                                                             num_cuts_in_part + next] = right_closest_in_process;
<span class="lineNum">    3026 </span>                :            :                         }
<span class="lineNum">    3027 </span>                :            :                         //set the shift position in the arrays
<span class="lineNum">    3028 </span>                :<span class="lineNoCov">          0 :                         tlr_array_shift += (num_total_part_in_part + 2 * num_cuts_in_part);</span>
<span class="lineNum">    3029 </span>                :<span class="lineNoCov">          0 :                         cut_shift += num_cuts_in_part;</span>
<span class="lineNum">    3030 </span>                :            :                 }
<span class="lineNum">    3031 </span>                :            : 
<span class="lineNum">    3032 </span>                :<span class="lineNoCov">          0 :                 tlr_array_shift = 0;</span>
<span class="lineNum">    3033 </span>                :<span class="lineNoCov">          0 :                 cut_shift = 0;</span>
<span class="lineNum">    3034 </span>                :<span class="lineNoCov">          0 :                 size_t total_part_array_shift = 0;</span>
<span class="lineNum">    3035 </span>                :            : 
<span class="lineNum">    3036 </span>                :            :                 //iterate for all concurrent parts to find the total weight in the process.
<span class="lineNum">    3037 </span>                :<span class="lineNoCov">          0 :                 for(mj_part_t i = 0; i &lt; current_concurrent_num_parts; ++i){</span>
<span class="lineNum">    3038 </span>                :            : 
<span class="lineNum">    3039 </span>                :<span class="lineNoCov">          0 :                         mj_part_t num_parts_in_part =  num_partitioning_in_current_dim[current_work_part + i];</span>
<span class="lineNum">    3040 </span>                :<span class="lineNoCov">          0 :                         mj_part_t num_cuts_in_part = num_parts_in_part - 1;</span>
<span class="lineNum">    3041 </span>                :<span class="lineNoCov">          0 :                         size_t num_total_part_in_part = num_parts_in_part + size_t (num_cuts_in_part) ;</span>
<span class="lineNum">    3042 </span>                :            : 
<span class="lineNum">    3043 </span>                :<span class="lineNoCov">          0 :                         for(size_t j = 0; j &lt; num_total_part_in_part; ++j){</span>
<span class="lineNum">    3044 </span>                :            : 
<span class="lineNum">    3045 </span>                :<span class="lineNoCov">          0 :                                 mj_part_t cut_ind = j / 2 + cut_shift;</span>
<span class="lineNum">    3046 </span>                :            : 
<span class="lineNum">    3047 </span>                :            :                                 //need to check j !=  num_total_part_in_part - 1
<span class="lineNum">    3048 </span>                :            :                                                 // which is same as j/2 != num_cuts_in_part.
<span class="lineNum">    3049 </span>                :            :                                 //we cannot check it using cut_ind, because of the concurrent part concantanetion.
<span class="lineNum">    3050 </span>                :<span class="lineNoCov">          0 :                                 if(j !=  num_total_part_in_part - 1 &amp;&amp; this-&gt;is_cut_line_determined[cut_ind]) continue;</span>
<span class="lineNum">    3051 </span>                :<span class="lineNoCov">          0 :                                 double pwj = 0;</span>
<span class="lineNum">    3052 </span>                :<span class="lineNoCov">          0 :                                 for (int k = 0; k &lt; this-&gt;num_threads; ++k){</span>
<span class="lineNum">    3053 </span>                :<span class="lineNoCov">          0 :                                         pwj += this-&gt;thread_part_weights[k][total_part_array_shift + j];</span>
<span class="lineNum">    3054 </span>                :            :                                 }
<span class="lineNum">    3055 </span>                :            :                                 //size_t jshift = j % total_part_count + i * (total_part_count + 2 * noCuts);
<span class="lineNum">    3056 </span>                :<span class="lineNoCov">          0 :                                 this-&gt;total_part_weight_left_right_closests[tlr_array_shift + j] = pwj;</span>
<span class="lineNum">    3057 </span>                :            :                         }
<span class="lineNum">    3058 </span>                :<span class="lineNoCov">          0 :                         cut_shift += num_cuts_in_part;</span>
<span class="lineNum">    3059 </span>                :<span class="lineNoCov">          0 :                         tlr_array_shift += num_total_part_in_part + 2 * num_cuts_in_part;</span>
<span class="lineNum">    3060 </span>                :<span class="lineNoCov">          0 :                         total_part_array_shift += num_total_part_in_part;</span>
<span class="lineNum">    3061 </span>                :            :                 }
<span class="lineNum">    3062 </span>                :            :         }
<span class="lineNum">    3063 </span>                :            :         //the other threads needs to wait here.
<span class="lineNum">    3064 </span>                :            :         //but we don't need a pragma omp barrier.
<span class="lineNum">    3065 </span>                :            :         //as omp single has already have implicit barrier.
<span class="lineNum">    3066 </span>                :<span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3067 </span>                :            : 
<span class="lineNum">    3068 </span>                :            : 
<span class="lineNum">    3069 </span>                :            : /*! \brief
<span class="lineNum">    3070 </span>                :            :  * Function that calculates the next pivot position,
<span class="lineNum">    3071 </span>                :            :  * according to given coordinates of upper bound and lower bound, the weights at upper and lower bounds, and the expected weight.
<span class="lineNum">    3072 </span>                :            :  * \param cut_upper_bound is the upper bound coordinate of the cut.
<span class="lineNum">    3073 </span>                :            :  * \param cut_lower_bound is the lower bound coordinate of the cut.
<span class="lineNum">    3074 </span>                :            :  * \param cut_upper_weight is the weights at the upper bound of the cut.
<span class="lineNum">    3075 </span>                :            :  * \param cut_lower_weight is the weights at the lower bound of the cut.
<span class="lineNum">    3076 </span>                :            :  * \param expected_weight is the expected weight that should be placed on the left of the cut line.
<span class="lineNum">    3077 </span>                :            :  */
<a name="3078"><span class="lineNum">    3078 </span>                :            : template &lt;typename mj_scalar_t, typename mj_lno_t, typename mj_gno_t,</a>
<span class="lineNum">    3079 </span>                :            :           typename mj_part_t&gt;
<span class="lineNum">    3080 </span>                :<span class="lineNoCov">          0 : void AlgMJ&lt;mj_scalar_t, mj_lno_t, mj_gno_t, mj_part_t&gt;::mj_calculate_new_cut_position (</span>
<span class="lineNum">    3081 </span>                :            :         mj_scalar_t cut_upper_bound,
<span class="lineNum">    3082 </span>                :            :     mj_scalar_t cut_lower_bound,
<span class="lineNum">    3083 </span>                :            :     mj_scalar_t cut_upper_weight,
<span class="lineNum">    3084 </span>                :            :     mj_scalar_t cut_lower_weight,
<span class="lineNum">    3085 </span>                :            :     mj_scalar_t expected_weight,
<span class="lineNum">    3086 </span>                :            :     mj_scalar_t &amp;new_cut_position){
<span class="lineNum">    3087 </span>                :            : 
<span class="lineNum">    3088 </span>                :<span class="lineNoCov">          0 :     if(ZOLTAN2_ABS(cut_upper_bound - cut_lower_bound) &lt; this-&gt;sEpsilon){</span>
<span class="lineNum">    3089 </span>                :<span class="lineNoCov">          0 :         new_cut_position = cut_upper_bound; //or lower bound does not matter.</span>
<span class="lineNum">    3090 </span>                :            :     }
<span class="lineNum">    3091 </span>                :            : 
<span class="lineNum">    3092 </span>                :            : 
<span class="lineNum">    3093 </span>                :<span class="lineNoCov">          0 :     if(ZOLTAN2_ABS(cut_upper_weight - cut_lower_weight) &lt; this-&gt;sEpsilon){</span>
<span class="lineNum">    3094 </span>                :<span class="lineNoCov">          0 :         new_cut_position = cut_lower_bound;</span>
<span class="lineNum">    3095 </span>                :            :     }
<span class="lineNum">    3096 </span>                :            : 
<span class="lineNum">    3097 </span>                :<span class="lineNoCov">          0 :     mj_scalar_t coordinate_range = (cut_upper_bound - cut_lower_bound);</span>
<span class="lineNum">    3098 </span>                :<span class="lineNoCov">          0 :     mj_scalar_t weight_range = (cut_upper_weight - cut_lower_weight);</span>
<span class="lineNum">    3099 </span>                :<span class="lineNoCov">          0 :     mj_scalar_t my_weight_diff = (expected_weight - cut_lower_weight);</span>
<span class="lineNum">    3100 </span>                :            : 
<span class="lineNum">    3101 </span>                :<span class="lineNoCov">          0 :     mj_scalar_t required_shift = (my_weight_diff / weight_range);</span>
<span class="lineNum">    3102 </span>                :<span class="lineNoCov">          0 :     int scale_constant = 20;</span>
<span class="lineNum">    3103 </span>                :<span class="lineNoCov">          0 :     int shiftint= int (required_shift * scale_constant);</span>
<span class="lineNum">    3104 </span>                :<span class="lineNoCov">          0 :     if (shiftint == 0) shiftint = 1;</span>
<span class="lineNum">    3105 </span>                :<span class="lineNoCov">          0 :     required_shift = mj_scalar_t (shiftint) / scale_constant;</span>
<span class="lineNum">    3106 </span>                :<span class="lineNoCov">          0 :     new_cut_position = coordinate_range * required_shift + cut_lower_bound;</span>
<span class="lineNum">    3107 </span>                :<span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3108 </span>                :            : 
<span class="lineNum">    3109 </span>                :            : 
<span class="lineNum">    3110 </span>                :            : /*! \brief Function that determines the permutation indices of the coordinates.
<span class="lineNum">    3111 </span>                :            :  * \param num_parts is the number of parts.
<span class="lineNum">    3112 </span>                :            :  * \param mj_current_dim_coords is 1 dimensional array holding the coordinate values.
<span class="lineNum">    3113 </span>                :            :  * \param current_concurrent_cut_coordinate is 1 dimensional array holding the cut coordinates.
<span class="lineNum">    3114 </span>                :            :  * \param coordinate_begin is the start index of the given partition on partitionedPointPermutations.
<span class="lineNum">    3115 </span>                :            :  * \param coordinate_end is the end index of the given partition on partitionedPointPermutations.
<span class="lineNum">    3116 </span>                :            :  * \param used_local_cut_line_weight_to_left holds how much weight of the coordinates on the cutline should be put on left side.
<span class="lineNum">    3117 </span>                :            :  * \param used_thread_part_weight_work is the two dimensional array holding the weight of parts for each thread. Assumes there are 2*P - 1 parts (cut lines are seperate parts).
<span class="lineNum">    3118 </span>                :            :  * \param out_part_xadj is the indices of coordinates calculated for the partition on next dimension.
<span class="lineNum">    3119 </span>                :            :  */
<a name="3120"><span class="lineNum">    3120 </span>                :            : template &lt;typename mj_scalar_t, typename mj_lno_t, typename mj_gno_t,</a>
<span class="lineNum">    3121 </span>                :            :           typename mj_part_t&gt;
<span class="lineNum">    3122 </span>                :<span class="lineNoCov">          0 : void AlgMJ&lt;mj_scalar_t, mj_lno_t, mj_gno_t, mj_part_t&gt;::mj_create_new_partitions(</span>
<span class="lineNum">    3123 </span>                :            :     mj_part_t num_parts,
<span class="lineNum">    3124 </span>                :            :     mj_scalar_t *mj_current_dim_coords,
<span class="lineNum">    3125 </span>                :            :     mj_scalar_t *current_concurrent_cut_coordinate,
<span class="lineNum">    3126 </span>                :            :     mj_lno_t coordinate_begin,
<span class="lineNum">    3127 </span>                :            :     mj_lno_t coordinate_end,
<span class="lineNum">    3128 </span>                :            :     mj_scalar_t *used_local_cut_line_weight_to_left,
<span class="lineNum">    3129 </span>                :            :     double **used_thread_part_weight_work,
<span class="lineNum">    3130 </span>                :            :     mj_lno_t *out_part_xadj){
<span class="lineNum">    3131 </span>                :            : 
<span class="lineNum">    3132 </span>                :<span class="lineNoCov">          0 :         mj_part_t num_cuts = num_parts - 1;</span>
<span class="lineNum">    3133 </span>                :            : 
<span class="lineNum">    3134 </span>                :            : #ifdef HAVE_ZOLTAN2_OMP
<span class="lineNum">    3135 </span>                :            : #pragma omp parallel
<span class="lineNum">    3136 </span>                :            : #endif
<span class="lineNum">    3137 </span>                :            :         {
<span class="lineNum">    3138 </span>                :<span class="lineNoCov">          0 :                 int me = 0;</span>
<span class="lineNum">    3139 </span>                :            : #ifdef HAVE_ZOLTAN2_OMP
<span class="lineNum">    3140 </span>                :            :                 me = omp_get_thread_num();
<span class="lineNum">    3141 </span>                :            : #endif
<span class="lineNum">    3142 </span>                :            : 
<span class="lineNum">    3143 </span>                :<span class="lineNoCov">          0 :                 mj_lno_t *thread_num_points_in_parts = this-&gt;thread_point_counts[me];</span>
<span class="lineNum">    3144 </span>                :<span class="lineNoCov">          0 :                 mj_scalar_t *my_local_thread_cut_weights_to_put_left = NULL;</span>
<span class="lineNum">    3145 </span>                :            : 
<span class="lineNum">    3146 </span>                :            :                 //now if the rectilinear partitioning is allowed we decide how
<span class="lineNum">    3147 </span>                :            :                 //much weight each thread should put to left and right.
<span class="lineNum">    3148 </span>                :<span class="lineNoCov">          0 :                 if (this-&gt;distribute_points_on_cut_lines){</span>
<span class="lineNum">    3149 </span>                :<span class="lineNoCov">          0 :                         my_local_thread_cut_weights_to_put_left = this-&gt;thread_cut_line_weight_to_put_left[me];</span>
<span class="lineNum">    3150 </span>                :            :                         // this for assumes the static scheduling in mj_1D_part calculation.
<span class="lineNum">    3151 </span>                :            : #ifdef HAVE_ZOLTAN2_OMP
<span class="lineNum">    3152 </span>                :            : #pragma omp for
<span class="lineNum">    3153 </span>                :            : #endif
<span class="lineNum">    3154 </span>                :<span class="lineNoCov">          0 :                         for (mj_part_t i = 0; i &lt; num_cuts; ++i){</span>
<span class="lineNum">    3155 </span>                :            :                                 //the left to be put on the left of the cut.
<span class="lineNum">    3156 </span>                :<span class="lineNoCov">          0 :                                 mj_scalar_t left_weight = used_local_cut_line_weight_to_left[i];</span>
<span class="lineNum">    3157 </span>                :<span class="lineNoCov">          0 :                                 for(int ii = 0; ii &lt; this-&gt;num_threads; ++ii){</span>
<span class="lineNum">    3158 </span>                :<span class="lineNoCov">          0 :                                         if(left_weight &gt; this-&gt;sEpsilon){</span>
<span class="lineNum">    3159 </span>                :            :                                                 //the weight of thread ii on cut.
<span class="lineNum">    3160 </span>                :<span class="lineNoCov">          0 :                                                 mj_scalar_t thread_ii_weight_on_cut = used_thread_part_weight_work[ii][i * 2 + 1] - used_thread_part_weight_work[ii][i * 2 ];</span>
<span class="lineNum">    3161 </span>                :<span class="lineNoCov">          0 :                                                 if(thread_ii_weight_on_cut &lt; left_weight){</span>
<span class="lineNum">    3162 </span>                :            :                                                         //if left weight is bigger than threads weight on cut.
<span class="lineNum">    3163 </span>                :<span class="lineNoCov">          0 :                                                         this-&gt;thread_cut_line_weight_to_put_left[ii][i] = thread_ii_weight_on_cut;</span>
<span class="lineNum">    3164 </span>                :            :                                                 }
<span class="lineNum">    3165 </span>                :            :                                                 else {
<span class="lineNum">    3166 </span>                :            :                                                         //if thread's weight is bigger than space, then put only a portion.
<span class="lineNum">    3167 </span>                :<span class="lineNoCov">          0 :                                                         this-&gt;thread_cut_line_weight_to_put_left[ii][i] = left_weight ;</span>
<span class="lineNum">    3168 </span>                :            :                                                 }
<span class="lineNum">    3169 </span>                :<span class="lineNoCov">          0 :                                                 left_weight -= thread_ii_weight_on_cut;</span>
<span class="lineNum">    3170 </span>                :            :                                         }
<span class="lineNum">    3171 </span>                :            :                                         else {
<span class="lineNum">    3172 </span>                :<span class="lineNoCov">          0 :                                                 this-&gt;thread_cut_line_weight_to_put_left[ii][i] = 0;</span>
<span class="lineNum">    3173 </span>                :            :                                         }
<span class="lineNum">    3174 </span>                :            :                                 }
<span class="lineNum">    3175 </span>                :            :                         }
<span class="lineNum">    3176 </span>                :            : 
<span class="lineNum">    3177 </span>                :<span class="lineNoCov">          0 :                         if(num_cuts &gt; 0){</span>
<span class="lineNum">    3178 </span>                :            :                                 //this is a special case. If cutlines share the same coordinate, their weights are equal.
<span class="lineNum">    3179 </span>                :            :                                 //we need to adjust the ratio for that.
<span class="lineNum">    3180 </span>                :<span class="lineNoCov">          0 :                                 for (mj_part_t i = num_cuts - 1; i &gt; 0 ; --i){</span>
<span class="lineNum">    3181 </span>                :<span class="lineNoCov">          0 :                                         if(ZOLTAN2_ABS(current_concurrent_cut_coordinate[i] - current_concurrent_cut_coordinate[i -1]) &lt; this-&gt;sEpsilon){</span>
<span class="lineNum">    3182 </span>                :<span class="lineNoCov">          0 :                                                 my_local_thread_cut_weights_to_put_left[i] -= my_local_thread_cut_weights_to_put_left[i - 1] ;</span>
<span class="lineNum">    3183 </span>                :            :                                         }
<span class="lineNum">    3184 </span>                :<span class="lineNoCov">          0 :                                         my_local_thread_cut_weights_to_put_left[i] = int ((my_local_thread_cut_weights_to_put_left[i] + LEAST_SIGNIFICANCE) * SIGNIFICANCE_MUL)</span>
<span class="lineNum">    3185 </span>                :            :                                                                 / mj_scalar_t(SIGNIFICANCE_MUL);
<span class="lineNum">    3186 </span>                :            :                                 }
<span class="lineNum">    3187 </span>                :            :                         }
<span class="lineNum">    3188 </span>                :            :                 }
<span class="lineNum">    3189 </span>                :            : 
<span class="lineNum">    3190 </span>                :<span class="lineNoCov">          0 :                 for(mj_part_t ii = 0; ii &lt; num_parts; ++ii){</span>
<span class="lineNum">    3191 </span>                :<span class="lineNoCov">          0 :                         thread_num_points_in_parts[ii] = 0;</span>
<span class="lineNum">    3192 </span>                :            :                 }
<span class="lineNum">    3193 </span>                :            : 
<span class="lineNum">    3194 </span>                :            : 
<span class="lineNum">    3195 </span>                :            : #ifdef HAVE_ZOLTAN2_OMP
<span class="lineNum">    3196 </span>                :            :                 //dont change static scheduler. the static partitioner used later as well.
<span class="lineNum">    3197 </span>                :            : #pragma omp for
<span class="lineNum">    3198 </span>                :            : #endif
<span class="lineNum">    3199 </span>                :<span class="lineNoCov">          0 :                 for (mj_lno_t ii = coordinate_begin; ii &lt; coordinate_end; ++ii){</span>
<span class="lineNum">    3200 </span>                :            : 
<span class="lineNum">    3201 </span>                :<span class="lineNoCov">          0 :                         mj_lno_t coordinate_index = this-&gt;coordinate_permutations[ii];</span>
<span class="lineNum">    3202 </span>                :<span class="lineNoCov">          0 :                         mj_scalar_t coordinate_weight = this-&gt;mj_uniform_weights[0]? 1:this-&gt;mj_weights[0][coordinate_index];</span>
<span class="lineNum">    3203 </span>                :<span class="lineNoCov">          0 :                         mj_part_t coordinate_assigned_place = this-&gt;assigned_part_ids[coordinate_index];</span>
<span class="lineNum">    3204 </span>                :<span class="lineNoCov">          0 :                         mj_part_t coordinate_assigned_part = coordinate_assigned_place / 2;</span>
<span class="lineNum">    3205 </span>                :<span class="lineNoCov">          0 :                         if(coordinate_assigned_place % 2 == 1){</span>
<span class="lineNum">    3206 </span>                :            :                                 //if it is on the cut.
<span class="lineNum">    3207 </span>                :<span class="lineNoCov">          0 :                                 if(this-&gt;distribute_points_on_cut_lines</span>
<span class="lineNum">    3208 </span>                :<span class="lineNoCov">          0 :                                                 &amp;&amp; my_local_thread_cut_weights_to_put_left[coordinate_assigned_part] &gt; this-&gt;sEpsilon){</span>
<span class="lineNum">    3209 </span>                :            :                                         //if the rectilinear partitioning is allowed,
<span class="lineNum">    3210 </span>                :            :                                         //and the thread has still space to put on the left of the cut
<span class="lineNum">    3211 </span>                :            :                                         //then thread puts the vertex to left.
<span class="lineNum">    3212 </span>                :<span class="lineNoCov">          0 :                                         my_local_thread_cut_weights_to_put_left[coordinate_assigned_part] -= coordinate_weight;</span>
<span class="lineNum">    3213 </span>                :            :                                         //if putting the vertex to left increased the weight more than expected.
<span class="lineNum">    3214 </span>                :            :                                         //and if the next cut is on the same coordinate,
<span class="lineNum">    3215 </span>                :            :                                         //then we need to adjust how much weight next cut puts to its left as well,
<span class="lineNum">    3216 </span>                :            :                                         //in order to take care of the imbalance.
<span class="lineNum">    3217 </span>                :<span class="lineNoCov">          0 :                                         if(my_local_thread_cut_weights_to_put_left[coordinate_assigned_part] &lt; 0</span>
<span class="lineNum">    3218 </span>                :            :                                                         &amp;&amp; coordinate_assigned_part &lt; num_cuts - 1
<span class="lineNum">    3219 </span>                :<span class="lineNoCov">          0 :                                                         &amp;&amp; ZOLTAN2_ABS(current_concurrent_cut_coordinate[coordinate_assigned_part+1] -</span>
<span class="lineNum">    3220 </span>                :<span class="lineNoCov">          0 :                                                                         current_concurrent_cut_coordinate[coordinate_assigned_part]) &lt; this-&gt;sEpsilon){</span>
<span class="lineNum">    3221 </span>                :<span class="lineNoCov">          0 :                                                 my_local_thread_cut_weights_to_put_left[coordinate_assigned_part + 1] += my_local_thread_cut_weights_to_put_left[coordinate_assigned_part];</span>
<span class="lineNum">    3222 </span>                :            :                                         }
<span class="lineNum">    3223 </span>                :<span class="lineNoCov">          0 :                                         ++thread_num_points_in_parts[coordinate_assigned_part];</span>
<span class="lineNum">    3224 </span>                :<span class="lineNoCov">          0 :                                         this-&gt;assigned_part_ids[coordinate_index] = coordinate_assigned_part;</span>
<span class="lineNum">    3225 </span>                :            :                                 }
<span class="lineNum">    3226 </span>                :            :                                 else{
<span class="lineNum">    3227 </span>                :            :                                         //if there is no more space on the left, put the coordinate to the right of the cut.
<span class="lineNum">    3228 </span>                :<span class="lineNoCov">          0 :                                         ++coordinate_assigned_part;</span>
<span class="lineNum">    3229 </span>                :            :                                         //this while loop is necessary when a line is partitioned into more than 2 parts.
<span class="lineNum">    3230 </span>                :<span class="lineNoCov">          0 :                                         while(this-&gt;distribute_points_on_cut_lines &amp;&amp;</span>
<span class="lineNum">    3231 </span>                :            :                                                         coordinate_assigned_part &lt; num_cuts){
<span class="lineNum">    3232 </span>                :            :                                                 //traverse all the cut lines having the same partitiong
<span class="lineNum">    3233 </span>                :<span class="lineNoCov">          0 :                                                 if(ZOLTAN2_ABS(current_concurrent_cut_coordinate[coordinate_assigned_part] -</span>
<span class="lineNum">    3234 </span>                :            :                                                                 current_concurrent_cut_coordinate[coordinate_assigned_part - 1])
<span class="lineNum">    3235 </span>                :<span class="lineNoCov">          0 :                                                                 &lt; this-&gt;sEpsilon){</span>
<span class="lineNum">    3236 </span>                :            :                                                         //if line has enough space on left, put it there.
<span class="lineNum">    3237 </span>                :<span class="lineNoCov">          0 :                                                         if(my_local_thread_cut_weights_to_put_left[coordinate_assigned_part] &gt;</span>
<span class="lineNum">    3238 </span>                :            :                                                         this-&gt;sEpsilon &amp;&amp;
<span class="lineNum">    3239 </span>                :<span class="lineNoCov">          0 :                                                         my_local_thread_cut_weights_to_put_left[coordinate_assigned_part] &gt;=</span>
<span class="lineNum">    3240 </span>                :<span class="lineNoCov">          0 :                                                         ZOLTAN2_ABS(my_local_thread_cut_weights_to_put_left[coordinate_assigned_part] - coordinate_weight)){</span>
<span class="lineNum">    3241 </span>                :<span class="lineNoCov">          0 :                                                                 my_local_thread_cut_weights_to_put_left[coordinate_assigned_part] -= coordinate_weight;</span>
<span class="lineNum">    3242 </span>                :            :                                                                 //Again if it put too much on left of the cut,
<span class="lineNum">    3243 </span>                :            :                                                                 //update how much the next cut sharing the same coordinate will put to its left.
<span class="lineNum">    3244 </span>                :<span class="lineNoCov">          0 :                                                                 if(my_local_thread_cut_weights_to_put_left[coordinate_assigned_part] &lt; 0 &amp;&amp;</span>
<span class="lineNum">    3245 </span>                :            :                                                                                 coordinate_assigned_part &lt; num_cuts - 1 &amp;&amp;
<span class="lineNum">    3246 </span>                :<span class="lineNoCov">          0 :                                                                                 ZOLTAN2_ABS(current_concurrent_cut_coordinate[coordinate_assigned_part+1] -</span>
<span class="lineNum">    3247 </span>                :<span class="lineNoCov">          0 :                                                                                                 current_concurrent_cut_coordinate[coordinate_assigned_part]) &lt; this-&gt;sEpsilon){</span>
<span class="lineNum">    3248 </span>                :<span class="lineNoCov">          0 :                                                                         my_local_thread_cut_weights_to_put_left[coordinate_assigned_part + 1] += my_local_thread_cut_weights_to_put_left[coordinate_assigned_part];</span>
<span class="lineNum">    3249 </span>                :            :                                                                 }
<span class="lineNum">    3250 </span>                :<span class="lineNoCov">          0 :                                                                 break;</span>
<span class="lineNum">    3251 </span>                :            :                                                         }
<span class="lineNum">    3252 </span>                :            :                                                 }
<span class="lineNum">    3253 </span>                :            :                                                 else {
<span class="lineNum">    3254 </span>                :<span class="lineNoCov">          0 :                                                         break;</span>
<span class="lineNum">    3255 </span>                :            :                                                 }
<span class="lineNum">    3256 </span>                :<span class="lineNoCov">          0 :                                                 ++coordinate_assigned_part;</span>
<span class="lineNum">    3257 </span>                :            :                                         }
<span class="lineNum">    3258 </span>                :<span class="lineNoCov">          0 :                                         ++thread_num_points_in_parts[coordinate_assigned_part];</span>
<span class="lineNum">    3259 </span>                :<span class="lineNoCov">          0 :                                         this-&gt;assigned_part_ids[coordinate_index] = coordinate_assigned_part;</span>
<span class="lineNum">    3260 </span>                :            :                                 }
<span class="lineNum">    3261 </span>                :            :                         }
<span class="lineNum">    3262 </span>                :            :                         else {
<span class="lineNum">    3263 </span>                :            :                                 //if it is already assigned to a part, then just put it to the corresponding part.
<span class="lineNum">    3264 </span>                :<span class="lineNoCov">          0 :                                 ++thread_num_points_in_parts[coordinate_assigned_part];</span>
<span class="lineNum">    3265 </span>                :<span class="lineNoCov">          0 :                                 this-&gt;assigned_part_ids[coordinate_index] = coordinate_assigned_part;</span>
<span class="lineNum">    3266 </span>                :            :                         }
<span class="lineNum">    3267 </span>                :            :                 }
<span class="lineNum">    3268 </span>                :            : 
<span class="lineNum">    3269 </span>                :            : 
<span class="lineNum">    3270 </span>                :            : 
<span class="lineNum">    3271 </span>                :            :                 //now we calculate where each thread will write in new_coordinate_permutations array.
<span class="lineNum">    3272 </span>                :            :                 //first we find the out_part_xadj, by marking the begin and end points of each part found.
<span class="lineNum">    3273 </span>                :            :                 //the below loop find the number of points in each part, and writes it to out_part_xadj
<span class="lineNum">    3274 </span>                :            : #ifdef HAVE_ZOLTAN2_OMP
<span class="lineNum">    3275 </span>                :            : #pragma omp for
<span class="lineNum">    3276 </span>                :            : #endif
<span class="lineNum">    3277 </span>                :<span class="lineNoCov">          0 :                 for(mj_part_t j = 0; j &lt; num_parts; ++j){</span>
<span class="lineNum">    3278 </span>                :<span class="lineNoCov">          0 :                         mj_lno_t num_points_in_part_j_upto_thread_i = 0;</span>
<span class="lineNum">    3279 </span>                :<span class="lineNoCov">          0 :                         for (int i = 0; i &lt; this-&gt;num_threads; ++i){</span>
<span class="lineNum">    3280 </span>                :<span class="lineNoCov">          0 :                                 mj_lno_t thread_num_points_in_part_j = this-&gt;thread_point_counts[i][j];</span>
<span class="lineNum">    3281 </span>                :            :                                 //prefix sum to thread point counts, so that each will have private space to write.
<span class="lineNum">    3282 </span>                :<span class="lineNoCov">          0 :                                 this-&gt;thread_point_counts[i][j] = num_points_in_part_j_upto_thread_i;</span>
<span class="lineNum">    3283 </span>                :<span class="lineNoCov">          0 :                                 num_points_in_part_j_upto_thread_i += thread_num_points_in_part_j;</span>
<span class="lineNum">    3284 </span>                :            : 
<span class="lineNum">    3285 </span>                :            :                         }
<span class="lineNum">    3286 </span>                :<span class="lineNoCov">          0 :                         out_part_xadj[j] = num_points_in_part_j_upto_thread_i;// + prev2; //+ coordinateBegin;</span>
<span class="lineNum">    3287 </span>                :            :                 }
<span class="lineNum">    3288 </span>                :            : 
<span class="lineNum">    3289 </span>                :            :                 //now we need to do a prefix sum to out_part_xadj[j], to point begin and end of each part.
<span class="lineNum">    3290 </span>                :            : #ifdef HAVE_ZOLTAN2_OMP
<span class="lineNum">    3291 </span>                :            : #pragma omp single
<span class="lineNum">    3292 </span>                :            : #endif
<span class="lineNum">    3293 </span>                :            :                 {
<span class="lineNum">    3294 </span>                :            :                         //perform prefix sum for num_points in parts.
<span class="lineNum">    3295 </span>                :<span class="lineNoCov">          0 :                         for(mj_part_t j = 1; j &lt; num_parts; ++j){</span>
<span class="lineNum">    3296 </span>                :<span class="lineNoCov">          0 :                                 out_part_xadj[j] += out_part_xadj[j - 1];</span>
<span class="lineNum">    3297 </span>                :            :                         }
<span class="lineNum">    3298 </span>                :            :                 }
<span class="lineNum">    3299 </span>                :            : 
<span class="lineNum">    3300 </span>                :            :                 //shift the num points in threads thread to obtain the
<span class="lineNum">    3301 </span>                :            :                 //beginning index of each thread's private space.
<span class="lineNum">    3302 </span>                :<span class="lineNoCov">          0 :                 for(mj_part_t j = 1; j &lt; num_parts; ++j){</span>
<span class="lineNum">    3303 </span>                :<span class="lineNoCov">          0 :                         thread_num_points_in_parts[j] += out_part_xadj[j - 1] ;</span>
<span class="lineNum">    3304 </span>                :            :                 }
<span class="lineNum">    3305 </span>                :            : 
<span class="lineNum">    3306 </span>                :            : 
<span class="lineNum">    3307 </span>                :            :                 //now thread gets the coordinate and writes the index of coordinate to the permutation array
<span class="lineNum">    3308 </span>                :            :                 //using the part index we calculated.
<span class="lineNum">    3309 </span>                :            : #ifdef HAVE_ZOLTAN2_OMP
<span class="lineNum">    3310 </span>                :            : #pragma omp for
<span class="lineNum">    3311 </span>                :            : #endif
<span class="lineNum">    3312 </span>                :<span class="lineNoCov">          0 :                 for (mj_lno_t ii = coordinate_begin; ii &lt; coordinate_end; ++ii){</span>
<span class="lineNum">    3313 </span>                :<span class="lineNoCov">          0 :                         mj_lno_t i = this-&gt;coordinate_permutations[ii];</span>
<span class="lineNum">    3314 </span>                :<span class="lineNoCov">          0 :                         mj_part_t p =  this-&gt;assigned_part_ids[i];</span>
<span class="lineNum">    3315 </span>                :<span class="lineNoCov">          0 :                         this-&gt;new_coordinate_permutations[coordinate_begin +</span>
<span class="lineNum">    3316 </span>                :<span class="lineNoCov">          0 :                                                           thread_num_points_in_parts[p]++] = i;</span>
<span class="lineNum">    3317 </span>                :            :                 }
<span class="lineNum">    3318 </span>                :            :         }
<span class="lineNum">    3319 </span>                :<span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3320 </span>                :            : 
<span class="lineNum">    3321 </span>                :            : 
<span class="lineNum">    3322 </span>                :            : 
<span class="lineNum">    3323 </span>                :            : /*! \brief Function that calculates the new coordinates for the cut lines. Function is called inside the parallel region.
<span class="lineNum">    3324 </span>                :            :  *
<span class="lineNum">    3325 </span>                :            :  * \param num_total_part is the sum of number of cutlines and number of parts. Simply it is 2*P - 1.
<span class="lineNum">    3326 </span>                :            :  * \param num_cuts is the number of cut lines. P - 1.
<span class="lineNum">    3327 </span>                :            :  * \param max_coordinate is the maximum coordinate in the current range of coordinates and in the current dimension.
<span class="lineNum">    3328 </span>                :            :  * \param min_coordinate is the maximum coordinate in the current range of coordinates and in the current dimension.
<span class="lineNum">    3329 </span>                :            :  * \param global_total_weight is the global total weight in the current range of coordinates.
<span class="lineNum">    3330 </span>                :            :  * \param used_imbalance_tolerance is the maximum allowed imbalance ratio.
<span class="lineNum">    3331 </span>                :            :  *
<span class="lineNum">    3332 </span>                :            :  *
<span class="lineNum">    3333 </span>                :            :  * \param current_global_part_weights is the array holding the weight of parts. Assumes there are 2*P - 1 parts (cut lines are seperate parts).
<span class="lineNum">    3334 </span>                :            :  * \param current_local_part_weights is the local totalweight of the processor.
<span class="lineNum">    3335 </span>                :            :  * \param current_part_target_weights are the desired cumulative part ratios, sized P.
<span class="lineNum">    3336 </span>                :            :  * \param current_cut_line_determined is the boolean array to determine if the correct position for a cut line is found.
<span class="lineNum">    3337 </span>                :            :  *
<span class="lineNum">    3338 </span>                :            :  * \param current_cut_coordinates is the array holding the coordinates of each cut line. Sized P - 1.
<span class="lineNum">    3339 </span>                :            :  * \param current_cut_upper_bounds is the array holding the upper bound coordinate for each cut line. Sized P - 1.
<span class="lineNum">    3340 </span>                :            :  * \param current_cut_lower_bounds is the array holding the lower bound coordinate for each cut line. Sized P - 1.
<span class="lineNum">    3341 </span>                :            :  * \param current_global_left_closest_points is the array holding the closest points to the cut lines from left.
<span class="lineNum">    3342 </span>                :            :  * \param current_global_right_closest_points is the array holding the closest points to the cut lines from right.
<span class="lineNum">    3343 </span>                :            :  * \param current_cut_lower_bound_weights is the array holding the weight of the parts at the left of lower bound coordinates.
<span class="lineNum">    3344 </span>                :            :  * \param current_cut_upper_weights is the array holding the weight of the parts at the left of upper bound coordinates.
<span class="lineNum">    3345 </span>                :            :  * \param new_current_cut_coordinates is the work array, sized P - 1.
<span class="lineNum">    3346 </span>                :            :  *
<span class="lineNum">    3347 </span>                :            :  * \param current_part_cut_line_weight_ratio holds how much weight of the coordinates on the cutline should be put on left side.
<span class="lineNum">    3348 </span>                :            :  * \param rectilinear_cut_count is the count of cut lines whose balance can be achived via distributing the points in same coordinate to different parts.
<span class="lineNum">    3349 </span>                :            :  * \param my_num_incomplete_cut is the number of cutlines whose position has not been determined yet. For K &gt; 1 it is the count in a single part (whose cut lines are determined).
<span class="lineNum">    3350 </span>                :            :  */
<a name="3351"><span class="lineNum">    3351 </span>                :            : template &lt;typename mj_scalar_t, typename mj_lno_t, typename mj_gno_t,</a>
<span class="lineNum">    3352 </span>                :            :           typename mj_part_t&gt;
<span class="lineNum">    3353 </span>                :<span class="lineNoCov">          0 : void AlgMJ&lt;mj_scalar_t, mj_lno_t, mj_gno_t, mj_part_t&gt;::mj_get_new_cut_coordinates(</span>
<span class="lineNum">    3354 </span>                :            :                 const size_t &amp;num_total_part,
<span class="lineNum">    3355 </span>                :            :                 const mj_part_t &amp;num_cuts,
<span class="lineNum">    3356 </span>                :            :                 const mj_scalar_t &amp;max_coordinate,
<span class="lineNum">    3357 </span>                :            :                 const mj_scalar_t &amp;min_coordinate,
<span class="lineNum">    3358 </span>                :            :                 const mj_scalar_t &amp;global_total_weight,
<span class="lineNum">    3359 </span>                :            :                 const mj_scalar_t &amp;used_imbalance_tolerance,
<span class="lineNum">    3360 </span>                :            :                 mj_scalar_t * current_global_part_weights,
<span class="lineNum">    3361 </span>                :            :                 const mj_scalar_t * current_local_part_weights,
<span class="lineNum">    3362 </span>                :            :                 const mj_scalar_t *current_part_target_weights,
<span class="lineNum">    3363 </span>                :            :                 bool *current_cut_line_determined,
<span class="lineNum">    3364 </span>                :            :                 mj_scalar_t *current_cut_coordinates,
<span class="lineNum">    3365 </span>                :            :                 mj_scalar_t *current_cut_upper_bounds,
<span class="lineNum">    3366 </span>                :            :                 mj_scalar_t *current_cut_lower_bounds,
<span class="lineNum">    3367 </span>                :            :                 mj_scalar_t *current_global_left_closest_points,
<span class="lineNum">    3368 </span>                :            :                 mj_scalar_t *current_global_right_closest_points,
<span class="lineNum">    3369 </span>                :            :                 mj_scalar_t * current_cut_lower_bound_weights,
<span class="lineNum">    3370 </span>                :            :                 mj_scalar_t * current_cut_upper_weights,
<span class="lineNum">    3371 </span>                :            :                 mj_scalar_t *new_current_cut_coordinates,
<span class="lineNum">    3372 </span>                :            :                 mj_scalar_t *current_part_cut_line_weight_to_put_left,
<span class="lineNum">    3373 </span>                :            :                 mj_part_t *rectilinear_cut_count,
<span class="lineNum">    3374 </span>                :            :                 mj_part_t &amp;my_num_incomplete_cut){
<span class="lineNum">    3375 </span>                :            : 
<span class="lineNum">    3376 </span>                :            :         //seen weight in the part
<span class="lineNum">    3377 </span>                :<span class="lineNoCov">          0 :         mj_scalar_t seen_weight_in_part = 0;</span>
<span class="lineNum">    3378 </span>                :            :         //expected weight for part.
<span class="lineNum">    3379 </span>                :<span class="lineNoCov">          0 :         mj_scalar_t expected_weight_in_part = 0;</span>
<span class="lineNum">    3380 </span>                :            :         //imbalance for the left and right side of the cut.
<span class="lineNum">    3381 </span>                :<span class="lineNoCov">          0 :         mj_scalar_t imbalance_on_left = 0, imbalance_on_right = 0;</span>
<span class="lineNum">    3382 </span>                :            : 
<span class="lineNum">    3383 </span>                :            : 
<span class="lineNum">    3384 </span>                :            : #ifdef HAVE_ZOLTAN2_OMP
<span class="lineNum">    3385 </span>                :            : #pragma omp for
<span class="lineNum">    3386 </span>                :            : #endif
<span class="lineNum">    3387 </span>                :<span class="lineNoCov">          0 :         for (mj_part_t i = 0; i &lt; num_cuts; i++){</span>
<span class="lineNum">    3388 </span>                :            :                 //if left and right closest points are not set yet,
<span class="lineNum">    3389 </span>                :            :                 //set it to the cut itself.
<span class="lineNum">    3390 </span>                :<span class="lineNoCov">          0 :                 if(min_coordinate - current_global_left_closest_points[i] &gt; this-&gt;sEpsilon)</span>
<span class="lineNum">    3391 </span>                :<span class="lineNoCov">          0 :                         current_global_left_closest_points[i] = current_cut_coordinates[i];</span>
<span class="lineNum">    3392 </span>                :<span class="lineNoCov">          0 :                 if(current_global_right_closest_points[i] - max_coordinate &gt; this-&gt;sEpsilon)</span>
<span class="lineNum">    3393 </span>                :<span class="lineNoCov">          0 :                         current_global_right_closest_points[i] = current_cut_coordinates[i];</span>
<span class="lineNum">    3394 </span>                :            : 
<span class="lineNum">    3395 </span>                :            :         }
<span class="lineNum">    3396 </span>                :            : #ifdef HAVE_ZOLTAN2_OMP
<span class="lineNum">    3397 </span>                :            : #pragma omp for
<span class="lineNum">    3398 </span>                :            : #endif
<span class="lineNum">    3399 </span>                :<span class="lineNoCov">          0 :         for (mj_part_t i = 0; i &lt; num_cuts; i++){</span>
<span class="lineNum">    3400 </span>                :            : 
<span class="lineNum">    3401 </span>                :<span class="lineNoCov">          0 :                 if(this-&gt;distribute_points_on_cut_lines){</span>
<span class="lineNum">    3402 </span>                :            :                         //init the weight on the cut.
<span class="lineNum">    3403 </span>                :<span class="lineNoCov">          0 :                         this-&gt;global_rectilinear_cut_weight[i] = 0;</span>
<span class="lineNum">    3404 </span>                :<span class="lineNoCov">          0 :                         this-&gt;process_rectilinear_cut_weight[i] = 0;</span>
<span class="lineNum">    3405 </span>                :            :                 }
<span class="lineNum">    3406 </span>                :            :                 //if already determined at previous iterations,
<span class="lineNum">    3407 </span>                :            :                 //then just write the coordinate to new array, and proceed.
<span class="lineNum">    3408 </span>                :<span class="lineNoCov">          0 :                 if(current_cut_line_determined[i]) {</span>
<span class="lineNum">    3409 </span>                :<span class="lineNoCov">          0 :                         new_current_cut_coordinates[i] = current_cut_coordinates[i];</span>
<span class="lineNum">    3410 </span>                :<span class="lineNoCov">          0 :                         continue;</span>
<span class="lineNum">    3411 </span>                :            :                 }
<span class="lineNum">    3412 </span>                :            : 
<span class="lineNum">    3413 </span>                :            :                 //current weight of the part at the left of the cut line.
<span class="lineNum">    3414 </span>                :<span class="lineNoCov">          0 :                 seen_weight_in_part = current_global_part_weights[i * 2];</span>
<span class="lineNum">    3415 </span>                :            : 
<span class="lineNum">    3416 </span>                :            :                 /*
<span class="lineNum">    3417 </span>                :            :                 cout &lt;&lt; &quot;seen_weight_in_part:&quot; &lt;&lt; i &lt;&lt; &quot; is &quot;&lt;&lt; seen_weight_in_part &lt;&lt; endl;
<span class="lineNum">    3418 </span>                :            :                 cout &lt;&lt; &quot;\tcut:&quot; &lt;&lt; current_cut_coordinates[i]
<span class="lineNum">    3419 </span>                :            :                        &lt;&lt; &quot; current_cut_lower_bounds:&quot; &lt;&lt; current_cut_lower_bounds[i]
<span class="lineNum">    3420 </span>                :            :                &lt;&lt; &quot; current_cut_upper_bounds:&quot; &lt;&lt; current_cut_upper_bounds[i] &lt;&lt; endl;
<span class="lineNum">    3421 </span>                :            :                */
<span class="lineNum">    3422 </span>                :            :                 //expected ratio
<span class="lineNum">    3423 </span>                :<span class="lineNoCov">          0 :                 expected_weight_in_part = current_part_target_weights[i];</span>
<span class="lineNum">    3424 </span>                :            :                 //leftImbalance = imbalanceOf(seenW, globalTotalWeight, expected);
<span class="lineNum">    3425 </span>                :<span class="lineNoCov">          0 :                 imbalance_on_left = imbalanceOf2(seen_weight_in_part, expected_weight_in_part);</span>
<span class="lineNum">    3426 </span>                :            :                 //rightImbalance = imbalanceOf(globalTotalWeight - seenW, globalTotalWeight, 1 - expected);
<span class="lineNum">    3427 </span>                :<span class="lineNoCov">          0 :                 imbalance_on_right = imbalanceOf2(global_total_weight - seen_weight_in_part, global_total_weight - expected_weight_in_part);</span>
<span class="lineNum">    3428 </span>                :            : 
<span class="lineNum">    3429 </span>                :<span class="lineNoCov">          0 :                 bool is_left_imbalance_valid = ZOLTAN2_ABS(imbalance_on_left) - used_imbalance_tolerance &lt; this-&gt;sEpsilon ;</span>
<span class="lineNum">    3430 </span>                :<span class="lineNoCov">          0 :                 bool is_right_imbalance_valid = ZOLTAN2_ABS(imbalance_on_right) - used_imbalance_tolerance &lt; this-&gt;sEpsilon;</span>
<span class="lineNum">    3431 </span>                :            : 
<span class="lineNum">    3432 </span>                :            :                 //if the cut line reaches to desired imbalance.
<span class="lineNum">    3433 </span>                :<span class="lineNoCov">          0 :                 if(is_left_imbalance_valid &amp;&amp; is_right_imbalance_valid){</span>
<span class="lineNum">    3434 </span>                :<span class="lineNoCov">          0 :                         current_cut_line_determined[i] = true;</span>
<span class="lineNum">    3435 </span>                :            : #ifdef HAVE_ZOLTAN2_OMP
<span class="lineNum">    3436 </span>                :            : #pragma omp atomic
<span class="lineNum">    3437 </span>                :            : #endif
<span class="lineNum">    3438 </span>                :<span class="lineNoCov">          0 :                         my_num_incomplete_cut -= 1;</span>
<span class="lineNum">    3439 </span>                :<span class="lineNoCov">          0 :                         new_current_cut_coordinates [i] = current_cut_coordinates[i];</span>
<span class="lineNum">    3440 </span>                :<span class="lineNoCov">          0 :                         continue;</span>
<span class="lineNum">    3441 </span>                :            :                 }
<span class="lineNum">    3442 </span>                :<span class="lineNoCov">          0 :                 else if(imbalance_on_left &lt; 0){</span>
<span class="lineNum">    3443 </span>                :            :                         //if left imbalance &lt; 0 then we need to move the cut to right.
<span class="lineNum">    3444 </span>                :            : 
<span class="lineNum">    3445 </span>                :<span class="lineNoCov">          0 :                         if(this-&gt;distribute_points_on_cut_lines){</span>
<span class="lineNum">    3446 </span>                :            :                                 //if it is okay to distribute the coordinate on
<span class="lineNum">    3447 </span>                :            :                                 //the same coordinate to left and right.
<span class="lineNum">    3448 </span>                :            :                                 //then check if we can reach to the target weight by including the
<span class="lineNum">    3449 </span>                :            :                                 //coordinates in the part.
<span class="lineNum">    3450 </span>                :<span class="lineNoCov">          0 :                                 if (current_global_part_weights[i * 2 + 1] == expected_weight_in_part){</span>
<span class="lineNum">    3451 </span>                :            :                                         //if it is we are done.
<span class="lineNum">    3452 </span>                :<span class="lineNoCov">          0 :                                         current_cut_line_determined[i] = true;</span>
<span class="lineNum">    3453 </span>                :            : #ifdef HAVE_ZOLTAN2_OMP
<span class="lineNum">    3454 </span>                :            : #pragma omp atomic
<span class="lineNum">    3455 </span>                :            : #endif
<span class="lineNum">    3456 </span>                :<span class="lineNoCov">          0 :                                         my_num_incomplete_cut -= 1;</span>
<span class="lineNum">    3457 </span>                :            : 
<span class="lineNum">    3458 </span>                :            :                                         //then assign everything on the cut to the left of the cut.
<span class="lineNum">    3459 </span>                :<span class="lineNoCov">          0 :                                         new_current_cut_coordinates [i] = current_cut_coordinates[i];</span>
<span class="lineNum">    3460 </span>                :            : 
<span class="lineNum">    3461 </span>                :            :                                         //for this cut all the weight on cut will be put to left.
<span class="lineNum">    3462 </span>                :            : 
<span class="lineNum">    3463 </span>                :<span class="lineNoCov">          0 :                                         current_part_cut_line_weight_to_put_left[i] = current_local_part_weights[i * 2 + 1] - current_local_part_weights[i * 2];</span>
<span class="lineNum">    3464 </span>                :<span class="lineNoCov">          0 :                                         continue;</span>
<span class="lineNum">    3465 </span>                :            :                                 }
<span class="lineNum">    3466 </span>                :<span class="lineNoCov">          0 :                                 else if (current_global_part_weights[i * 2 + 1] &gt; expected_weight_in_part){</span>
<span class="lineNum">    3467 </span>                :            : 
<span class="lineNum">    3468 </span>                :            :                                         //if the weight is larger than the expected weight,
<span class="lineNum">    3469 </span>                :            :                                         //then we need to distribute some points to left, some to right.
<span class="lineNum">    3470 </span>                :<span class="lineNoCov">          0 :                                         current_cut_line_determined[i] = true;</span>
<span class="lineNum">    3471 </span>                :            : #ifdef HAVE_ZOLTAN2_OMP
<span class="lineNum">    3472 </span>                :            : #pragma omp atomic
<span class="lineNum">    3473 </span>                :            : #endif
<span class="lineNum">    3474 </span>                :<span class="lineNoCov">          0 :                                         *rectilinear_cut_count += 1;</span>
<span class="lineNum">    3475 </span>                :            :                                         //increase the num cuts to be determined with rectilinear partitioning.
<span class="lineNum">    3476 </span>                :            : 
<span class="lineNum">    3477 </span>                :            : #ifdef HAVE_ZOLTAN2_OMP
<span class="lineNum">    3478 </span>                :            : #pragma omp atomic
<span class="lineNum">    3479 </span>                :            : #endif
<span class="lineNum">    3480 </span>                :<span class="lineNoCov">          0 :                                         my_num_incomplete_cut -= 1;</span>
<span class="lineNum">    3481 </span>                :<span class="lineNoCov">          0 :                                         new_current_cut_coordinates [i] = current_cut_coordinates[i];</span>
<span class="lineNum">    3482 </span>                :<span class="lineNoCov">          0 :                                         this-&gt;process_rectilinear_cut_weight[i] = current_local_part_weights[i * 2 + 1] -</span>
<span class="lineNum">    3483 </span>                :<span class="lineNoCov">          0 :                                                         current_local_part_weights[i * 2];</span>
<span class="lineNum">    3484 </span>                :<span class="lineNoCov">          0 :                                         continue;</span>
<span class="lineNum">    3485 </span>                :            :                                 }
<span class="lineNum">    3486 </span>                :            :                         }
<span class="lineNum">    3487 </span>                :            :                         //we need to move further right,so set lower bound to current line, and shift it to the closes point from right.
<span class="lineNum">    3488 </span>                :<span class="lineNoCov">          0 :                         current_cut_lower_bounds[i] = current_global_right_closest_points[i];</span>
<span class="lineNum">    3489 </span>                :            :                         //set the lower bound weight to the weight we have seen.
<span class="lineNum">    3490 </span>                :<span class="lineNoCov">          0 :                         current_cut_lower_bound_weights[i] = seen_weight_in_part;</span>
<span class="lineNum">    3491 </span>                :            : 
<span class="lineNum">    3492 </span>                :            :                         //compare the upper bound with what has been found in the last iteration.
<span class="lineNum">    3493 </span>                :            :                         //we try to make more strict bounds for the cut here.
<span class="lineNum">    3494 </span>                :<span class="lineNoCov">          0 :                         for (mj_part_t ii = i + 1; ii &lt; num_cuts ; ++ii){</span>
<span class="lineNum">    3495 </span>                :<span class="lineNoCov">          0 :                                 mj_scalar_t p_weight = current_global_part_weights[ii * 2];</span>
<span class="lineNum">    3496 </span>                :<span class="lineNoCov">          0 :                                 mj_scalar_t line_weight = current_global_part_weights[ii * 2 + 1];</span>
<span class="lineNum">    3497 </span>                :            : 
<span class="lineNum">    3498 </span>                :<span class="lineNoCov">          0 :                                 if(p_weight &gt;= expected_weight_in_part){</span>
<span class="lineNum">    3499 </span>                :            :                                         //if a cut on the right has the expected weight, then we found
<span class="lineNum">    3500 </span>                :            :                                         //our cut position. Set up and low coordiantes to this new cut coordinate.
<span class="lineNum">    3501 </span>                :            :                                         //but we need one more iteration to finalize the cut position,
<span class="lineNum">    3502 </span>                :            :                                         //as wee need to update the part ids.
<span class="lineNum">    3503 </span>                :<span class="lineNoCov">          0 :                                         if(p_weight == expected_weight_in_part){</span>
<span class="lineNum">    3504 </span>                :<span class="lineNoCov">          0 :                                                 current_cut_upper_bounds[i] = current_cut_coordinates[ii];</span>
<span class="lineNum">    3505 </span>                :<span class="lineNoCov">          0 :                                                 current_cut_upper_weights[i] = p_weight;</span>
<span class="lineNum">    3506 </span>                :<span class="lineNoCov">          0 :                                                 current_cut_lower_bounds[i] = current_cut_coordinates[ii];</span>
<span class="lineNum">    3507 </span>                :<span class="lineNoCov">          0 :                                                 current_cut_lower_bound_weights[i] = p_weight;</span>
<span class="lineNum">    3508 </span>                :<span class="lineNoCov">          0 :                                         } else if (p_weight &lt; current_cut_upper_weights[i]){</span>
<span class="lineNum">    3509 </span>                :            :                                                 //if a part weight is larger then my expected weight,
<span class="lineNum">    3510 </span>                :            :                                                 //but lower than my upper bound weight, update upper bound.
<span class="lineNum">    3511 </span>                :<span class="lineNoCov">          0 :                                                 current_cut_upper_bounds[i] = current_global_left_closest_points[ii];</span>
<span class="lineNum">    3512 </span>                :<span class="lineNoCov">          0 :                                                 current_cut_upper_weights[i] = p_weight;</span>
<span class="lineNum">    3513 </span>                :            :                                         }
<span class="lineNum">    3514 </span>                :<span class="lineNoCov">          0 :                                         break;</span>
<span class="lineNum">    3515 </span>                :            :                                 }
<span class="lineNum">    3516 </span>                :            :                                 //if comes here then pw &lt; ew
<span class="lineNum">    3517 </span>                :            :                                 //then compare the weight against line weight.
<span class="lineNum">    3518 </span>                :<span class="lineNoCov">          0 :                                 if(line_weight &gt;= expected_weight_in_part){</span>
<span class="lineNum">    3519 </span>                :            :                                         //if the line is larger than the expected weight,
<span class="lineNum">    3520 </span>                :            :                                         //then we need to reach to the balance by distributing coordinates on this line.
<span class="lineNum">    3521 </span>                :<span class="lineNoCov">          0 :                                         current_cut_upper_bounds[i] = current_cut_coordinates[ii];</span>
<span class="lineNum">    3522 </span>                :<span class="lineNoCov">          0 :                                         current_cut_upper_weights[i] = line_weight;</span>
<span class="lineNum">    3523 </span>                :<span class="lineNoCov">          0 :                                         current_cut_lower_bounds[i] = current_cut_coordinates[ii];</span>
<span class="lineNum">    3524 </span>                :<span class="lineNoCov">          0 :                                         current_cut_lower_bound_weights[i] = p_weight;</span>
<span class="lineNum">    3525 </span>                :<span class="lineNoCov">          0 :                                         break;</span>
<span class="lineNum">    3526 </span>                :            :                                 }
<span class="lineNum">    3527 </span>                :            :                                 //if a stricter lower bound is found,
<span class="lineNum">    3528 </span>                :            :                                 //update the lower bound.
<span class="lineNum">    3529 </span>                :<span class="lineNoCov">          0 :                                 if (p_weight &lt;= expected_weight_in_part &amp;&amp; p_weight &gt;= current_cut_lower_bound_weights[i]){</span>
<span class="lineNum">    3530 </span>                :<span class="lineNoCov">          0 :                                         current_cut_lower_bounds[i] = current_global_right_closest_points[ii] ;</span>
<span class="lineNum">    3531 </span>                :<span class="lineNoCov">          0 :                                         current_cut_lower_bound_weights[i] = p_weight;</span>
<span class="lineNum">    3532 </span>                :            :                                 }
<span class="lineNum">    3533 </span>                :            :                         }
<span class="lineNum">    3534 </span>                :            : 
<span class="lineNum">    3535 </span>                :            : 
<span class="lineNum">    3536 </span>                :<span class="lineNoCov">          0 :                         mj_scalar_t new_cut_position = 0;</span>
<span class="lineNum">    3537 </span>                :<span class="lineNoCov">          0 :                         this-&gt;mj_calculate_new_cut_position(</span>
<span class="lineNum">    3538 </span>                :<span class="lineNoCov">          0 :                                         current_cut_upper_bounds[i],</span>
<span class="lineNum">    3539 </span>                :<span class="lineNoCov">          0 :                                         current_cut_lower_bounds[i],</span>
<span class="lineNum">    3540 </span>                :<span class="lineNoCov">          0 :                                         current_cut_upper_weights[i],</span>
<span class="lineNum">    3541 </span>                :<span class="lineNoCov">          0 :                                         current_cut_lower_bound_weights[i],</span>
<span class="lineNum">    3542 </span>                :            :                                         expected_weight_in_part, new_cut_position);
<span class="lineNum">    3543 </span>                :            : 
<span class="lineNum">    3544 </span>                :            :                         //if cut line does not move significantly.
<span class="lineNum">    3545 </span>                :            :                         //then finalize the search.
<span class="lineNum">    3546 </span>                :<span class="lineNoCov">          0 :                         if (ZOLTAN2_ABS(current_cut_coordinates[i] - new_cut_position) &lt; this-&gt;sEpsilon</span>
<span class="lineNum">    3547 </span>                :            :                                 /*|| current_cut_lower_bounds[i] - current_cut_upper_bounds[i] &gt; this-&gt;sEpsilon*/
<span class="lineNum">    3548 </span>                :            :                                 ){
<span class="lineNum">    3549 </span>                :<span class="lineNoCov">          0 :                                 current_cut_line_determined[i] = true;</span>
<span class="lineNum">    3550 </span>                :            : #ifdef HAVE_ZOLTAN2_OMP
<span class="lineNum">    3551 </span>                :            : #pragma omp atomic
<span class="lineNum">    3552 </span>                :            : #endif
<span class="lineNum">    3553 </span>                :<span class="lineNoCov">          0 :                                 my_num_incomplete_cut -= 1;</span>
<span class="lineNum">    3554 </span>                :            : 
<span class="lineNum">    3555 </span>                :            :                                 //set the cut coordinate and proceed.
<span class="lineNum">    3556 </span>                :<span class="lineNoCov">          0 :                                 new_current_cut_coordinates [i] = current_cut_coordinates[i];</span>
<span class="lineNum">    3557 </span>                :            :                         } else {
<span class="lineNum">    3558 </span>                :<span class="lineNoCov">          0 :                                 new_current_cut_coordinates [i] = new_cut_position;</span>
<span class="lineNum">    3559 </span>                :            :                         }
<span class="lineNum">    3560 </span>                :            :                 } else {
<span class="lineNum">    3561 </span>                :            : 
<span class="lineNum">    3562 </span>                :            :                         //need to move the cut line to left.
<span class="lineNum">    3563 </span>                :            :                         //set upper bound to current line.
<span class="lineNum">    3564 </span>                :<span class="lineNoCov">          0 :                         current_cut_upper_bounds[i] = current_global_left_closest_points[i];</span>
<span class="lineNum">    3565 </span>                :<span class="lineNoCov">          0 :                         current_cut_upper_weights[i] = seen_weight_in_part;</span>
<span class="lineNum">    3566 </span>                :            : 
<span class="lineNum">    3567 </span>                :            :                         // compare the current cut line weights with previous upper and lower bounds.
<span class="lineNum">    3568 </span>                :<span class="lineNoCov">          0 :                         for (int ii = i - 1; ii &gt;= 0; --ii){</span>
<span class="lineNum">    3569 </span>                :<span class="lineNoCov">          0 :                                 mj_scalar_t p_weight = current_global_part_weights[ii * 2];</span>
<span class="lineNum">    3570 </span>                :<span class="lineNoCov">          0 :                                 mj_scalar_t line_weight = current_global_part_weights[ii * 2 + 1];</span>
<span class="lineNum">    3571 </span>                :<span class="lineNoCov">          0 :                                 if(p_weight &lt;= expected_weight_in_part){</span>
<span class="lineNum">    3572 </span>                :<span class="lineNoCov">          0 :                                         if(p_weight == expected_weight_in_part){</span>
<span class="lineNum">    3573 </span>                :            :                                                 //if the weight of the part is my expected weight
<span class="lineNum">    3574 </span>                :            :                                                 //then we find the solution.
<span class="lineNum">    3575 </span>                :<span class="lineNoCov">          0 :                                                 current_cut_upper_bounds[i] = current_cut_coordinates[ii];</span>
<span class="lineNum">    3576 </span>                :<span class="lineNoCov">          0 :                                                 current_cut_upper_weights[i] = p_weight;</span>
<span class="lineNum">    3577 </span>                :<span class="lineNoCov">          0 :                                                 current_cut_lower_bounds[i] = current_cut_coordinates[ii];</span>
<span class="lineNum">    3578 </span>                :<span class="lineNoCov">          0 :                                                 current_cut_lower_bound_weights[i] = p_weight;</span>
<span class="lineNum">    3579 </span>                :            :                                         }
<span class="lineNum">    3580 </span>                :<span class="lineNoCov">          0 :                                         else if (p_weight &gt; current_cut_lower_bound_weights[i]){</span>
<span class="lineNum">    3581 </span>                :            :                                                 //if found weight is bigger than the lower bound
<span class="lineNum">    3582 </span>                :            :                                                 //then update the lower bound.
<span class="lineNum">    3583 </span>                :<span class="lineNoCov">          0 :                                                 current_cut_lower_bounds[i] = current_global_right_closest_points[ii];</span>
<span class="lineNum">    3584 </span>                :<span class="lineNoCov">          0 :                                                 current_cut_lower_bound_weights[i] = p_weight;</span>
<span class="lineNum">    3585 </span>                :            : 
<span class="lineNum">    3586 </span>                :            :                                                 //at the same time, if weight of line is bigger than the
<span class="lineNum">    3587 </span>                :            :                                                 //expected weight, then update the upper bound as well.
<span class="lineNum">    3588 </span>                :            :                                                 //in this case the balance will be obtained by distributing weightss
<span class="lineNum">    3589 </span>                :            :                                                 //on this cut position.
<span class="lineNum">    3590 </span>                :<span class="lineNoCov">          0 :                                                 if(line_weight &gt; expected_weight_in_part){</span>
<span class="lineNum">    3591 </span>                :<span class="lineNoCov">          0 :                                                         current_cut_upper_bounds[i] = current_global_right_closest_points[ii];</span>
<span class="lineNum">    3592 </span>                :<span class="lineNoCov">          0 :                                                         current_cut_upper_weights[i] = line_weight;</span>
<span class="lineNum">    3593 </span>                :            :                                                 }
<span class="lineNum">    3594 </span>                :            :                                         }
<span class="lineNum">    3595 </span>                :<span class="lineNoCov">          0 :                                         break;</span>
<span class="lineNum">    3596 </span>                :            :                                 }
<span class="lineNum">    3597 </span>                :            :                                 //if the weight of the cut on the left is still bigger than my weight,
<span class="lineNum">    3598 </span>                :            :                                 //and also if the weight is smaller than the current upper weight,
<span class="lineNum">    3599 </span>                :            :                                 //or if the weight is equal to current upper weight, but on the left of
<span class="lineNum">    3600 </span>                :            :                                 // the upper weight, then update upper bound.
<span class="lineNum">    3601 </span>                :<span class="lineNoCov">          0 :                                 if (p_weight &gt;= expected_weight_in_part &amp;&amp;</span>
<span class="lineNum">    3602 </span>                :<span class="lineNoCov">          0 :                                                 (p_weight &lt; current_cut_upper_weights[i] ||</span>
<span class="lineNum">    3603 </span>                :<span class="lineNoCov">          0 :                                                                 (p_weight == current_cut_upper_weights[i] &amp;&amp;</span>
<span class="lineNum">    3604 </span>                :<span class="lineNoCov">          0 :                                                                                 current_cut_upper_bounds[i] &gt; current_global_left_closest_points[ii]</span>
<span class="lineNum">    3605 </span>                :            :                                                                 )
<span class="lineNum">    3606 </span>                :            :                                                 )
<span class="lineNum">    3607 </span>                :            :                                         ){
<span class="lineNum">    3608 </span>                :<span class="lineNoCov">          0 :                                         current_cut_upper_bounds[i] = current_global_left_closest_points[ii] ;</span>
<span class="lineNum">    3609 </span>                :<span class="lineNoCov">          0 :                                         current_cut_upper_weights[i] = p_weight;</span>
<span class="lineNum">    3610 </span>                :            :                                 }
<span class="lineNum">    3611 </span>                :            :                         }
<span class="lineNum">    3612 </span>                :<span class="lineNoCov">          0 :                         mj_scalar_t new_cut_position = 0;</span>
<span class="lineNum">    3613 </span>                :<span class="lineNoCov">          0 :                         this-&gt;mj_calculate_new_cut_position(</span>
<span class="lineNum">    3614 </span>                :<span class="lineNoCov">          0 :                                         current_cut_upper_bounds[i],</span>
<span class="lineNum">    3615 </span>                :<span class="lineNoCov">          0 :                                         current_cut_lower_bounds[i],</span>
<span class="lineNum">    3616 </span>                :<span class="lineNoCov">          0 :                                         current_cut_upper_weights[i],</span>
<span class="lineNum">    3617 </span>                :<span class="lineNoCov">          0 :                                         current_cut_lower_bound_weights[i],</span>
<span class="lineNum">    3618 </span>                :            :                                         expected_weight_in_part,
<span class="lineNum">    3619 </span>                :            :                                         new_cut_position);
<span class="lineNum">    3620 </span>                :            : 
<span class="lineNum">    3621 </span>                :            :                         //if cut line does not move significantly.
<span class="lineNum">    3622 </span>                :<span class="lineNoCov">          0 :                         if (ZOLTAN2_ABS(current_cut_coordinates[i] - new_cut_position) &lt; this-&gt;sEpsilon</span>
<span class="lineNum">    3623 </span>                :            :                                         /*|| current_cut_lower_bounds[i] - current_cut_upper_bounds[i] &gt; this-&gt;sEpsilon*/ ){
<span class="lineNum">    3624 </span>                :<span class="lineNoCov">          0 :                                 current_cut_line_determined[i] = true;</span>
<span class="lineNum">    3625 </span>                :            : #ifdef HAVE_ZOLTAN2_OMP
<span class="lineNum">    3626 </span>                :            : #pragma omp atomic
<span class="lineNum">    3627 </span>                :            : #endif
<span class="lineNum">    3628 </span>                :<span class="lineNoCov">          0 :                                 my_num_incomplete_cut -= 1;</span>
<span class="lineNum">    3629 </span>                :            :                                 //set the cut coordinate and proceed.
<span class="lineNum">    3630 </span>                :<span class="lineNoCov">          0 :                                 new_current_cut_coordinates [ i] = current_cut_coordinates[i];</span>
<span class="lineNum">    3631 </span>                :            :                         } else {
<span class="lineNum">    3632 </span>                :<span class="lineNoCov">          0 :                                 new_current_cut_coordinates [ i] = new_cut_position;</span>
<span class="lineNum">    3633 </span>                :            :                         }
<span class="lineNum">    3634 </span>                :            :                 }
<span class="lineNum">    3635 </span>                :            :         }
<span class="lineNum">    3636 </span>                :            : 
<span class="lineNum">    3637 </span>                :            :         //communication to determine the ratios of processors for the distribution
<span class="lineNum">    3638 </span>                :            :         //of coordinates on the cut lines.
<span class="lineNum">    3639 </span>                :            : #ifdef HAVE_ZOLTAN2_OMP
<span class="lineNum">    3640 </span>                :            :         //no need barrier here as it is implicit.
<span class="lineNum">    3641 </span>                :            : #pragma omp single
<span class="lineNum">    3642 </span>                :            : #endif
<span class="lineNum">    3643 </span>                :            :         {
<span class="lineNum">    3644 </span>                :<span class="lineNoCov">          0 :                 if(*rectilinear_cut_count &gt; 0){</span>
<span class="lineNum">    3645 </span>                :            : 
<span class="lineNum">    3646 </span>                :            :                         try{
<span class="lineNum">    3647 </span>                :<span class="lineNoCov">          0 :                                 Teuchos::scan&lt;int,mj_scalar_t&gt;(</span>
<span class="lineNum">    3648 </span>                :            :                                                 *comm, Teuchos::REDUCE_SUM,
<span class="lineNum">    3649 </span>                :            :                                                 num_cuts,
<span class="lineNum">    3650 </span>                :            :                                                 this-&gt;process_rectilinear_cut_weight,
<span class="lineNum">    3651 </span>                :            :                                                 this-&gt;global_rectilinear_cut_weight
<span class="lineNum">    3652 </span>                :            :                                 );
<span class="lineNum">    3653 </span>                :            :                         }
<span class="lineNum">    3654 </span>                :<span class="lineNoCov">          0 :                         Z2_THROW_OUTSIDE_ERROR(*(this-&gt;mj_env))</span>
<span class="lineNum">    3655 </span>                :            : 
<span class="lineNum">    3656 </span>                :<span class="lineNoCov">          0 :                         for (mj_part_t i = 0; i &lt; num_cuts; ++i){</span>
<span class="lineNum">    3657 </span>                :            :                                 //if cut line weight to be distributed.
<span class="lineNum">    3658 </span>                :<span class="lineNoCov">          0 :                                 if(this-&gt;global_rectilinear_cut_weight[i] &gt; 0) {</span>
<span class="lineNum">    3659 </span>                :            :                                         //expected weight to go to left of the cut.
<span class="lineNum">    3660 </span>                :<span class="lineNoCov">          0 :                                         mj_scalar_t expected_part_weight = current_part_target_weights[i];</span>
<span class="lineNum">    3661 </span>                :            :                                         //the weight that should be put to left of the cut.
<span class="lineNum">    3662 </span>                :<span class="lineNoCov">          0 :                                         mj_scalar_t necessary_weight_on_line_for_left = expected_part_weight - current_global_part_weights[i * 2];</span>
<span class="lineNum">    3663 </span>                :            :                                         //the weight of the cut in the process
<span class="lineNum">    3664 </span>                :<span class="lineNoCov">          0 :                                         mj_scalar_t my_weight_on_line = this-&gt;process_rectilinear_cut_weight[i];</span>
<span class="lineNum">    3665 </span>                :            :                                         //the sum of the cut weights upto this process, including the weight of this process.
<span class="lineNum">    3666 </span>                :<span class="lineNoCov">          0 :                                         mj_scalar_t weight_on_line_upto_process_inclusive = this-&gt;global_rectilinear_cut_weight[i];</span>
<span class="lineNum">    3667 </span>                :            :                                         //the space on the left side of the cut after all processes before this process (including this process)
<span class="lineNum">    3668 </span>                :            :                                         //puts their weights on cut to left.
<span class="lineNum">    3669 </span>                :<span class="lineNoCov">          0 :                                         mj_scalar_t space_to_put_left = necessary_weight_on_line_for_left - weight_on_line_upto_process_inclusive;</span>
<span class="lineNum">    3670 </span>                :            :                                         //add my weight to this space to find out how much space is left to me.
<span class="lineNum">    3671 </span>                :<span class="lineNoCov">          0 :                                         mj_scalar_t space_left_to_me = space_to_put_left + my_weight_on_line;</span>
<span class="lineNum">    3672 </span>                :            : 
<span class="lineNum">    3673 </span>                :            :                                         /*
<span class="lineNum">    3674 </span>                :            :                                         cout &lt;&lt; &quot;expected_part_weight:&quot; &lt;&lt; expected_part_weight
<span class="lineNum">    3675 </span>                :            :                                                         &lt;&lt; &quot; necessary_weight_on_line_for_left:&quot; &lt;&lt; necessary_weight_on_line_for_left
<span class="lineNum">    3676 </span>                :            :                                                         &lt;&lt; &quot; my_weight_on_line&quot; &lt;&lt; my_weight_on_line
<span class="lineNum">    3677 </span>                :            :                                                         &lt;&lt; &quot; weight_on_line_upto_process_inclusive:&quot; &lt;&lt; weight_on_line_upto_process_inclusive
<span class="lineNum">    3678 </span>                :            :                                                         &lt;&lt; &quot; space_to_put_left:&quot; &lt;&lt; space_to_put_left
<span class="lineNum">    3679 </span>                :            :                                                         &lt;&lt; &quot; space_left_to_me&quot; &lt;&lt; space_left_to_me &lt;&lt; endl;
<span class="lineNum">    3680 </span>                :            :                                          */
<span class="lineNum">    3681 </span>                :<span class="lineNoCov">          0 :                                         if(space_left_to_me &lt; 0){</span>
<span class="lineNum">    3682 </span>                :            :                                                 //space_left_to_me is negative and i dont need to put anything to left.
<span class="lineNum">    3683 </span>                :<span class="lineNoCov">          0 :                                                 current_part_cut_line_weight_to_put_left[i] = 0;</span>
<span class="lineNum">    3684 </span>                :            :                                         }
<span class="lineNum">    3685 </span>                :<span class="lineNoCov">          0 :                                         else if(space_left_to_me &gt;= my_weight_on_line){</span>
<span class="lineNum">    3686 </span>                :            :                                                 //space left to me is bigger than the weight of the processor on cut.
<span class="lineNum">    3687 </span>                :            :                                                 //so put everything to left.
<span class="lineNum">    3688 </span>                :<span class="lineNoCov">          0 :                                                 current_part_cut_line_weight_to_put_left[i] = my_weight_on_line;</span>
<span class="lineNum">    3689 </span>                :            :                                                 //cout &lt;&lt; &quot;setting current_part_cut_line_weight_to_put_left to my_weight_on_line:&quot; &lt;&lt; my_weight_on_line &lt;&lt; endl;
<span class="lineNum">    3690 </span>                :            :                                         }
<span class="lineNum">    3691 </span>                :            :                                         else {
<span class="lineNum">    3692 </span>                :            :                                                 //put only the weight as much as the space.
<span class="lineNum">    3693 </span>                :<span class="lineNoCov">          0 :                                                 current_part_cut_line_weight_to_put_left[i] = space_left_to_me ;</span>
<span class="lineNum">    3694 </span>                :            : 
<span class="lineNum">    3695 </span>                :            :                                                 //cout &lt;&lt; &quot;setting current_part_cut_line_weight_to_put_left to space_left_to_me:&quot; &lt;&lt; space_left_to_me &lt;&lt; endl;
<span class="lineNum">    3696 </span>                :            :                                         }
<span class="lineNum">    3697 </span>                :            : 
<span class="lineNum">    3698 </span>                :            :                                 }
<span class="lineNum">    3699 </span>                :            :                         }
<span class="lineNum">    3700 </span>                :<span class="lineNoCov">          0 :                         *rectilinear_cut_count = 0;</span>
<span class="lineNum">    3701 </span>                :            :                 }
<span class="lineNum">    3702 </span>                :            :         }
<span class="lineNum">    3703 </span>                :<span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3704 </span>                :            : 
<span class="lineNum">    3705 </span>                :            : /*! \brief Function fills up the num_points_in_all_processor_parts, so that
<span class="lineNum">    3706 </span>                :            :  * it has the number of coordinates in each processor of each part.
<span class="lineNum">    3707 </span>                :            :  * to access how many points processor i has on part j, num_points_in_all_processor_parts[i * num_parts + j].
<span class="lineNum">    3708 </span>                :            :  *
<span class="lineNum">    3709 </span>                :            :  * \param num_procs is the number of processor attending to migration operation.
<span class="lineNum">    3710 </span>                :            :  * \param num_parts is the number of parts that exist in the current partitioning.
<span class="lineNum">    3711 </span>                :            :  * \param num_points_in_all_processor_parts is the output array that holds
<span class="lineNum">    3712 </span>                :            :  * the number of coordinates in each part in each processor.
<span class="lineNum">    3713 </span>                :            :  */
<a name="3714"><span class="lineNum">    3714 </span>                :            : template &lt;typename mj_scalar_t, typename mj_lno_t, typename mj_gno_t,</a>
<span class="lineNum">    3715 </span>                :            :           typename mj_part_t&gt;
<span class="lineNum">    3716 </span>                :<span class="lineNoCov">          0 : void AlgMJ&lt;mj_scalar_t, mj_lno_t, mj_gno_t, mj_part_t&gt;::get_processor_num_points_in_parts(</span>
<span class="lineNum">    3717 </span>                :            :     mj_part_t num_procs,
<span class="lineNum">    3718 </span>                :            :     mj_part_t num_parts,
<span class="lineNum">    3719 </span>                :            :     mj_gno_t *&amp;num_points_in_all_processor_parts){
<span class="lineNum">    3720 </span>                :            : 
<span class="lineNum">    3721 </span>                :            :         //initially allocation_size is num_parts
<span class="lineNum">    3722 </span>                :<span class="lineNoCov">          0 :         size_t allocation_size = num_parts * (num_procs + 1);</span>
<span class="lineNum">    3723 </span>                :            : 
<span class="lineNum">    3724 </span>                :            :         //this will be output
<span class="lineNum">    3725 </span>                :            :         //holds how many each processor has in each part.
<span class="lineNum">    3726 </span>                :            :         //last portion is the sum of all processor points in each part.
<span class="lineNum">    3727 </span>                :            : 
<span class="lineNum">    3728 </span>                :            :         //allocate memory for the local num coordinates in each part.
<span class="lineNum">    3729 </span>                :<span class="lineNoCov">          0 :         mj_gno_t *num_local_points_in_each_part_to_reduce_sum = allocMemory&lt;mj_gno_t&gt;(allocation_size);</span>
<span class="lineNum">    3730 </span>                :            : 
<span class="lineNum">    3731 </span>                :            : 
<span class="lineNum">    3732 </span>                :            :         //this is the portion of the memory which will be used
<span class="lineNum">    3733 </span>                :            :         //at the summation to obtain total number of processors' points in each part.
<span class="lineNum">    3734 </span>                :<span class="lineNoCov">          0 :         mj_gno_t *my_local_points_to_reduce_sum = num_local_points_in_each_part_to_reduce_sum + num_procs * num_parts;</span>
<span class="lineNum">    3735 </span>                :            :         //this is the portion of the memory where each stores its local number.
<span class="lineNum">    3736 </span>                :            :         //this information is needed by other processors.
<span class="lineNum">    3737 </span>                :<span class="lineNoCov">          0 :         mj_gno_t *my_local_point_counts_in_each_art = num_local_points_in_each_part_to_reduce_sum + this-&gt;myRank * num_parts;</span>
<span class="lineNum">    3738 </span>                :            : 
<span class="lineNum">    3739 </span>                :            :         //initialize the array with 0's.
<span class="lineNum">    3740 </span>                :<span class="lineNoCov">          0 :         memset(num_local_points_in_each_part_to_reduce_sum, 0, sizeof(mj_gno_t)*allocation_size);</span>
<span class="lineNum">    3741 </span>                :            : 
<span class="lineNum">    3742 </span>                :            :         //write the number of coordinates in each part.
<span class="lineNum">    3743 </span>                :<span class="lineNoCov">          0 :         for (mj_part_t i = 0; i &lt; num_parts; ++i){</span>
<span class="lineNum">    3744 </span>                :<span class="lineNoCov">          0 :                 mj_lno_t part_begin_index = 0;</span>
<span class="lineNum">    3745 </span>                :<span class="lineNoCov">          0 :                 if (i &gt; 0){</span>
<span class="lineNum">    3746 </span>                :<span class="lineNoCov">          0 :                         part_begin_index = this-&gt;new_part_xadj[i - 1];</span>
<span class="lineNum">    3747 </span>                :            :                 }
<span class="lineNum">    3748 </span>                :<span class="lineNoCov">          0 :                 mj_lno_t part_end_index = this-&gt;new_part_xadj[i];</span>
<span class="lineNum">    3749 </span>                :<span class="lineNoCov">          0 :                 my_local_points_to_reduce_sum[i] = part_end_index - part_begin_index;</span>
<span class="lineNum">    3750 </span>                :            :         }
<span class="lineNum">    3751 </span>                :            : 
<span class="lineNum">    3752 </span>                :            :         //copy the local num parts to the last portion of array,
<span class="lineNum">    3753 </span>                :            :         //so that this portion will represent the global num points in each part after the reduction.
<span class="lineNum">    3754 </span>                :<span class="lineNoCov">          0 :         memcpy (my_local_point_counts_in_each_art,</span>
<span class="lineNum">    3755 </span>                :            :                         my_local_points_to_reduce_sum,
<span class="lineNum">    3756 </span>                :            :                         sizeof(mj_gno_t) * (num_parts) );
<span class="lineNum">    3757 </span>                :            : 
<span class="lineNum">    3758 </span>                :            : 
<span class="lineNum">    3759 </span>                :            :         //reduceAll operation.
<span class="lineNum">    3760 </span>                :            :         //the portion that belongs to a processor with index p
<span class="lineNum">    3761 </span>                :            :         //will start from myRank * num_parts.
<span class="lineNum">    3762 </span>                :            :         //the global number of points will be held at the index
<span class="lineNum">    3763 </span>                :            :         try{
<span class="lineNum">    3764 </span>                :<span class="lineNoCov">          0 :                 reduceAll&lt;int, mj_gno_t&gt;(</span>
<span class="lineNum">    3765 </span>                :<span class="lineNoCov">          0 :                                 *(this-&gt;comm),</span>
<span class="lineNum">    3766 </span>                :            :                                 Teuchos::REDUCE_SUM,
<span class="lineNum">    3767 </span>                :            :                                 allocation_size,
<span class="lineNum">    3768 </span>                :            :                                 num_local_points_in_each_part_to_reduce_sum,
<span class="lineNum">    3769 </span>                :            :                                 num_points_in_all_processor_parts);
<span class="lineNum">    3770 </span>                :            :         }
<span class="lineNum">    3771 </span>                :<span class="lineNoCov">          0 :         Z2_THROW_OUTSIDE_ERROR(*(this-&gt;mj_env))</span>
<span class="lineNum">    3772 </span>                :<span class="lineNoCov">          0 :         freeArray&lt;mj_gno_t&gt;(num_local_points_in_each_part_to_reduce_sum);</span>
<span class="lineNum">    3773 </span>                :<span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3774 </span>                :            : 
<span class="lineNum">    3775 </span>                :            : 
<span class="lineNum">    3776 </span>                :            : 
<span class="lineNum">    3777 </span>                :            : /*! \brief Function checks if should do migration or not.
<span class="lineNum">    3778 </span>                :            :  * It returns true to point that migration should be done when
<span class="lineNum">    3779 </span>                :            :  * -migration_reduce_all_population are higher than a predetermined value
<span class="lineNum">    3780 </span>                :            :  * -num_coords_for_last_dim_part that left for the last dimension partitioning is less than a predetermined value
<span class="lineNum">    3781 </span>                :            :  * -the imbalance of the processors on the parts are higher than given threshold.
<span class="lineNum">    3782 </span>                :            :  * \param migration_reduce_all_population is the multiplication of the number of reduceall operations estimated and the number of processors.
<span class="lineNum">    3783 </span>                :            :  * \param num_coords_for_last_dim_part is the estimated number of coordinates in a part per processor in the last dimension partitioning.
<span class="lineNum">    3784 </span>                :            :  * \param num_procs is the number of processor attending to migration operation.
<span class="lineNum">    3785 </span>                :            :  * \param num_parts is the number of parts that exist in the current partitioning.
<span class="lineNum">    3786 </span>                :            :  * \param num_points_in_all_processor_parts is the input array that holds
<span class="lineNum">    3787 </span>                :            :  * the number of coordinates in each part in each processor.
<span class="lineNum">    3788 </span>                :            :  */
<a name="3789"><span class="lineNum">    3789 </span>                :            : template &lt;typename mj_scalar_t, typename mj_lno_t, typename mj_gno_t,</a>
<span class="lineNum">    3790 </span>                :            :           typename mj_part_t&gt;
<span class="lineNum">    3791 </span>                :<span class="lineNoCov">          0 : bool AlgMJ&lt;mj_scalar_t, mj_lno_t, mj_gno_t, mj_part_t&gt;::mj_check_to_migrate(</span>
<span class="lineNum">    3792 </span>                :            :     size_t migration_reduce_all_population,
<span class="lineNum">    3793 </span>                :            :     mj_lno_t num_coords_for_last_dim_part,
<span class="lineNum">    3794 </span>                :            :     mj_part_t num_procs,
<span class="lineNum">    3795 </span>                :            :     mj_part_t num_parts,
<span class="lineNum">    3796 </span>                :            :     mj_gno_t *num_points_in_all_processor_parts){
<span class="lineNum">    3797 </span>                :            : 
<span class="lineNum">    3798 </span>                :            :         //if reduce all count and population in the last dim is too high
<span class="lineNum">    3799 </span>                :<span class="lineNoCov">          0 :     if (migration_reduce_all_population &gt; FUTURE_REDUCEALL_CUTOFF) return true;</span>
<span class="lineNum">    3800 </span>                :            :     //if the work in a part per processor in the last dim is too low.
<span class="lineNum">    3801 </span>                :<span class="lineNoCov">          0 :     if (num_coords_for_last_dim_part &lt; MIN_WORK_LAST_DIM) return true;</span>
<span class="lineNum">    3802 </span>                :            : 
<span class="lineNum">    3803 </span>                :            :         //if migration is to be checked and the imbalance is too high
<span class="lineNum">    3804 </span>                :<span class="lineNoCov">          0 :     if (this-&gt;check_migrate_avoid_migration_option == 0){</span>
<span class="lineNum">    3805 </span>                :<span class="lineNoCov">          0 :         double global_imbalance = 0;</span>
<span class="lineNum">    3806 </span>                :            :         //global shift to reach the sum of coordiante count in each part.
<span class="lineNum">    3807 </span>                :<span class="lineNoCov">          0 :         size_t global_shift = num_procs * num_parts;</span>
<span class="lineNum">    3808 </span>                :            : 
<span class="lineNum">    3809 </span>                :<span class="lineNoCov">          0 :         for (mj_part_t ii = 0; ii &lt; num_procs; ++ii){</span>
<span class="lineNum">    3810 </span>                :<span class="lineNoCov">          0 :                 for (mj_part_t i = 0; i &lt; num_parts; ++i){</span>
<span class="lineNum">    3811 </span>                :<span class="lineNoCov">          0 :                         double ideal_num = num_points_in_all_processor_parts[global_shift + i]</span>
<span class="lineNum">    3812 </span>                :<span class="lineNoCov">          0 :                                                                 / double(num_procs);</span>
<span class="lineNum">    3813 </span>                :            : 
<span class="lineNum">    3814 </span>                :<span class="lineNoCov">          0 :                         global_imbalance += ZOLTAN2_ABS(ideal_num -</span>
<span class="lineNum">    3815 </span>                :            :                                         num_points_in_all_processor_parts[ii * num_parts + i]) /  (ideal_num);
<span class="lineNum">    3816 </span>                :            :                 }
<span class="lineNum">    3817 </span>                :            :         }
<span class="lineNum">    3818 </span>                :<span class="lineNoCov">          0 :         global_imbalance /= num_parts;</span>
<span class="lineNum">    3819 </span>                :<span class="lineNoCov">          0 :         global_imbalance /= num_procs;</span>
<span class="lineNum">    3820 </span>                :            : 
<span class="lineNum">    3821 </span>                :            :                 /*
<span class="lineNum">    3822 </span>                :            :         if (this-&gt;myRank == 0) {
<span class="lineNum">    3823 </span>                :            :                 cout &lt;&lt; &quot;imbalance for next iteration:&quot; &lt;&lt; global_imbalance &lt;&lt; endl;
<span class="lineNum">    3824 </span>                :            :         }
<span class="lineNum">    3825 </span>                :            :         */
<span class="lineNum">    3826 </span>                :            : 
<span class="lineNum">    3827 </span>                :<span class="lineNoCov">          0 :         if(global_imbalance &lt;= this-&gt;minimum_migration_imbalance){</span>
<span class="lineNum">    3828 </span>                :<span class="lineNoCov">          0 :                 return false;</span>
<span class="lineNum">    3829 </span>                :            :         }
<span class="lineNum">    3830 </span>                :            :         else {
<span class="lineNum">    3831 </span>                :<span class="lineNoCov">          0 :                 return true;</span>
<span class="lineNum">    3832 </span>                :            :         }
<span class="lineNum">    3833 </span>                :            :     }
<span class="lineNum">    3834 </span>                :            :     else {
<span class="lineNum">    3835 </span>                :            :         //if migration is forced
<span class="lineNum">    3836 </span>                :<span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">    3837 </span>                :            :     }
<span class="lineNum">    3838 </span>                :            : }
<span class="lineNum">    3839 </span>                :            : 
<span class="lineNum">    3840 </span>                :            : 
<span class="lineNum">    3841 </span>                :            : /*! \brief Function fills up coordinate_destinations is the output array
<span class="lineNum">    3842 </span>                :            :  * that holds which part each coordinate should be sent.
<span class="lineNum">    3843 </span>                :            :  *
<span class="lineNum">    3844 </span>                :            :  * \param num_parts is the number of parts that exist in the current partitioning.
<span class="lineNum">    3845 </span>                :            :  * \param part_assignment_proc_begin_indices ([i]) points to the first processor index that part i will be sent to.
<span class="lineNum">    3846 </span>                :            :  * \param processor_chains_in_parts the array that holds the linked list structure, started from part_assignment_proc_begin_indices ([i]).
<span class="lineNum">    3847 </span>                :            :  * \param send_count_to_each_proc array array storing the number of points to be sent to each part.
<span class="lineNum">    3848 </span>                :            :  * \param coordinate_destinations is the output array that holds which part each coordinate should be sent.
<span class="lineNum">    3849 </span>                :            :  */
<a name="3850"><span class="lineNum">    3850 </span>                :            : template &lt;typename mj_scalar_t, typename mj_lno_t, typename mj_gno_t,</a>
<span class="lineNum">    3851 </span>                :            :           typename mj_part_t&gt;
<span class="lineNum">    3852 </span>                :<span class="lineNoCov">          0 : void AlgMJ&lt;mj_scalar_t, mj_lno_t, mj_gno_t, mj_part_t&gt;::assign_send_destinations(</span>
<span class="lineNum">    3853 </span>                :            :     mj_part_t num_parts,
<span class="lineNum">    3854 </span>                :            :     mj_part_t *part_assignment_proc_begin_indices,
<span class="lineNum">    3855 </span>                :            :     mj_part_t *processor_chains_in_parts,
<span class="lineNum">    3856 </span>                :            :     mj_lno_t *send_count_to_each_proc,
<span class="lineNum">    3857 </span>                :            :     int *coordinate_destinations){
<span class="lineNum">    3858 </span>                :            : 
<span class="lineNum">    3859 </span>                :<span class="lineNoCov">          0 :     for (mj_part_t p = 0; p &lt; num_parts; ++p){</span>
<span class="lineNum">    3860 </span>                :<span class="lineNoCov">          0 :         mj_lno_t part_begin = 0;</span>
<span class="lineNum">    3861 </span>                :<span class="lineNoCov">          0 :         if (p &gt; 0) part_begin = this-&gt;new_part_xadj[p - 1];</span>
<span class="lineNum">    3862 </span>                :<span class="lineNoCov">          0 :         mj_lno_t part_end = this-&gt;new_part_xadj[p];</span>
<span class="lineNum">    3863 </span>                :            : 
<span class="lineNum">    3864 </span>                :            :         //get the first part that current processor will send its part-p.
<span class="lineNum">    3865 </span>                :<span class="lineNoCov">          0 :         mj_part_t proc_to_sent = part_assignment_proc_begin_indices[p];</span>
<span class="lineNum">    3866 </span>                :            :         //initialize how many point I sent to this processor.
<span class="lineNum">    3867 </span>                :<span class="lineNoCov">          0 :         mj_lno_t num_total_send = 0;</span>
<span class="lineNum">    3868 </span>                :<span class="lineNoCov">          0 :         for (mj_lno_t j=part_begin; j &lt; part_end; j++){</span>
<span class="lineNum">    3869 </span>                :<span class="lineNoCov">          0 :             mj_lno_t local_ind = this-&gt;new_coordinate_permutations[j];</span>
<span class="lineNum">    3870 </span>                :<span class="lineNoCov">          0 :             while (num_total_send &gt;= send_count_to_each_proc[proc_to_sent]){</span>
<span class="lineNum">    3871 </span>                :            :                 //then get the next processor to send the points in part p.
<span class="lineNum">    3872 </span>                :<span class="lineNoCov">          0 :                 num_total_send = 0;</span>
<span class="lineNum">    3873 </span>                :            :                 //assign new processor to part_assign_begin[p]
<span class="lineNum">    3874 </span>                :<span class="lineNoCov">          0 :                 part_assignment_proc_begin_indices[p] = processor_chains_in_parts[proc_to_sent];</span>
<span class="lineNum">    3875 </span>                :            :                 //remove the previous processor
<span class="lineNum">    3876 </span>                :<span class="lineNoCov">          0 :                 processor_chains_in_parts[proc_to_sent] = -1;</span>
<span class="lineNum">    3877 </span>                :            :                 //choose the next processor as the next one to send.
<span class="lineNum">    3878 </span>                :<span class="lineNoCov">          0 :                 proc_to_sent = part_assignment_proc_begin_indices[p];</span>
<span class="lineNum">    3879 </span>                :            :             }
<span class="lineNum">    3880 </span>                :            :             //write the gno index to corresponding position in sendBuf.
<span class="lineNum">    3881 </span>                :<span class="lineNoCov">          0 :             coordinate_destinations[local_ind] = proc_to_sent;</span>
<span class="lineNum">    3882 </span>                :<span class="lineNoCov">          0 :             ++num_total_send;</span>
<span class="lineNum">    3883 </span>                :            :         }
<span class="lineNum">    3884 </span>                :            :     }
<span class="lineNum">    3885 </span>                :<span class="lineNoCov">          0 : }</span>
<span class="lineNum">    3886 </span>                :            : 
<span class="lineNum">    3887 </span>                :            : /*! \brief Function fills up coordinate_destinations is the output array
<span class="lineNum">    3888 </span>                :            :  * that holds which part each coordinate should be sent.
<span class="lineNum">    3889 </span>                :            :  *
<span class="lineNum">    3890 </span>                :            :  * \param num_points_in_all_processor_parts is the array holding the num points in each part in each proc.
<span class="lineNum">    3891 </span>                :            :  * \param num_parts is the number of parts that exist in the current partitioning.
<span class="lineNum">    3892 </span>                :            :  * \param num_procs is the number of processor attending to migration operation.
<span class="lineNum">    3893 </span>                :            : 
<span class="lineNum">    3894 </span>                :            :  * \param send_count_to_each_proc array array storing the number of points to be sent to each part.
<span class="lineNum">    3895 </span>                :            :  * \param processor_ranks_for_subcomm is the ranks of the processors that will be in the subcommunicator with me.
<span class="lineNum">    3896 </span>                :            :  * \param next_future_num_parts_in_parts is the vector, how many more parts each part will be divided into in the future.
<span class="lineNum">    3897 </span>                :            :  * \param out_part_index is the index of the part to which the processor is assigned.
<span class="lineNum">    3898 </span>                :            :  * \param output_part_numbering_begin_index is how much the numbers should be shifted when numbering the result parts.
<span class="lineNum">    3899 </span>                :            :  * \param coordinate_destinations is the output array that holds which part each coordinate should be sent.
<span class="lineNum">    3900 </span>                :            :  */
<a name="3901"><span class="lineNum">    3901 </span>                :            : template &lt;typename mj_scalar_t, typename mj_lno_t, typename mj_gno_t,</a>
<span class="lineNum">    3902 </span>                :            :           typename mj_part_t&gt;
<span class="lineNum">    3903 </span>                :<span class="lineNoCov">          0 : void AlgMJ&lt;mj_scalar_t, mj_lno_t, mj_gno_t, mj_part_t&gt;::mj_assign_proc_to_parts(</span>
<span class="lineNum">    3904 </span>                :            :                 mj_gno_t * num_points_in_all_processor_parts,
<span class="lineNum">    3905 </span>                :            :                 mj_part_t num_parts,
<span class="lineNum">    3906 </span>                :            :                 mj_part_t num_procs,
<span class="lineNum">    3907 </span>                :            :                 mj_lno_t *send_count_to_each_proc,
<span class="lineNum">    3908 </span>                :            :                 std::vector&lt;mj_part_t&gt; &amp;processor_ranks_for_subcomm,
<span class="lineNum">    3909 </span>                :            :                 std::vector&lt;mj_part_t&gt; *next_future_num_parts_in_parts,
<span class="lineNum">    3910 </span>                :            :                 mj_part_t &amp;out_part_index,
<span class="lineNum">    3911 </span>                :            :                 mj_part_t &amp;output_part_numbering_begin_index,
<span class="lineNum">    3912 </span>                :            :                 int *coordinate_destinations){
<span class="lineNum">    3913 </span>                :            : 
<span class="lineNum">    3914 </span>                :            : 
<span class="lineNum">    3915 </span>                :<span class="lineNoCov">          0 :     mj_gno_t *global_num_points_in_parts = num_points_in_all_processor_parts + num_procs * num_parts;</span>
<span class="lineNum">    3916 </span>                :<span class="lineNoCov">          0 :     mj_part_t *num_procs_assigned_to_each_part = allocMemory&lt;mj_part_t&gt;(num_parts);</span>
<span class="lineNum">    3917 </span>                :            : 
<span class="lineNum">    3918 </span>                :            :     //boolean variable if the process finds its part to be assigned.
<span class="lineNum">    3919 </span>                :<span class="lineNoCov">          0 :     bool did_i_find_my_group = false;</span>
<span class="lineNum">    3920 </span>                :            : 
<span class="lineNum">    3921 </span>                :<span class="lineNoCov">          0 :     mj_part_t num_free_procs = num_procs;</span>
<span class="lineNum">    3922 </span>                :<span class="lineNoCov">          0 :     mj_part_t minimum_num_procs_required_for_rest_of_parts = num_parts - 1;</span>
<span class="lineNum">    3923 </span>                :            : 
<span class="lineNum">    3924 </span>                :<span class="lineNoCov">          0 :     double max_imbalance_difference = 0;</span>
<span class="lineNum">    3925 </span>                :<span class="lineNoCov">          0 :     mj_part_t max_differing_part = 0;</span>
<span class="lineNum">    3926 </span>                :            : 
<span class="lineNum">    3927 </span>                :            :     //find how many processor each part requires.
<span class="lineNum">    3928 </span>                :<span class="lineNoCov">          0 :     for (mj_part_t i=0; i &lt; num_parts; i++){</span>
<span class="lineNum">    3929 </span>                :            : 
<span class="lineNum">    3930 </span>                :            :         //scalar portion of the required processors
<span class="lineNum">    3931 </span>                :            :         double scalar_required_proc = num_procs *
<span class="lineNum">    3932 </span>                :<span class="lineNoCov">          0 :                 (double (global_num_points_in_parts[i]) / double (this-&gt;num_global_coords));</span>
<span class="lineNum">    3933 </span>                :            : 
<span class="lineNum">    3934 </span>                :            :         //round it to closest integer.
<span class="lineNum">    3935 </span>                :<span class="lineNoCov">          0 :         mj_part_t required_proc = static_cast&lt;mj_part_t&gt; (0.5 + scalar_required_proc);</span>
<span class="lineNum">    3936 </span>                :            : 
<span class="lineNum">    3937 </span>                :            :         //if assigning the required num procs, creates problems for the rest of the parts.
<span class="lineNum">    3938 </span>                :            :         //then only assign {num_free_procs - (minimum_num_procs_required_for_rest_of_parts)} procs to this part.
<span class="lineNum">    3939 </span>                :<span class="lineNoCov">          0 :         if (num_free_procs - required_proc &lt; minimum_num_procs_required_for_rest_of_parts){</span>
<span class="lineNum">    3940 </span>                :<span class="lineNoCov">          0 :             required_proc = num_free_procs - (minimum_num_procs_required_for_rest_of_parts);</span>
<span class="lineNum">    3941 </span>                :            :         }
<span class="lineNum">    3942 </span>                :            : 
<span class="lineNum">    3943 </span>                :            :         //reduce the free processor count
<span class="lineNum">    3944 </span>                :<span class="lineNoCov">          0 :         num_free_procs -= required_proc;</span>
<span class="lineNum">    3945 </span>                :            :         //reduce the free minimum processor count required for the rest of the part by 1.
<span class="lineNum">    3946 </span>                :<span class="lineNoCov">          0 :         --minimum_num_procs_required_for_rest_of_parts;</span>
<span class="lineNum">    3947 </span>                :            : 
<span class="lineNum">    3948 </span>                :            :         //part (i) is assigned to (required_proc) processors.
<span class="lineNum">    3949 </span>                :<span class="lineNoCov">          0 :         num_procs_assigned_to_each_part[i] = required_proc;</span>
<span class="lineNum">    3950 </span>                :            : 
<span class="lineNum">    3951 </span>                :            :         //because of the roundings some processors might be left as unassigned.
<span class="lineNum">    3952 </span>                :            :         //we want to assign those processors to the part with most imbalance.
<span class="lineNum">    3953 </span>                :            :         //find the part with the maximum imbalance here.
<span class="lineNum">    3954 </span>                :<span class="lineNoCov">          0 :         double imbalance_wrt_ideal = (scalar_required_proc - required_proc) /  required_proc;</span>
<span class="lineNum">    3955 </span>                :<span class="lineNoCov">          0 :         if (imbalance_wrt_ideal &gt; max_imbalance_difference){</span>
<span class="lineNum">    3956 </span>                :<span class="lineNoCov">          0 :             max_imbalance_difference = imbalance_wrt_ideal;</span>
<span class="lineNum">    3957 </span>                :<span class="lineNoCov">          0 :             max_differing_part = i;</span>
<span class="lineNum">    3958 </span>                :            :         }
<span class="lineNum">    3959 </span>                :            :     }
<span class="lineNum">    3960 </span>                :            : 
<span class="lineNum">    3961 </span>                :            :     //assign extra processors to the part with maximum imbalance than the ideal.
<span class="lineNum">    3962 </span>                :<span class="lineNoCov">          0 :     if (num_free_procs &gt; 0){</span>
<span class="lineNum">    3963 </span>                :<span class="lineNoCov">          0 :         num_procs_assigned_to_each_part[max_differing_part] +=  num_free_procs;</span>
<span class="lineNum">    3964 </span>                :            :     }
<span class="lineNum">    3965 </span>                :            : 
<span class="lineNum">    3966 </span>                :            :     //now find what are the best processors with least migration for each part.
<span class="lineNum">    3967 </span>                :            : 
<span class="lineNum">    3968 </span>                :            :     //part_assignment_proc_begin_indices ([i]) is the array that holds the beginning
<span class="lineNum">    3969 </span>                :            :     //index of a processor that processor sends its data for part - i
<span class="lineNum">    3970 </span>                :<span class="lineNoCov">          0 :     mj_part_t *part_assignment_proc_begin_indices = allocMemory&lt;mj_part_t&gt;(num_parts);</span>
<span class="lineNum">    3971 </span>                :            :     //the next processor send is found in processor_chains_in_parts, in linked list manner.
<span class="lineNum">    3972 </span>                :<span class="lineNoCov">          0 :     mj_part_t *processor_chains_in_parts = allocMemory&lt;mj_part_t&gt;(num_procs);</span>
<span class="lineNum">    3973 </span>                :<span class="lineNoCov">          0 :     mj_part_t *processor_part_assignments = allocMemory&lt;mj_part_t&gt;(num_procs);</span>
<span class="lineNum">    3974 </span>                :            : 
<span class="lineNum">    3975 </span>                :            :     //initialize the assignment of each processor.
<span class="lineNum">    3976 </span>                :            :     //this has a linked list implementation.
<span class="lineNum">    3977 </span>                :            :     //the beginning of processors assigned
<span class="lineNum">    3978 </span>                :            :     //to each part is hold at  part_assignment_proc_begin_indices[part].
<span class="lineNum">    3979 </span>                :            :     //then the next processor assigned to that part is located at
<span class="lineNum">    3980 </span>                :            :     //proc_part_assignments[part_assign_begins[part]], this is a chain
<span class="lineNum">    3981 </span>                :            :     //until the value of -1 is reached.
<span class="lineNum">    3982 </span>                :<span class="lineNoCov">          0 :     for (int i = 0; i &lt; num_procs; ++i ){</span>
<span class="lineNum">    3983 </span>                :<span class="lineNoCov">          0 :         processor_part_assignments[i] = -1;</span>
<span class="lineNum">    3984 </span>                :<span class="lineNoCov">          0 :         processor_chains_in_parts[i] = -1;</span>
<span class="lineNum">    3985 </span>                :            :     }
<span class="lineNum">    3986 </span>                :<span class="lineNoCov">          0 :     for (int i = 0; i &lt; num_parts; ++i ){</span>
<span class="lineNum">    3987 </span>                :<span class="lineNoCov">          0 :         part_assignment_proc_begin_indices[i] = -1;</span>
<span class="lineNum">    3988 </span>                :            :     }
<span class="lineNum">    3989 </span>                :            : 
<span class="lineNum">    3990 </span>                :            : 
<span class="lineNum">    3991 </span>                :            :     //Allocate memory for sorting data structure.
<span class="lineNum">    3992 </span>                :<span class="lineNoCov">          0 :     uSortItem&lt;mj_part_t, mj_gno_t&gt; * sort_item_num_part_points_in_procs = allocMemory &lt;uSortItem&lt;mj_part_t, mj_gno_t&gt; &gt; (num_procs);</span>
<span class="lineNum">    3993 </span>                :<span class="lineNoCov">          0 :     for(mj_part_t i = 0; i &lt; num_parts; ++i){</span>
<span class="lineNum">    3994 </span>                :            :         //the algorithm tries to minimize the cost of migration,
<span class="lineNum">    3995 </span>                :            :         //by assigning the processors with highest number of coordinates on that part.
<span class="lineNum">    3996 </span>                :            :         //here we might want to implement a maximum weighted bipartite matching algorithm.
<span class="lineNum">    3997 </span>                :<span class="lineNoCov">          0 :         for(mj_part_t ii = 0; ii &lt; num_procs; ++ii){</span>
<span class="lineNum">    3998 </span>                :<span class="lineNoCov">          0 :                 sort_item_num_part_points_in_procs[ii].id = ii;</span>
<span class="lineNum">    3999 </span>                :            :                 //if processor is not assigned yet.
<span class="lineNum">    4000 </span>                :            :                 //add its num points to the sort data structure.
<span class="lineNum">    4001 </span>                :<span class="lineNoCov">          0 :                 if (processor_part_assignments[ii] == -1){</span>
<span class="lineNum">    4002 </span>                :<span class="lineNoCov">          0 :                         sort_item_num_part_points_in_procs[ii].val =</span>
<span class="lineNum">    4003 </span>                :<span class="lineNoCov">          0 :                                         num_points_in_all_processor_parts[ii * num_parts + i];</span>
<span class="lineNum">    4004 </span>                :            :                 }
<span class="lineNum">    4005 </span>                :            :                 else {
<span class="lineNum">    4006 </span>                :            :                         //if processor is already assigned, insert -nLocal - 1 so that it won't be selected again.
<span class="lineNum">    4007 </span>                :            :                         //would be same if we simply set it to -1,
<span class="lineNum">    4008 </span>                :            :                         //but more information with no extra cost (which is used later) is provided.
<span class="lineNum">    4009 </span>                :<span class="lineNoCov">          0 :                         sort_item_num_part_points_in_procs[ii].val = -num_points_in_all_processor_parts[ii * num_parts + i] - 1;</span>
<span class="lineNum">    4010 </span>                :            :                 }
<span class="lineNum">    4011 </span>                :            :         }
<span class="lineNum">    4012 </span>                :            :         //sort the processors in the part.
<span class="lineNum">    4013 </span>                :<span class="lineNoCov">          0 :         uqsort&lt;mj_part_t, mj_gno_t&gt;(num_procs, sort_item_num_part_points_in_procs);</span>
<span class="lineNum">    4014 </span>                :            : 
<span class="lineNum">    4015 </span>                :<span class="lineNoCov">          0 :         mj_part_t required_proc_count =  num_procs_assigned_to_each_part[i];</span>
<span class="lineNum">    4016 </span>                :<span class="lineNoCov">          0 :         mj_gno_t total_num_points_in_part = global_num_points_in_parts[i];</span>
<span class="lineNum">    4017 </span>                :            :         mj_gno_t ideal_num_points_in_a_proc =
<span class="lineNum">    4018 </span>                :<span class="lineNoCov">          0 :                 Teuchos::as&lt;mj_gno_t&gt;(ceil (total_num_points_in_part / double (required_proc_count)));</span>
<span class="lineNum">    4019 </span>                :            : 
<span class="lineNum">    4020 </span>                :            :         //starts sending to least heaviest part.
<span class="lineNum">    4021 </span>                :<span class="lineNoCov">          0 :         mj_part_t next_proc_to_send_index = num_procs - required_proc_count;</span>
<span class="lineNum">    4022 </span>                :<span class="lineNoCov">          0 :         mj_part_t next_proc_to_send_id = sort_item_num_part_points_in_procs[next_proc_to_send_index].id;</span>
<span class="lineNum">    4023 </span>                :<span class="lineNoCov">          0 :         mj_lno_t space_left_in_sent_proc =  ideal_num_points_in_a_proc - sort_item_num_part_points_in_procs[next_proc_to_send_index].val;</span>
<span class="lineNum">    4024 </span>                :            : 
<span class="lineNum">    4025 </span>                :            :         //find the processors that will be assigned to this part, which are the heaviest
<span class="lineNum">    4026 </span>                :            :         //non assigned processors.
<span class="lineNum">    4027 </span>                :<span class="lineNoCov">          0 :         for(mj_part_t ii = num_procs - 1; ii &gt;= num_procs - required_proc_count; --ii){</span>
<span class="lineNum">    4028 </span>                :<span class="lineNoCov">          0 :             mj_part_t proc_id = sort_item_num_part_points_in_procs[ii].id;</span>
<span class="lineNum">    4029 </span>                :            :             //assign processor to part - i.
<span class="lineNum">    4030 </span>                :<span class="lineNoCov">          0 :             processor_part_assignments[proc_id] = i;</span>
<span class="lineNum">    4031 </span>                :            :         }
<span class="lineNum">    4032 </span>                :            : 
<span class="lineNum">    4033 </span>                :<span class="lineNoCov">          0 :         bool did_change_sign = false;</span>
<span class="lineNum">    4034 </span>                :            :         //if processor has a minus count, reverse it.
<span class="lineNum">    4035 </span>                :<span class="lineNoCov">          0 :         for(mj_part_t ii = 0; ii &lt; num_procs; ++ii){</span>
<span class="lineNum">    4036 </span>                :            :             // TODO:  THE LINE BELOW PRODUCES A WARNING IF gno_t IS UNSIGNED
<span class="lineNum">    4037 </span>                :            :             // TODO:  SEE BUG 6194
<span class="lineNum">    4038 </span>                :            :             if (sort_item_num_part_points_in_procs[ii].val &lt; 0){
<span class="lineNum">    4039 </span>                :            :                 did_change_sign = true;
<span class="lineNum">    4040 </span>                :            :                 sort_item_num_part_points_in_procs[ii].val = -sort_item_num_part_points_in_procs[ii].val - 1;
<span class="lineNum">    4041 </span>                :            :             }
<span class="lineNum">    4042 </span>                :            :             else {
<span class="lineNum">    4043 </span>                :<span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    4044 </span>                :            :             }
<span class="lineNum">    4045 </span>                :            :         }
<span class="lineNum">    4046 </span>                :<span class="lineNoCov">          0 :         if(did_change_sign){</span>
<span class="lineNum">    4047 </span>                :            :             //resort the processors in the part for the rest of the processors that is not assigned.
<span class="lineNum">    4048 </span>                :<span class="lineNoCov">          0 :             uqsort&lt;mj_part_t, mj_gno_t&gt;(num_procs - required_proc_count, sort_item_num_part_points_in_procs);</span>
<span class="lineNum">    4049 </span>                :            :         }
<span class="lineNum">    4050 </span>                :            : 
<span class="lineNum">    4051 </span>                :            :         //check if this processors is one of the procs assigned to this part.
<span class="lineNum">    4052 </span>                :            :         //if it is, then get the group.
<span class="lineNum">    4053 </span>                :<span class="lineNoCov">          0 :         if (!did_i_find_my_group){</span>
<span class="lineNum">    4054 </span>                :<span class="lineNoCov">          0 :             for(mj_part_t ii = num_procs - 1; ii &gt;= num_procs - required_proc_count; --ii){</span>
<span class="lineNum">    4055 </span>                :            : 
<span class="lineNum">    4056 </span>                :<span class="lineNoCov">          0 :                 mj_part_t proc_id_to_assign = sort_item_num_part_points_in_procs[ii].id;</span>
<span class="lineNum">    4057 </span>                :            :                 //add the proc to the group.
<span class="lineNum">    4058 </span>                :<span class="lineNoCov">          0 :                 processor_ranks_for_subcomm.push_back(proc_id_to_assign);</span>
<span class="lineNum">    4059 </span>                :            : 
<span class="lineNum">    4060 </span>                :<span class="lineNoCov">          0 :                 if(proc_id_to_assign == this-&gt;myRank){</span>
<span class="lineNum">    4061 </span>                :            :                         //if the assigned process is me, then I find my group.
<span class="lineNum">    4062 </span>                :<span class="lineNoCov">          0 :                     did_i_find_my_group = true;</span>
<span class="lineNum">    4063 </span>                :            :                     //set the beginning of part i to my rank.
<span class="lineNum">    4064 </span>                :<span class="lineNoCov">          0 :                     part_assignment_proc_begin_indices[i] = this-&gt;myRank;</span>
<span class="lineNum">    4065 </span>                :<span class="lineNoCov">          0 :                     processor_chains_in_parts[this-&gt;myRank] = -1;</span>
<span class="lineNum">    4066 </span>                :            : 
<span class="lineNum">    4067 </span>                :            :                     //set send count to myself to the number of points that I have in part i.
<span class="lineNum">    4068 </span>                :<span class="lineNoCov">          0 :                     send_count_to_each_proc[this-&gt;myRank] = sort_item_num_part_points_in_procs[ii].val;</span>
<span class="lineNum">    4069 </span>                :            : 
<span class="lineNum">    4070 </span>                :            :                     //calculate the shift required for the output_part_numbering_begin_index
<span class="lineNum">    4071 </span>                :<span class="lineNoCov">          0 :                     for (mj_part_t in = 0; in &lt; i; ++in){</span>
<span class="lineNum">    4072 </span>                :<span class="lineNoCov">          0 :                         output_part_numbering_begin_index += (*next_future_num_parts_in_parts)[in];</span>
<span class="lineNum">    4073 </span>                :            :                     }
<span class="lineNum">    4074 </span>                :<span class="lineNoCov">          0 :                     out_part_index = i;</span>
<span class="lineNum">    4075 </span>                :            :                 }
<span class="lineNum">    4076 </span>                :            :             }
<span class="lineNum">    4077 </span>                :            :             //if these was not my group,
<span class="lineNum">    4078 </span>                :            :             //clear the subcomminicator processor array.
<span class="lineNum">    4079 </span>                :<span class="lineNoCov">          0 :             if (!did_i_find_my_group){</span>
<span class="lineNum">    4080 </span>                :<span class="lineNoCov">          0 :                 processor_ranks_for_subcomm.clear();</span>
<span class="lineNum">    4081 </span>                :            :             }
<span class="lineNum">    4082 </span>                :            :         }
<span class="lineNum">    4083 </span>                :            : 
<span class="lineNum">    4084 </span>                :            :         //send points of the nonassigned coordinates to the assigned coordinates.
<span class="lineNum">    4085 </span>                :            :         //starts from the heaviest nonassigned processor.
<span class="lineNum">    4086 </span>                :            :         //TODO we might want to play with this part, that allows more computational imbalance
<span class="lineNum">    4087 </span>                :            :         //but having better communication balance.
<span class="lineNum">    4088 </span>                :<span class="lineNoCov">          0 :         for(mj_part_t ii = num_procs - required_proc_count - 1; ii &gt;= 0; --ii){</span>
<span class="lineNum">    4089 </span>                :<span class="lineNoCov">          0 :             mj_part_t nonassigned_proc_id = sort_item_num_part_points_in_procs[ii].id;</span>
<span class="lineNum">    4090 </span>                :<span class="lineNoCov">          0 :             mj_lno_t num_points_to_sent = sort_item_num_part_points_in_procs[ii].val;</span>
<span class="lineNum">    4091 </span>                :            : 
<span class="lineNum">    4092 </span>                :            :             //we set number of points to -to_sent - 1 for the assigned processors.
<span class="lineNum">    4093 </span>                :            :             //we reverse it here. This should not happen, as we have already reversed them above.
<span class="lineNum">    4094 </span>                :            : #ifdef MJ_DEBUG
<span class="lineNum">    4095 </span>                :            :             if (num_points_to_sent &lt; 0) {
<span class="lineNum">    4096 </span>                :            :                 cout &lt;&lt; &quot;Migration - processor assignments - for part:&quot; &lt;&lt; i &lt;&lt; &quot;from proc:&quot; &lt;&lt; nonassigned_proc_id &lt;&lt; &quot; num_points_to_sent:&quot; &lt;&lt; num_points_to_sent &lt;&lt; std::endl;
<span class="lineNum">    4097 </span>                :            :                 exit(1);
<span class="lineNum">    4098 </span>                :            :             }
<span class="lineNum">    4099 </span>                :            : #endif
<span class="lineNum">    4100 </span>                :            : 
<span class="lineNum">    4101 </span>                :            :             //now sends the points to the assigned processors.
<span class="lineNum">    4102 </span>                :<span class="lineNoCov">          0 :             while (num_points_to_sent &gt; 0){</span>
<span class="lineNum">    4103 </span>                :            :                 //if the processor has enough space.
<span class="lineNum">    4104 </span>                :<span class="lineNoCov">          0 :                 if (num_points_to_sent &lt;= space_left_in_sent_proc){</span>
<span class="lineNum">    4105 </span>                :            :                         //reduce the space left in the processor.
<span class="lineNum">    4106 </span>                :<span class="lineNoCov">          0 :                         space_left_in_sent_proc -= num_points_to_sent;</span>
<span class="lineNum">    4107 </span>                :            :                         //if my rank is the one that is sending the coordinates.
<span class="lineNum">    4108 </span>                :<span class="lineNoCov">          0 :                     if (this-&gt;myRank == nonassigned_proc_id){</span>
<span class="lineNum">    4109 </span>                :            :                         //set my sent count to the sent processor.
<span class="lineNum">    4110 </span>                :<span class="lineNoCov">          0 :                         send_count_to_each_proc[next_proc_to_send_id] = num_points_to_sent;</span>
<span class="lineNum">    4111 </span>                :            :                         //save the processor in the list (processor_chains_in_parts and part_assignment_proc_begin_indices)
<span class="lineNum">    4112 </span>                :            :                         //that the processor will send its point in part-i.
<span class="lineNum">    4113 </span>                :<span class="lineNoCov">          0 :                         mj_part_t prev_begin = part_assignment_proc_begin_indices[i];</span>
<span class="lineNum">    4114 </span>                :<span class="lineNoCov">          0 :                         part_assignment_proc_begin_indices[i] = next_proc_to_send_id;</span>
<span class="lineNum">    4115 </span>                :<span class="lineNoCov">          0 :                         processor_chains_in_parts[next_proc_to_send_id] = prev_begin;</span>
<span class="lineNum">    4116 </span>                :            :                     }
<span class="lineNum">    4117 </span>                :<span class="lineNoCov">          0 :                     num_points_to_sent = 0;</span>
<span class="lineNum">    4118 </span>                :            :                 }
<span class="lineNum">    4119 </span>                :            :                 else {
<span class="lineNum">    4120 </span>                :            :                     //there might be no space left in the processor.
<span class="lineNum">    4121 </span>                :<span class="lineNoCov">          0 :                     if(space_left_in_sent_proc &gt; 0){</span>
<span class="lineNum">    4122 </span>                :<span class="lineNoCov">          0 :                         num_points_to_sent -= space_left_in_sent_proc;</span>
<span class="lineNum">    4123 </span>                :            : 
<span class="lineNum">    4124 </span>                :            :                         //send as the space left in the processor.
<span class="lineNum">    4125 </span>                :<span class="lineNoCov">          0 :                         if (this-&gt;myRank == nonassigned_proc_id){</span>
<span class="lineNum">    4126 </span>                :            :                                 //send as much as the space in this case.
<span class="lineNum">    4127 </span>                :<span class="lineNoCov">          0 :                             send_count_to_each_proc[next_proc_to_send_id] = space_left_in_sent_proc;</span>
<span class="lineNum">    4128 </span>                :<span class="lineNoCov">          0 :                             mj_part_t prev_begin = part_assignment_proc_begin_indices[i];</span>
<span class="lineNum">    4129 </span>                :<span class="lineNoCov">          0 :                             part_assignment_proc_begin_indices[i] = next_proc_to_send_id;</span>
<span class="lineNum">    4130 </span>                :<span class="lineNoCov">          0 :                             processor_chains_in_parts[next_proc_to_send_id] = prev_begin;</span>
<span class="lineNum">    4131 </span>                :            : 
<span class="lineNum">    4132 </span>                :            :                         }
<span class="lineNum">    4133 </span>                :            :                     }
<span class="lineNum">    4134 </span>                :            :                     //change the sent part
<span class="lineNum">    4135 </span>                :<span class="lineNoCov">          0 :                     ++next_proc_to_send_index;</span>
<span class="lineNum">    4136 </span>                :            : 
<span class="lineNum">    4137 </span>                :            : #ifdef MJ_DEBUG
<span class="lineNum">    4138 </span>                :            :                     if(next_part_to_send_index &lt;  nprocs - required_proc_count ){
<span class="lineNum">    4139 </span>                :            :                         cout &lt;&lt; &quot;Migration - processor assignments - for part:&quot;
<span class="lineNum">    4140 </span>                :            :                                         &lt;&lt; i
<span class="lineNum">    4141 </span>                :            :                                         &lt;&lt;  &quot; next_part_to_send :&quot; &lt;&lt; next_part_to_send_index
<span class="lineNum">    4142 </span>                :            :                                         &lt;&lt; &quot; nprocs:&quot; &lt;&lt; nprocs
<span class="lineNum">    4143 </span>                :            :                                         &lt;&lt; &quot; required_proc_count:&quot; &lt;&lt; required_proc_count
<span class="lineNum">    4144 </span>                :            :                                         &lt;&lt; &quot; Error: next_part_to_send_index &lt;  nprocs - required_proc_count&quot; &lt;&lt; std::endl;
<span class="lineNum">    4145 </span>                :            :                         exit(1)l
<span class="lineNum">    4146 </span>                :            : 
<span class="lineNum">    4147 </span>                :            :                     }
<span class="lineNum">    4148 </span>                :            : #endif
<span class="lineNum">    4149 </span>                :            :                     //send the new id.
<span class="lineNum">    4150 </span>                :<span class="lineNoCov">          0 :                     next_proc_to_send_id =  sort_item_num_part_points_in_procs[next_proc_to_send_index].id;</span>
<span class="lineNum">    4151 </span>                :            :                     //set the new space in the processor.
<span class="lineNum">    4152 </span>                :<span class="lineNoCov">          0 :                     space_left_in_sent_proc = ideal_num_points_in_a_proc - sort_item_num_part_points_in_procs[next_proc_to_send_index].val;</span>
<span class="lineNum">    4153 </span>                :            :                 }
<span class="lineNum">    4154 </span>                :            :             }
<span class="lineNum">    4155 </span>                :            :         }
<span class="lineNum">    4156 </span>                :            :     }
<span class="lineNum">    4157 </span>                :            : 
<span class="lineNum">    4158 </span>                :            : 
<span class="lineNum">    4159 </span>                :            : 
<span class="lineNum">    4160 </span>                :<span class="lineNoCov">          0 :     this-&gt;assign_send_destinations(</span>
<span class="lineNum">    4161 </span>                :            :                 num_parts,
<span class="lineNum">    4162 </span>                :            :             part_assignment_proc_begin_indices,
<span class="lineNum">    4163 </span>                :            :             processor_chains_in_parts,
<span class="lineNum">    4164 </span>                :            :             send_count_to_each_proc,
<span class="lineNum">    4165 </span>                :            :             coordinate_destinations);
<span class="lineNum">    4166 </span>                :            : 
<span class="lineNum">    4167 </span>                :<span class="lineNoCov">          0 :     freeArray&lt;mj_part_t&gt;(part_assignment_proc_begin_indices);</span>
<span class="lineNum">    4168 </span>                :<span class="lineNoCov">          0 :     freeArray&lt;mj_part_t&gt;(processor_chains_in_parts);</span>
<span class="lineNum">    4169 </span>                :<span class="lineNoCov">          0 :     freeArray&lt;mj_part_t&gt;(processor_part_assignments);</span>
<span class="lineNum">    4170 </span>                :<span class="lineNoCov">          0 :     freeArray&lt;uSortItem&lt;mj_part_t, mj_gno_t&gt; &gt; (sort_item_num_part_points_in_procs);</span>
<span class="lineNum">    4171 </span>                :<span class="lineNoCov">          0 :     freeArray&lt;mj_part_t &gt; (num_procs_assigned_to_each_part);</span>
<span class="lineNum">    4172 </span>                :            : 
<span class="lineNum">    4173 </span>                :<span class="lineNoCov">          0 : }</span>
<span class="lineNum">    4174 </span>                :            : 
<span class="lineNum">    4175 </span>                :            : 
<span class="lineNum">    4176 </span>                :            : /*! \brief Function fills up coordinate_destinations is the output array
<span class="lineNum">    4177 </span>                :            :  * that holds which part each coordinate should be sent. In addition it calculates
<span class="lineNum">    4178 </span>                :            :  * the shift amount (output_part_numbering_begin_index) to be done when
<span class="lineNum">    4179 </span>                :            :  * final numberings of the parts are performed.
<span class="lineNum">    4180 </span>                :            :  *
<span class="lineNum">    4181 </span>                :            :  * \param num_parts is the number of parts that exist in the current partitioning.
<span class="lineNum">    4182 </span>                :            :  * \param sort_item_part_to_proc_assignment is the sorted parts with respect to the assigned processors.
<span class="lineNum">    4183 </span>                :            :  * \param coordinate_destinations is the output array that holds which part each coordinate should be sent.
<span class="lineNum">    4184 </span>                :            :  * \param output_part_numbering_begin_index is how much the numbers should be shifted when numbering the result parts.
<span class="lineNum">    4185 </span>                :            :  * \param next_future_num_parts_in_parts is the vector, how many more parts each part will be divided into in the future.
<span class="lineNum">    4186 </span>                :            :  *
<span class="lineNum">    4187 </span>                :            :  */
<a name="4188"><span class="lineNum">    4188 </span>                :            : template &lt;typename mj_scalar_t, typename mj_lno_t, typename mj_gno_t,</a>
<span class="lineNum">    4189 </span>                :            :           typename mj_part_t&gt;
<span class="lineNum">    4190 </span>                :<span class="lineNoCov">          0 : void AlgMJ&lt;mj_scalar_t, mj_lno_t, mj_gno_t, mj_part_t&gt;::assign_send_destinations2(</span>
<span class="lineNum">    4191 </span>                :            :     mj_part_t num_parts,
<span class="lineNum">    4192 </span>                :            :     uSortItem&lt;mj_part_t, mj_part_t&gt; * sort_item_part_to_proc_assignment, //input sorted wrt processors
<span class="lineNum">    4193 </span>                :            :     int *coordinate_destinations,
<span class="lineNum">    4194 </span>                :            :     mj_part_t &amp;output_part_numbering_begin_index,
<span class="lineNum">    4195 </span>                :            :     std::vector&lt;mj_part_t&gt; *next_future_num_parts_in_parts){
<span class="lineNum">    4196 </span>                :            : 
<span class="lineNum">    4197 </span>                :<span class="lineNoCov">          0 :     mj_part_t part_shift_amount = output_part_numbering_begin_index;</span>
<span class="lineNum">    4198 </span>                :<span class="lineNoCov">          0 :     mj_part_t previous_processor = -1;</span>
<span class="lineNum">    4199 </span>                :<span class="lineNoCov">          0 :     for(mj_part_t i = 0; i &lt; num_parts; ++i){</span>
<span class="lineNum">    4200 </span>                :<span class="lineNoCov">          0 :         mj_part_t p = sort_item_part_to_proc_assignment[i].id;</span>
<span class="lineNum">    4201 </span>                :            :         //assigned processors are sorted.
<span class="lineNum">    4202 </span>                :<span class="lineNoCov">          0 :         mj_lno_t part_begin_index = 0;</span>
<span class="lineNum">    4203 </span>                :<span class="lineNoCov">          0 :         if (p &gt; 0) part_begin_index = this-&gt;new_part_xadj[p - 1];</span>
<span class="lineNum">    4204 </span>                :<span class="lineNoCov">          0 :         mj_lno_t part_end_index = this-&gt;new_part_xadj[p];</span>
<span class="lineNum">    4205 </span>                :            : 
<span class="lineNum">    4206 </span>                :<span class="lineNoCov">          0 :         mj_part_t assigned_proc = sort_item_part_to_proc_assignment[i].val;</span>
<span class="lineNum">    4207 </span>                :<span class="lineNoCov">          0 :         if (this-&gt;myRank == assigned_proc &amp;&amp; previous_processor != assigned_proc){</span>
<span class="lineNum">    4208 </span>                :<span class="lineNoCov">          0 :             output_part_numbering_begin_index =  part_shift_amount;</span>
<span class="lineNum">    4209 </span>                :            :         }
<span class="lineNum">    4210 </span>                :<span class="lineNoCov">          0 :         previous_processor = assigned_proc;</span>
<span class="lineNum">    4211 </span>                :<span class="lineNoCov">          0 :         part_shift_amount += (*next_future_num_parts_in_parts)[p];</span>
<span class="lineNum">    4212 </span>                :            : 
<span class="lineNum">    4213 </span>                :<span class="lineNoCov">          0 :         for (mj_lno_t j=part_begin_index; j &lt; part_end_index; j++){</span>
<span class="lineNum">    4214 </span>                :<span class="lineNoCov">          0 :             mj_lno_t localInd = this-&gt;new_coordinate_permutations[j];</span>
<span class="lineNum">    4215 </span>                :<span class="lineNoCov">          0 :             coordinate_destinations[localInd] = assigned_proc;</span>
<span class="lineNum">    4216 </span>                :            :         }
<span class="lineNum">    4217 </span>                :            :     }
<span class="lineNum">    4218 </span>                :<span class="lineNoCov">          0 : }</span>
<span class="lineNum">    4219 </span>                :            : 
<span class="lineNum">    4220 </span>                :            : 
<span class="lineNum">    4221 </span>                :            : /*! \brief Function fills up coordinate_destinations is the output array
<span class="lineNum">    4222 </span>                :            :  * that holds which part each coordinate should be sent. In addition it calculates
<span class="lineNum">    4223 </span>                :            :  * the shift amount (output_part_numbering_begin_index) to be done when
<span class="lineNum">    4224 </span>                :            :  * final numberings of the parts are performed.
<span class="lineNum">    4225 </span>                :            :  *
<span class="lineNum">    4226 </span>                :            :  * \param num_points_in_all_processor_parts is the array holding the num points in each part in each proc.
<span class="lineNum">    4227 </span>                :            :  * \param num_parts is the number of parts that exist in the current partitioning.
<span class="lineNum">    4228 </span>                :            :  * \param num_procs is the number of processor attending to migration operation.
<span class="lineNum">    4229 </span>                :            : 
<span class="lineNum">    4230 </span>                :            :  * \param send_count_to_each_proc array array storing the number of points to be sent to each part.
<span class="lineNum">    4231 </span>                :            :  * \param next_future_num_parts_in_parts is the vector, how many more parts each part will be divided into in the future.
<span class="lineNum">    4232 </span>                :            :  * \param out_num_part is the number of parts assigned to the process.
<span class="lineNum">    4233 </span>                :            :  * \param out_part_indices is the indices of the part to which the processor is assigned.
<span class="lineNum">    4234 </span>                :            :  * \param output_part_numbering_begin_index is how much the numbers should be shifted when numbering the result parts.
<span class="lineNum">    4235 </span>                :            :  * \param coordinate_destinations is the output array that holds which part each coordinate should be sent.
<span class="lineNum">    4236 </span>                :            :  */
<a name="4237"><span class="lineNum">    4237 </span>                :            : template &lt;typename mj_scalar_t, typename mj_lno_t, typename mj_gno_t,</a>
<span class="lineNum">    4238 </span>                :            :           typename mj_part_t&gt;
<span class="lineNum">    4239 </span>                :<span class="lineNoCov">          0 : void AlgMJ&lt;mj_scalar_t, mj_lno_t, mj_gno_t, mj_part_t&gt;::mj_assign_parts_to_procs(</span>
<span class="lineNum">    4240 </span>                :            :     mj_gno_t * num_points_in_all_processor_parts,
<span class="lineNum">    4241 </span>                :            :     mj_part_t num_parts,
<span class="lineNum">    4242 </span>                :            :     mj_part_t num_procs,
<span class="lineNum">    4243 </span>                :            :     mj_lno_t *send_count_to_each_proc, //output: sized nprocs, show the number of send point counts to each proc.
<span class="lineNum">    4244 </span>                :            :     std::vector&lt;mj_part_t&gt; *next_future_num_parts_in_parts,//input how many more partitions the part will be partitioned into.
<span class="lineNum">    4245 </span>                :            :     mj_part_t &amp;out_num_part, //output, how many parts the processor will have. this is always 1 for this function.
<span class="lineNum">    4246 </span>                :            :     std::vector&lt;mj_part_t&gt; &amp;out_part_indices, //output: the part indices which the processor is assigned to.
<span class="lineNum">    4247 </span>                :            :     mj_part_t &amp;output_part_numbering_begin_index, //output: how much the part number should be shifted when setting the solution
<span class="lineNum">    4248 </span>                :            :     int *coordinate_destinations){
<span class="lineNum">    4249 </span>                :<span class="lineNoCov">          0 :     out_num_part = 0;</span>
<span class="lineNum">    4250 </span>                :            : 
<span class="lineNum">    4251 </span>                :<span class="lineNoCov">          0 :     mj_gno_t *global_num_points_in_parts = num_points_in_all_processor_parts + num_procs * num_parts;</span>
<span class="lineNum">    4252 </span>                :<span class="lineNoCov">          0 :     out_part_indices.clear();</span>
<span class="lineNum">    4253 </span>                :            : 
<span class="lineNum">    4254 </span>                :            :     //to sort the parts that is assigned to the processors.
<span class="lineNum">    4255 </span>                :            :     //id is the part number, sort value is the assigned processor id.
<span class="lineNum">    4256 </span>                :<span class="lineNoCov">          0 :     uSortItem&lt;mj_part_t, mj_part_t&gt; * sort_item_part_to_proc_assignment  = allocMemory &lt;uSortItem&lt;mj_part_t, mj_part_t&gt; &gt;(num_parts);</span>
<span class="lineNum">    4257 </span>                :<span class="lineNoCov">          0 :     uSortItem&lt;mj_part_t, mj_gno_t&gt; * sort_item_num_points_of_proc_in_part_i = allocMemory &lt;uSortItem&lt;mj_part_t, mj_gno_t&gt; &gt;(num_procs);</span>
<span class="lineNum">    4258 </span>                :            : 
<span class="lineNum">    4259 </span>                :            : 
<span class="lineNum">    4260 </span>                :            :     //calculate the optimal number of coordinates that should be assigned to each processor.
<span class="lineNum">    4261 </span>                :<span class="lineNoCov">          0 :     mj_lno_t work_each = mj_lno_t (this-&gt;num_global_coords / (double (num_procs)) + 0.5f);</span>
<span class="lineNum">    4262 </span>                :            :     //to hold the left space as the number of coordinates to the optimal number in each proc.
<span class="lineNum">    4263 </span>                :<span class="lineNoCov">          0 :     mj_lno_t *space_in_each_processor = allocMemory &lt;mj_lno_t&gt;(num_procs);</span>
<span class="lineNum">    4264 </span>                :            :     //initialize left space in each.
<span class="lineNum">    4265 </span>                :<span class="lineNoCov">          0 :     for (mj_part_t i = 0; i &lt; num_procs; ++i){</span>
<span class="lineNum">    4266 </span>                :<span class="lineNoCov">          0 :         space_in_each_processor[i] = work_each;</span>
<span class="lineNum">    4267 </span>                :            :     }
<span class="lineNum">    4268 </span>                :            : 
<span class="lineNum">    4269 </span>                :            :     //we keep track of how many parts each processor is assigned to.
<span class="lineNum">    4270 </span>                :            :     //because in some weird inputs, it might be possible that some
<span class="lineNum">    4271 </span>                :            :     //processors is not assigned to any part. Using these variables,
<span class="lineNum">    4272 </span>                :            :     //we force each processor to have at least one part.
<span class="lineNum">    4273 </span>                :<span class="lineNoCov">          0 :     mj_part_t *num_parts_proc_assigned = allocMemory &lt;mj_part_t&gt;(num_procs);</span>
<span class="lineNum">    4274 </span>                :<span class="lineNoCov">          0 :     memset(num_parts_proc_assigned, 0, sizeof(mj_part_t) * num_procs);</span>
<span class="lineNum">    4275 </span>                :<span class="lineNoCov">          0 :     int empty_proc_count = num_procs;</span>
<span class="lineNum">    4276 </span>                :            : 
<span class="lineNum">    4277 </span>                :            :     //to sort the parts with decreasing order of their coordiantes.
<span class="lineNum">    4278 </span>                :            :     //id are the part numbers, sort value is the number of points in each.
<span class="lineNum">    4279 </span>                :<span class="lineNoCov">          0 :     uSortItem&lt;mj_part_t, mj_gno_t&gt; * sort_item_point_counts_in_parts  = allocMemory &lt;uSortItem&lt;mj_part_t, mj_gno_t&gt; &gt;(num_parts);</span>
<span class="lineNum">    4280 </span>                :            : 
<span class="lineNum">    4281 </span>                :            :     //initially we will sort the parts according to the number of coordinates they have.
<span class="lineNum">    4282 </span>                :            :     //so that we will start assigning with the part that has the most number of coordinates.
<span class="lineNum">    4283 </span>                :<span class="lineNoCov">          0 :     for (mj_part_t i = 0; i &lt; num_parts; ++i){</span>
<span class="lineNum">    4284 </span>                :<span class="lineNoCov">          0 :         sort_item_point_counts_in_parts[i].id = i;</span>
<span class="lineNum">    4285 </span>                :<span class="lineNoCov">          0 :         sort_item_point_counts_in_parts[i].val = global_num_points_in_parts[i];</span>
<span class="lineNum">    4286 </span>                :            :     }
<span class="lineNum">    4287 </span>                :            :     //sort parts with increasing order of loads.
<span class="lineNum">    4288 </span>                :<span class="lineNoCov">          0 :     uqsort&lt;mj_part_t, mj_gno_t&gt;(num_parts, sort_item_point_counts_in_parts);</span>
<span class="lineNum">    4289 </span>                :            : 
<span class="lineNum">    4290 </span>                :            : 
<span class="lineNum">    4291 </span>                :            :     //assigning parts to the processors
<span class="lineNum">    4292 </span>                :            :     //traverse the part win decreasing order of load.
<span class="lineNum">    4293 </span>                :            :     //first assign the heaviest part.
<span class="lineNum">    4294 </span>                :<span class="lineNoCov">          0 :     for (mj_part_t j = 0; j &lt; num_parts; ++j){</span>
<span class="lineNum">    4295 </span>                :            :         //sorted with increasing order, traverse inverse.
<span class="lineNum">    4296 </span>                :<span class="lineNoCov">          0 :         mj_part_t i = sort_item_point_counts_in_parts[num_parts - 1 - j].id;</span>
<span class="lineNum">    4297 </span>                :            :         //load of the part
<span class="lineNum">    4298 </span>                :<span class="lineNoCov">          0 :         mj_gno_t load = global_num_points_in_parts[i];</span>
<span class="lineNum">    4299 </span>                :            : 
<span class="lineNum">    4300 </span>                :            :         //assigned processors
<span class="lineNum">    4301 </span>                :<span class="lineNoCov">          0 :         mj_part_t assigned_proc = -1;</span>
<span class="lineNum">    4302 </span>                :            :         //if not fit best processor.
<span class="lineNum">    4303 </span>                :<span class="lineNoCov">          0 :         mj_part_t best_proc_to_assign = 0;</span>
<span class="lineNum">    4304 </span>                :            : 
<span class="lineNum">    4305 </span>                :            : 
<span class="lineNum">    4306 </span>                :            :         //sort processors with increasing number of points in this part.
<span class="lineNum">    4307 </span>                :<span class="lineNoCov">          0 :         for (mj_part_t ii = 0; ii &lt; num_procs; ++ii){</span>
<span class="lineNum">    4308 </span>                :<span class="lineNoCov">          0 :             sort_item_num_points_of_proc_in_part_i[ii].id = ii;</span>
<span class="lineNum">    4309 </span>                :            : 
<span class="lineNum">    4310 </span>                :            :             //if there are still enough parts to fill empty processors, than proceed normally.
<span class="lineNum">    4311 </span>                :            :             //but if empty processor count is equal to the number of part, then
<span class="lineNum">    4312 </span>                :            :             //we force to part assignments only to empty processors.
<span class="lineNum">    4313 </span>                :<span class="lineNoCov">          0 :             if (empty_proc_count &lt; num_parts - j || num_parts_proc_assigned[ii] == 0){</span>
<span class="lineNum">    4314 </span>                :            :                 //how many points processor ii has in part i?
<span class="lineNum">    4315 </span>                :<span class="lineNoCov">          0 :                 sort_item_num_points_of_proc_in_part_i[ii].val =  num_points_in_all_processor_parts[ii * num_parts + i];</span>
<span class="lineNum">    4316 </span>                :            :             }
<span class="lineNum">    4317 </span>                :            :             else {
<span class="lineNum">    4318 </span>                :<span class="lineNoCov">          0 :                 sort_item_num_points_of_proc_in_part_i[ii].val  = -1;</span>
<span class="lineNum">    4319 </span>                :            :             }
<span class="lineNum">    4320 </span>                :            :         }
<span class="lineNum">    4321 </span>                :<span class="lineNoCov">          0 :         uqsort&lt;mj_part_t, mj_gno_t&gt;(num_procs, sort_item_num_points_of_proc_in_part_i);</span>
<span class="lineNum">    4322 </span>                :            : 
<span class="lineNum">    4323 </span>                :            :         //traverse all processors with decreasing load.
<span class="lineNum">    4324 </span>                :<span class="lineNoCov">          0 :         for (mj_part_t iii = num_procs - 1; iii &gt;= 0; --iii){</span>
<span class="lineNum">    4325 </span>                :<span class="lineNoCov">          0 :             mj_part_t ii = sort_item_num_points_of_proc_in_part_i[iii].id;</span>
<span class="lineNum">    4326 </span>                :<span class="lineNoCov">          0 :             mj_lno_t left_space = space_in_each_processor[ii] - load;</span>
<span class="lineNum">    4327 </span>                :            :             //if enought space, assign to this part.
<span class="lineNum">    4328 </span>                :            :             if(left_space &gt;= 0 ){
<span class="lineNum">    4329 </span>                :<span class="lineNoCov">          0 :                 assigned_proc = ii;</span>
<span class="lineNum">    4330 </span>                :<span class="lineNoCov">          0 :                 break;</span>
<span class="lineNum">    4331 </span>                :            :             }
<span class="lineNum">    4332 </span>                :            :             //if space is not enough, store the best candidate part.
<span class="lineNum">    4333 </span>                :            :             if (space_in_each_processor[best_proc_to_assign] &lt; space_in_each_processor[ii]){
<span class="lineNum">    4334 </span>                :            :                 best_proc_to_assign = ii;
<span class="lineNum">    4335 </span>                :            :             }
<span class="lineNum">    4336 </span>                :            :         }
<span class="lineNum">    4337 </span>                :            : 
<span class="lineNum">    4338 </span>                :            :         //if none had enough space, then assign it to best part.
<span class="lineNum">    4339 </span>                :<span class="lineNoCov">          0 :         if (assigned_proc == -1){</span>
<span class="lineNum">    4340 </span>                :<span class="lineNoCov">          0 :             assigned_proc = best_proc_to_assign;</span>
<span class="lineNum">    4341 </span>                :            :         }
<span class="lineNum">    4342 </span>                :            : 
<span class="lineNum">    4343 </span>                :<span class="lineNoCov">          0 :         if (num_parts_proc_assigned[assigned_proc]++ == 0){</span>
<span class="lineNum">    4344 </span>                :<span class="lineNoCov">          0 :                 --empty_proc_count;</span>
<span class="lineNum">    4345 </span>                :            :         }
<span class="lineNum">    4346 </span>                :<span class="lineNoCov">          0 :         space_in_each_processor[assigned_proc] -= load;</span>
<span class="lineNum">    4347 </span>                :            :         //to sort later, part-i is assigned to the proccessor - assignment.
<span class="lineNum">    4348 </span>                :<span class="lineNoCov">          0 :         sort_item_part_to_proc_assignment[j].id = i; //part i</span>
<span class="lineNum">    4349 </span>                :<span class="lineNoCov">          0 :         sort_item_part_to_proc_assignment[j].val = assigned_proc; //assigned to processor - assignment.</span>
<span class="lineNum">    4350 </span>                :            : 
<span class="lineNum">    4351 </span>                :            : 
<span class="lineNum">    4352 </span>                :            :         //if assigned processor is me, increase the number.
<span class="lineNum">    4353 </span>                :<span class="lineNoCov">          0 :         if (assigned_proc == this-&gt;myRank){</span>
<span class="lineNum">    4354 </span>                :<span class="lineNoCov">          0 :             out_num_part++;//assigned_part_count;</span>
<span class="lineNum">    4355 </span>                :<span class="lineNoCov">          0 :             out_part_indices.push_back(i);</span>
<span class="lineNum">    4356 </span>                :            :         }
<span class="lineNum">    4357 </span>                :            :         //increase the send to that processor by the number of points in that part.
<span class="lineNum">    4358 </span>                :            :         //as everyone send their coordiantes in this part to the processor assigned to this part.
<span class="lineNum">    4359 </span>                :<span class="lineNoCov">          0 :         send_count_to_each_proc[assigned_proc] += num_points_in_all_processor_parts[this-&gt;myRank * num_parts + i];</span>
<span class="lineNum">    4360 </span>                :            :     }
<span class="lineNum">    4361 </span>                :<span class="lineNoCov">          0 :     freeArray&lt;mj_part_t&gt;(num_parts_proc_assigned);</span>
<span class="lineNum">    4362 </span>                :<span class="lineNoCov">          0 :     freeArray&lt; uSortItem&lt;mj_part_t, mj_gno_t&gt; &gt; (sort_item_num_points_of_proc_in_part_i);</span>
<span class="lineNum">    4363 </span>                :<span class="lineNoCov">          0 :     freeArray&lt;uSortItem&lt;mj_part_t, mj_gno_t&gt; &gt;(sort_item_point_counts_in_parts);</span>
<span class="lineNum">    4364 </span>                :<span class="lineNoCov">          0 :     freeArray&lt;mj_lno_t &gt;(space_in_each_processor);</span>
<span class="lineNum">    4365 </span>                :            : 
<span class="lineNum">    4366 </span>                :            : 
<span class="lineNum">    4367 </span>                :            :     //sort assignments with respect to the assigned processors.
<span class="lineNum">    4368 </span>                :<span class="lineNoCov">          0 :     uqsort&lt;mj_part_t, mj_part_t&gt;(num_parts, sort_item_part_to_proc_assignment);</span>
<span class="lineNum">    4369 </span>                :            :     //fill sendBuf.
<span class="lineNum">    4370 </span>                :            : 
<span class="lineNum">    4371 </span>                :            : 
<span class="lineNum">    4372 </span>                :<span class="lineNoCov">          0 :     this-&gt;assign_send_destinations2(</span>
<span class="lineNum">    4373 </span>                :            :             num_parts,
<span class="lineNum">    4374 </span>                :            :             sort_item_part_to_proc_assignment,
<span class="lineNum">    4375 </span>                :            :             coordinate_destinations,
<span class="lineNum">    4376 </span>                :            :             output_part_numbering_begin_index,
<span class="lineNum">    4377 </span>                :            :             next_future_num_parts_in_parts);
<span class="lineNum">    4378 </span>                :            : 
<span class="lineNum">    4379 </span>                :<span class="lineNoCov">          0 :     freeArray&lt;uSortItem&lt;mj_part_t, mj_part_t&gt; &gt;(sort_item_part_to_proc_assignment);</span>
<span class="lineNum">    4380 </span>                :<span class="lineNoCov">          0 : }</span>
<span class="lineNum">    4381 </span>                :            : 
<span class="lineNum">    4382 </span>                :            : 
<span class="lineNum">    4383 </span>                :            : /*! \brief Function fills up coordinate_destinations is the output array
<span class="lineNum">    4384 </span>                :            :  * that holds which part each coordinate should be sent. In addition it calculates
<span class="lineNum">    4385 </span>                :            :  * the shift amount (output_part_numbering_begin_index) to be done when
<span class="lineNum">    4386 </span>                :            :  * final numberings of the parts are performed.
<span class="lineNum">    4387 </span>                :            :  *
<span class="lineNum">    4388 </span>                :            :  * \param num_points_in_all_processor_parts is the array holding the num points in each part in each proc.
<span class="lineNum">    4389 </span>                :            :  * \param num_parts is the number of parts that exist in the current partitioning.
<span class="lineNum">    4390 </span>                :            :  * \param num_procs is the number of processor attending to migration operation.
<span class="lineNum">    4391 </span>                :            : 
<span class="lineNum">    4392 </span>                :            :  * \param send_count_to_each_proc array array storing the number of points to be sent to each part.
<span class="lineNum">    4393 </span>                :            :  * \param processor_ranks_for_subcomm is the ranks of the processors that will be in the subcommunicator with me.
<span class="lineNum">    4394 </span>                :            :  * \param next_future_num_parts_in_parts is the vector, how many more parts each part will be divided into in the future.
<span class="lineNum">    4395 </span>                :            :  * \param out_num_part is the number of parts assigned to the process.
<span class="lineNum">    4396 </span>                :            :  * \param out_part_indices is the indices of the part to which the processor is assigned.
<span class="lineNum">    4397 </span>                :            :  * \param output_part_numbering_begin_index is how much the numbers should be shifted when numbering the result parts.
<span class="lineNum">    4398 </span>                :            :  * \param coordinate_destinations is the output array that holds which part each coordinate should be sent.
<span class="lineNum">    4399 </span>                :            :  */
<a name="4400"><span class="lineNum">    4400 </span>                :            : template &lt;typename mj_scalar_t, typename mj_lno_t, typename mj_gno_t,</a>
<span class="lineNum">    4401 </span>                :            :           typename mj_part_t&gt;
<span class="lineNum">    4402 </span>                :<span class="lineNoCov">          0 : void AlgMJ&lt;mj_scalar_t, mj_lno_t, mj_gno_t, mj_part_t&gt;::mj_migration_part_proc_assignment(</span>
<span class="lineNum">    4403 </span>                :            :     mj_gno_t * num_points_in_all_processor_parts,
<span class="lineNum">    4404 </span>                :            :     mj_part_t num_parts,
<span class="lineNum">    4405 </span>                :            :     mj_part_t num_procs,
<span class="lineNum">    4406 </span>                :            :     mj_lno_t *send_count_to_each_proc,
<span class="lineNum">    4407 </span>                :            :     std::vector&lt;mj_part_t&gt; &amp;processor_ranks_for_subcomm,
<span class="lineNum">    4408 </span>                :            :     std::vector&lt;mj_part_t&gt; *next_future_num_parts_in_parts,
<span class="lineNum">    4409 </span>                :            :     mj_part_t &amp;out_num_part,
<span class="lineNum">    4410 </span>                :            :     std::vector&lt;mj_part_t&gt; &amp;out_part_indices,
<span class="lineNum">    4411 </span>                :            :     mj_part_t &amp;output_part_numbering_begin_index,
<span class="lineNum">    4412 </span>                :            :     int *coordinate_destinations){
<span class="lineNum">    4413 </span>                :            : 
<span class="lineNum">    4414 </span>                :            : 
<span class="lineNum">    4415 </span>                :            : 
<span class="lineNum">    4416 </span>                :<span class="lineNoCov">          0 :         processor_ranks_for_subcomm.clear();</span>
<span class="lineNum">    4417 </span>                :            :         // if (this-&gt;num_local_coords &gt; 0)
<span class="lineNum">    4418 </span>                :<span class="lineNoCov">          0 :         if (num_procs &gt; num_parts){</span>
<span class="lineNum">    4419 </span>                :            :                 //if there are more processors than the number of current part
<span class="lineNum">    4420 </span>                :            :                 //then processors share the existing parts.
<span class="lineNum">    4421 </span>                :            :                 //at the end each processor will have a single part,
<span class="lineNum">    4422 </span>                :            :                 //but a part will be shared by a group of processors.
<span class="lineNum">    4423 </span>                :<span class="lineNoCov">          0 :                 mj_part_t out_part_index = 0;</span>
<span class="lineNum">    4424 </span>                :<span class="lineNoCov">          0 :                 this-&gt;mj_assign_proc_to_parts(</span>
<span class="lineNum">    4425 </span>                :            :                                 num_points_in_all_processor_parts,
<span class="lineNum">    4426 </span>                :            :                                 num_parts,
<span class="lineNum">    4427 </span>                :            :                                 num_procs,
<span class="lineNum">    4428 </span>                :            :                                 send_count_to_each_proc,
<span class="lineNum">    4429 </span>                :            :                                 processor_ranks_for_subcomm,
<span class="lineNum">    4430 </span>                :            :                                 next_future_num_parts_in_parts,
<span class="lineNum">    4431 </span>                :            :                                 out_part_index,
<span class="lineNum">    4432 </span>                :            :                                 output_part_numbering_begin_index,
<span class="lineNum">    4433 </span>                :            :                                 coordinate_destinations
<span class="lineNum">    4434 </span>                :            :                 );
<span class="lineNum">    4435 </span>                :            : 
<span class="lineNum">    4436 </span>                :<span class="lineNoCov">          0 :                 out_num_part = 1;</span>
<span class="lineNum">    4437 </span>                :<span class="lineNoCov">          0 :                 out_part_indices.clear();</span>
<span class="lineNum">    4438 </span>                :<span class="lineNoCov">          0 :                 out_part_indices.push_back(out_part_index);</span>
<span class="lineNum">    4439 </span>                :            :         }
<span class="lineNum">    4440 </span>                :            :         else {
<span class="lineNum">    4441 </span>                :            : 
<span class="lineNum">    4442 </span>                :            :                 //there are more parts than the processors.
<span class="lineNum">    4443 </span>                :            :                 //therefore a processor will be assigned multiple parts,
<span class="lineNum">    4444 </span>                :            :                 //the subcommunicators will only have a single processor.
<span class="lineNum">    4445 </span>                :<span class="lineNoCov">          0 :                 processor_ranks_for_subcomm.push_back(this-&gt;myRank);</span>
<span class="lineNum">    4446 </span>                :            : 
<span class="lineNum">    4447 </span>                :            :                 //since there are more parts then procs,
<span class="lineNum">    4448 </span>                :            :                 //assign multiple parts to processors.
<span class="lineNum">    4449 </span>                :<span class="lineNoCov">          0 :                 this-&gt;mj_assign_parts_to_procs(</span>
<span class="lineNum">    4450 </span>                :            :                                 num_points_in_all_processor_parts,
<span class="lineNum">    4451 </span>                :            :                                 num_parts,
<span class="lineNum">    4452 </span>                :            :                                 num_procs,
<span class="lineNum">    4453 </span>                :            :                                 send_count_to_each_proc,
<span class="lineNum">    4454 </span>                :            :                                 next_future_num_parts_in_parts,
<span class="lineNum">    4455 </span>                :            :                                 out_num_part,
<span class="lineNum">    4456 </span>                :            :                                 out_part_indices,
<span class="lineNum">    4457 </span>                :            :                                 output_part_numbering_begin_index,
<span class="lineNum">    4458 </span>                :            :                                 coordinate_destinations);
<span class="lineNum">    4459 </span>                :            :         }
<span class="lineNum">    4460 </span>                :<span class="lineNoCov">          0 : }</span>
<span class="lineNum">    4461 </span>                :            : 
<span class="lineNum">    4462 </span>                :            : /*! \brief Function fills up coordinate_destinations is the output array
<span class="lineNum">    4463 </span>                :            :  * that holds which part each coordinate should be sent. In addition it calculates
<span class="lineNum">    4464 </span>                :            :  * the shift amount (output_part_numbering_begin_index) to be done when
<span class="lineNum">    4465 </span>                :            :  * final numberings of the parts are performed.
<span class="lineNum">    4466 </span>                :            :  *
<span class="lineNum">    4467 </span>                :            :  *
<span class="lineNum">    4468 </span>                :            :  * \param num_procs is the number of processor attending to migration operation.
<span class="lineNum">    4469 </span>                :            :  * \param num_new_local_points is the output to represent the new number of local points.
<span class="lineNum">    4470 </span>                :            :  * \param iteration is the string for the current iteration.
<span class="lineNum">    4471 </span>                :            :  * \param coordinate_destinations is the output array that holds which part each coordinate should be sent.
<span class="lineNum">    4472 </span>                :            :  * \param num_parts is the number of parts that exist in the current partitioning.
<span class="lineNum">    4473 </span>                :            :  */
<a name="4474"><span class="lineNum">    4474 </span>                :            : template &lt;typename mj_scalar_t, typename mj_lno_t, typename mj_gno_t,</a>
<span class="lineNum">    4475 </span>                :            :           typename mj_part_t&gt;
<span class="lineNum">    4476 </span>                :<span class="lineNoCov">          0 : void AlgMJ&lt;mj_scalar_t, mj_lno_t, mj_gno_t, mj_part_t&gt;::mj_migrate_coords(</span>
<span class="lineNum">    4477 </span>                :            :     mj_part_t num_procs,
<span class="lineNum">    4478 </span>                :            :     mj_lno_t &amp;num_new_local_points,
<span class="lineNum">    4479 </span>                :            :     std::string iteration,
<span class="lineNum">    4480 </span>                :            :     int *coordinate_destinations,
<span class="lineNum">    4481 </span>                :            :     mj_part_t num_parts)
<span class="lineNum">    4482 </span>                :            : {
<span class="lineNum">    4483 </span>                :            : #ifdef ENABLE_ZOLTAN_MIGRATION
<span class="lineNum">    4484 </span>                :            :     if (sizeof(mj_lno_t) &lt;= sizeof(int)) {
<span class="lineNum">    4485 </span>                :            : 
<span class="lineNum">    4486 </span>                :            :         // Cannot use Zoltan_Comm with local ordinals larger than ints.
<span class="lineNum">    4487 </span>                :            :         // In Zoltan_Comm_Create, the cast int(this-&gt;num_local_coords)
<span class="lineNum">    4488 </span>                :            :         // may overflow.
<span class="lineNum">    4489 </span>                :            : 
<span class="lineNum">    4490 </span>                :            :         ZOLTAN_COMM_OBJ *plan = NULL;
<span class="lineNum">    4491 </span>                :            :         MPI_Comm mpi_comm = Teuchos2MPI (this-&gt;comm);
<span class="lineNum">    4492 </span>                :            :         int num_incoming_gnos = 0;
<span class="lineNum">    4493 </span>                :            :         int message_tag = 7859;
<span class="lineNum">    4494 </span>                :            : 
<span class="lineNum">    4495 </span>                :            :         this-&gt;mj_env-&gt;timerStart(MACRO_TIMERS, &quot;MultiJagged - Migration Z1PlanCreating-&quot; + iteration);
<span class="lineNum">    4496 </span>                :            :         int ierr = Zoltan_Comm_Create(
<span class="lineNum">    4497 </span>                :            :                         &amp;plan,
<span class="lineNum">    4498 </span>                :            :                         int(this-&gt;num_local_coords),
<span class="lineNum">    4499 </span>                :            :                         coordinate_destinations,
<span class="lineNum">    4500 </span>                :            :                         mpi_comm,
<span class="lineNum">    4501 </span>                :            :                         message_tag,
<span class="lineNum">    4502 </span>                :            :                         &amp;num_incoming_gnos);
<span class="lineNum">    4503 </span>                :            :         Z2_ASSERT_VALUE(ierr, ZOLTAN_OK);
<span class="lineNum">    4504 </span>                :            :         this-&gt;mj_env-&gt;timerStop(MACRO_TIMERS, &quot;MultiJagged - Migration Z1PlanCreating-&quot; + iteration);
<span class="lineNum">    4505 </span>                :            : 
<span class="lineNum">    4506 </span>                :            :         this-&gt;mj_env-&gt;timerStart(MACRO_TIMERS, &quot;MultiJagged - Migration Z1Migration-&quot; + iteration);
<span class="lineNum">    4507 </span>                :            :         mj_gno_t *incoming_gnos = allocMemory&lt; mj_gno_t&gt;(num_incoming_gnos);
<span class="lineNum">    4508 </span>                :            : 
<span class="lineNum">    4509 </span>                :            :         //migrate gnos.
<span class="lineNum">    4510 </span>                :            :         message_tag++;
<span class="lineNum">    4511 </span>                :            :         ierr = Zoltan_Comm_Do(
<span class="lineNum">    4512 </span>                :            :                         plan,
<span class="lineNum">    4513 </span>                :            :                         message_tag,
<span class="lineNum">    4514 </span>                :            :                         (char *) this-&gt;current_mj_gnos,
<span class="lineNum">    4515 </span>                :            :                         sizeof(mj_gno_t),
<span class="lineNum">    4516 </span>                :            :                         (char *) incoming_gnos);
<span class="lineNum">    4517 </span>                :            :         Z2_ASSERT_VALUE(ierr, ZOLTAN_OK);
<span class="lineNum">    4518 </span>                :            : 
<span class="lineNum">    4519 </span>                :            :         freeArray&lt;mj_gno_t&gt;(this-&gt;current_mj_gnos);
<span class="lineNum">    4520 </span>                :            :         this-&gt;current_mj_gnos = incoming_gnos;
<span class="lineNum">    4521 </span>                :            : 
<span class="lineNum">    4522 </span>                :            : 
<span class="lineNum">    4523 </span>                :            :         //migrate coordinates
<span class="lineNum">    4524 </span>                :            :         for (int i = 0; i &lt; this-&gt;coord_dim; ++i){
<span class="lineNum">    4525 </span>                :            :                 message_tag++;
<span class="lineNum">    4526 </span>                :            :                 mj_scalar_t *coord = this-&gt;mj_coordinates[i];
<span class="lineNum">    4527 </span>                :            : 
<span class="lineNum">    4528 </span>                :            :                 this-&gt;mj_coordinates[i] = allocMemory&lt;mj_scalar_t&gt;(num_incoming_gnos);
<span class="lineNum">    4529 </span>                :            :                 ierr = Zoltan_Comm_Do(
<span class="lineNum">    4530 </span>                :            :                                 plan,
<span class="lineNum">    4531 </span>                :            :                                 message_tag,
<span class="lineNum">    4532 </span>                :            :                                 (char *) coord,
<span class="lineNum">    4533 </span>                :            :                                 sizeof(mj_scalar_t),
<span class="lineNum">    4534 </span>                :            :                                 (char *) this-&gt;mj_coordinates[i]);
<span class="lineNum">    4535 </span>                :            :                 Z2_ASSERT_VALUE(ierr, ZOLTAN_OK);
<span class="lineNum">    4536 </span>                :            :                 freeArray&lt;mj_scalar_t&gt;(coord);
<span class="lineNum">    4537 </span>                :            :         }
<span class="lineNum">    4538 </span>                :            : 
<span class="lineNum">    4539 </span>                :            :         //migrate weights.
<span class="lineNum">    4540 </span>                :            :         for (int i = 0; i &lt; this-&gt;num_weights_per_coord; ++i){
<span class="lineNum">    4541 </span>                :            :                 message_tag++;
<span class="lineNum">    4542 </span>                :            :                 mj_scalar_t *weight = this-&gt;mj_weights[i];
<span class="lineNum">    4543 </span>                :            : 
<span class="lineNum">    4544 </span>                :            :                 this-&gt;mj_weights[i] = allocMemory&lt;mj_scalar_t&gt;(num_incoming_gnos);
<span class="lineNum">    4545 </span>                :            :                 ierr = Zoltan_Comm_Do(
<span class="lineNum">    4546 </span>                :            :                                 plan,
<span class="lineNum">    4547 </span>                :            :                                 message_tag,
<span class="lineNum">    4548 </span>                :            :                                 (char *) weight,
<span class="lineNum">    4549 </span>                :            :                                 sizeof(mj_scalar_t),
<span class="lineNum">    4550 </span>                :            :                                 (char *) this-&gt;mj_weights[i]);
<span class="lineNum">    4551 </span>                :            :                 Z2_ASSERT_VALUE(ierr, ZOLTAN_OK);
<span class="lineNum">    4552 </span>                :            :                 freeArray&lt;mj_scalar_t&gt;(weight);
<span class="lineNum">    4553 </span>                :            :         }
<span class="lineNum">    4554 </span>                :            : 
<span class="lineNum">    4555 </span>                :            : 
<span class="lineNum">    4556 </span>                :            :         //migrate owners.
<span class="lineNum">    4557 </span>                :            :         int *coord_own = allocMemory&lt;int&gt;(num_incoming_gnos);
<span class="lineNum">    4558 </span>                :            :         message_tag++;
<span class="lineNum">    4559 </span>                :            :         ierr = Zoltan_Comm_Do(
<span class="lineNum">    4560 </span>                :            :                         plan,
<span class="lineNum">    4561 </span>                :            :                         message_tag,
<span class="lineNum">    4562 </span>                :            :                         (char *) this-&gt;owner_of_coordinate,
<span class="lineNum">    4563 </span>                :            :                         sizeof(int), (char *) coord_own);
<span class="lineNum">    4564 </span>                :            :         Z2_ASSERT_VALUE(ierr, ZOLTAN_OK);
<span class="lineNum">    4565 </span>                :            :         freeArray&lt;int&gt;(this-&gt;owner_of_coordinate);
<span class="lineNum">    4566 </span>                :            :         this-&gt;owner_of_coordinate = coord_own;
<span class="lineNum">    4567 </span>                :            : 
<span class="lineNum">    4568 </span>                :            : 
<span class="lineNum">    4569 </span>                :            :         //if num procs is less than num parts,
<span class="lineNum">    4570 </span>                :            :         //we need the part assigment arrays as well, since
<span class="lineNum">    4571 </span>                :            :         //there will be multiple parts in processor.
<span class="lineNum">    4572 </span>                :            :         mj_part_t *new_parts = allocMemory&lt;mj_part_t&gt;(num_incoming_gnos);
<span class="lineNum">    4573 </span>                :            :         if(num_procs &lt; num_parts){
<span class="lineNum">    4574 </span>                :            :                 message_tag++;
<span class="lineNum">    4575 </span>                :            :                 ierr = Zoltan_Comm_Do(
<span class="lineNum">    4576 </span>                :            :                                 plan,
<span class="lineNum">    4577 </span>                :            :                                 message_tag,
<span class="lineNum">    4578 </span>                :            :                                 (char *) this-&gt;assigned_part_ids,
<span class="lineNum">    4579 </span>                :            :                                 sizeof(mj_part_t),
<span class="lineNum">    4580 </span>                :            :                                 (char *) new_parts);
<span class="lineNum">    4581 </span>                :            :                 Z2_ASSERT_VALUE(ierr, ZOLTAN_OK);
<span class="lineNum">    4582 </span>                :            :         }
<span class="lineNum">    4583 </span>                :            :         freeArray&lt;mj_part_t&gt;(this-&gt;assigned_part_ids);
<span class="lineNum">    4584 </span>                :            :         this-&gt;assigned_part_ids = new_parts;
<span class="lineNum">    4585 </span>                :            : 
<span class="lineNum">    4586 </span>                :            :         ierr = Zoltan_Comm_Destroy(&amp;plan);
<span class="lineNum">    4587 </span>                :            :         Z2_ASSERT_VALUE(ierr, ZOLTAN_OK);
<span class="lineNum">    4588 </span>                :            :         num_new_local_points = num_incoming_gnos;
<span class="lineNum">    4589 </span>                :            :         this-&gt;mj_env-&gt;timerStop(MACRO_TIMERS, &quot;MultiJagged - Migration Z1Migration-&quot; + iteration);
<span class="lineNum">    4590 </span>                :            :     }
<span class="lineNum">    4591 </span>                :            : 
<span class="lineNum">    4592 </span>                :            :     else
<span class="lineNum">    4593 </span>                :            : 
<span class="lineNum">    4594 </span>                :            : #endif  // ENABLE_ZOLTAN_MIGRATION
<span class="lineNum">    4595 </span>                :            :     {
<span class="lineNum">    4596 </span>                :<span class="lineNoCov">          0 :         this-&gt;mj_env-&gt;timerStart(MACRO_TIMERS, &quot;MultiJagged - Migration DistributorPlanCreating-&quot; + iteration);</span>
<span class="lineNum">    4597 </span>                :<span class="lineNoCov">          0 :         Tpetra::Distributor distributor(this-&gt;comm);</span>
<span class="lineNum">    4598 </span>                :<span class="lineNoCov">          0 :         ArrayView&lt;const mj_part_t&gt; destinations( coordinate_destinations, this-&gt;num_local_coords);</span>
<span class="lineNum">    4599 </span>                :<span class="lineNoCov">          0 :         mj_lno_t num_incoming_gnos = distributor.createFromSends(destinations);</span>
<span class="lineNum">    4600 </span>                :<span class="lineNoCov">          0 :         this-&gt;mj_env-&gt;timerStop(MACRO_TIMERS, &quot;MultiJagged - Migration DistributorPlanCreating-&quot; + iteration);</span>
<span class="lineNum">    4601 </span>                :            : 
<span class="lineNum">    4602 </span>                :<span class="lineNoCov">          0 :         this-&gt;mj_env-&gt;timerStart(MACRO_TIMERS, &quot;MultiJagged - Migration DistributorMigration-&quot; + iteration);</span>
<span class="lineNum">    4603 </span>                :            :         {
<span class="lineNum">    4604 </span>                :            :                 //migrate gnos.
<span class="lineNum">    4605 </span>                :<span class="lineNoCov">          0 :                 ArrayRCP&lt;mj_gno_t&gt; received_gnos(num_incoming_gnos);</span>
<span class="lineNum">    4606 </span>                :<span class="lineNoCov">          0 :                 ArrayView&lt;mj_gno_t&gt; sent_gnos(this-&gt;current_mj_gnos, this-&gt;num_local_coords);</span>
<span class="lineNum">    4607 </span>                :<span class="lineNoCov">          0 :                 distributor.doPostsAndWaits&lt;mj_gno_t&gt;(sent_gnos, 1, received_gnos());</span>
<span class="lineNum">    4608 </span>                :<span class="lineNoCov">          0 :                 freeArray&lt;mj_gno_t&gt;(this-&gt;current_mj_gnos);</span>
<span class="lineNum">    4609 </span>                :<span class="lineNoCov">          0 :                 this-&gt;current_mj_gnos = allocMemory&lt;mj_gno_t&gt;(num_incoming_gnos);</span>
<span class="lineNum">    4610 </span>                :<span class="lineNoCov">          0 :                 memcpy(</span>
<span class="lineNum">    4611 </span>                :            :                                 this-&gt;current_mj_gnos,
<span class="lineNum">    4612 </span>                :            :                                 received_gnos.getRawPtr(),
<span class="lineNum">    4613 </span>                :            :                                 num_incoming_gnos * sizeof(mj_gno_t));
<span class="lineNum">    4614 </span>                :            :         }
<span class="lineNum">    4615 </span>                :            :         //migrate coordinates
<span class="lineNum">    4616 </span>                :<span class="lineNoCov">          0 :         for (int i = 0; i &lt; this-&gt;coord_dim; ++i){</span>
<span class="lineNum">    4617 </span>                :            : 
<span class="lineNum">    4618 </span>                :<span class="lineNoCov">          0 :                 ArrayView&lt;mj_scalar_t&gt; sent_coord(this-&gt;mj_coordinates[i], this-&gt;num_local_coords);</span>
<span class="lineNum">    4619 </span>                :<span class="lineNoCov">          0 :                 ArrayRCP&lt;mj_scalar_t&gt; received_coord(num_incoming_gnos);</span>
<span class="lineNum">    4620 </span>                :<span class="lineNoCov">          0 :                 distributor.doPostsAndWaits&lt;mj_scalar_t&gt;(sent_coord, 1, received_coord());</span>
<span class="lineNum">    4621 </span>                :<span class="lineNoCov">          0 :                 freeArray&lt;mj_scalar_t&gt;(this-&gt;mj_coordinates[i]);</span>
<span class="lineNum">    4622 </span>                :<span class="lineNoCov">          0 :                 this-&gt;mj_coordinates[i] = allocMemory&lt;mj_scalar_t&gt;(num_incoming_gnos);</span>
<span class="lineNum">    4623 </span>                :<span class="lineNoCov">          0 :                 memcpy(</span>
<span class="lineNum">    4624 </span>                :<span class="lineNoCov">          0 :                                 this-&gt;mj_coordinates[i],</span>
<span class="lineNum">    4625 </span>                :            :                                 received_coord.getRawPtr(),
<span class="lineNum">    4626 </span>                :            :                                 num_incoming_gnos * sizeof(mj_scalar_t));
<span class="lineNum">    4627 </span>                :            :         }
<span class="lineNum">    4628 </span>                :            : 
<span class="lineNum">    4629 </span>                :            :         //migrate weights.
<span class="lineNum">    4630 </span>                :<span class="lineNoCov">          0 :         for (int i = 0; i &lt; this-&gt;num_weights_per_coord; ++i){</span>
<span class="lineNum">    4631 </span>                :            : 
<span class="lineNum">    4632 </span>                :<span class="lineNoCov">          0 :                 ArrayView&lt;mj_scalar_t&gt; sent_weight(this-&gt;mj_weights[i], this-&gt;num_local_coords);</span>
<span class="lineNum">    4633 </span>                :<span class="lineNoCov">          0 :                 ArrayRCP&lt;mj_scalar_t&gt; received_weight(num_incoming_gnos);</span>
<span class="lineNum">    4634 </span>                :<span class="lineNoCov">          0 :                 distributor.doPostsAndWaits&lt;mj_scalar_t&gt;(sent_weight, 1, received_weight());</span>
<span class="lineNum">    4635 </span>                :<span class="lineNoCov">          0 :                 freeArray&lt;mj_scalar_t&gt;(this-&gt;mj_weights[i]);</span>
<span class="lineNum">    4636 </span>                :<span class="lineNoCov">          0 :                 this-&gt;mj_weights[i] = allocMemory&lt;mj_scalar_t&gt;(num_incoming_gnos);</span>
<span class="lineNum">    4637 </span>                :<span class="lineNoCov">          0 :                 memcpy(</span>
<span class="lineNum">    4638 </span>                :<span class="lineNoCov">          0 :                                 this-&gt;mj_weights[i],</span>
<span class="lineNum">    4639 </span>                :            :                                 received_weight.getRawPtr(),
<span class="lineNum">    4640 </span>                :            :                                 num_incoming_gnos * sizeof(mj_scalar_t));
<span class="lineNum">    4641 </span>                :            :         }
<span class="lineNum">    4642 </span>                :            : 
<span class="lineNum">    4643 </span>                :            :         {
<span class="lineNum">    4644 </span>                :            :                 //migrate the owners of the coordinates
<span class="lineNum">    4645 </span>                :<span class="lineNoCov">          0 :                 ArrayView&lt;int&gt; sent_owners(this-&gt;owner_of_coordinate, this-&gt;num_local_coords);</span>
<span class="lineNum">    4646 </span>                :<span class="lineNoCov">          0 :                 ArrayRCP&lt;int&gt; received_owners(num_incoming_gnos);</span>
<span class="lineNum">    4647 </span>                :<span class="lineNoCov">          0 :                 distributor.doPostsAndWaits&lt;int&gt;(sent_owners, 1, received_owners());</span>
<span class="lineNum">    4648 </span>                :<span class="lineNoCov">          0 :                 freeArray&lt;int&gt;(this-&gt;owner_of_coordinate);</span>
<span class="lineNum">    4649 </span>                :<span class="lineNoCov">          0 :                 this-&gt;owner_of_coordinate = allocMemory&lt;int&gt;(num_incoming_gnos);</span>
<span class="lineNum">    4650 </span>                :<span class="lineNoCov">          0 :                 memcpy(</span>
<span class="lineNum">    4651 </span>                :            :                                                 this-&gt;owner_of_coordinate,
<span class="lineNum">    4652 </span>                :<span class="lineNoCov">          0 :                                                 received_owners.getRawPtr(),</span>
<span class="lineNum">    4653 </span>                :            :                                                 num_incoming_gnos * sizeof(int));
<span class="lineNum">    4654 </span>                :            :         }
<span class="lineNum">    4655 </span>                :            : 
<span class="lineNum">    4656 </span>                :            :         //if num procs is less than num parts,
<span class="lineNum">    4657 </span>                :            :         //we need the part assigment arrays as well, since
<span class="lineNum">    4658 </span>                :            :         //there will be multiple parts in processor.
<span class="lineNum">    4659 </span>                :<span class="lineNoCov">          0 :         if(num_procs &lt; num_parts){</span>
<span class="lineNum">    4660 </span>                :<span class="lineNoCov">          0 :                 ArrayView&lt;mj_part_t&gt; sent_partids(this-&gt;assigned_part_ids, this-&gt;num_local_coords);</span>
<span class="lineNum">    4661 </span>                :<span class="lineNoCov">          0 :                 ArrayRCP&lt;mj_part_t&gt; received_partids(num_incoming_gnos);</span>
<span class="lineNum">    4662 </span>                :<span class="lineNoCov">          0 :                 distributor.doPostsAndWaits&lt;mj_part_t&gt;(sent_partids, 1, received_partids());</span>
<span class="lineNum">    4663 </span>                :<span class="lineNoCov">          0 :                 freeArray&lt;mj_part_t&gt;(this-&gt;assigned_part_ids);</span>
<span class="lineNum">    4664 </span>                :<span class="lineNoCov">          0 :                 this-&gt;assigned_part_ids = allocMemory&lt;mj_part_t&gt;(num_incoming_gnos);</span>
<span class="lineNum">    4665 </span>                :<span class="lineNoCov">          0 :                 memcpy(</span>
<span class="lineNum">    4666 </span>                :            :                                 this-&gt;assigned_part_ids,
<span class="lineNum">    4667 </span>                :            :                                 received_partids.getRawPtr(),
<span class="lineNum">    4668 </span>                :            :                                 num_incoming_gnos * sizeof(mj_part_t));
<span class="lineNum">    4669 </span>                :            :         }
<span class="lineNum">    4670 </span>                :            :         else {
<span class="lineNum">    4671 </span>                :<span class="lineNoCov">          0 :                 mj_part_t *new_parts = allocMemory&lt;int&gt;(num_incoming_gnos);</span>
<span class="lineNum">    4672 </span>                :<span class="lineNoCov">          0 :                 freeArray&lt;mj_part_t&gt;(this-&gt;assigned_part_ids);</span>
<span class="lineNum">    4673 </span>                :<span class="lineNoCov">          0 :                 this-&gt;assigned_part_ids = new_parts;</span>
<span class="lineNum">    4674 </span>                :            :         }
<span class="lineNum">    4675 </span>                :<span class="lineNoCov">          0 :         this-&gt;mj_env-&gt;timerStop(MACRO_TIMERS, &quot;MultiJagged - Migration DistributorMigration-&quot; + iteration);</span>
<span class="lineNum">    4676 </span>                :<span class="lineNoCov">          0 :         num_new_local_points = num_incoming_gnos;</span>
<span class="lineNum">    4677 </span>                :            : 
<span class="lineNum">    4678 </span>                :            :     }
<span class="lineNum">    4679 </span>                :<span class="lineNoCov">          0 : }</span>
<span class="lineNum">    4680 </span>                :            : 
<span class="lineNum">    4681 </span>                :            : /*! \brief Function creates the new subcomminicator for the processors
<span class="lineNum">    4682 </span>                :            :  * given in processor_ranks_for_subcomm.
<span class="lineNum">    4683 </span>                :            :  *
<span class="lineNum">    4684 </span>                :            :  * \param processor_ranks_for_subcomm is the vector that has the ranks of
<span class="lineNum">    4685 </span>                :            :  * the processors that will be in the same group.
<span class="lineNum">    4686 </span>                :            :  */
<a name="4687"><span class="lineNum">    4687 </span>                :            : template &lt;typename mj_scalar_t, typename mj_lno_t, typename mj_gno_t,</a>
<span class="lineNum">    4688 </span>                :            :           typename mj_part_t&gt;
<span class="lineNum">    4689 </span>                :<span class="lineNoCov">          0 : void AlgMJ&lt;mj_scalar_t, mj_lno_t, mj_gno_t, mj_part_t&gt;::create_sub_communicator(std::vector&lt;mj_part_t&gt; &amp;processor_ranks_for_subcomm){</span>
<span class="lineNum">    4690 </span>                :<span class="lineNoCov">          0 :     mj_part_t group_size = processor_ranks_for_subcomm.size();</span>
<span class="lineNum">    4691 </span>                :<span class="lineNoCov">          0 :     mj_part_t *ids = allocMemory&lt;mj_part_t&gt;(group_size);</span>
<span class="lineNum">    4692 </span>                :<span class="lineNoCov">          0 :     for(mj_part_t i = 0; i &lt; group_size; ++i) {</span>
<span class="lineNum">    4693 </span>                :<span class="lineNoCov">          0 :         ids[i] = processor_ranks_for_subcomm[i];</span>
<span class="lineNum">    4694 </span>                :            :     }
<span class="lineNum">    4695 </span>                :<span class="lineNoCov">          0 :     ArrayView&lt;const mj_part_t&gt; idView(ids, group_size);</span>
<span class="lineNum">    4696 </span>                :<span class="lineNoCov">          0 :     this-&gt;comm = this-&gt;comm-&gt;createSubcommunicator(idView);</span>
<span class="lineNum">    4697 </span>                :<span class="lineNoCov">          0 :     freeArray&lt;mj_part_t&gt;(ids);</span>
<span class="lineNum">    4698 </span>                :<span class="lineNoCov">          0 : }</span>
<span class="lineNum">    4699 </span>                :            : 
<span class="lineNum">    4700 </span>                :            : 
<span class="lineNum">    4701 </span>                :            : /*! \brief Function writes the new permutation arrays after the migration.
<span class="lineNum">    4702 </span>                :            :  *
<span class="lineNum">    4703 </span>                :            :  * \param output_num_parts is the number of parts that is assigned to the processor.
<span class="lineNum">    4704 </span>                :            :  * \param num_parts is the number of parts right before migration.
<span class="lineNum">    4705 </span>                :            :  */
<a name="4706"><span class="lineNum">    4706 </span>                :            : template &lt;typename mj_scalar_t, typename mj_lno_t, typename mj_gno_t,</a>
<span class="lineNum">    4707 </span>                :            :           typename mj_part_t&gt;
<span class="lineNum">    4708 </span>                :<span class="lineNoCov">          0 : void AlgMJ&lt;mj_scalar_t, mj_lno_t, mj_gno_t, mj_part_t&gt;::fill_permutation_array(</span>
<span class="lineNum">    4709 </span>                :            :     mj_part_t output_num_parts,
<span class="lineNum">    4710 </span>                :            :     mj_part_t num_parts){
<span class="lineNum">    4711 </span>                :            :         //if there is single output part, then simply fill the permutation array.
<span class="lineNum">    4712 </span>                :<span class="lineNoCov">          0 :     if (output_num_parts == 1){</span>
<span class="lineNum">    4713 </span>                :<span class="lineNoCov">          0 :         for(mj_lno_t i = 0; i &lt; this-&gt;num_local_coords; ++i){</span>
<span class="lineNum">    4714 </span>                :<span class="lineNoCov">          0 :             this-&gt;new_coordinate_permutations[i] = i;</span>
<span class="lineNum">    4715 </span>                :            :         }
<span class="lineNum">    4716 </span>                :<span class="lineNoCov">          0 :         this-&gt;new_part_xadj[0] = this-&gt;num_local_coords;</span>
<span class="lineNum">    4717 </span>                :            :     }
<span class="lineNum">    4718 </span>                :            :     else {
<span class="lineNum">    4719 </span>                :            : 
<span class="lineNum">    4720 </span>                :            :         //otherwise we need to count how many points are there in each part.
<span class="lineNum">    4721 </span>                :            :         //we allocate here as num_parts, because the sent partids are up to num_parts,
<span class="lineNum">    4722 </span>                :            :         //although there are outout_num_parts different part.
<span class="lineNum">    4723 </span>                :<span class="lineNoCov">          0 :         mj_lno_t *num_points_in_parts = allocMemory&lt;mj_lno_t&gt;(num_parts);</span>
<span class="lineNum">    4724 </span>                :            :         //part shift holds the which part number an old part number corresponds to.
<span class="lineNum">    4725 </span>                :<span class="lineNoCov">          0 :         mj_part_t *part_shifts = allocMemory&lt;mj_part_t&gt;(num_parts);</span>
<span class="lineNum">    4726 </span>                :            : 
<span class="lineNum">    4727 </span>                :<span class="lineNoCov">          0 :         memset(num_points_in_parts, 0, sizeof(mj_lno_t) * num_parts);</span>
<span class="lineNum">    4728 </span>                :            : 
<span class="lineNum">    4729 </span>                :<span class="lineNoCov">          0 :         for(mj_lno_t i = 0; i &lt; this-&gt;num_local_coords; ++i){</span>
<span class="lineNum">    4730 </span>                :<span class="lineNoCov">          0 :             mj_part_t ii = this-&gt;assigned_part_ids[i];</span>
<span class="lineNum">    4731 </span>                :<span class="lineNoCov">          0 :             ++num_points_in_parts[ii];</span>
<span class="lineNum">    4732 </span>                :            :         }
<span class="lineNum">    4733 </span>                :            : 
<span class="lineNum">    4734 </span>                :            :         //write the end points of the parts.
<span class="lineNum">    4735 </span>                :<span class="lineNoCov">          0 :         mj_part_t p = 0;</span>
<span class="lineNum">    4736 </span>                :<span class="lineNoCov">          0 :         mj_lno_t prev_index = 0;</span>
<span class="lineNum">    4737 </span>                :<span class="lineNoCov">          0 :         for(mj_part_t i = 0; i &lt; num_parts; ++i){</span>
<span class="lineNum">    4738 </span>                :<span class="lineNoCov">          0 :             if(num_points_in_parts[i] &gt; 0)  {</span>
<span class="lineNum">    4739 </span>                :<span class="lineNoCov">          0 :                 this-&gt;new_part_xadj[p] =  prev_index + num_points_in_parts[i];</span>
<span class="lineNum">    4740 </span>                :<span class="lineNoCov">          0 :                 prev_index += num_points_in_parts[i];</span>
<span class="lineNum">    4741 </span>                :<span class="lineNoCov">          0 :                 part_shifts[i] = p++;</span>
<span class="lineNum">    4742 </span>                :            :             }
<span class="lineNum">    4743 </span>                :            :         }
<span class="lineNum">    4744 </span>                :            : 
<span class="lineNum">    4745 </span>                :            :         //for the rest of the parts write the end index as end point.
<span class="lineNum">    4746 </span>                :<span class="lineNoCov">          0 :         mj_part_t assigned_num_parts = p - 1;</span>
<span class="lineNum">    4747 </span>                :<span class="lineNoCov">          0 :         for (;p &lt; num_parts; ++p){</span>
<span class="lineNum">    4748 </span>                :<span class="lineNoCov">          0 :             this-&gt;new_part_xadj[p] =  this-&gt;new_part_xadj[assigned_num_parts];</span>
<span class="lineNum">    4749 </span>                :            :         }
<span class="lineNum">    4750 </span>                :<span class="lineNoCov">          0 :         for(mj_part_t i = 0; i &lt; output_num_parts; ++i){</span>
<span class="lineNum">    4751 </span>                :<span class="lineNoCov">          0 :             num_points_in_parts[i] = this-&gt;new_part_xadj[i];</span>
<span class="lineNum">    4752 </span>                :            :         }
<span class="lineNum">    4753 </span>                :            : 
<span class="lineNum">    4754 </span>                :            :         //write the permutation array here.
<span class="lineNum">    4755 </span>                :            :         //get the part of the coordinate i, shift it to obtain the new part number.
<span class="lineNum">    4756 </span>                :            :         //assign it to the end of the new part numbers pointer.
<span class="lineNum">    4757 </span>                :<span class="lineNoCov">          0 :         for(mj_lno_t i = this-&gt;num_local_coords - 1; i &gt;= 0; --i){</span>
<span class="lineNum">    4758 </span>                :<span class="lineNoCov">          0 :             mj_part_t part = part_shifts[mj_part_t(this-&gt;assigned_part_ids[i])];</span>
<span class="lineNum">    4759 </span>                :<span class="lineNoCov">          0 :             this-&gt;new_coordinate_permutations[--num_points_in_parts[part]] = i;</span>
<span class="lineNum">    4760 </span>                :            :         }
<span class="lineNum">    4761 </span>                :            : 
<span class="lineNum">    4762 </span>                :            :         freeArray&lt;mj_lno_t&gt;(num_points_in_parts);
<span class="lineNum">    4763 </span>                :            :         freeArray&lt;mj_part_t&gt;(part_shifts);
<span class="lineNum">    4764 </span>                :            :     }
<span class="lineNum">    4765 </span>                :<span class="lineNoCov">          0 : }</span>
<span class="lineNum">    4766 </span>                :            : 
<span class="lineNum">    4767 </span>                :            : 
<span class="lineNum">    4768 </span>                :            : /*! \brief Function checks if should do migration or not.
<span class="lineNum">    4769 </span>                :            :  * It returns true to point that migration should be done when
<span class="lineNum">    4770 </span>                :            :  * -migration_reduce_all_population are higher than a predetermined value
<span class="lineNum">    4771 </span>                :            :  * -num_coords_for_last_dim_part that left for the last dimension partitioning is less than a predetermined value
<span class="lineNum">    4772 </span>                :            :  * -the imbalance of the processors on the parts are higher than given threshold.
<span class="lineNum">    4773 </span>                :            : 
<span class="lineNum">    4774 </span>                :            :  * \param input_num_parts is the number of parts when migration is called.
<span class="lineNum">    4775 </span>                :            :  * \param output_num_parts is the output number of parts after migration.
<span class="lineNum">    4776 </span>                :            :  * \param next_future_num_parts_in_parts is the number of total future parts each
<span class="lineNum">    4777 </span>                :            :  * part is partitioned into. This will be updated when migration is performed.
<span class="lineNum">    4778 </span>                :            :  * \param output_part_begin_index is the number that will be used as beginning part number
<span class="lineNum">    4779 </span>                :            :  * when final solution part numbers are assigned.
<span class="lineNum">    4780 </span>                :            :  * \param migration_reduce_all_population is the estimated total number of reduceall operations
<span class="lineNum">    4781 </span>                :            :  * multiplied with number of processors to be used for determining migration.
<span class="lineNum">    4782 </span>                :            :  *
<span class="lineNum">    4783 </span>                :            :  * \param num_coords_for_last_dim_part is the estimated number of points in each part,
<span class="lineNum">    4784 </span>                :            :  * when last dimension partitioning is performed.
<span class="lineNum">    4785 </span>                :            :  * \param iteration is the string that gives information about the dimension for printing purposes.
<span class="lineNum">    4786 </span>                :            :  * \param input_part_boxes is the array that holds the part boxes after the migration. (swapped)
<span class="lineNum">    4787 </span>                :            :  * \param output_part_boxes is the array that holds the part boxes before the migration. (swapped)
<span class="lineNum">    4788 </span>                :            :  *
<span class="lineNum">    4789 </span>                :            :  */
<a name="4790"><span class="lineNum">    4790 </span>                :            : template &lt;typename mj_scalar_t, typename mj_lno_t, typename mj_gno_t,</a>
<span class="lineNum">    4791 </span>                :            :           typename mj_part_t&gt;
<span class="lineNum">    4792 </span>                :<span class="lineNoCov">          0 : bool AlgMJ&lt;mj_scalar_t, mj_lno_t, mj_gno_t, mj_part_t&gt;::mj_perform_migration(</span>
<span class="lineNum">    4793 </span>                :            :     mj_part_t input_num_parts, //current umb parts
<span class="lineNum">    4794 </span>                :            :     mj_part_t &amp;output_num_parts, //output umb parts.
<span class="lineNum">    4795 </span>                :            :     std::vector&lt;mj_part_t&gt; *next_future_num_parts_in_parts,
<span class="lineNum">    4796 </span>                :            :     mj_part_t &amp;output_part_begin_index,
<span class="lineNum">    4797 </span>                :            :     size_t migration_reduce_all_population,
<span class="lineNum">    4798 </span>                :            :     mj_lno_t num_coords_for_last_dim_part,
<span class="lineNum">    4799 </span>                :            :     std::string iteration,
<span class="lineNum">    4800 </span>                :            :     RCP&lt;mj_partBoxVector_t&gt; &amp;input_part_boxes,
<span class="lineNum">    4801 </span>                :            :     RCP&lt;mj_partBoxVector_t&gt; &amp;output_part_boxes
<span class="lineNum">    4802 </span>                :            : )
<span class="lineNum">    4803 </span>                :            : {
<span class="lineNum">    4804 </span>                :<span class="lineNoCov">          0 :         mj_part_t num_procs = this-&gt;comm-&gt;getSize();</span>
<span class="lineNum">    4805 </span>                :<span class="lineNoCov">          0 :         this-&gt;myRank = this-&gt;comm-&gt;getRank();</span>
<span class="lineNum">    4806 </span>                :            : 
<span class="lineNum">    4807 </span>                :            : 
<span class="lineNum">    4808 </span>                :            :         //this array holds how many points each processor has in each part.
<span class="lineNum">    4809 </span>                :            :         //to access how many points processor i has on part j,
<span class="lineNum">    4810 </span>                :            :         //num_points_in_all_processor_parts[i * num_parts + j]
<span class="lineNum">    4811 </span>                :<span class="lineNoCov">          0 :         mj_gno_t *num_points_in_all_processor_parts = allocMemory&lt;mj_gno_t&gt;(input_num_parts * (num_procs + 1));</span>
<span class="lineNum">    4812 </span>                :            : 
<span class="lineNum">    4813 </span>                :            :         //get the number of coordinates in each part in each processor.
<span class="lineNum">    4814 </span>                :<span class="lineNoCov">          0 :         this-&gt;get_processor_num_points_in_parts(</span>
<span class="lineNum">    4815 </span>                :            :                         num_procs,
<span class="lineNum">    4816 </span>                :            :                         input_num_parts,
<span class="lineNum">    4817 </span>                :            :                         num_points_in_all_processor_parts);
<span class="lineNum">    4818 </span>                :            : 
<span class="lineNum">    4819 </span>                :            : 
<span class="lineNum">    4820 </span>                :            :         //check if migration will be performed or not.
<span class="lineNum">    4821 </span>                :<span class="lineNoCov">          0 :         if (!this-&gt;mj_check_to_migrate(</span>
<span class="lineNum">    4822 </span>                :            :                         migration_reduce_all_population,
<span class="lineNum">    4823 </span>                :            :                         num_coords_for_last_dim_part,
<span class="lineNum">    4824 </span>                :            :                         num_procs,
<span class="lineNum">    4825 </span>                :            :                         input_num_parts,
<span class="lineNum">    4826 </span>                :            :                         num_points_in_all_processor_parts)){
<span class="lineNum">    4827 </span>                :<span class="lineNoCov">          0 :                 freeArray&lt;mj_gno_t&gt;(num_points_in_all_processor_parts);</span>
<span class="lineNum">    4828 </span>                :<span class="lineNoCov">          0 :                 return false;</span>
<span class="lineNum">    4829 </span>                :            :         }
<span class="lineNum">    4830 </span>                :            : 
<span class="lineNum">    4831 </span>                :            : 
<span class="lineNum">    4832 </span>                :<span class="lineNoCov">          0 :         mj_lno_t *send_count_to_each_proc = NULL;</span>
<span class="lineNum">    4833 </span>                :<span class="lineNoCov">          0 :         int *coordinate_destinations = allocMemory&lt;int&gt;(this-&gt;num_local_coords);</span>
<span class="lineNum">    4834 </span>                :<span class="lineNoCov">          0 :         send_count_to_each_proc = allocMemory&lt;mj_lno_t&gt;(num_procs);</span>
<span class="lineNum">    4835 </span>                :<span class="lineNoCov">          0 :         for (int i = 0; i &lt; num_procs; ++i) send_count_to_each_proc[i] = 0;</span>
<span class="lineNum">    4836 </span>                :            : 
<span class="lineNum">    4837 </span>                :<span class="lineNoCov">          0 :         std::vector&lt;mj_part_t&gt; processor_ranks_for_subcomm;</span>
<span class="lineNum">    4838 </span>                :<span class="lineNoCov">          0 :         std::vector&lt;mj_part_t&gt; out_part_indices;</span>
<span class="lineNum">    4839 </span>                :            : 
<span class="lineNum">    4840 </span>                :            :         //determine which processors are assigned to which parts
<span class="lineNum">    4841 </span>                :<span class="lineNoCov">          0 :         this-&gt;mj_migration_part_proc_assignment(</span>
<span class="lineNum">    4842 </span>                :            :                         num_points_in_all_processor_parts,
<span class="lineNum">    4843 </span>                :            :                         input_num_parts,
<span class="lineNum">    4844 </span>                :            :                         num_procs,
<span class="lineNum">    4845 </span>                :            :                         send_count_to_each_proc,
<span class="lineNum">    4846 </span>                :            :                         processor_ranks_for_subcomm,
<span class="lineNum">    4847 </span>                :            :                         next_future_num_parts_in_parts,
<span class="lineNum">    4848 </span>                :            :                         output_num_parts,
<span class="lineNum">    4849 </span>                :            :                         out_part_indices,
<span class="lineNum">    4850 </span>                :            :                         output_part_begin_index,
<span class="lineNum">    4851 </span>                :            :                         coordinate_destinations);
<span class="lineNum">    4852 </span>                :            : 
<span class="lineNum">    4853 </span>                :            : 
<span class="lineNum">    4854 </span>                :            : 
<span class="lineNum">    4855 </span>                :            : 
<span class="lineNum">    4856 </span>                :<span class="lineNoCov">          0 :         freeArray&lt;mj_lno_t&gt;(send_count_to_each_proc);</span>
<span class="lineNum">    4857 </span>                :<span class="lineNoCov">          0 :         std::vector &lt;mj_part_t&gt; tmpv;</span>
<span class="lineNum">    4858 </span>                :            : 
<span class="lineNum">    4859 </span>                :<span class="lineNoCov">          0 :         std::sort (out_part_indices.begin(), out_part_indices.end());</span>
<span class="lineNum">    4860 </span>                :<span class="lineNoCov">          0 :         mj_part_t outP = out_part_indices.size();</span>
<span class="lineNum">    4861 </span>                :            : 
<span class="lineNum">    4862 </span>                :<span class="lineNoCov">          0 :         mj_gno_t new_global_num_points = 0;</span>
<span class="lineNum">    4863 </span>                :<span class="lineNoCov">          0 :         mj_gno_t *global_num_points_in_parts = num_points_in_all_processor_parts + num_procs * input_num_parts;</span>
<span class="lineNum">    4864 </span>                :            : 
<span class="lineNum">    4865 </span>                :<span class="lineNoCov">          0 :         if (this-&gt;mj_keep_part_boxes){</span>
<span class="lineNum">    4866 </span>                :<span class="lineNoCov">          0 :                 input_part_boxes-&gt;clear();</span>
<span class="lineNum">    4867 </span>                :            :         }
<span class="lineNum">    4868 </span>                :            : 
<span class="lineNum">    4869 </span>                :            :         //now we calculate the new values for next_future_num_parts_in_parts.
<span class="lineNum">    4870 </span>                :            :         //same for the part boxes.
<span class="lineNum">    4871 </span>                :<span class="lineNoCov">          0 :         for (mj_part_t i = 0; i &lt; outP; ++i){</span>
<span class="lineNum">    4872 </span>                :<span class="lineNoCov">          0 :                 mj_part_t ind = out_part_indices[i];</span>
<span class="lineNum">    4873 </span>                :<span class="lineNoCov">          0 :                 new_global_num_points += global_num_points_in_parts[ind];</span>
<span class="lineNum">    4874 </span>                :<span class="lineNoCov">          0 :                 tmpv.push_back((*next_future_num_parts_in_parts)[ind]);</span>
<span class="lineNum">    4875 </span>                :<span class="lineNoCov">          0 :                 if (this-&gt;mj_keep_part_boxes){</span>
<span class="lineNum">    4876 </span>                :<span class="lineNoCov">          0 :                         input_part_boxes-&gt;push_back((*output_part_boxes)[ind]);</span>
<span class="lineNum">    4877 </span>                :            :                 }
<span class="lineNum">    4878 </span>                :            :         }
<span class="lineNum">    4879 </span>                :            :         //swap the input and output part boxes.
<span class="lineNum">    4880 </span>                :<span class="lineNoCov">          0 :         if (this-&gt;mj_keep_part_boxes){</span>
<span class="lineNum">    4881 </span>                :<span class="lineNoCov">          0 :                 RCP&lt;mj_partBoxVector_t&gt; tmpPartBoxes = input_part_boxes;</span>
<span class="lineNum">    4882 </span>                :<span class="lineNoCov">          0 :                 input_part_boxes = output_part_boxes;</span>
<span class="lineNum">    4883 </span>                :<span class="lineNoCov">          0 :                 output_part_boxes = tmpPartBoxes;</span>
<span class="lineNum">    4884 </span>                :            :         }
<span class="lineNum">    4885 </span>                :<span class="lineNoCov">          0 :         next_future_num_parts_in_parts-&gt;clear();</span>
<span class="lineNum">    4886 </span>                :<span class="lineNoCov">          0 :         for (mj_part_t i = 0; i &lt; outP; ++i){</span>
<span class="lineNum">    4887 </span>                :<span class="lineNoCov">          0 :                 mj_part_t p = tmpv[i];</span>
<span class="lineNum">    4888 </span>                :<span class="lineNoCov">          0 :                 next_future_num_parts_in_parts-&gt;push_back(p);</span>
<span class="lineNum">    4889 </span>                :            :         }
<span class="lineNum">    4890 </span>                :            : 
<span class="lineNum">    4891 </span>                :<span class="lineNoCov">          0 :         freeArray&lt;mj_gno_t&gt;(num_points_in_all_processor_parts);</span>
<span class="lineNum">    4892 </span>                :            : 
<span class="lineNum">    4893 </span>                :<span class="lineNoCov">          0 :         mj_lno_t num_new_local_points = 0;</span>
<span class="lineNum">    4894 </span>                :            : 
<span class="lineNum">    4895 </span>                :            : 
<span class="lineNum">    4896 </span>                :            :         //perform the actual migration operation here.
<span class="lineNum">    4897 </span>                :<span class="lineNoCov">          0 :         this-&gt;mj_migrate_coords(</span>
<span class="lineNum">    4898 </span>                :            :                         num_procs,
<span class="lineNum">    4899 </span>                :            :                         num_new_local_points,
<span class="lineNum">    4900 </span>                :            :                         iteration,
<span class="lineNum">    4901 </span>                :            :                         coordinate_destinations,
<span class="lineNum">    4902 </span>                :            :                         input_num_parts);
<span class="lineNum">    4903 </span>                :            : 
<span class="lineNum">    4904 </span>                :            : 
<span class="lineNum">    4905 </span>                :<span class="lineNoCov">          0 :         freeArray&lt;int&gt;(coordinate_destinations);</span>
<span class="lineNum">    4906 </span>                :            : 
<span class="lineNum">    4907 </span>                :<span class="lineNoCov">          0 :         if(this-&gt;num_local_coords != num_new_local_points){</span>
<span class="lineNum">    4908 </span>                :<span class="lineNoCov">          0 :                 freeArray&lt;mj_lno_t&gt;(this-&gt;new_coordinate_permutations);</span>
<span class="lineNum">    4909 </span>                :<span class="lineNoCov">          0 :                 freeArray&lt;mj_lno_t&gt;(this-&gt;coordinate_permutations);</span>
<span class="lineNum">    4910 </span>                :            : 
<span class="lineNum">    4911 </span>                :<span class="lineNoCov">          0 :                 this-&gt;new_coordinate_permutations = allocMemory&lt;mj_lno_t&gt;(num_new_local_points);</span>
<span class="lineNum">    4912 </span>                :<span class="lineNoCov">          0 :                 this-&gt;coordinate_permutations = allocMemory&lt;mj_lno_t&gt;(num_new_local_points);</span>
<span class="lineNum">    4913 </span>                :            :         }
<span class="lineNum">    4914 </span>                :<span class="lineNoCov">          0 :         this-&gt;num_local_coords = num_new_local_points;</span>
<span class="lineNum">    4915 </span>                :<span class="lineNoCov">          0 :         this-&gt;num_global_coords = new_global_num_points;</span>
<span class="lineNum">    4916 </span>                :            : 
<span class="lineNum">    4917 </span>                :            : 
<span class="lineNum">    4918 </span>                :            : 
<span class="lineNum">    4919 </span>                :            :         //create subcommunicator.
<span class="lineNum">    4920 </span>                :<span class="lineNoCov">          0 :         this-&gt;create_sub_communicator(processor_ranks_for_subcomm);</span>
<span class="lineNum">    4921 </span>                :<span class="lineNoCov">          0 :         processor_ranks_for_subcomm.clear();</span>
<span class="lineNum">    4922 </span>                :            : 
<span class="lineNum">    4923 </span>                :            :         //fill the new permutation arrays.
<span class="lineNum">    4924 </span>                :<span class="lineNoCov">          0 :         this-&gt;fill_permutation_array(</span>
<span class="lineNum">    4925 </span>                :            :                         output_num_parts,
<span class="lineNum">    4926 </span>                :            :                         input_num_parts);
<span class="lineNum">    4927 </span>                :<span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">    4928 </span>                :            : }
<span class="lineNum">    4929 </span>                :            : 
<span class="lineNum">    4930 </span>                :            : 
<span class="lineNum">    4931 </span>                :            : /*! \brief Function creates consistent chunks for task partitioning. Used only in the case of
<span class="lineNum">    4932 </span>                :            :  * sequential task partitioning, where consistent handle of the points on the cuts are required.
<span class="lineNum">    4933 </span>                :            :  *
<span class="lineNum">    4934 </span>                :            :  * \param num_parts is the number of parts.
<span class="lineNum">    4935 </span>                :            :  * \param mj_current_dim_coords is 1 dimensional array holding the coordinate values.
<span class="lineNum">    4936 </span>                :            :  * \param current_concurrent_cut_coordinate is 1 dimensional array holding the cut coordinates.
<span class="lineNum">    4937 </span>                :            :  * \param coordinate_begin is the start index of the given partition on partitionedPointPermutations.
<span class="lineNum">    4938 </span>                :            :  * \param coordinate_end is the end index of the given partition on partitionedPointPermutations.
<span class="lineNum">    4939 </span>                :            :  * \param used_local_cut_line_weight_to_left holds how much weight of the coordinates on the cutline should be put on left side.
<span class="lineNum">    4940 </span>                :            :  *
<span class="lineNum">    4941 </span>                :            :  * \param out_part_xadj is the indices of begginning and end of the parts in the output partition.
<span class="lineNum">    4942 </span>                :            :  * \param coordInd is the index according to which the partitioning is done.
<span class="lineNum">    4943 </span>                :            :  */
<a name="4944"><span class="lineNum">    4944 </span>                :            : template &lt;typename mj_scalar_t, typename mj_lno_t, typename mj_gno_t,</a>
<span class="lineNum">    4945 </span>                :            :           typename mj_part_t&gt;
<span class="lineNum">    4946 </span>                :<span class="lineNoCov">          0 : void AlgMJ&lt;mj_scalar_t, mj_lno_t, mj_gno_t, mj_part_t&gt;::create_consistent_chunks(</span>
<span class="lineNum">    4947 </span>                :            :     mj_part_t num_parts,
<span class="lineNum">    4948 </span>                :            :     mj_scalar_t *mj_current_dim_coords,
<span class="lineNum">    4949 </span>                :            :     mj_scalar_t *current_concurrent_cut_coordinate,
<span class="lineNum">    4950 </span>                :            :     mj_lno_t coordinate_begin,
<span class="lineNum">    4951 </span>                :            :     mj_lno_t coordinate_end,
<span class="lineNum">    4952 </span>                :            :     mj_scalar_t *used_local_cut_line_weight_to_left,
<span class="lineNum">    4953 </span>                :            :     mj_lno_t *out_part_xadj,
<span class="lineNum">    4954 </span>                :            :     int coordInd){
<span class="lineNum">    4955 </span>                :            : 
<span class="lineNum">    4956 </span>                :            :         //mj_lno_t numCoordsInPart =  coordinateEnd - coordinateBegin;
<span class="lineNum">    4957 </span>                :<span class="lineNoCov">          0 :         mj_part_t no_cuts = num_parts - 1;</span>
<span class="lineNum">    4958 </span>                :            : 
<span class="lineNum">    4959 </span>                :            : 
<span class="lineNum">    4960 </span>                :            : 
<span class="lineNum">    4961 </span>                :<span class="lineNoCov">          0 :         int me = 0;</span>
<span class="lineNum">    4962 </span>                :<span class="lineNoCov">          0 :         mj_lno_t *thread_num_points_in_parts = this-&gt;thread_point_counts[me];</span>
<span class="lineNum">    4963 </span>                :<span class="lineNoCov">          0 :         mj_scalar_t *my_local_thread_cut_weights_to_put_left = NULL;</span>
<span class="lineNum">    4964 </span>                :            : 
<span class="lineNum">    4965 </span>                :            : 
<span class="lineNum">    4966 </span>                :            :         //now if the rectilinear partitioning is allowed we decide how
<span class="lineNum">    4967 </span>                :            :         //much weight each thread should put to left and right.
<span class="lineNum">    4968 </span>                :<span class="lineNoCov">          0 :         if (this-&gt;distribute_points_on_cut_lines){</span>
<span class="lineNum">    4969 </span>                :            : 
<span class="lineNum">    4970 </span>                :<span class="lineNoCov">          0 :                 my_local_thread_cut_weights_to_put_left = this-&gt;thread_cut_line_weight_to_put_left[me];</span>
<span class="lineNum">    4971 </span>                :<span class="lineNoCov">          0 :                 for (mj_part_t i = 0; i &lt; no_cuts; ++i){</span>
<span class="lineNum">    4972 </span>                :            :                         //the left to be put on the left of the cut.
<span class="lineNum">    4973 </span>                :<span class="lineNoCov">          0 :                         mj_scalar_t left_weight = used_local_cut_line_weight_to_left[i];</span>
<span class="lineNum">    4974 </span>                :            :                         //cout &lt;&lt; &quot;i:&quot; &lt;&lt; i &lt;&lt; &quot; left_weight:&quot; &lt;&lt; left_weight &lt;&lt; endl;
<span class="lineNum">    4975 </span>                :<span class="lineNoCov">          0 :                         for(int ii = 0; ii &lt; this-&gt;num_threads; ++ii){</span>
<span class="lineNum">    4976 </span>                :<span class="lineNoCov">          0 :                                 if(left_weight &gt; this-&gt;sEpsilon){</span>
<span class="lineNum">    4977 </span>                :            :                                         //the weight of thread ii on cut.
<span class="lineNum">    4978 </span>                :<span class="lineNoCov">          0 :                                         mj_scalar_t thread_ii_weight_on_cut = this-&gt;thread_part_weight_work[ii][i * 2 + 1] - this-&gt;thread_part_weight_work[ii][i * 2 ];</span>
<span class="lineNum">    4979 </span>                :<span class="lineNoCov">          0 :                                         if(thread_ii_weight_on_cut &lt; left_weight){</span>
<span class="lineNum">    4980 </span>                :<span class="lineNoCov">          0 :                                                 this-&gt;thread_cut_line_weight_to_put_left[ii][i] = thread_ii_weight_on_cut;</span>
<span class="lineNum">    4981 </span>                :            :                                         }
<span class="lineNum">    4982 </span>                :            :                                         else {
<span class="lineNum">    4983 </span>                :<span class="lineNoCov">          0 :                                                 this-&gt;thread_cut_line_weight_to_put_left[ii][i] = left_weight ;</span>
<span class="lineNum">    4984 </span>                :            :                                         }
<span class="lineNum">    4985 </span>                :<span class="lineNoCov">          0 :                                         left_weight -= thread_ii_weight_on_cut;</span>
<span class="lineNum">    4986 </span>                :            :                                 }
<span class="lineNum">    4987 </span>                :            :                                 else {
<span class="lineNum">    4988 </span>                :<span class="lineNoCov">          0 :                                         this-&gt;thread_cut_line_weight_to_put_left[ii][i] = 0;</span>
<span class="lineNum">    4989 </span>                :            :                                 }
<span class="lineNum">    4990 </span>                :            :                         }
<span class="lineNum">    4991 </span>                :            :                 }
<span class="lineNum">    4992 </span>                :            : 
<span class="lineNum">    4993 </span>                :<span class="lineNoCov">          0 :                 if(no_cuts &gt; 0){</span>
<span class="lineNum">    4994 </span>                :            :                         //this is a special case. If cutlines share the same coordinate, their weights are equal.
<span class="lineNum">    4995 </span>                :            :                         //we need to adjust the ratio for that.
<span class="lineNum">    4996 </span>                :<span class="lineNoCov">          0 :                         for (mj_part_t i = no_cuts - 1; i &gt; 0 ; --i){</span>
<span class="lineNum">    4997 </span>                :<span class="lineNoCov">          0 :                                 if(ZOLTAN2_ABS(current_concurrent_cut_coordinate[i] - current_concurrent_cut_coordinate[i -1]) &lt; this-&gt;sEpsilon){</span>
<span class="lineNum">    4998 </span>                :<span class="lineNoCov">          0 :                                         my_local_thread_cut_weights_to_put_left[i] -= my_local_thread_cut_weights_to_put_left[i - 1] ;</span>
<span class="lineNum">    4999 </span>                :            :                                 }
<span class="lineNum">    5000 </span>                :<span class="lineNoCov">          0 :                                 my_local_thread_cut_weights_to_put_left[i] = int ((my_local_thread_cut_weights_to_put_left[i] + LEAST_SIGNIFICANCE) * SIGNIFICANCE_MUL)</span>
<span class="lineNum">    5001 </span>                :            :                                                                                                 / mj_scalar_t(SIGNIFICANCE_MUL);
<span class="lineNum">    5002 </span>                :            :                         }
<span class="lineNum">    5003 </span>                :            :                 }
<span class="lineNum">    5004 </span>                :            :         }
<span class="lineNum">    5005 </span>                :            : 
<span class="lineNum">    5006 </span>                :<span class="lineNoCov">          0 :         for(mj_part_t ii = 0; ii &lt; num_parts; ++ii){</span>
<span class="lineNum">    5007 </span>                :<span class="lineNoCov">          0 :                 thread_num_points_in_parts[ii] = 0;</span>
<span class="lineNum">    5008 </span>                :            :         }
<span class="lineNum">    5009 </span>                :            : 
<span class="lineNum">    5010 </span>                :            :         //for this specific case we dont want to distribute the points along the cut position
<span class="lineNum">    5011 </span>                :            :         //randomly, as we need a specific ordering of them. Instead,
<span class="lineNum">    5012 </span>                :            :         //we put the coordinates into a sort item, where we sort those
<span class="lineNum">    5013 </span>                :            :         //using the coordinates of points on other dimensions and the index.
<span class="lineNum">    5014 </span>                :            : 
<span class="lineNum">    5015 </span>                :            : 
<span class="lineNum">    5016 </span>                :            :         //some of the cuts might share the same position.
<span class="lineNum">    5017 </span>                :            :         //in this case, if cut i and cut j share the same position
<span class="lineNum">    5018 </span>                :            :         //cut_map[i] = cut_map[j] = sort item index.
<span class="lineNum">    5019 </span>                :<span class="lineNoCov">          0 :         mj_part_t *cut_map = allocMemory&lt;mj_part_t&gt; (no_cuts);</span>
<span class="lineNum">    5020 </span>                :            : 
<span class="lineNum">    5021 </span>                :            : 
<span class="lineNum">    5022 </span>                :            :         typedef uMultiSortItem&lt;mj_lno_t, int, mj_scalar_t&gt; multiSItem;
<span class="lineNum">    5023 </span>                :            :         typedef std::vector&lt; multiSItem &gt; multiSVector;
<span class="lineNum">    5024 </span>                :            :         typedef std::vector&lt;multiSVector&gt; multiS2Vector;
<span class="lineNum">    5025 </span>                :            : 
<span class="lineNum">    5026 </span>                :            :         //to keep track of the memory allocated.
<span class="lineNum">    5027 </span>                :<span class="lineNoCov">          0 :         std::vector&lt;mj_scalar_t *&gt;allocated_memory;</span>
<span class="lineNum">    5028 </span>                :            : 
<span class="lineNum">    5029 </span>                :            :         //vector for which the coordinates will be sorted.
<span class="lineNum">    5030 </span>                :<span class="lineNoCov">          0 :         multiS2Vector sort_vector_points_on_cut;</span>
<span class="lineNum">    5031 </span>                :            : 
<span class="lineNum">    5032 </span>                :            :         //the number of cuts that have different coordinates.
<span class="lineNum">    5033 </span>                :<span class="lineNoCov">          0 :         mj_part_t different_cut_count = 1;</span>
<span class="lineNum">    5034 </span>                :<span class="lineNoCov">          0 :         cut_map[0] = 0;</span>
<span class="lineNum">    5035 </span>                :            : 
<span class="lineNum">    5036 </span>                :            :         //now we insert 1 sort vector for all cuts on the different
<span class="lineNum">    5037 </span>                :            :         //positins.if multiple cuts are on the same position, they share sort vectors.
<span class="lineNum">    5038 </span>                :<span class="lineNoCov">          0 :         multiSVector tmpMultiSVector;</span>
<span class="lineNum">    5039 </span>                :<span class="lineNoCov">          0 :         sort_vector_points_on_cut.push_back(tmpMultiSVector);</span>
<span class="lineNum">    5040 </span>                :            : 
<span class="lineNum">    5041 </span>                :<span class="lineNoCov">          0 :         for (mj_part_t i = 1; i &lt; no_cuts ; ++i){</span>
<span class="lineNum">    5042 </span>                :            :                 //if cuts share the same cut coordinates
<span class="lineNum">    5043 </span>                :            :                 //set the cutmap accordingly.
<span class="lineNum">    5044 </span>                :<span class="lineNoCov">          0 :                 if(ZOLTAN2_ABS(current_concurrent_cut_coordinate[i] - current_concurrent_cut_coordinate[i -1]) &lt; this-&gt;sEpsilon){</span>
<span class="lineNum">    5045 </span>                :<span class="lineNoCov">          0 :                         cut_map[i] = cut_map[i-1];</span>
<span class="lineNum">    5046 </span>                :            :                 }
<span class="lineNum">    5047 </span>                :            :                 else {
<span class="lineNum">    5048 </span>                :<span class="lineNoCov">          0 :                         cut_map[i] = different_cut_count++;</span>
<span class="lineNum">    5049 </span>                :<span class="lineNoCov">          0 :                         multiSVector tmp2MultiSVector;</span>
<span class="lineNum">    5050 </span>                :<span class="lineNoCov">          0 :                         sort_vector_points_on_cut.push_back(tmp2MultiSVector);</span>
<span class="lineNum">    5051 </span>                :            :                 }
<span class="lineNum">    5052 </span>                :            :         }
<span class="lineNum">    5053 </span>                :            : 
<span class="lineNum">    5054 </span>                :            : 
<span class="lineNum">    5055 </span>                :            :         //now the actual part assigment.
<span class="lineNum">    5056 </span>                :<span class="lineNoCov">          0 :         for (mj_lno_t ii = coordinate_begin; ii &lt; coordinate_end; ++ii){</span>
<span class="lineNum">    5057 </span>                :            : 
<span class="lineNum">    5058 </span>                :<span class="lineNoCov">          0 :                 mj_lno_t i = this-&gt;coordinate_permutations[ii];</span>
<span class="lineNum">    5059 </span>                :            : 
<span class="lineNum">    5060 </span>                :<span class="lineNoCov">          0 :                 mj_part_t pp = this-&gt;assigned_part_ids[i];</span>
<span class="lineNum">    5061 </span>                :<span class="lineNoCov">          0 :                 mj_part_t p = pp / 2;</span>
<span class="lineNum">    5062 </span>                :            :                 //if the coordinate is on a cut.
<span class="lineNum">    5063 </span>                :<span class="lineNoCov">          0 :                 if(pp % 2 == 1 ){</span>
<span class="lineNum">    5064 </span>                :<span class="lineNoCov">          0 :                         mj_scalar_t *vals = allocMemory&lt;mj_scalar_t&gt;(this-&gt;coord_dim -1);</span>
<span class="lineNum">    5065 </span>                :<span class="lineNoCov">          0 :                         allocated_memory.push_back(vals);</span>
<span class="lineNum">    5066 </span>                :            : 
<span class="lineNum">    5067 </span>                :            :                         //we insert the coordinates to the sort item here.
<span class="lineNum">    5068 </span>                :<span class="lineNoCov">          0 :                         int val_ind = 0;</span>
<span class="lineNum">    5069 </span>                :<span class="lineNoCov">          0 :                         for(int dim = coordInd + 1; dim &lt; this-&gt;coord_dim; ++dim){</span>
<span class="lineNum">    5070 </span>                :<span class="lineNoCov">          0 :                                 vals[val_ind++] = this-&gt;mj_coordinates[dim][i];</span>
<span class="lineNum">    5071 </span>                :            :                         }
<span class="lineNum">    5072 </span>                :<span class="lineNoCov">          0 :                         for(int dim = 0; dim &lt; coordInd; ++dim){</span>
<span class="lineNum">    5073 </span>                :<span class="lineNoCov">          0 :                                 vals[val_ind++] = this-&gt;mj_coordinates[dim][i];</span>
<span class="lineNum">    5074 </span>                :            :                         }
<span class="lineNum">    5075 </span>                :<span class="lineNoCov">          0 :                         multiSItem tempSortItem(i, this-&gt;coord_dim -1, vals);</span>
<span class="lineNum">    5076 </span>                :            :                         //inser the point to the sort vector pointed by the cut_map[p].
<span class="lineNum">    5077 </span>                :<span class="lineNoCov">          0 :                         mj_part_t cmap = cut_map[p];</span>
<span class="lineNum">    5078 </span>                :<span class="lineNoCov">          0 :                         sort_vector_points_on_cut[cmap].push_back(tempSortItem);</span>
<span class="lineNum">    5079 </span>                :            :                 }
<span class="lineNum">    5080 </span>                :            :                 else {
<span class="lineNum">    5081 </span>                :            :                         //if it is not on the cut, simple sorting.
<span class="lineNum">    5082 </span>                :<span class="lineNoCov">          0 :                         ++thread_num_points_in_parts[p];</span>
<span class="lineNum">    5083 </span>                :<span class="lineNoCov">          0 :                         this-&gt;assigned_part_ids[i] = p;</span>
<span class="lineNum">    5084 </span>                :            :                 }
<span class="lineNum">    5085 </span>                :            :         }
<span class="lineNum">    5086 </span>                :            : 
<span class="lineNum">    5087 </span>                :            :         //sort all the sort vectors.
<span class="lineNum">    5088 </span>                :<span class="lineNoCov">          0 :         for (mj_part_t i = 0; i &lt; different_cut_count; ++i){</span>
<span class="lineNum">    5089 </span>                :<span class="lineNoCov">          0 :                 std::sort (sort_vector_points_on_cut[i].begin(), sort_vector_points_on_cut[i].end());</span>
<span class="lineNum">    5090 </span>                :            :         }
<span class="lineNum">    5091 </span>                :            : 
<span class="lineNum">    5092 </span>                :            :         //we do the part assignment for the points on cuts here.
<span class="lineNum">    5093 </span>                :<span class="lineNoCov">          0 :         mj_part_t previous_cut_map = cut_map[0];</span>
<span class="lineNum">    5094 </span>                :            : 
<span class="lineNum">    5095 </span>                :            :         //this is how much previous part owns the weight of the current part.
<span class="lineNum">    5096 </span>                :            :         //when target part weight is 1.6, and the part on the left is given 2,
<span class="lineNum">    5097 </span>                :            :         //the left has an extra 0.4, while the right has missing 0.4 from the previous cut.
<span class="lineNum">    5098 </span>                :            :         //this parameter is used to balance this issues.
<span class="lineNum">    5099 </span>                :            :         //in the above example weight_stolen_from_previous_part will be 0.4.
<span class="lineNum">    5100 </span>                :            :         //if the left part target is 2.2 but it is given 2,
<span class="lineNum">    5101 </span>                :            :         //then weight_stolen_from_previous_part will be -0.2.
<span class="lineNum">    5102 </span>                :<span class="lineNoCov">          0 :         mj_scalar_t weight_stolen_from_previous_part = 0;</span>
<span class="lineNum">    5103 </span>                :<span class="lineNoCov">          0 :         for (mj_part_t p = 0; p &lt; no_cuts; ++p){</span>
<span class="lineNum">    5104 </span>                :            : 
<span class="lineNum">    5105 </span>                :<span class="lineNoCov">          0 :                 mj_part_t mapped_cut = cut_map[p];</span>
<span class="lineNum">    5106 </span>                :            : 
<span class="lineNum">    5107 </span>                :            :                 //if previous cut map is done, and it does not have the same index,
<span class="lineNum">    5108 </span>                :            :                 //then assign all points left on that cut to its right.
<span class="lineNum">    5109 </span>                :<span class="lineNoCov">          0 :                 if (previous_cut_map != mapped_cut){</span>
<span class="lineNum">    5110 </span>                :<span class="lineNoCov">          0 :                         mj_lno_t sort_vector_end = (mj_lno_t)sort_vector_points_on_cut[previous_cut_map].size() - 1;</span>
<span class="lineNum">    5111 </span>                :<span class="lineNoCov">          0 :                         for (; sort_vector_end &gt;= 0; --sort_vector_end){</span>
<span class="lineNum">    5112 </span>                :<span class="lineNoCov">          0 :                                 multiSItem t = sort_vector_points_on_cut[previous_cut_map][sort_vector_end];</span>
<span class="lineNum">    5113 </span>                :<span class="lineNoCov">          0 :                                 mj_lno_t i = t.index;</span>
<span class="lineNum">    5114 </span>                :<span class="lineNoCov">          0 :                                 ++thread_num_points_in_parts[p];</span>
<span class="lineNum">    5115 </span>                :<span class="lineNoCov">          0 :                                 this-&gt;assigned_part_ids[i] = p;</span>
<span class="lineNum">    5116 </span>                :            :                         }
<span class="lineNum">    5117 </span>                :<span class="lineNoCov">          0 :                         sort_vector_points_on_cut[previous_cut_map].clear();</span>
<span class="lineNum">    5118 </span>                :            :                 }
<span class="lineNum">    5119 </span>                :<span class="lineNoCov">          0 :                 mj_lno_t sort_vector_end = (mj_lno_t)sort_vector_points_on_cut[mapped_cut].size() - 1;</span>
<span class="lineNum">    5120 </span>                :            : 
<span class="lineNum">    5121 </span>                :<span class="lineNoCov">          0 :                 for (; sort_vector_end &gt;= 0; --sort_vector_end){</span>
<span class="lineNum">    5122 </span>                :<span class="lineNoCov">          0 :                         multiSItem t = sort_vector_points_on_cut[mapped_cut][sort_vector_end];</span>
<span class="lineNum">    5123 </span>                :<span class="lineNoCov">          0 :                         mj_lno_t i = t.index;</span>
<span class="lineNum">    5124 </span>                :<span class="lineNoCov">          0 :                         mj_scalar_t w = this-&gt;mj_uniform_weights[0]? 1:this-&gt;mj_weights[0][i];</span>
<span class="lineNum">    5125 </span>                :            : 
<span class="lineNum">    5126 </span>                :            : 
<span class="lineNum">    5127 </span>                :            :                         //part p has enough space for point i, then put it to point i.
<span class="lineNum">    5128 </span>                :<span class="lineNoCov">          0 :                         if(     my_local_thread_cut_weights_to_put_left[p] + weight_stolen_from_previous_part&gt; this-&gt;sEpsilon &amp;&amp;</span>
<span class="lineNum">    5129 </span>                :<span class="lineNoCov">          0 :                                 my_local_thread_cut_weights_to_put_left[p] + weight_stolen_from_previous_part - ZOLTAN2_ABS(my_local_thread_cut_weights_to_put_left[p] + weight_stolen_from_previous_part - w)</span>
<span class="lineNum">    5130 </span>                :<span class="lineNoCov">          0 :                                         &gt; this-&gt;sEpsilon){</span>
<span class="lineNum">    5131 </span>                :            : 
<span class="lineNum">    5132 </span>                :<span class="lineNoCov">          0 :                                 my_local_thread_cut_weights_to_put_left[p] -= w;</span>
<span class="lineNum">    5133 </span>                :<span class="lineNoCov">          0 :                                 sort_vector_points_on_cut[mapped_cut].pop_back();</span>
<span class="lineNum">    5134 </span>                :<span class="lineNoCov">          0 :                                 ++thread_num_points_in_parts[p];</span>
<span class="lineNum">    5135 </span>                :<span class="lineNoCov">          0 :                                 this-&gt;assigned_part_ids[i] = p;</span>
<span class="lineNum">    5136 </span>                :            :                                 //if putting this weight to left overweights the left cut, then
<span class="lineNum">    5137 </span>                :            :                                 //increase the space for the next cut using weight_stolen_from_previous_part.
<span class="lineNum">    5138 </span>                :<span class="lineNoCov">          0 :                                 if(p &lt; no_cuts - 1 &amp;&amp; my_local_thread_cut_weights_to_put_left[p] &lt; this-&gt;sEpsilon){</span>
<span class="lineNum">    5139 </span>                :<span class="lineNoCov">          0 :                                         if(mapped_cut == cut_map[p + 1] ){</span>
<span class="lineNum">    5140 </span>                :            :                                                 //if the cut before the cut indexed at p was also at the same position
<span class="lineNum">    5141 </span>                :            :                                                 //special case, as we handle the weight differently here.
<span class="lineNum">    5142 </span>                :<span class="lineNoCov">          0 :                                                 if (previous_cut_map != mapped_cut){</span>
<span class="lineNum">    5143 </span>                :<span class="lineNoCov">          0 :                                                         weight_stolen_from_previous_part = my_local_thread_cut_weights_to_put_left[p];</span>
<span class="lineNum">    5144 </span>                :            :                                                 }
<span class="lineNum">    5145 </span>                :            :                                                 else {
<span class="lineNum">    5146 </span>                :            :                                                         //if the cut before the cut indexed at p was also at the same position
<span class="lineNum">    5147 </span>                :            :                                                         //we assign extra weights cumulatively in this case.
<span class="lineNum">    5148 </span>                :<span class="lineNoCov">          0 :                                                         weight_stolen_from_previous_part += my_local_thread_cut_weights_to_put_left[p];</span>
<span class="lineNum">    5149 </span>                :            :                                                 }
<span class="lineNum">    5150 </span>                :            :                                         }
<span class="lineNum">    5151 </span>                :            :                                         else{
<span class="lineNum">    5152 </span>                :<span class="lineNoCov">          0 :                                                 weight_stolen_from_previous_part = -my_local_thread_cut_weights_to_put_left[p];</span>
<span class="lineNum">    5153 </span>                :            :                                         }
<span class="lineNum">    5154 </span>                :            :                                         //end assignment for part p
<span class="lineNum">    5155 </span>                :<span class="lineNoCov">          0 :                                         break;</span>
<span class="lineNum">    5156 </span>                :            :                                 }
<span class="lineNum">    5157 </span>                :            :                         } else {
<span class="lineNum">    5158 </span>                :            :                                 //if part p does not have enough space for this point
<span class="lineNum">    5159 </span>                :            :                                 //and if there is another cut sharing the same positon,
<span class="lineNum">    5160 </span>                :            :                                 //again increase the space for the next
<span class="lineNum">    5161 </span>                :<span class="lineNoCov">          0 :                                 if(p &lt; no_cuts - 1 &amp;&amp; mapped_cut == cut_map[p + 1]){</span>
<span class="lineNum">    5162 </span>                :<span class="lineNoCov">          0 :                                         if (previous_cut_map != mapped_cut){</span>
<span class="lineNum">    5163 </span>                :<span class="lineNoCov">          0 :                                                 weight_stolen_from_previous_part = my_local_thread_cut_weights_to_put_left[p];</span>
<span class="lineNum">    5164 </span>                :            :                                         }
<span class="lineNum">    5165 </span>                :            :                                         else {
<span class="lineNum">    5166 </span>                :<span class="lineNoCov">          0 :                                                 weight_stolen_from_previous_part += my_local_thread_cut_weights_to_put_left[p];</span>
<span class="lineNum">    5167 </span>                :            :                                         }
<span class="lineNum">    5168 </span>                :            :                                 }
<span class="lineNum">    5169 </span>                :            :                                 else{
<span class="lineNum">    5170 </span>                :<span class="lineNoCov">          0 :                                         weight_stolen_from_previous_part = -my_local_thread_cut_weights_to_put_left[p];</span>
<span class="lineNum">    5171 </span>                :            :                                 }
<span class="lineNum">    5172 </span>                :            :                                 //end assignment for part p
<span class="lineNum">    5173 </span>                :<span class="lineNoCov">          0 :                                 break;</span>
<span class="lineNum">    5174 </span>                :            :                         }
<span class="lineNum">    5175 </span>                :            :                 }
<span class="lineNum">    5176 </span>                :<span class="lineNoCov">          0 :                 previous_cut_map = mapped_cut;</span>
<span class="lineNum">    5177 </span>                :            :         }
<span class="lineNum">    5178 </span>                :            :         //put everything left on the last cut to the last part.
<span class="lineNum">    5179 </span>                :<span class="lineNoCov">          0 :         mj_lno_t sort_vector_end = (mj_lno_t)sort_vector_points_on_cut[previous_cut_map].size() - 1;</span>
<span class="lineNum">    5180 </span>                :<span class="lineNoCov">          0 :         for (; sort_vector_end &gt;= 0; --sort_vector_end){</span>
<span class="lineNum">    5181 </span>                :<span class="lineNoCov">          0 :                 multiSItem t = sort_vector_points_on_cut[previous_cut_map][sort_vector_end];</span>
<span class="lineNum">    5182 </span>                :<span class="lineNoCov">          0 :                 mj_lno_t i = t.index;</span>
<span class="lineNum">    5183 </span>                :<span class="lineNoCov">          0 :                 ++thread_num_points_in_parts[no_cuts];</span>
<span class="lineNum">    5184 </span>                :<span class="lineNoCov">          0 :                 this-&gt;assigned_part_ids[i] = no_cuts;</span>
<span class="lineNum">    5185 </span>                :            :         }
<span class="lineNum">    5186 </span>                :<span class="lineNoCov">          0 :         sort_vector_points_on_cut[previous_cut_map].clear();</span>
<span class="lineNum">    5187 </span>                :<span class="lineNoCov">          0 :         freeArray&lt;mj_part_t&gt; (cut_map);</span>
<span class="lineNum">    5188 </span>                :            : 
<span class="lineNum">    5189 </span>                :            :         //free the memory allocated for vertex sort items .
<span class="lineNum">    5190 </span>                :<span class="lineNoCov">          0 :         mj_lno_t vSize = (mj_lno_t) allocated_memory.size();</span>
<span class="lineNum">    5191 </span>                :<span class="lineNoCov">          0 :         for(mj_lno_t i = 0; i &lt; vSize; ++i){</span>
<span class="lineNum">    5192 </span>                :<span class="lineNoCov">          0 :                 freeArray&lt;mj_scalar_t&gt; (allocated_memory[i]);</span>
<span class="lineNum">    5193 </span>                :            :         }
<span class="lineNum">    5194 </span>                :            : 
<span class="lineNum">    5195 </span>                :            :         //creation of part_xadj as in usual case.
<span class="lineNum">    5196 </span>                :<span class="lineNoCov">          0 :         for(mj_part_t j = 0; j &lt; num_parts; ++j){</span>
<span class="lineNum">    5197 </span>                :<span class="lineNoCov">          0 :                 mj_lno_t num_points_in_part_j_upto_thread_i = 0;</span>
<span class="lineNum">    5198 </span>                :<span class="lineNoCov">          0 :                 for (int i = 0; i &lt; this-&gt;num_threads; ++i){</span>
<span class="lineNum">    5199 </span>                :<span class="lineNoCov">          0 :                         mj_lno_t thread_num_points_in_part_j = this-&gt;thread_point_counts[i][j];</span>
<span class="lineNum">    5200 </span>                :<span class="lineNoCov">          0 :                         this-&gt;thread_point_counts[i][j] = num_points_in_part_j_upto_thread_i;</span>
<span class="lineNum">    5201 </span>                :<span class="lineNoCov">          0 :                         num_points_in_part_j_upto_thread_i += thread_num_points_in_part_j;</span>
<span class="lineNum">    5202 </span>                :            : 
<span class="lineNum">    5203 </span>                :            :                 }
<span class="lineNum">    5204 </span>                :<span class="lineNoCov">          0 :                 out_part_xadj[j] = num_points_in_part_j_upto_thread_i;// + prev2; //+ coordinateBegin;</span>
<span class="lineNum">    5205 </span>                :            :         }
<span class="lineNum">    5206 </span>                :            : 
<span class="lineNum">    5207 </span>                :            :         //perform prefix sum for num_points in parts.
<span class="lineNum">    5208 </span>                :<span class="lineNoCov">          0 :         for(mj_part_t j = 1; j &lt; num_parts; ++j){</span>
<span class="lineNum">    5209 </span>                :<span class="lineNoCov">          0 :                 out_part_xadj[j] += out_part_xadj[j - 1];</span>
<span class="lineNum">    5210 </span>                :            :         }
<span class="lineNum">    5211 </span>                :            : 
<span class="lineNum">    5212 </span>                :            : 
<span class="lineNum">    5213 </span>                :            :         //shift the num points in threads thread to obtain the
<span class="lineNum">    5214 </span>                :            :         //beginning index of each thread's private space.
<span class="lineNum">    5215 </span>                :<span class="lineNoCov">          0 :         for(mj_part_t j = 1; j &lt; num_parts; ++j){</span>
<span class="lineNum">    5216 </span>                :<span class="lineNoCov">          0 :                 thread_num_points_in_parts[j] += out_part_xadj[j - 1] ;</span>
<span class="lineNum">    5217 </span>                :            :         }
<span class="lineNum">    5218 </span>                :            : 
<span class="lineNum">    5219 </span>                :            :         //now thread gets the coordinate and writes the index of coordinate to the permutation array
<span class="lineNum">    5220 </span>                :            :         //using the part index we calculated.
<span class="lineNum">    5221 </span>                :<span class="lineNoCov">          0 :         for (mj_lno_t ii = coordinate_begin; ii &lt; coordinate_end; ++ii){</span>
<span class="lineNum">    5222 </span>                :<span class="lineNoCov">          0 :                 mj_lno_t i = this-&gt;coordinate_permutations[ii];</span>
<span class="lineNum">    5223 </span>                :<span class="lineNoCov">          0 :                 mj_part_t p =  this-&gt;assigned_part_ids[i];</span>
<span class="lineNum">    5224 </span>                :<span class="lineNoCov">          0 :                 this-&gt;new_coordinate_permutations[coordinate_begin +</span>
<span class="lineNum">    5225 </span>                :<span class="lineNoCov">          0 :                                                   thread_num_points_in_parts[p]++] = i;</span>
<span class="lineNum">    5226 </span>                :            :         }
<span class="lineNum">    5227 </span>                :<span class="lineNoCov">          0 : }</span>
<span class="lineNum">    5228 </span>                :            : 
<span class="lineNum">    5229 </span>                :            : 
<span class="lineNum">    5230 </span>                :            : 
<span class="lineNum">    5231 </span>                :            : /*! \brief Function sends the found partids to the owner of the coordinates,
<span class="lineNum">    5232 </span>                :            :  * if the data is ever migrated. otherwise, it seets the part numbers and returns.
<span class="lineNum">    5233 </span>                :            :  * \param current_num_parts is the number of parts in the process.
<span class="lineNum">    5234 </span>                :            :  * \param output_part_begin_index is the number that will be used as beginning part number
<span class="lineNum">    5235 </span>                :            :  * \param output_part_boxes is the array that holds the part boxes
<span class="lineNum">    5236 </span>                :            :  * \param is_data_ever_migrated is the boolean value which is true
<span class="lineNum">    5237 </span>                :            :  * if the data is ever migrated during the partitioning.
<span class="lineNum">    5238 </span>                :            :  *
<span class="lineNum">    5239 </span>                :            :  */
<a name="5240"><span class="lineNum">    5240 </span>                :            : template &lt;typename mj_scalar_t, typename mj_lno_t, typename mj_gno_t,</a>
<span class="lineNum">    5241 </span>                :            :           typename mj_part_t&gt;
<span class="lineNum">    5242 </span>                :<span class="lineNoCov">          0 : void AlgMJ&lt;mj_scalar_t, mj_lno_t, mj_gno_t, mj_part_t&gt;::set_final_parts(</span>
<span class="lineNum">    5243 </span>                :            :                 mj_part_t current_num_parts,
<span class="lineNum">    5244 </span>                :            :                 mj_part_t output_part_begin_index,
<span class="lineNum">    5245 </span>                :            :                 RCP&lt;mj_partBoxVector_t&gt; &amp;output_part_boxes,
<span class="lineNum">    5246 </span>                :            :                 bool is_data_ever_migrated)
<span class="lineNum">    5247 </span>                :            : {
<span class="lineNum">    5248 </span>                :<span class="lineNoCov">          0 :     this-&gt;mj_env-&gt;timerStart(MACRO_TIMERS, &quot;MultiJagged - Part_Assignment&quot;);</span>
<span class="lineNum">    5249 </span>                :            : 
<span class="lineNum">    5250 </span>                :            : #ifdef HAVE_ZOLTAN2_OMP
<span class="lineNum">    5251 </span>                :            : #pragma omp parallel for
<span class="lineNum">    5252 </span>                :            : #endif
<span class="lineNum">    5253 </span>                :<span class="lineNoCov">          0 :     for(mj_part_t i = 0; i &lt; current_num_parts;++i){</span>
<span class="lineNum">    5254 </span>                :            : 
<span class="lineNum">    5255 </span>                :<span class="lineNoCov">          0 :         mj_lno_t begin = 0;</span>
<span class="lineNum">    5256 </span>                :<span class="lineNoCov">          0 :         mj_lno_t end = this-&gt;part_xadj[i];</span>
<span class="lineNum">    5257 </span>                :            : 
<span class="lineNum">    5258 </span>                :<span class="lineNoCov">          0 :         if(i &gt; 0) begin = this-&gt;part_xadj[i -1];</span>
<span class="lineNum">    5259 </span>                :<span class="lineNoCov">          0 :         mj_part_t part_to_set_index = i + output_part_begin_index;</span>
<span class="lineNum">    5260 </span>                :<span class="lineNoCov">          0 :         if (this-&gt;mj_keep_part_boxes){</span>
<span class="lineNum">    5261 </span>                :<span class="lineNoCov">          0 :                 (*output_part_boxes)[i].setpId(part_to_set_index);</span>
<span class="lineNum">    5262 </span>                :            :         }
<span class="lineNum">    5263 </span>                :<span class="lineNoCov">          0 :         for (mj_lno_t ii = begin; ii &lt; end; ++ii){</span>
<span class="lineNum">    5264 </span>                :<span class="lineNoCov">          0 :                 mj_lno_t k = this-&gt;coordinate_permutations[ii];</span>
<span class="lineNum">    5265 </span>                :<span class="lineNoCov">          0 :                 this-&gt;assigned_part_ids[k] = part_to_set_index;</span>
<span class="lineNum">    5266 </span>                :            :         }
<span class="lineNum">    5267 </span>                :            :     }
<span class="lineNum">    5268 </span>                :            : 
<span class="lineNum">    5269 </span>                :            :     //ArrayRCP&lt;const mj_gno_t&gt; gnoList;
<span class="lineNum">    5270 </span>                :<span class="lineNoCov">          0 :     if(!is_data_ever_migrated){</span>
<span class="lineNum">    5271 </span>                :            :         //freeArray&lt;mj_gno_t&gt;(this-&gt;current_mj_gnos);
<span class="lineNum">    5272 </span>                :            :         //if(this-&gt;num_local_coords &gt; 0){
<span class="lineNum">    5273 </span>                :            :         //    gnoList = arcpFromArrayView(this-&gt;mj_gnos);
<span class="lineNum">    5274 </span>                :            :         //}
<span class="lineNum">    5275 </span>                :            :     }
<span class="lineNum">    5276 </span>                :            :     else {
<span class="lineNum">    5277 </span>                :            : #ifdef ENABLE_ZOLTAN_MIGRATION
<span class="lineNum">    5278 </span>                :            :       if (sizeof(mj_lno_t) &lt;=  sizeof(int)) {
<span class="lineNum">    5279 </span>                :            : 
<span class="lineNum">    5280 </span>                :            :         // Cannot use Zoltan_Comm with local ordinals larger than ints.
<span class="lineNum">    5281 </span>                :            :         // In Zoltan_Comm_Create, the cast int(this-&gt;num_local_coords)
<span class="lineNum">    5282 </span>                :            :         // may overflow.
<span class="lineNum">    5283 </span>                :            : 
<span class="lineNum">    5284 </span>                :            :         //if data is migrated, then send part numbers to the original owners.
<span class="lineNum">    5285 </span>                :            :         ZOLTAN_COMM_OBJ *plan = NULL;
<span class="lineNum">    5286 </span>                :            :         MPI_Comm mpi_comm = Teuchos2MPI (this-&gt;mj_problemComm);
<span class="lineNum">    5287 </span>                :            : 
<span class="lineNum">    5288 </span>                :            :         int incoming = 0;
<span class="lineNum">    5289 </span>                :            :         int message_tag = 7856;
<span class="lineNum">    5290 </span>                :            : 
<span class="lineNum">    5291 </span>                :            :         this-&gt;mj_env-&gt;timerStart(MACRO_TIMERS, &quot;MultiJagged - Final Z1PlanCreating&quot;);
<span class="lineNum">    5292 </span>                :            :         int ierr = Zoltan_Comm_Create( &amp;plan, int(this-&gt;num_local_coords),
<span class="lineNum">    5293 </span>                :            :                         this-&gt;owner_of_coordinate, mpi_comm, message_tag,
<span class="lineNum">    5294 </span>                :            :                         &amp;incoming);
<span class="lineNum">    5295 </span>                :            :         Z2_ASSERT_VALUE(ierr, ZOLTAN_OK);
<span class="lineNum">    5296 </span>                :            :         this-&gt;mj_env-&gt;timerStop(MACRO_TIMERS, &quot;MultiJagged - Final Z1PlanCreating&quot; );
<span class="lineNum">    5297 </span>                :            : 
<span class="lineNum">    5298 </span>                :            :         mj_gno_t *incoming_gnos = allocMemory&lt; mj_gno_t&gt;(incoming);
<span class="lineNum">    5299 </span>                :            : 
<span class="lineNum">    5300 </span>                :            :         message_tag++;
<span class="lineNum">    5301 </span>                :            :         this-&gt;mj_env-&gt;timerStart(MACRO_TIMERS, &quot;MultiJagged - Final Z1PlanComm&quot;);
<span class="lineNum">    5302 </span>                :            :         ierr = Zoltan_Comm_Do( plan, message_tag, (char *) this-&gt;current_mj_gnos,
<span class="lineNum">    5303 </span>                :            :                         sizeof(mj_gno_t), (char *) incoming_gnos);
<span class="lineNum">    5304 </span>                :            :         Z2_ASSERT_VALUE(ierr, ZOLTAN_OK);
<span class="lineNum">    5305 </span>                :            : 
<span class="lineNum">    5306 </span>                :            :         freeArray&lt;mj_gno_t&gt;(this-&gt;current_mj_gnos);
<span class="lineNum">    5307 </span>                :            :         this-&gt;current_mj_gnos = incoming_gnos;
<span class="lineNum">    5308 </span>                :            : 
<span class="lineNum">    5309 </span>                :            :         mj_part_t *incoming_partIds = allocMemory&lt; mj_part_t&gt;(incoming);
<span class="lineNum">    5310 </span>                :            : 
<span class="lineNum">    5311 </span>                :            :         message_tag++;
<span class="lineNum">    5312 </span>                :            :         ierr = Zoltan_Comm_Do( plan, message_tag, (char *) this-&gt;assigned_part_ids,
<span class="lineNum">    5313 </span>                :            :                         sizeof(mj_part_t), (char *) incoming_partIds);
<span class="lineNum">    5314 </span>                :            :         Z2_ASSERT_VALUE(ierr, ZOLTAN_OK);
<span class="lineNum">    5315 </span>                :            :         freeArray&lt;mj_part_t&gt;(this-&gt;assigned_part_ids);
<span class="lineNum">    5316 </span>                :            :         this-&gt;assigned_part_ids = incoming_partIds;
<span class="lineNum">    5317 </span>                :            : 
<span class="lineNum">    5318 </span>                :            :         this-&gt;mj_env-&gt;timerStop(MACRO_TIMERS, &quot;MultiJagged - Final Z1PlanComm&quot;);
<span class="lineNum">    5319 </span>                :            :         ierr = Zoltan_Comm_Destroy(&amp;plan);
<span class="lineNum">    5320 </span>                :            :         Z2_ASSERT_VALUE(ierr, ZOLTAN_OK);
<span class="lineNum">    5321 </span>                :            : 
<span class="lineNum">    5322 </span>                :            :         this-&gt;num_local_coords = incoming;
<span class="lineNum">    5323 </span>                :            :         //gnoList = arcp(this-&gt;current_mj_gnos, 0, this-&gt;num_local_coords, true);
<span class="lineNum">    5324 </span>                :            :       }
<span class="lineNum">    5325 </span>                :            :       else
<span class="lineNum">    5326 </span>                :            : 
<span class="lineNum">    5327 </span>                :            : #endif  // !ENABLE_ZOLTAN_MIGRATION
<span class="lineNum">    5328 </span>                :            :       {
<span class="lineNum">    5329 </span>                :            :         //if data is migrated, then send part numbers to the original owners.
<span class="lineNum">    5330 </span>                :<span class="lineNoCov">          0 :         this-&gt;mj_env-&gt;timerStart(MACRO_TIMERS, &quot;MultiJagged - Final DistributorPlanCreating&quot;);</span>
<span class="lineNum">    5331 </span>                :<span class="lineNoCov">          0 :         Tpetra::Distributor distributor(this-&gt;mj_problemComm);</span>
<span class="lineNum">    5332 </span>                :<span class="lineNoCov">          0 :         ArrayView&lt;const mj_part_t&gt; owners_of_coords(this-&gt;owner_of_coordinate, this-&gt;num_local_coords);</span>
<span class="lineNum">    5333 </span>                :<span class="lineNoCov">          0 :         mj_lno_t incoming = distributor.createFromSends(owners_of_coords);</span>
<span class="lineNum">    5334 </span>                :<span class="lineNoCov">          0 :         this-&gt;mj_env-&gt;timerStop(MACRO_TIMERS, &quot;MultiJagged - Final DistributorPlanCreating&quot; );</span>
<span class="lineNum">    5335 </span>                :            : 
<span class="lineNum">    5336 </span>                :<span class="lineNoCov">          0 :         this-&gt;mj_env-&gt;timerStart(MACRO_TIMERS, &quot;MultiJagged - Final DistributorPlanComm&quot;);</span>
<span class="lineNum">    5337 </span>                :            :         //migrate gnos to actual owners.
<span class="lineNum">    5338 </span>                :<span class="lineNoCov">          0 :         ArrayRCP&lt;mj_gno_t&gt; received_gnos(incoming);</span>
<span class="lineNum">    5339 </span>                :<span class="lineNoCov">          0 :         ArrayView&lt;mj_gno_t&gt; sent_gnos(this-&gt;current_mj_gnos, this-&gt;num_local_coords);</span>
<span class="lineNum">    5340 </span>                :<span class="lineNoCov">          0 :         distributor.doPostsAndWaits&lt;mj_gno_t&gt;(sent_gnos, 1, received_gnos());</span>
<span class="lineNum">    5341 </span>                :<span class="lineNoCov">          0 :         freeArray&lt;mj_gno_t&gt;(this-&gt;current_mj_gnos);</span>
<span class="lineNum">    5342 </span>                :<span class="lineNoCov">          0 :         this-&gt;current_mj_gnos = allocMemory&lt;mj_gno_t&gt;(incoming);</span>
<span class="lineNum">    5343 </span>                :<span class="lineNoCov">          0 :         memcpy( this-&gt;current_mj_gnos,</span>
<span class="lineNum">    5344 </span>                :            :                 received_gnos.getRawPtr(),
<span class="lineNum">    5345 </span>                :            :                 incoming * sizeof(mj_gno_t));
<span class="lineNum">    5346 </span>                :            : 
<span class="lineNum">    5347 </span>                :            :                 //migrate part ids to actual owners.
<span class="lineNum">    5348 </span>                :<span class="lineNoCov">          0 :         ArrayView&lt;mj_part_t&gt; sent_partids(this-&gt;assigned_part_ids, this-&gt;num_local_coords);</span>
<span class="lineNum">    5349 </span>                :<span class="lineNoCov">          0 :         ArrayRCP&lt;mj_part_t&gt; received_partids(incoming);</span>
<span class="lineNum">    5350 </span>                :<span class="lineNoCov">          0 :         distributor.doPostsAndWaits&lt;mj_part_t&gt;(sent_partids, 1, received_partids());</span>
<span class="lineNum">    5351 </span>                :<span class="lineNoCov">          0 :         freeArray&lt;mj_part_t&gt;(this-&gt;assigned_part_ids);</span>
<span class="lineNum">    5352 </span>                :<span class="lineNoCov">          0 :         this-&gt;assigned_part_ids = allocMemory&lt;mj_part_t&gt;(incoming);</span>
<span class="lineNum">    5353 </span>                :<span class="lineNoCov">          0 :         memcpy( this-&gt;assigned_part_ids,</span>
<span class="lineNum">    5354 </span>                :            :                 received_partids.getRawPtr(),
<span class="lineNum">    5355 </span>                :            :                 incoming * sizeof(mj_part_t));
<span class="lineNum">    5356 </span>                :            : 
<span class="lineNum">    5357 </span>                :<span class="lineNoCov">          0 :         this-&gt;num_local_coords = incoming;</span>
<span class="lineNum">    5358 </span>                :<span class="lineNoCov">          0 :         this-&gt;mj_env-&gt;timerStop(MACRO_TIMERS, &quot;MultiJagged - Final DistributorPlanComm&quot;);</span>
<span class="lineNum">    5359 </span>                :            : 
<span class="lineNum">    5360 </span>                :            :       }
<span class="lineNum">    5361 </span>                :            :     }
<span class="lineNum">    5362 </span>                :            : 
<span class="lineNum">    5363 </span>                :<span class="lineNoCov">          0 :     this-&gt;mj_env-&gt;timerStop(MACRO_TIMERS, &quot;MultiJagged - Part_Assignment&quot;);</span>
<span class="lineNum">    5364 </span>                :            : 
<span class="lineNum">    5365 </span>                :<span class="lineNoCov">          0 :     this-&gt;mj_env-&gt;timerStart(MACRO_TIMERS, &quot;MultiJagged - Solution_Part_Assignment&quot;);</span>
<span class="lineNum">    5366 </span>                :            : 
<span class="lineNum">    5367 </span>                :            :     //ArrayRCP&lt;mj_part_t&gt; partId;
<span class="lineNum">    5368 </span>                :            :     //partId = arcp(this-&gt;assigned_part_ids, 0, this-&gt;num_local_coords, true);
<span class="lineNum">    5369 </span>                :            : 
<span class="lineNum">    5370 </span>                :<span class="lineNoCov">          0 :     if (this-&gt;mj_keep_part_boxes){</span>
<span class="lineNum">    5371 </span>                :<span class="lineNoCov">          0 :         this-&gt;kept_boxes = compute_global_box_boundaries(output_part_boxes);</span>
<span class="lineNum">    5372 </span>                :            : 
<span class="lineNum">    5373 </span>                :            :     }
<span class="lineNum">    5374 </span>                :            : 
<span class="lineNum">    5375 </span>                :<span class="lineNoCov">          0 :     this-&gt;mj_env-&gt;timerStop(MACRO_TIMERS, &quot;MultiJagged - Solution_Part_Assignment&quot;);</span>
<span class="lineNum">    5376 </span>                :<span class="lineNoCov">          0 : }</span>
<span class="lineNum">    5377 </span>                :            : 
<span class="lineNum">    5378 </span>                :            : /*! \brief Function frees all allocated work memory.
<span class="lineNum">    5379 </span>                :            : */
<a name="5380"><span class="lineNum">    5380 </span>                :            : template &lt;typename mj_scalar_t, typename mj_lno_t, typename mj_gno_t,</a>
<span class="lineNum">    5381 </span>                :            :           typename mj_part_t&gt;
<span class="lineNum">    5382 </span>                :<span class="lineNoCov">          0 : void AlgMJ&lt;mj_scalar_t, mj_lno_t, mj_gno_t, mj_part_t&gt;::free_work_memory(){</span>
<span class="lineNum">    5383 </span>                :<span class="lineNoCov">          0 :         this-&gt;mj_env-&gt;timerStart(MACRO_TIMERS, &quot;MultiJagged - Problem_Free&quot;);</span>
<span class="lineNum">    5384 </span>                :            : 
<span class="lineNum">    5385 </span>                :<span class="lineNoCov">          0 :         for (int i=0; i &lt; this-&gt;coord_dim; i++){</span>
<span class="lineNum">    5386 </span>                :<span class="lineNoCov">          0 :                 freeArray&lt;mj_scalar_t&gt;(this-&gt;mj_coordinates[i]);</span>
<span class="lineNum">    5387 </span>                :            :         }
<span class="lineNum">    5388 </span>                :<span class="lineNoCov">          0 :         freeArray&lt;mj_scalar_t *&gt;(this-&gt;mj_coordinates);</span>
<span class="lineNum">    5389 </span>                :            : 
<span class="lineNum">    5390 </span>                :<span class="lineNoCov">          0 :         for (int i=0; i &lt; this-&gt;num_weights_per_coord; i++){</span>
<span class="lineNum">    5391 </span>                :<span class="lineNoCov">          0 :                 freeArray&lt;mj_scalar_t&gt;(this-&gt;mj_weights[i]);</span>
<span class="lineNum">    5392 </span>                :            :         }
<span class="lineNum">    5393 </span>                :<span class="lineNoCov">          0 :         freeArray&lt;mj_scalar_t *&gt;(this-&gt;mj_weights);</span>
<span class="lineNum">    5394 </span>                :            : 
<span class="lineNum">    5395 </span>                :<span class="lineNoCov">          0 :         freeArray&lt;int&gt;(this-&gt;owner_of_coordinate);</span>
<span class="lineNum">    5396 </span>                :            : 
<span class="lineNum">    5397 </span>                :<span class="lineNoCov">          0 :         for(int i = 0; i &lt; this-&gt;num_threads; ++i){</span>
<span class="lineNum">    5398 </span>                :<span class="lineNoCov">          0 :                 freeArray&lt;mj_lno_t&gt;(this-&gt;thread_point_counts[i]);</span>
<span class="lineNum">    5399 </span>                :            :         }
<span class="lineNum">    5400 </span>                :            : 
<span class="lineNum">    5401 </span>                :<span class="lineNoCov">          0 :         freeArray&lt;mj_lno_t *&gt;(this-&gt;thread_point_counts);</span>
<span class="lineNum">    5402 </span>                :<span class="lineNoCov">          0 :         freeArray&lt;double *&gt; (this-&gt;thread_part_weight_work);</span>
<span class="lineNum">    5403 </span>                :            : 
<span class="lineNum">    5404 </span>                :<span class="lineNoCov">          0 :         if(this-&gt;distribute_points_on_cut_lines){</span>
<span class="lineNum">    5405 </span>                :<span class="lineNoCov">          0 :                 freeArray&lt;mj_scalar_t&gt;(this-&gt;process_cut_line_weight_to_put_left);</span>
<span class="lineNum">    5406 </span>                :<span class="lineNoCov">          0 :                 for(int i = 0; i &lt; this-&gt;num_threads; ++i){</span>
<span class="lineNum">    5407 </span>                :<span class="lineNoCov">          0 :                         freeArray&lt;mj_scalar_t&gt;(this-&gt;thread_cut_line_weight_to_put_left[i]);</span>
<span class="lineNum">    5408 </span>                :            :                 }
<span class="lineNum">    5409 </span>                :<span class="lineNoCov">          0 :                 freeArray&lt;mj_scalar_t *&gt;(this-&gt;thread_cut_line_weight_to_put_left);</span>
<span class="lineNum">    5410 </span>                :<span class="lineNoCov">          0 :                 freeArray&lt;mj_scalar_t&gt;(this-&gt;process_rectilinear_cut_weight);</span>
<span class="lineNum">    5411 </span>                :<span class="lineNoCov">          0 :                 freeArray&lt;mj_scalar_t&gt;(this-&gt;global_rectilinear_cut_weight);</span>
<span class="lineNum">    5412 </span>                :            :         }
<span class="lineNum">    5413 </span>                :            : 
<span class="lineNum">    5414 </span>                :<span class="lineNoCov">          0 :         freeArray&lt;mj_part_t&gt;(this-&gt;my_incomplete_cut_count);</span>
<span class="lineNum">    5415 </span>                :            : 
<span class="lineNum">    5416 </span>                :<span class="lineNoCov">          0 :         freeArray&lt;mj_scalar_t&gt;(this-&gt;max_min_coords);</span>
<span class="lineNum">    5417 </span>                :            : 
<span class="lineNum">    5418 </span>                :<span class="lineNoCov">          0 :         freeArray&lt;mj_lno_t&gt;(this-&gt;new_part_xadj);</span>
<span class="lineNum">    5419 </span>                :            : 
<span class="lineNum">    5420 </span>                :<span class="lineNoCov">          0 :         freeArray&lt;mj_lno_t&gt;(this-&gt;coordinate_permutations);</span>
<span class="lineNum">    5421 </span>                :            : 
<span class="lineNum">    5422 </span>                :<span class="lineNoCov">          0 :         freeArray&lt;mj_lno_t&gt;(this-&gt;new_coordinate_permutations);</span>
<span class="lineNum">    5423 </span>                :            : 
<span class="lineNum">    5424 </span>                :<span class="lineNoCov">          0 :         freeArray&lt;mj_scalar_t&gt;(this-&gt;all_cut_coordinates);</span>
<span class="lineNum">    5425 </span>                :            : 
<span class="lineNum">    5426 </span>                :<span class="lineNoCov">          0 :         freeArray&lt;mj_scalar_t&gt; (this-&gt;process_local_min_max_coord_total_weight);</span>
<span class="lineNum">    5427 </span>                :            : 
<span class="lineNum">    5428 </span>                :<span class="lineNoCov">          0 :         freeArray&lt;mj_scalar_t&gt; (this-&gt;global_min_max_coord_total_weight);</span>
<span class="lineNum">    5429 </span>                :            : 
<span class="lineNum">    5430 </span>                :<span class="lineNoCov">          0 :         freeArray&lt;mj_scalar_t&gt;(this-&gt;cut_coordinates_work_array);</span>
<span class="lineNum">    5431 </span>                :            : 
<span class="lineNum">    5432 </span>                :<span class="lineNoCov">          0 :         freeArray&lt;mj_scalar_t&gt;(this-&gt;target_part_weights);</span>
<span class="lineNum">    5433 </span>                :            : 
<span class="lineNum">    5434 </span>                :<span class="lineNoCov">          0 :         freeArray&lt;mj_scalar_t&gt;(this-&gt;cut_upper_bound_coordinates);</span>
<span class="lineNum">    5435 </span>                :            : 
<span class="lineNum">    5436 </span>                :<span class="lineNoCov">          0 :         freeArray&lt;mj_scalar_t&gt;(this-&gt;cut_lower_bound_coordinates);</span>
<span class="lineNum">    5437 </span>                :            : 
<span class="lineNum">    5438 </span>                :<span class="lineNoCov">          0 :         freeArray&lt;mj_scalar_t&gt;(this-&gt;cut_lower_bound_weights);</span>
<span class="lineNum">    5439 </span>                :<span class="lineNoCov">          0 :         freeArray&lt;mj_scalar_t&gt;(this-&gt;cut_upper_bound_weights);</span>
<span class="lineNum">    5440 </span>                :<span class="lineNoCov">          0 :         freeArray&lt;bool&gt;(this-&gt;is_cut_line_determined);</span>
<span class="lineNum">    5441 </span>                :<span class="lineNoCov">          0 :         freeArray&lt;mj_scalar_t&gt;(this-&gt;total_part_weight_left_right_closests);</span>
<span class="lineNum">    5442 </span>                :<span class="lineNoCov">          0 :         freeArray&lt;mj_scalar_t&gt;(this-&gt;global_total_part_weight_left_right_closests);</span>
<span class="lineNum">    5443 </span>                :            : 
<span class="lineNum">    5444 </span>                :<span class="lineNoCov">          0 :         for(int i = 0; i &lt; this-&gt;num_threads; ++i){</span>
<span class="lineNum">    5445 </span>                :<span class="lineNoCov">          0 :                 freeArray&lt;double&gt;(this-&gt;thread_part_weights[i]);</span>
<span class="lineNum">    5446 </span>                :<span class="lineNoCov">          0 :                 freeArray&lt;mj_scalar_t&gt;(this-&gt;thread_cut_right_closest_point[i]);</span>
<span class="lineNum">    5447 </span>                :<span class="lineNoCov">          0 :                 freeArray&lt;mj_scalar_t&gt;(this-&gt;thread_cut_left_closest_point[i]);</span>
<span class="lineNum">    5448 </span>                :            :         }
<span class="lineNum">    5449 </span>                :            : 
<span class="lineNum">    5450 </span>                :<span class="lineNoCov">          0 :         freeArray&lt;double *&gt;(this-&gt;thread_part_weights);</span>
<span class="lineNum">    5451 </span>                :<span class="lineNoCov">          0 :         freeArray&lt;mj_scalar_t *&gt;(this-&gt;thread_cut_left_closest_point);</span>
<span class="lineNum">    5452 </span>                :<span class="lineNoCov">          0 :         freeArray&lt;mj_scalar_t *&gt;(this-&gt;thread_cut_right_closest_point);</span>
<span class="lineNum">    5453 </span>                :            : 
<span class="lineNum">    5454 </span>                :<span class="lineNoCov">          0 :         this-&gt;mj_env-&gt;timerStop(MACRO_TIMERS, &quot;MultiJagged - Problem_Free&quot;);</span>
<span class="lineNum">    5455 </span>                :<span class="lineNoCov">          0 : }</span>
<span class="lineNum">    5456 </span>                :            : 
<span class="lineNum">    5457 </span>                :            : /*! \brief Multi Jagged  coordinate partitioning algorithm.
<span class="lineNum">    5458 </span>                :            :  *
<span class="lineNum">    5459 </span>                :            :  *  \param distribute_points_on_cut_lines_ :  if partitioning can distribute points on same coordinate to different parts.
<span class="lineNum">    5460 </span>                :            :  *  \param max_concurrent_part_calculation_ : how many parts we can calculate concurrently.
<span class="lineNum">    5461 </span>                :            :  *  \param check_migrate_avoid_migration_option_ : whether to migrate=1, avoid migrate=2, or leave decision to MJ=0
<span class="lineNum">    5462 </span>                :            :  *  \param minimum_migration_imbalance_  : when MJ decides whether to migrate, the minimum imbalance for migration.
<span class="lineNum">    5463 </span>                :            :  */
<a name="5464"><span class="lineNum">    5464 </span>                :            : template &lt;typename mj_scalar_t, typename mj_lno_t, typename mj_gno_t,</a>
<span class="lineNum">    5465 </span>                :            :           typename mj_part_t&gt;
<span class="lineNum">    5466 </span>                :<span class="lineNoCov">          0 : void AlgMJ&lt;mj_scalar_t, mj_lno_t, mj_gno_t, mj_part_t&gt;::set_partitioning_parameters(</span>
<span class="lineNum">    5467 </span>                :            :                 bool distribute_points_on_cut_lines_,
<span class="lineNum">    5468 </span>                :            :                 int max_concurrent_part_calculation_,
<span class="lineNum">    5469 </span>                :            :                 int check_migrate_avoid_migration_option_,
<span class="lineNum">    5470 </span>                :            :                 mj_scalar_t minimum_migration_imbalance_){
<span class="lineNum">    5471 </span>                :<span class="lineNoCov">          0 :         this-&gt;distribute_points_on_cut_lines = distribute_points_on_cut_lines_;</span>
<span class="lineNum">    5472 </span>                :<span class="lineNoCov">          0 :         this-&gt;max_concurrent_part_calculation = max_concurrent_part_calculation_;</span>
<span class="lineNum">    5473 </span>                :<span class="lineNoCov">          0 :         this-&gt;check_migrate_avoid_migration_option = check_migrate_avoid_migration_option_;</span>
<span class="lineNum">    5474 </span>                :<span class="lineNoCov">          0 :         this-&gt;minimum_migration_imbalance = minimum_migration_imbalance_;</span>
<span class="lineNum">    5475 </span>                :            : 
<span class="lineNum">    5476 </span>                :<span class="lineNoCov">          0 : }</span>
<span class="lineNum">    5477 </span>                :            : 
<span class="lineNum">    5478 </span>                :            : 
<span class="lineNum">    5479 </span>                :            : /*! \brief Multi Jagged  coordinate partitioning algorithm.
<span class="lineNum">    5480 </span>                :            :  *
<span class="lineNum">    5481 </span>                :            :  *  \param env   library configuration and problem parameters
<span class="lineNum">    5482 </span>                :            :  *  \param problemComm the communicator for the problem
<span class="lineNum">    5483 </span>                :            :  *  \param imbalance_tolerance : the input provided imbalance tolerance.
<span class="lineNum">    5484 </span>                :            :  *  \param num_global_parts: number of target global parts.
<span class="lineNum">    5485 </span>                :            :  *  \param part_no_array: part no array, if provided this will be used for partitioning.
<span class="lineNum">    5486 </span>                :            :  *  \param recursion_depth: if part no array is provided, it is the length of part no array,
<span class="lineNum">    5487 </span>                :            :  *                                              if part no is not provided than it is the number of steps that algorithm will divide into num_global_parts parts.
<span class="lineNum">    5488 </span>                :            :  *
<span class="lineNum">    5489 </span>                :            :  *  \param coord_dim: coordinate dimension
<span class="lineNum">    5490 </span>                :            :  *  \param num_local_coords: number of local coordinates
<span class="lineNum">    5491 </span>                :            :  *  \param num_global_coords: number of global coordinates
<span class="lineNum">    5492 </span>                :            :  *  \param initial_mj_gnos: the list of initial global id's
<span class="lineNum">    5493 </span>                :            :  *  \param mj_coordinates: the two dimensional coordinate array.
<span class="lineNum">    5494 </span>                :            :  *
<span class="lineNum">    5495 </span>                :            :  *  \param num_weights_per_coord: number of weights per coordinate
<span class="lineNum">    5496 </span>                :            :  *  \param mj_uniform_weights: if weight index [i] has uniform weight or not.
<span class="lineNum">    5497 </span>                :            :  *  \param mj_weights: the two dimensional array for weights
<span class="lineNum">    5498 </span>                :            :  *  \param mj_uniform_parts: if the target partitioning aims uniform parts
<span class="lineNum">    5499 </span>                :            :  *  \param mj_part_sizes: if the target partitioning does not aim uniform parts, then weight of each part.
<span class="lineNum">    5500 </span>                :            :  *
<span class="lineNum">    5501 </span>                :            :  *  \param result_assigned_part_ids: Output - 1D pointer, should be provided as null. Memory is given in the function.
<span class="lineNum">    5502 </span>                :            :  *                      the result partids corresponding to the coordinates given in result_mj_gnos.
<span class="lineNum">    5503 </span>                :            :  *  \param result_mj_gnos: Output - 1D pointer, should be provided as null. Memory is given in the function.
<span class="lineNum">    5504 </span>                :            :  *                      the result coordinate global id's corresponding to the part_ids array.
<span class="lineNum">    5505 </span>                :            :  *
<span class="lineNum">    5506 </span>                :            :  */
<a name="5507"><span class="lineNum">    5507 </span>                :            : template &lt;typename mj_scalar_t, typename mj_lno_t, typename mj_gno_t,</a>
<span class="lineNum">    5508 </span>                :            :           typename mj_part_t&gt;
<span class="lineNum">    5509 </span>                :<span class="lineNoCov">          0 : void AlgMJ&lt;mj_scalar_t, mj_lno_t, mj_gno_t, mj_part_t&gt;::multi_jagged_part(</span>
<span class="lineNum">    5510 </span>                :            : 
<span class="lineNum">    5511 </span>                :            :         const RCP&lt;const Environment&gt; &amp;env,
<span class="lineNum">    5512 </span>                :            :         RCP&lt;Comm&lt;int&gt; &gt; &amp;problemComm,
<span class="lineNum">    5513 </span>                :            : 
<span class="lineNum">    5514 </span>                :            :         double imbalance_tolerance_,
<span class="lineNum">    5515 </span>                :            :         size_t num_global_parts_,
<span class="lineNum">    5516 </span>                :            :         mj_part_t *part_no_array_,
<span class="lineNum">    5517 </span>                :            :         int recursion_depth_,
<span class="lineNum">    5518 </span>                :            : 
<span class="lineNum">    5519 </span>                :            :         int coord_dim_,
<span class="lineNum">    5520 </span>                :            :         mj_lno_t num_local_coords_,
<span class="lineNum">    5521 </span>                :            :         mj_gno_t num_global_coords_,
<span class="lineNum">    5522 </span>                :            :         const mj_gno_t *initial_mj_gnos_,
<span class="lineNum">    5523 </span>                :            :         mj_scalar_t **mj_coordinates_,
<span class="lineNum">    5524 </span>                :            : 
<span class="lineNum">    5525 </span>                :            :         int num_weights_per_coord_,
<span class="lineNum">    5526 </span>                :            :         bool *mj_uniform_weights_,
<span class="lineNum">    5527 </span>                :            :         mj_scalar_t **mj_weights_,
<span class="lineNum">    5528 </span>                :            :         bool *mj_uniform_parts_,
<span class="lineNum">    5529 </span>                :            :         mj_scalar_t **mj_part_sizes_,
<span class="lineNum">    5530 </span>                :            : 
<span class="lineNum">    5531 </span>                :            :         mj_part_t *&amp;result_assigned_part_ids_,
<span class="lineNum">    5532 </span>                :            :         mj_gno_t *&amp;result_mj_gnos_
<span class="lineNum">    5533 </span>                :            : )
<span class="lineNum">    5534 </span>                :            : {
<span class="lineNum">    5535 </span>                :            : 
<span class="lineNum">    5536 </span>                :            : #ifdef print_debug
<span class="lineNum">    5537 </span>                :            :     if(comm-&gt;getRank() == 0){
<span class="lineNum">    5538 </span>                :            :         std::cout &lt;&lt; &quot;size of gno:&quot; &lt;&lt; sizeof(mj_gno_t) &lt;&lt; std::endl;
<span class="lineNum">    5539 </span>                :            :         std::cout &lt;&lt; &quot;size of lno:&quot; &lt;&lt; sizeof(mj_lno_t) &lt;&lt; std::endl;
<span class="lineNum">    5540 </span>                :            :         std::cout &lt;&lt; &quot;size of mj_scalar_t:&quot; &lt;&lt; sizeof(mj_scalar_t) &lt;&lt; std::endl;
<span class="lineNum">    5541 </span>                :            :     }
<span class="lineNum">    5542 </span>                :            : #endif
<span class="lineNum">    5543 </span>                :            : 
<span class="lineNum">    5544 </span>                :<span class="lineNoCov">          0 :     this-&gt;mj_env = env;</span>
<span class="lineNum">    5545 </span>                :<span class="lineNoCov">          0 :     this-&gt;mj_problemComm = problemComm;</span>
<span class="lineNum">    5546 </span>                :<span class="lineNoCov">          0 :     this-&gt;myActualRank = this-&gt;myRank = this-&gt;mj_problemComm-&gt;getRank();</span>
<span class="lineNum">    5547 </span>                :            : 
<span class="lineNum">    5548 </span>                :<span class="lineNoCov">          0 :     this-&gt;mj_env-&gt;timerStart(MACRO_TIMERS, &quot;MultiJagged - Total&quot;);</span>
<span class="lineNum">    5549 </span>                :<span class="lineNoCov">          0 :     this-&gt;mj_env-&gt;debug(3, &quot;In MultiJagged Jagged&quot;);</span>
<span class="lineNum">    5550 </span>                :            : 
<span class="lineNum">    5551 </span>                :            :     {
<span class="lineNum">    5552 </span>                :<span class="lineNoCov">          0 :         this-&gt;imbalance_tolerance = imbalance_tolerance_;</span>
<span class="lineNum">    5553 </span>                :<span class="lineNoCov">          0 :         this-&gt;num_global_parts = num_global_parts_;</span>
<span class="lineNum">    5554 </span>                :<span class="lineNoCov">          0 :         this-&gt;part_no_array =  part_no_array_;</span>
<span class="lineNum">    5555 </span>                :<span class="lineNoCov">          0 :         this-&gt;recursion_depth = recursion_depth_;</span>
<span class="lineNum">    5556 </span>                :            : 
<span class="lineNum">    5557 </span>                :<span class="lineNoCov">          0 :         this-&gt;coord_dim = coord_dim_;</span>
<span class="lineNum">    5558 </span>                :<span class="lineNoCov">          0 :         this-&gt;num_local_coords = num_local_coords_;</span>
<span class="lineNum">    5559 </span>                :<span class="lineNoCov">          0 :         this-&gt;num_global_coords = num_global_coords_;</span>
<span class="lineNum">    5560 </span>                :<span class="lineNoCov">          0 :         this-&gt;mj_coordinates = mj_coordinates_; //will copy the memory to this-&gt;mj_coordinates.</span>
<span class="lineNum">    5561 </span>                :<span class="lineNoCov">          0 :         this-&gt;initial_mj_gnos = (mj_gno_t *) initial_mj_gnos_; //will copy the memory to this-&gt;current_mj_gnos[j].</span>
<span class="lineNum">    5562 </span>                :            : 
<span class="lineNum">    5563 </span>                :<span class="lineNoCov">          0 :         this-&gt;num_weights_per_coord = num_weights_per_coord_;</span>
<span class="lineNum">    5564 </span>                :<span class="lineNoCov">          0 :         this-&gt;mj_uniform_weights = mj_uniform_weights_;</span>
<span class="lineNum">    5565 </span>                :<span class="lineNoCov">          0 :         this-&gt;mj_weights = mj_weights_; //will copy the memory to this-&gt;mj_weights</span>
<span class="lineNum">    5566 </span>                :<span class="lineNoCov">          0 :         this-&gt;mj_uniform_parts = mj_uniform_parts_;</span>
<span class="lineNum">    5567 </span>                :<span class="lineNoCov">          0 :         this-&gt;mj_part_sizes = mj_part_sizes_;</span>
<span class="lineNum">    5568 </span>                :            : 
<span class="lineNum">    5569 </span>                :<span class="lineNoCov">          0 :         this-&gt;num_threads = 1;</span>
<span class="lineNum">    5570 </span>                :            : #ifdef HAVE_ZOLTAN2_OMP
<span class="lineNum">    5571 </span>                :            : #pragma omp parallel
<span class="lineNum">    5572 </span>                :            : 
<span class="lineNum">    5573 </span>                :            :         {
<span class="lineNum">    5574 </span>                :            :                 this-&gt;num_threads = omp_get_num_threads();
<span class="lineNum">    5575 </span>                :            :         }
<span class="lineNum">    5576 </span>                :            : #endif
<span class="lineNum">    5577 </span>                :            :     }
<span class="lineNum">    5578 </span>                :            :     //this-&gt;set_input_data();
<span class="lineNum">    5579 </span>                :<span class="lineNoCov">          0 :     this-&gt;set_part_specifications();</span>
<span class="lineNum">    5580 </span>                :            : 
<span class="lineNum">    5581 </span>                :<span class="lineNoCov">          0 :     this-&gt;allocate_set_work_memory();</span>
<span class="lineNum">    5582 </span>                :            : 
<span class="lineNum">    5583 </span>                :            :     //We duplicate the comm as we create subcommunicators during migration.
<span class="lineNum">    5584 </span>                :            :     //We keep the problemComm as it is, while comm changes after each migration.
<span class="lineNum">    5585 </span>                :<span class="lineNoCov">          0 :     this-&gt;comm = this-&gt;mj_problemComm-&gt;duplicate();</span>
<span class="lineNum">    5586 </span>                :            : 
<span class="lineNum">    5587 </span>                :            :     //initially there is a single partition
<span class="lineNum">    5588 </span>                :<span class="lineNoCov">          0 :     mj_part_t current_num_parts = 1;</span>
<span class="lineNum">    5589 </span>                :<span class="lineNoCov">          0 :     mj_scalar_t *current_cut_coordinates =  this-&gt;all_cut_coordinates;</span>
<span class="lineNum">    5590 </span>                :            : 
<span class="lineNum">    5591 </span>                :<span class="lineNoCov">          0 :     this-&gt;mj_env-&gt;timerStart(MACRO_TIMERS, &quot;MultiJagged - Problem_Partitioning&quot;);</span>
<span class="lineNum">    5592 </span>                :            : 
<span class="lineNum">    5593 </span>                :<span class="lineNoCov">          0 :     mj_part_t output_part_begin_index = 0;</span>
<span class="lineNum">    5594 </span>                :<span class="lineNoCov">          0 :     mj_part_t future_num_parts = this-&gt;total_num_part;</span>
<span class="lineNum">    5595 </span>                :<span class="lineNoCov">          0 :     bool is_data_ever_migrated = false;</span>
<span class="lineNum">    5596 </span>                :            : 
<span class="lineNum">    5597 </span>                :<span class="lineNoCov">          0 :     std::vector&lt;mj_part_t&gt; *future_num_part_in_parts = new std::vector&lt;mj_part_t&gt; ();</span>
<span class="lineNum">    5598 </span>                :<span class="lineNoCov">          0 :     std::vector&lt;mj_part_t&gt; *next_future_num_parts_in_parts = new std::vector&lt;mj_part_t&gt; ();</span>
<span class="lineNum">    5599 </span>                :<span class="lineNoCov">          0 :     next_future_num_parts_in_parts-&gt;push_back(this-&gt;num_global_parts);</span>
<span class="lineNum">    5600 </span>                :            : 
<span class="lineNum">    5601 </span>                :<span class="lineNoCov">          0 :     RCP&lt;mj_partBoxVector_t&gt; input_part_boxes(new mj_partBoxVector_t(), true) ;</span>
<span class="lineNum">    5602 </span>                :<span class="lineNoCov">          0 :     RCP&lt;mj_partBoxVector_t&gt; output_part_boxes(new mj_partBoxVector_t(), true);</span>
<span class="lineNum">    5603 </span>                :            : 
<span class="lineNum">    5604 </span>                :<span class="lineNoCov">          0 :     compute_global_box();</span>
<span class="lineNum">    5605 </span>                :<span class="lineNoCov">          0 :     if(this-&gt;mj_keep_part_boxes){</span>
<span class="lineNum">    5606 </span>                :<span class="lineNoCov">          0 :         this-&gt;init_part_boxes(output_part_boxes);</span>
<span class="lineNum">    5607 </span>                :            :     }
<span class="lineNum">    5608 </span>                :            : 
<span class="lineNum">    5609 </span>                :<span class="lineNoCov">          0 :     for (int i = 0; i &lt; this-&gt;recursion_depth; ++i){</span>
<span class="lineNum">    5610 </span>                :            :         //partitioning array. size will be as the number of current partitions and this
<span class="lineNum">    5611 </span>                :            :         //holds how many parts that each part will be in the current dimension partitioning.
<span class="lineNum">    5612 </span>                :<span class="lineNoCov">          0 :         std::vector &lt;mj_part_t&gt; num_partitioning_in_current_dim;</span>
<span class="lineNum">    5613 </span>                :            : 
<span class="lineNum">    5614 </span>                :            :         //number of parts that will be obtained at the end of this partitioning.
<span class="lineNum">    5615 </span>                :            :         //future_num_part_in_parts is as the size of current number of parts.
<span class="lineNum">    5616 </span>                :            :         //holds how many more parts each should be divided in the further
<span class="lineNum">    5617 </span>                :            :         //iterations. this will be used to calculate num_partitioning_in_current_dim,
<span class="lineNum">    5618 </span>                :            :         //as the number of parts that the part will be partitioned
<span class="lineNum">    5619 </span>                :            :         //in the current dimension partitioning.
<span class="lineNum">    5620 </span>                :            : 
<span class="lineNum">    5621 </span>                :            :         //next_future_num_parts_in_parts will be as the size of outnumParts,
<span class="lineNum">    5622 </span>                :            :         //and this will hold how many more parts that each output part
<span class="lineNum">    5623 </span>                :            :         //should be divided. this array will also be used to determine the weight ratios
<span class="lineNum">    5624 </span>                :            :         //of the parts.
<span class="lineNum">    5625 </span>                :            :         //swap the arrays to use iteratively..
<span class="lineNum">    5626 </span>                :<span class="lineNoCov">          0 :         std::vector&lt;mj_part_t&gt; *tmpPartVect= future_num_part_in_parts;</span>
<span class="lineNum">    5627 </span>                :<span class="lineNoCov">          0 :         future_num_part_in_parts = next_future_num_parts_in_parts;</span>
<span class="lineNum">    5628 </span>                :<span class="lineNoCov">          0 :         next_future_num_parts_in_parts = tmpPartVect;</span>
<span class="lineNum">    5629 </span>                :            : 
<span class="lineNum">    5630 </span>                :            :         //clear next_future_num_parts_in_parts array as
<span class="lineNum">    5631 </span>                :            :         //getPartitionArrays expects it to be empty.
<span class="lineNum">    5632 </span>                :            :         //it also expects num_partitioning_in_current_dim to be empty as well.
<span class="lineNum">    5633 </span>                :<span class="lineNoCov">          0 :         next_future_num_parts_in_parts-&gt;clear();</span>
<span class="lineNum">    5634 </span>                :            : 
<span class="lineNum">    5635 </span>                :<span class="lineNoCov">          0 :         if(this-&gt;mj_keep_part_boxes){</span>
<span class="lineNum">    5636 </span>                :<span class="lineNoCov">          0 :             RCP&lt;mj_partBoxVector_t&gt; tmpPartBoxes = input_part_boxes;</span>
<span class="lineNum">    5637 </span>                :<span class="lineNoCov">          0 :             input_part_boxes = output_part_boxes;</span>
<span class="lineNum">    5638 </span>                :<span class="lineNoCov">          0 :             output_part_boxes = tmpPartBoxes;</span>
<span class="lineNum">    5639 </span>                :<span class="lineNoCov">          0 :             output_part_boxes-&gt;clear();</span>
<span class="lineNum">    5640 </span>                :            :         }
<span class="lineNum">    5641 </span>                :            : 
<span class="lineNum">    5642 </span>                :            :         //returns the total no. of output parts for this dimension partitioning.
<span class="lineNum">    5643 </span>                :            :         mj_part_t output_part_count_in_dimension =
<span class="lineNum">    5644 </span>                :            :                         this-&gt;update_part_num_arrays(
<span class="lineNum">    5645 </span>                :            :                                         num_partitioning_in_current_dim,
<span class="lineNum">    5646 </span>                :            :                                         future_num_part_in_parts,
<span class="lineNum">    5647 </span>                :            :                                         next_future_num_parts_in_parts,
<span class="lineNum">    5648 </span>                :            :                                         future_num_parts,
<span class="lineNum">    5649 </span>                :            :                                         current_num_parts,
<span class="lineNum">    5650 </span>                :            :                                         i,
<span class="lineNum">    5651 </span>                :            :                                         input_part_boxes,
<span class="lineNum">    5652 </span>                :<span class="lineNoCov">          0 :                                         output_part_boxes);</span>
<span class="lineNum">    5653 </span>                :            : 
<span class="lineNum">    5654 </span>                :            :         //if the number of obtained parts equal to current number of parts,
<span class="lineNum">    5655 </span>                :            :         //skip this dimension. For example, this happens when 1 is given in the input
<span class="lineNum">    5656 </span>                :            :         //part array is given. P=4,5,1,2
<span class="lineNum">    5657 </span>                :<span class="lineNoCov">          0 :         if(output_part_count_in_dimension == current_num_parts) {</span>
<span class="lineNum">    5658 </span>                :            :                 //still need to swap the input output arrays.
<span class="lineNum">    5659 </span>                :<span class="lineNoCov">          0 :             tmpPartVect= future_num_part_in_parts;</span>
<span class="lineNum">    5660 </span>                :<span class="lineNoCov">          0 :             future_num_part_in_parts = next_future_num_parts_in_parts;</span>
<span class="lineNum">    5661 </span>                :<span class="lineNoCov">          0 :             next_future_num_parts_in_parts = tmpPartVect;</span>
<span class="lineNum">    5662 </span>                :            : 
<span class="lineNum">    5663 </span>                :<span class="lineNoCov">          0 :             if(this-&gt;mj_keep_part_boxes){</span>
<span class="lineNum">    5664 </span>                :<span class="lineNoCov">          0 :                 RCP&lt;mj_partBoxVector_t&gt; tmpPartBoxes = input_part_boxes;</span>
<span class="lineNum">    5665 </span>                :<span class="lineNoCov">          0 :                 input_part_boxes = output_part_boxes;</span>
<span class="lineNum">    5666 </span>                :<span class="lineNoCov">          0 :                 output_part_boxes = tmpPartBoxes;</span>
<span class="lineNum">    5667 </span>                :            :             }
<span class="lineNum">    5668 </span>                :<span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">    5669 </span>                :            :         }
<span class="lineNum">    5670 </span>                :            : 
<span class="lineNum">    5671 </span>                :            : 
<span class="lineNum">    5672 </span>                :            :         //get the coordinate axis along which the partitioning will be done.
<span class="lineNum">    5673 </span>                :<span class="lineNoCov">          0 :         int coordInd = i % this-&gt;coord_dim;</span>
<span class="lineNum">    5674 </span>                :<span class="lineNoCov">          0 :         mj_scalar_t * mj_current_dim_coords = this-&gt;mj_coordinates[coordInd];</span>
<span class="lineNum">    5675 </span>                :            : 
<span class="lineNum">    5676 </span>                :            :         //convert i to string to be used for debugging purposes.
<span class="lineNum">    5677 </span>                :<span class="lineNoCov">          0 :         std::string istring = toString&lt;int&gt;(i);</span>
<span class="lineNum">    5678 </span>                :<span class="lineNoCov">          0 :         this-&gt;mj_env-&gt;timerStart(MACRO_TIMERS, &quot;MultiJagged - Problem_Partitioning_&quot; + istring);</span>
<span class="lineNum">    5679 </span>                :            : 
<span class="lineNum">    5680 </span>                :            :         //alloc Memory to point the indices
<span class="lineNum">    5681 </span>                :            :         //of the parts in the permutation array.
<span class="lineNum">    5682 </span>                :<span class="lineNoCov">          0 :         this-&gt;new_part_xadj = allocMemory&lt;mj_lno_t&gt;(output_part_count_in_dimension);</span>
<span class="lineNum">    5683 </span>                :            : 
<span class="lineNum">    5684 </span>                :            :         //the index where in the new_part_xadj will be written.
<span class="lineNum">    5685 </span>                :<span class="lineNoCov">          0 :         mj_part_t output_part_index = 0;</span>
<span class="lineNum">    5686 </span>                :            :         //whatever is written to output_part_index will be added with putput_coordinate_end_index
<span class="lineNum">    5687 </span>                :            :         //so that the points will be shifted.
<span class="lineNum">    5688 </span>                :<span class="lineNoCov">          0 :         mj_part_t output_coordinate_end_index = 0;</span>
<span class="lineNum">    5689 </span>                :            : 
<span class="lineNum">    5690 </span>                :<span class="lineNoCov">          0 :         mj_part_t current_work_part = 0;</span>
<span class="lineNum">    5691 </span>                :            :         mj_part_t current_concurrent_num_parts =
<span class="lineNum">    5692 </span>                :<span class="lineNoCov">          0 :                         std::min(current_num_parts - current_work_part, this-&gt;max_concurrent_part_calculation);</span>
<span class="lineNum">    5693 </span>                :            : 
<span class="lineNum">    5694 </span>                :<span class="lineNoCov">          0 :         mj_part_t obtained_part_index = 0;</span>
<span class="lineNum">    5695 </span>                :            : 
<span class="lineNum">    5696 </span>                :            :         //run for all available parts.
<span class="lineNum">    5697 </span>                :<span class="lineNoCov">          0 :         for (; current_work_part &lt; current_num_parts;</span>
<span class="lineNum">    5698 </span>                :            :                  current_work_part += current_concurrent_num_parts){
<span class="lineNum">    5699 </span>                :            : 
<span class="lineNum">    5700 </span>                :<span class="lineNoCov">          0 :             current_concurrent_num_parts = std::min(current_num_parts - current_work_part,</span>
<span class="lineNum">    5701 </span>                :            :                                  this-&gt;max_concurrent_part_calculation);
<span class="lineNum">    5702 </span>                :            : 
<span class="lineNum">    5703 </span>                :<span class="lineNoCov">          0 :             mj_part_t actual_work_part_count = 0;</span>
<span class="lineNum">    5704 </span>                :            :             //initialization for 1D partitioning.
<span class="lineNum">    5705 </span>                :            :             //get the min and max coordinates of each part
<span class="lineNum">    5706 </span>                :            :             //together with the part weights of each part.
<span class="lineNum">    5707 </span>                :<span class="lineNoCov">          0 :             for(int kk = 0; kk &lt; current_concurrent_num_parts; ++kk){</span>
<span class="lineNum">    5708 </span>                :<span class="lineNoCov">          0 :                 mj_part_t current_work_part_in_concurrent_parts = current_work_part + kk;</span>
<span class="lineNum">    5709 </span>                :            : 
<span class="lineNum">    5710 </span>                :            :                 //if this part wont be partitioned any further
<span class="lineNum">    5711 </span>                :            :                 //dont do any work for this part.
<span class="lineNum">    5712 </span>                :<span class="lineNoCov">          0 :                 if (num_partitioning_in_current_dim[current_work_part_in_concurrent_parts] == 1){</span>
<span class="lineNum">    5713 </span>                :<span class="lineNoCov">          0 :                     continue;</span>
<span class="lineNum">    5714 </span>                :            :                 }
<span class="lineNum">    5715 </span>                :<span class="lineNoCov">          0 :                 ++actual_work_part_count;</span>
<span class="lineNum">    5716 </span>                :<span class="lineNoCov">          0 :                 mj_lno_t coordinate_end_index= this-&gt;part_xadj[current_work_part_in_concurrent_parts];</span>
<span class="lineNum">    5717 </span>                :<span class="lineNoCov">          0 :                 mj_lno_t coordinate_begin_index = current_work_part_in_concurrent_parts==0 ? 0: this-&gt;part_xadj[current_work_part_in_concurrent_parts -1];</span>
<span class="lineNum">    5718 </span>                :            : 
<span class="lineNum">    5719 </span>                :            : /*
<span class="lineNum">    5720 </span>                :            :                 cout &lt;&lt; &quot;i:&quot; &lt;&lt; i &lt;&lt; &quot; j:&quot; &lt;&lt; current_work_part + kk
<span class="lineNum">    5721 </span>                :            :                                 &lt;&lt; &quot; coordinate_begin_index:&quot; &lt;&lt; coordinate_begin_index
<span class="lineNum">    5722 </span>                :            :                                 &lt;&lt; &quot; coordinate_end_index:&quot; &lt;&lt; coordinate_end_index
<span class="lineNum">    5723 </span>                :            :                                 &lt;&lt; &quot; total:&quot; &lt;&lt; coordinate_end_index - coordinate_begin_index&lt;&lt; endl;
<span class="lineNum">    5724 </span>                :            :                                 */
<span class="lineNum">    5725 </span>                :<span class="lineNoCov">          0 :                 this-&gt;mj_get_local_min_max_coord_totW(</span>
<span class="lineNum">    5726 </span>                :            :                                 coordinate_begin_index,
<span class="lineNum">    5727 </span>                :            :                                 coordinate_end_index,
<span class="lineNum">    5728 </span>                :            :                                 this-&gt;coordinate_permutations,
<span class="lineNum">    5729 </span>                :            :                                 mj_current_dim_coords,
<span class="lineNum">    5730 </span>                :<span class="lineNoCov">          0 :                             this-&gt;process_local_min_max_coord_total_weight[kk], //min_coordinate</span>
<span class="lineNum">    5731 </span>                :<span class="lineNoCov">          0 :                             this-&gt;process_local_min_max_coord_total_weight[kk + current_concurrent_num_parts], //max_coordinate</span>
<span class="lineNum">    5732 </span>                :<span class="lineNoCov">          0 :                             this-&gt;process_local_min_max_coord_total_weight[kk + 2*current_concurrent_num_parts]); //total_weight</span>
<span class="lineNum">    5733 </span>                :            : 
<span class="lineNum">    5734 </span>                :            :             }
<span class="lineNum">    5735 </span>                :            : 
<span class="lineNum">    5736 </span>                :            :             //1D partitioning
<span class="lineNum">    5737 </span>                :<span class="lineNoCov">          0 :             if (actual_work_part_count &gt; 0){</span>
<span class="lineNum">    5738 </span>                :            :                 //obtain global Min max of the part.
<span class="lineNum">    5739 </span>                :<span class="lineNoCov">          0 :                 this-&gt;mj_get_global_min_max_coord_totW(</span>
<span class="lineNum">    5740 </span>                :            :                                 current_concurrent_num_parts,
<span class="lineNum">    5741 </span>                :            :                                 this-&gt;process_local_min_max_coord_total_weight,
<span class="lineNum">    5742 </span>                :            :                                 this-&gt;global_min_max_coord_total_weight);
<span class="lineNum">    5743 </span>                :            : 
<span class="lineNum">    5744 </span>                :            :                 //represents the total number of cutlines
<span class="lineNum">    5745 </span>                :            :                 //whose coordinate should be determined.
<span class="lineNum">    5746 </span>                :<span class="lineNoCov">          0 :                 mj_part_t total_incomplete_cut_count = 0;</span>
<span class="lineNum">    5747 </span>                :            : 
<span class="lineNum">    5748 </span>                :            :                 //Compute weight ratios for parts &amp; cuts:
<span class="lineNum">    5749 </span>                :            :                 //e.g., 0.25  0.25  0.5    0.5  0.75 0.75  1
<span class="lineNum">    5750 </span>                :            :                 //part0  cut0  part1 cut1 part2 cut2 part3
<span class="lineNum">    5751 </span>                :<span class="lineNoCov">          0 :                 mj_part_t concurrent_part_cut_shift = 0;</span>
<span class="lineNum">    5752 </span>                :<span class="lineNoCov">          0 :                 mj_part_t concurrent_part_part_shift = 0;</span>
<span class="lineNum">    5753 </span>                :<span class="lineNoCov">          0 :                 for(int kk = 0; kk &lt; current_concurrent_num_parts; ++kk){</span>
<span class="lineNum">    5754 </span>                :<span class="lineNoCov">          0 :                     mj_scalar_t min_coordinate = this-&gt;global_min_max_coord_total_weight[kk];</span>
<span class="lineNum">    5755 </span>                :<span class="lineNoCov">          0 :                     mj_scalar_t max_coordinate = this-&gt;global_min_max_coord_total_weight[kk +</span>
<span class="lineNum">    5756 </span>                :<span class="lineNoCov">          0 :                                                      current_concurrent_num_parts];</span>
<span class="lineNum">    5757 </span>                :            : 
<span class="lineNum">    5758 </span>                :<span class="lineNoCov">          0 :                     mj_scalar_t global_total_weight = this-&gt;global_min_max_coord_total_weight[kk +</span>
<span class="lineNum">    5759 </span>                :<span class="lineNoCov">          0 :                                                         2 * current_concurrent_num_parts];</span>
<span class="lineNum">    5760 </span>                :            : 
<span class="lineNum">    5761 </span>                :<span class="lineNoCov">          0 :                     mj_part_t concurrent_current_part_index = current_work_part + kk;</span>
<span class="lineNum">    5762 </span>                :            : 
<span class="lineNum">    5763 </span>                :<span class="lineNoCov">          0 :                     mj_part_t partition_count = num_partitioning_in_current_dim[concurrent_current_part_index];</span>
<span class="lineNum">    5764 </span>                :            : 
<span class="lineNum">    5765 </span>                :<span class="lineNoCov">          0 :                     mj_scalar_t *usedCutCoordinate = current_cut_coordinates + concurrent_part_cut_shift;</span>
<span class="lineNum">    5766 </span>                :<span class="lineNoCov">          0 :                     mj_scalar_t *current_target_part_weights = this-&gt;target_part_weights +</span>
<span class="lineNum">    5767 </span>                :<span class="lineNoCov">          0 :                                                         concurrent_part_part_shift;</span>
<span class="lineNum">    5768 </span>                :            :                     //shift the usedCutCoordinate array as noCuts.
<span class="lineNum">    5769 </span>                :<span class="lineNoCov">          0 :                     concurrent_part_cut_shift += partition_count - 1;</span>
<span class="lineNum">    5770 </span>                :            :                     //shift the partRatio array as noParts.
<span class="lineNum">    5771 </span>                :<span class="lineNoCov">          0 :                     concurrent_part_part_shift += partition_count;</span>
<span class="lineNum">    5772 </span>                :            : 
<span class="lineNum">    5773 </span>                :            : 
<span class="lineNum">    5774 </span>                :            :                     //calculate only if part is not empty,
<span class="lineNum">    5775 </span>                :            :                     //and part will be further partitioned.
<span class="lineNum">    5776 </span>                :<span class="lineNoCov">          0 :                     if(partition_count &gt; 1 &amp;&amp; min_coordinate &lt;= max_coordinate){</span>
<span class="lineNum">    5777 </span>                :            : 
<span class="lineNum">    5778 </span>                :            :                         //increase num_cuts_do_be_determined by the number of cuts of the current
<span class="lineNum">    5779 </span>                :            :                         //part's cut line number.
<span class="lineNum">    5780 </span>                :<span class="lineNoCov">          0 :                         total_incomplete_cut_count += partition_count - 1;</span>
<span class="lineNum">    5781 </span>                :            :                         //set the number of cut lines that should be determined
<span class="lineNum">    5782 </span>                :            :                         //for this part.
<span class="lineNum">    5783 </span>                :<span class="lineNoCov">          0 :                         this-&gt;my_incomplete_cut_count[kk] = partition_count - 1;</span>
<span class="lineNum">    5784 </span>                :            : 
<span class="lineNum">    5785 </span>                :            :                         //get the target weights of the parts.
<span class="lineNum">    5786 </span>                :<span class="lineNoCov">          0 :                         this-&gt;mj_get_initial_cut_coords_target_weights(</span>
<span class="lineNum">    5787 </span>                :            :                                         min_coordinate,
<span class="lineNum">    5788 </span>                :            :                                         max_coordinate,
<span class="lineNum">    5789 </span>                :            :                                         partition_count - 1,
<span class="lineNum">    5790 </span>                :            :                                         global_total_weight,
<span class="lineNum">    5791 </span>                :            :                                         usedCutCoordinate,
<span class="lineNum">    5792 </span>                :            :                                         current_target_part_weights,
<span class="lineNum">    5793 </span>                :            :                                         future_num_part_in_parts,
<span class="lineNum">    5794 </span>                :            :                                         next_future_num_parts_in_parts,
<span class="lineNum">    5795 </span>                :            :                                         concurrent_current_part_index,
<span class="lineNum">    5796 </span>                :            :                                         obtained_part_index);
<span class="lineNum">    5797 </span>                :            : 
<span class="lineNum">    5798 </span>                :<span class="lineNoCov">          0 :                         mj_lno_t coordinate_end_index= this-&gt;part_xadj[concurrent_current_part_index];</span>
<span class="lineNum">    5799 </span>                :<span class="lineNoCov">          0 :                         mj_lno_t coordinate_begin_index = concurrent_current_part_index==0 ? 0: this-&gt;part_xadj[concurrent_current_part_index -1];</span>
<span class="lineNum">    5800 </span>                :            : 
<span class="lineNum">    5801 </span>                :            :                         //get the initial estimated part assignments of the
<span class="lineNum">    5802 </span>                :            :                         //coordinates.
<span class="lineNum">    5803 </span>                :<span class="lineNoCov">          0 :                         this-&gt;set_initial_coordinate_parts(</span>
<span class="lineNum">    5804 </span>                :            :                             max_coordinate,
<span class="lineNum">    5805 </span>                :            :                             min_coordinate,
<span class="lineNum">    5806 </span>                :            :                             concurrent_current_part_index,
<span class="lineNum">    5807 </span>                :            :                             coordinate_begin_index, coordinate_end_index,
<span class="lineNum">    5808 </span>                :            :                             this-&gt;coordinate_permutations,
<span class="lineNum">    5809 </span>                :            :                             mj_current_dim_coords,
<span class="lineNum">    5810 </span>                :            :                             this-&gt;assigned_part_ids,
<span class="lineNum">    5811 </span>                :<span class="lineNoCov">          0 :                             partition_count);</span>
<span class="lineNum">    5812 </span>                :            :                     }
<span class="lineNum">    5813 </span>                :            :                     else {
<span class="lineNum">    5814 </span>                :            :                         // e.g., if have fewer coordinates than parts, don't need to do next dim.
<span class="lineNum">    5815 </span>                :<span class="lineNoCov">          0 :                         this-&gt;my_incomplete_cut_count[kk] = 0;</span>
<span class="lineNum">    5816 </span>                :            :                     }
<span class="lineNum">    5817 </span>                :<span class="lineNoCov">          0 :                     obtained_part_index += partition_count;</span>
<span class="lineNum">    5818 </span>                :            :                 }
<span class="lineNum">    5819 </span>                :            : 
<span class="lineNum">    5820 </span>                :            : 
<span class="lineNum">    5821 </span>                :            : 
<span class="lineNum">    5822 </span>                :            :                 //used imbalance, it is always 0, as it is difficult to
<span class="lineNum">    5823 </span>                :            :                 //estimate a range.
<span class="lineNum">    5824 </span>                :<span class="lineNoCov">          0 :                 mj_scalar_t used_imbalance = 0;</span>
<span class="lineNum">    5825 </span>                :            : 
<span class="lineNum">    5826 </span>                :            : 
<span class="lineNum">    5827 </span>                :            :                 // Determine cut lines for all concurrent parts parts here.
<span class="lineNum">    5828 </span>                :<span class="lineNoCov">          0 :                 this-&gt;mj_1D_part(</span>
<span class="lineNum">    5829 </span>                :            :                     mj_current_dim_coords,
<span class="lineNum">    5830 </span>                :            :                     used_imbalance,
<span class="lineNum">    5831 </span>                :            :                     current_work_part,
<span class="lineNum">    5832 </span>                :            :                     current_concurrent_num_parts,
<span class="lineNum">    5833 </span>                :            :                     current_cut_coordinates,
<span class="lineNum">    5834 </span>                :            :                     total_incomplete_cut_count,
<span class="lineNum">    5835 </span>                :            :                     num_partitioning_in_current_dim);
<span class="lineNum">    5836 </span>                :            :             }
<span class="lineNum">    5837 </span>                :            : 
<span class="lineNum">    5838 </span>                :            :             //create new part chunks
<span class="lineNum">    5839 </span>                :            :             {
<span class="lineNum">    5840 </span>                :<span class="lineNoCov">          0 :                 mj_part_t output_array_shift = 0;</span>
<span class="lineNum">    5841 </span>                :<span class="lineNoCov">          0 :                 mj_part_t cut_shift = 0;</span>
<span class="lineNum">    5842 </span>                :<span class="lineNoCov">          0 :                 size_t tlr_shift = 0;</span>
<span class="lineNum">    5843 </span>                :<span class="lineNoCov">          0 :                 size_t partweight_array_shift = 0;</span>
<span class="lineNum">    5844 </span>                :            : 
<span class="lineNum">    5845 </span>                :<span class="lineNoCov">          0 :                 for(int kk = 0; kk &lt; current_concurrent_num_parts; ++kk){</span>
<span class="lineNum">    5846 </span>                :<span class="lineNoCov">          0 :                     mj_part_t current_concurrent_work_part = current_work_part + kk;</span>
<span class="lineNum">    5847 </span>                :<span class="lineNoCov">          0 :                     mj_part_t num_parts = num_partitioning_in_current_dim[current_concurrent_work_part];</span>
<span class="lineNum">    5848 </span>                :            : 
<span class="lineNum">    5849 </span>                :            :                     //if the part is empty, skip the part.
<span class="lineNum">    5850 </span>                :<span class="lineNoCov">          0 :                     if((num_parts != 1  )</span>
<span class="lineNum">    5851 </span>                :            :                                 &amp;&amp;
<span class="lineNum">    5852 </span>                :<span class="lineNoCov">          0 :                                 this-&gt;global_min_max_coord_total_weight[kk] &gt;</span>
<span class="lineNum">    5853 </span>                :<span class="lineNoCov">          0 :                              this-&gt;global_min_max_coord_total_weight[kk + current_concurrent_num_parts]) {</span>
<span class="lineNum">    5854 </span>                :            : 
<span class="lineNum">    5855 </span>                :            :                         //we still need to write the begin and end point of the
<span class="lineNum">    5856 </span>                :            :                         //empty part. simply set it zero, the array indices will be shifted later.
<span class="lineNum">    5857 </span>                :<span class="lineNoCov">          0 :                         for(mj_part_t jj = 0; jj &lt; num_parts; ++jj){</span>
<span class="lineNum">    5858 </span>                :<span class="lineNoCov">          0 :                                 this-&gt;new_part_xadj[output_part_index + output_array_shift + jj] = 0;</span>
<span class="lineNum">    5859 </span>                :            :                         }
<span class="lineNum">    5860 </span>                :<span class="lineNoCov">          0 :                         cut_shift += num_parts - 1;</span>
<span class="lineNum">    5861 </span>                :<span class="lineNoCov">          0 :                         tlr_shift += (4 *(num_parts - 1) + 1);</span>
<span class="lineNum">    5862 </span>                :<span class="lineNoCov">          0 :                         output_array_shift += num_parts;</span>
<span class="lineNum">    5863 </span>                :<span class="lineNoCov">          0 :                         partweight_array_shift += (2 * (num_parts - 1) + 1);</span>
<span class="lineNum">    5864 </span>                :<span class="lineNoCov">          0 :                         continue;</span>
<span class="lineNum">    5865 </span>                :            :                     }
<span class="lineNum">    5866 </span>                :            : 
<span class="lineNum">    5867 </span>                :<span class="lineNoCov">          0 :                     mj_lno_t coordinate_end= this-&gt;part_xadj[current_concurrent_work_part];</span>
<span class="lineNum">    5868 </span>                :<span class="lineNoCov">          0 :                     mj_lno_t coordinate_begin = current_concurrent_work_part==0 ? 0: this-&gt;part_xadj[</span>
<span class="lineNum">    5869 </span>                :<span class="lineNoCov">          0 :                                                                 current_concurrent_work_part -1];</span>
<span class="lineNum">    5870 </span>                :<span class="lineNoCov">          0 :                     mj_scalar_t *current_concurrent_cut_coordinate = current_cut_coordinates + cut_shift;</span>
<span class="lineNum">    5871 </span>                :<span class="lineNoCov">          0 :                     mj_scalar_t *used_local_cut_line_weight_to_left = this-&gt;process_cut_line_weight_to_put_left +</span>
<span class="lineNum">    5872 </span>                :<span class="lineNoCov">          0 :                                                             cut_shift;</span>
<span class="lineNum">    5873 </span>                :            : 
<span class="lineNum">    5874 </span>                :            :                     //mj_scalar_t *used_tlr_array =  this-&gt;total_part_weight_left_right_closests + tlr_shift;
<span class="lineNum">    5875 </span>                :            : 
<span class="lineNum">    5876 </span>                :<span class="lineNoCov">          0 :                     for(int ii = 0; ii &lt; this-&gt;num_threads; ++ii){</span>
<span class="lineNum">    5877 </span>                :<span class="lineNoCov">          0 :                         this-&gt;thread_part_weight_work[ii] = this-&gt;thread_part_weights[ii] +  partweight_array_shift;</span>
<span class="lineNum">    5878 </span>                :            :                     }
<span class="lineNum">    5879 </span>                :            : 
<span class="lineNum">    5880 </span>                :<span class="lineNoCov">          0 :                     if(num_parts &gt; 1){</span>
<span class="lineNum">    5881 </span>                :<span class="lineNoCov">          0 :                         if(this-&gt;mj_keep_part_boxes){</span>
<span class="lineNum">    5882 </span>                :            :                                 //if part boxes are to be stored update the boundaries.
<span class="lineNum">    5883 </span>                :<span class="lineNoCov">          0 :                             for (mj_part_t j = 0; j &lt; num_parts - 1; ++j){</span>
<span class="lineNum">    5884 </span>                :<span class="lineNoCov">          0 :                                 (*output_part_boxes)[output_array_shift + output_part_index +</span>
<span class="lineNum">    5885 </span>                :<span class="lineNoCov">          0 :                                  j].updateMinMax(current_concurrent_cut_coordinate[j], 1</span>
<span class="lineNum">    5886 </span>                :            :                                   /*update max*/, coordInd);
<span class="lineNum">    5887 </span>                :            : 
<span class="lineNum">    5888 </span>                :<span class="lineNoCov">          0 :                                 (*output_part_boxes)[output_array_shift + output_part_index + j +</span>
<span class="lineNum">    5889 </span>                :<span class="lineNoCov">          0 :                                  1].updateMinMax(current_concurrent_cut_coordinate[j], 0</span>
<span class="lineNum">    5890 </span>                :            :                                   /*update min*/, coordInd);
<span class="lineNum">    5891 </span>                :            :                             }
<span class="lineNum">    5892 </span>                :            :                         }
<span class="lineNum">    5893 </span>                :            : 
<span class="lineNum">    5894 </span>                :            :                         // Rewrite the indices based on the computed cuts.
<span class="lineNum">    5895 </span>                :<span class="lineNoCov">          0 :                         this-&gt;mj_create_new_partitions(</span>
<span class="lineNum">    5896 </span>                :            :                             num_parts,
<span class="lineNum">    5897 </span>                :            :                             mj_current_dim_coords,
<span class="lineNum">    5898 </span>                :            :                             current_concurrent_cut_coordinate,
<span class="lineNum">    5899 </span>                :            :                             coordinate_begin,
<span class="lineNum">    5900 </span>                :            :                             coordinate_end,
<span class="lineNum">    5901 </span>                :            :                             used_local_cut_line_weight_to_left,
<span class="lineNum">    5902 </span>                :            :                             this-&gt;thread_part_weight_work,
<span class="lineNum">    5903 </span>                :<span class="lineNoCov">          0 :                             this-&gt;new_part_xadj + output_part_index + output_array_shift</span>
<span class="lineNum">    5904 </span>                :            :                             );
<span class="lineNum">    5905 </span>                :            : 
<span class="lineNum">    5906 </span>                :            :                     }
<span class="lineNum">    5907 </span>                :            :                     else {
<span class="lineNum">    5908 </span>                :            :                         //if this part is partitioned into 1 then just copy
<span class="lineNum">    5909 </span>                :            :                         //the old values.
<span class="lineNum">    5910 </span>                :<span class="lineNoCov">          0 :                         mj_lno_t part_size = coordinate_end - coordinate_begin;</span>
<span class="lineNum">    5911 </span>                :<span class="lineNoCov">          0 :                         *(this-&gt;new_part_xadj + output_part_index + output_array_shift) = part_size;</span>
<span class="lineNum">    5912 </span>                :<span class="lineNoCov">          0 :                         memcpy(</span>
<span class="lineNum">    5913 </span>                :<span class="lineNoCov">          0 :                                 this-&gt;new_coordinate_permutations + coordinate_begin,</span>
<span class="lineNum">    5914 </span>                :<span class="lineNoCov">          0 :                             this-&gt;coordinate_permutations + coordinate_begin,</span>
<span class="lineNum">    5915 </span>                :            :                             part_size * sizeof(mj_lno_t));
<span class="lineNum">    5916 </span>                :            :                     }
<span class="lineNum">    5917 </span>                :<span class="lineNoCov">          0 :                     cut_shift += num_parts - 1;</span>
<span class="lineNum">    5918 </span>                :<span class="lineNoCov">          0 :                     tlr_shift += (4 *(num_parts - 1) + 1);</span>
<span class="lineNum">    5919 </span>                :<span class="lineNoCov">          0 :                     output_array_shift += num_parts;</span>
<span class="lineNum">    5920 </span>                :<span class="lineNoCov">          0 :                     partweight_array_shift += (2 * (num_parts - 1) + 1);</span>
<span class="lineNum">    5921 </span>                :            :                 }
<span class="lineNum">    5922 </span>                :            : 
<span class="lineNum">    5923 </span>                :            :                 //shift cut coordinates so that all cut coordinates are stored.
<span class="lineNum">    5924 </span>                :            :                 //no shift now because we dont keep the cuts.
<span class="lineNum">    5925 </span>                :            :                 //current_cut_coordinates += cut_shift;
<span class="lineNum">    5926 </span>                :            : 
<span class="lineNum">    5927 </span>                :            :                 //mj_create_new_partitions from coordinates partitioned the parts and
<span class="lineNum">    5928 </span>                :            :                 //write the indices as if there were a single part.
<span class="lineNum">    5929 </span>                :            :                 //now we need to shift the beginning indices.
<span class="lineNum">    5930 </span>                :<span class="lineNoCov">          0 :                 for(mj_part_t kk = 0; kk &lt; current_concurrent_num_parts; ++kk){</span>
<span class="lineNum">    5931 </span>                :<span class="lineNoCov">          0 :                     mj_part_t num_parts = num_partitioning_in_current_dim[ current_work_part + kk];</span>
<span class="lineNum">    5932 </span>                :<span class="lineNoCov">          0 :                     for (mj_part_t ii = 0;ii &lt; num_parts ; ++ii){</span>
<span class="lineNum">    5933 </span>                :            :                         //shift it by previousCount
<span class="lineNum">    5934 </span>                :<span class="lineNoCov">          0 :                         this-&gt;new_part_xadj[output_part_index+ii] += output_coordinate_end_index;</span>
<span class="lineNum">    5935 </span>                :            :                     }
<span class="lineNum">    5936 </span>                :            :                     //increase the previous count by current end.
<span class="lineNum">    5937 </span>                :<span class="lineNoCov">          0 :                     output_coordinate_end_index = this-&gt;new_part_xadj[output_part_index + num_parts - 1];</span>
<span class="lineNum">    5938 </span>                :            :                     //increase the current out.
<span class="lineNum">    5939 </span>                :<span class="lineNoCov">          0 :                     output_part_index += num_parts ;</span>
<span class="lineNum">    5940 </span>                :            :                 }
<span class="lineNum">    5941 </span>                :            :             }
<span class="lineNum">    5942 </span>                :            :         }
<span class="lineNum">    5943 </span>                :            :         // end of this partitioning dimension
<span class="lineNum">    5944 </span>                :            : 
<span class="lineNum">    5945 </span>                :            : 
<span class="lineNum">    5946 </span>                :<span class="lineNoCov">          0 :         int current_world_size = this-&gt;comm-&gt;getSize();</span>
<span class="lineNum">    5947 </span>                :<span class="lineNoCov">          0 :         long migration_reduce_all_population = this-&gt;total_dim_num_reduce_all * current_world_size;</span>
<span class="lineNum">    5948 </span>                :            : 
<span class="lineNum">    5949 </span>                :            : 
<span class="lineNum">    5950 </span>                :<span class="lineNoCov">          0 :         bool is_migrated_in_current_dimension = false;</span>
<span class="lineNum">    5951 </span>                :            : 
<span class="lineNum">    5952 </span>                :            :         //we migrate if there are more partitionings to be done after this step
<span class="lineNum">    5953 </span>                :            :         //and if the migration is not forced to be avoided.
<span class="lineNum">    5954 </span>                :            :         //and the operation is not sequential.
<span class="lineNum">    5955 </span>                :<span class="lineNoCov">          0 :         if (future_num_parts &gt; 1 &amp;&amp;</span>
<span class="lineNum">    5956 </span>                :<span class="lineNoCov">          0 :             this-&gt;check_migrate_avoid_migration_option &gt;= 0 &amp;&amp;</span>
<span class="lineNum">    5957 </span>                :            :             current_world_size &gt; 1){
<span class="lineNum">    5958 </span>                :            : 
<span class="lineNum">    5959 </span>                :<span class="lineNoCov">          0 :                 this-&gt;mj_env-&gt;timerStart(MACRO_TIMERS, &quot;MultiJagged - Problem_Migration-&quot; + istring);</span>
<span class="lineNum">    5960 </span>                :<span class="lineNoCov">          0 :                 mj_part_t num_parts = output_part_count_in_dimension;</span>
<span class="lineNum">    5961 </span>                :<span class="lineNoCov">          0 :                 if ( this-&gt;mj_perform_migration(</span>
<span class="lineNum">    5962 </span>                :            :                                                 num_parts,
<span class="lineNum">    5963 </span>                :            :                                                 current_num_parts, //output
<span class="lineNum">    5964 </span>                :            :                                                 next_future_num_parts_in_parts, //output
<span class="lineNum">    5965 </span>                :            :                                                 output_part_begin_index,
<span class="lineNum">    5966 </span>                :            :                                                 migration_reduce_all_population,
<span class="lineNum">    5967 </span>                :<span class="lineNoCov">          0 :                                                 this-&gt;num_local_coords / (future_num_parts * current_num_parts),</span>
<span class="lineNum">    5968 </span>                :            :                                                 istring,
<span class="lineNum">    5969 </span>                :            :                                                 input_part_boxes, output_part_boxes) ) {
<span class="lineNum">    5970 </span>                :<span class="lineNoCov">          0 :                         is_migrated_in_current_dimension = true;</span>
<span class="lineNum">    5971 </span>                :<span class="lineNoCov">          0 :                         is_data_ever_migrated = true;</span>
<span class="lineNum">    5972 </span>                :<span class="lineNoCov">          0 :                         this-&gt;mj_env-&gt;timerStop(MACRO_TIMERS, &quot;MultiJagged - Problem_Migration-&quot; +</span>
<span class="lineNum">    5973 </span>                :            :                                         istring);
<span class="lineNum">    5974 </span>                :            :                         //since data is migrated, we reduce the number of reduceAll operations for the last part.
<span class="lineNum">    5975 </span>                :<span class="lineNoCov">          0 :                         this-&gt;total_dim_num_reduce_all /= num_parts;</span>
<span class="lineNum">    5976 </span>                :            :                 }
<span class="lineNum">    5977 </span>                :            :                 else {
<span class="lineNum">    5978 </span>                :<span class="lineNoCov">          0 :                         is_migrated_in_current_dimension = false;</span>
<span class="lineNum">    5979 </span>                :<span class="lineNoCov">          0 :                         this-&gt;mj_env-&gt;timerStop(MACRO_TIMERS, &quot;MultiJagged - Problem_Migration-&quot; + istring);</span>
<span class="lineNum">    5980 </span>                :            :                 }
<span class="lineNum">    5981 </span>                :            :         }
<span class="lineNum">    5982 </span>                :            : 
<span class="lineNum">    5983 </span>                :            :         //swap the coordinate permutations for the next dimension.
<span class="lineNum">    5984 </span>                :<span class="lineNoCov">          0 :         mj_lno_t * tmp = this-&gt;coordinate_permutations;</span>
<span class="lineNum">    5985 </span>                :<span class="lineNoCov">          0 :         this-&gt;coordinate_permutations = this-&gt;new_coordinate_permutations;</span>
<span class="lineNum">    5986 </span>                :<span class="lineNoCov">          0 :         this-&gt;new_coordinate_permutations = tmp;</span>
<span class="lineNum">    5987 </span>                :            : 
<span class="lineNum">    5988 </span>                :<span class="lineNoCov">          0 :         if(!is_migrated_in_current_dimension){</span>
<span class="lineNum">    5989 </span>                :<span class="lineNoCov">          0 :             this-&gt;total_dim_num_reduce_all -= current_num_parts;</span>
<span class="lineNum">    5990 </span>                :<span class="lineNoCov">          0 :             current_num_parts = output_part_count_in_dimension;</span>
<span class="lineNum">    5991 </span>                :            :         }
<span class="lineNum">    5992 </span>                :<span class="lineNoCov">          0 :         freeArray&lt;mj_lno_t&gt;(this-&gt;part_xadj);</span>
<span class="lineNum">    5993 </span>                :<span class="lineNoCov">          0 :         this-&gt;part_xadj = this-&gt;new_part_xadj;</span>
<span class="lineNum">    5994 </span>                :            : 
<span class="lineNum">    5995 </span>                :<span class="lineNoCov">          0 :         this-&gt;mj_env-&gt;timerStop(MACRO_TIMERS, &quot;MultiJagged - Problem_Partitioning_&quot; + istring);</span>
<span class="lineNum">    5996 </span>                :            :     }
<span class="lineNum">    5997 </span>                :            : 
<span class="lineNum">    5998 </span>                :            :     // Partitioning is done
<span class="lineNum">    5999 </span>                :<span class="lineNoCov">          0 :     delete future_num_part_in_parts;</span>
<span class="lineNum">    6000 </span>                :<span class="lineNoCov">          0 :     delete next_future_num_parts_in_parts;</span>
<span class="lineNum">    6001 </span>                :            : 
<span class="lineNum">    6002 </span>                :<span class="lineNoCov">          0 :     this-&gt;mj_env-&gt;timerStop(MACRO_TIMERS, &quot;MultiJagged - Problem_Partitioning&quot;);</span>
<span class="lineNum">    6003 </span>                :            :     /////////////////////////////End of the partitioning////////////////////////
<span class="lineNum">    6004 </span>                :            : 
<span class="lineNum">    6005 </span>                :            : 
<span class="lineNum">    6006 </span>                :            :     //get the final parts of each initial coordinate
<span class="lineNum">    6007 </span>                :            :     //the results will be written to
<span class="lineNum">    6008 </span>                :            :     //this-&gt;assigned_part_ids for gnos given in this-&gt;current_mj_gnos
<span class="lineNum">    6009 </span>                :<span class="lineNoCov">          0 :     this-&gt;set_final_parts(</span>
<span class="lineNum">    6010 </span>                :            :                 current_num_parts,
<span class="lineNum">    6011 </span>                :            :                 output_part_begin_index,
<span class="lineNum">    6012 </span>                :            :                 output_part_boxes,
<span class="lineNum">    6013 </span>                :            :                 is_data_ever_migrated);
<span class="lineNum">    6014 </span>                :            : 
<span class="lineNum">    6015 </span>                :<span class="lineNoCov">          0 :     result_assigned_part_ids_ = this-&gt;assigned_part_ids;</span>
<span class="lineNum">    6016 </span>                :<span class="lineNoCov">          0 :     result_mj_gnos_ = this-&gt;current_mj_gnos;</span>
<span class="lineNum">    6017 </span>                :            : 
<span class="lineNum">    6018 </span>                :<span class="lineNoCov">          0 :     this-&gt;free_work_memory();</span>
<span class="lineNum">    6019 </span>                :<span class="lineNoCov">          0 :     this-&gt;mj_env-&gt;timerStop(MACRO_TIMERS, &quot;MultiJagged - Total&quot;);</span>
<span class="lineNum">    6020 </span>                :<span class="lineNoCov">          0 :     this-&gt;mj_env-&gt;debug(3, &quot;Out of MultiJagged&quot;);</span>
<span class="lineNum">    6021 </span>                :            : 
<span class="lineNum">    6022 </span>                :<span class="lineNoCov">          0 : }</span>
<span class="lineNum">    6023 </span>                :            : 
<span class="lineNum">    6024 </span>                :            : 
<span class="lineNum">    6025 </span>                :            : /*! \brief Multi Jagged coordinate partitioning algorithm.
<span class="lineNum">    6026 </span>                :            :  *
<span class="lineNum">    6027 </span>                :            :  */
<span class="lineNum">    6028 </span>                :            : template &lt;typename Adapter&gt;
<span class="lineNum">    6029 </span>                :            : class Zoltan2_AlgMJ : public Algorithm&lt;Adapter&gt;
<span class="lineNum">    6030 </span>                :            : {
<span class="lineNum">    6031 </span>                :            : private:
<span class="lineNum">    6032 </span>                :            : 
<span class="lineNum">    6033 </span>                :            : #ifndef DOXYGEN_SHOULD_SKIP_THIS
<span class="lineNum">    6034 </span>                :            : 
<span class="lineNum">    6035 </span>                :            :     typedef CoordinateModel&lt;typename Adapter::base_adapter_t&gt; coordinateModel_t;
<span class="lineNum">    6036 </span>                :            :     typedef typename Adapter::scalar_t mj_scalar_t;
<span class="lineNum">    6037 </span>                :            :     typedef typename Adapter::gno_t mj_gno_t;
<span class="lineNum">    6038 </span>                :            :     typedef typename Adapter::lno_t mj_lno_t;
<span class="lineNum">    6039 </span>                :            :     typedef typename Adapter::node_t mj_node_t;
<span class="lineNum">    6040 </span>                :            :     typedef typename Adapter::part_t mj_part_t;
<span class="lineNum">    6041 </span>                :            :     typedef coordinateModelPartBox&lt;mj_scalar_t, mj_part_t&gt; mj_partBox_t;
<span class="lineNum">    6042 </span>                :            :     typedef std::vector&lt;mj_partBox_t&gt; mj_partBoxVector_t;
<span class="lineNum">    6043 </span>                :            : #endif
<span class="lineNum">    6044 </span>                :            :     AlgMJ&lt;mj_scalar_t, mj_lno_t, mj_gno_t, mj_part_t&gt; mj_partitioner;
<span class="lineNum">    6045 </span>                :            : 
<span class="lineNum">    6046 </span>                :            :     RCP&lt;const Environment&gt; mj_env; //the environment object
<span class="lineNum">    6047 </span>                :            :     RCP&lt;Comm&lt;int&gt; &gt; mj_problemComm; //initial comm object
<span class="lineNum">    6048 </span>                :            :     RCP&lt;const coordinateModel_t&gt; mj_coords; //coordinate adapter
<span class="lineNum">    6049 </span>                :            : 
<span class="lineNum">    6050 </span>                :            :     //PARAMETERS
<span class="lineNum">    6051 </span>                :            :     double imbalance_tolerance; //input imbalance tolerance.
<span class="lineNum">    6052 </span>                :            :     size_t num_global_parts; //the targeted number of parts
<span class="lineNum">    6053 </span>                :            :     mj_part_t *part_no_array; //input part array specifying num part to divide along each dim.
<span class="lineNum">    6054 </span>                :            :     int recursion_depth; //the number of steps that partitioning will be solved in.
<span class="lineNum">    6055 </span>                :            : 
<span class="lineNum">    6056 </span>                :            :     int coord_dim; // coordinate dimension.
<span class="lineNum">    6057 </span>                :            :     mj_lno_t num_local_coords; //number of local coords.
<span class="lineNum">    6058 </span>                :            :     mj_gno_t num_global_coords; //number of global coords.
<span class="lineNum">    6059 </span>                :            :     const mj_gno_t *initial_mj_gnos; //initial global ids of the coordinates.
<span class="lineNum">    6060 </span>                :            :     mj_scalar_t **mj_coordinates; //two dimension coordinate array
<span class="lineNum">    6061 </span>                :            : 
<span class="lineNum">    6062 </span>                :            :     int num_weights_per_coord; // number of weights per coordinate
<span class="lineNum">    6063 </span>                :            :     bool *mj_uniform_weights; //if the coordinates have uniform weights.
<span class="lineNum">    6064 </span>                :            :     mj_scalar_t **mj_weights; //two dimensional weight array
<span class="lineNum">    6065 </span>                :            :     bool *mj_uniform_parts; //if the target parts are uniform
<span class="lineNum">    6066 </span>                :            :     mj_scalar_t **mj_part_sizes; //target part weight sizes.
<span class="lineNum">    6067 </span>                :            : 
<span class="lineNum">    6068 </span>                :            :     bool distribute_points_on_cut_lines; //if partitioning can distribute points on same coordiante to different parts.
<span class="lineNum">    6069 </span>                :            :     mj_part_t max_concurrent_part_calculation; // how many parts we can calculate concurrently.
<span class="lineNum">    6070 </span>                :            :     int check_migrate_avoid_migration_option; //whether to migrate=1, avoid migrate=2, or leave decision to MJ=0
<span class="lineNum">    6071 </span>                :            :     mj_scalar_t minimum_migration_imbalance; //when MJ decides whether to migrate, the minimum imbalance for migration.
<span class="lineNum">    6072 </span>                :            :     int mj_keep_part_boxes; //if the boxes need to be kept.
<span class="lineNum">    6073 </span>                :            : 
<span class="lineNum">    6074 </span>                :            :     int num_threads;
<span class="lineNum">    6075 </span>                :            : 
<span class="lineNum">    6076 </span>                :            :     int mj_run_as_rcb; //if this is set, then recursion depth is adjusted to its maximum value.
<span class="lineNum">    6077 </span>                :            : 
<span class="lineNum">    6078 </span>                :            :     ArrayRCP&lt;mj_part_t&gt; comXAdj_; //communication graph xadj
<span class="lineNum">    6079 </span>                :            :     ArrayRCP&lt;mj_part_t&gt; comAdj_; //communication graph adj.
<span class="lineNum">    6080 </span>                :            : 
<span class="lineNum">    6081 </span>                :            : 
<span class="lineNum">    6082 </span>                :            :     //when we have strided data, it returns a unstrided data in RCP form.
<span class="lineNum">    6083 </span>                :            :     //we need to hold on to that data, during the execution of mj, so that the data is not released.
<span class="lineNum">    6084 </span>                :            :     //coordinate_rcp_holder will hold that data, and release it when MJ is deleted.
<span class="lineNum">    6085 </span>                :            :     ArrayRCP&lt;const mj_scalar_t&gt; * coordinate_ArrayRCP_holder;
<span class="lineNum">    6086 </span>                :            : 
<span class="lineNum">    6087 </span>                :            :     void set_up_partitioning_data(
<span class="lineNum">    6088 </span>                :            :       const RCP&lt;PartitioningSolution&lt;Adapter&gt; &gt;&amp;solution);
<span class="lineNum">    6089 </span>                :            : 
<span class="lineNum">    6090 </span>                :            :     void set_input_parameters(const Teuchos::ParameterList &amp;p);
<span class="lineNum">    6091 </span>                :            : 
<span class="lineNum">    6092 </span>                :            :     void free_work_memory();
<span class="lineNum">    6093 </span>                :            : 
<span class="lineNum">    6094 </span>                :            :     RCP&lt;mj_partBoxVector_t&gt; getGlobalBoxBoundaries() const;
<span class="lineNum">    6095 </span>                :            : 
<a name="6096"><span class="lineNum">    6096 </span>                :            : public:</a>
<span class="lineNum">    6097 </span>                :            : 
<span class="lineNum">    6098 </span>                :<span class="lineNoCov">          0 :     Zoltan2_AlgMJ(const RCP&lt;const Environment&gt; &amp;env,</span>
<span class="lineNum">    6099 </span>                :            :                   RCP&lt;Comm&lt;int&gt; &gt; &amp;problemComm,
<span class="lineNum">    6100 </span>                :            :                   const RCP&lt;const coordinateModel_t&gt; &amp;coords) :
<span class="lineNum">    6101 </span>                :            :                         mj_partitioner(), mj_env(env),
<span class="lineNum">    6102 </span>                :            :                         mj_problemComm(problemComm),
<span class="lineNum">    6103 </span>                :            :                         mj_coords(coords),
<span class="lineNum">    6104 </span>                :            :                         imbalance_tolerance(0),
<span class="lineNum">    6105 </span>                :            :                         num_global_parts(1), part_no_array(NULL),
<span class="lineNum">    6106 </span>                :            :                         recursion_depth(0),
<span class="lineNum">    6107 </span>                :            :                         coord_dim(0),num_local_coords(0), num_global_coords(0),
<span class="lineNum">    6108 </span>                :            :                         initial_mj_gnos(NULL), mj_coordinates(NULL),
<span class="lineNum">    6109 </span>                :            :                         num_weights_per_coord(0),
<span class="lineNum">    6110 </span>                :            :                         mj_uniform_weights(NULL), mj_weights(NULL),
<span class="lineNum">    6111 </span>                :            :                         mj_uniform_parts(NULL),
<span class="lineNum">    6112 </span>                :            :                         mj_part_sizes(NULL),
<span class="lineNum">    6113 </span>                :            :                         distribute_points_on_cut_lines(true),
<span class="lineNum">    6114 </span>                :            :                         max_concurrent_part_calculation(1),
<span class="lineNum">    6115 </span>                :            :                         check_migrate_avoid_migration_option(0),
<span class="lineNum">    6116 </span>                :            :                         minimum_migration_imbalance(0.30),
<span class="lineNum">    6117 </span>                :            :                         mj_keep_part_boxes(0), num_threads(1), mj_run_as_rcb(0),
<a name="6118"><span class="lineNum">    6118 </span>                :<span class="lineNoCov">          0 :                         comXAdj_(), comAdj_(), coordinate_ArrayRCP_holder (NULL)</span></a>
<span class="lineNum">    6119 </span>                :<span class="lineNoCov">          0 :     {}</span>
<span class="lineNum">    6120 </span>                :<span class="lineNoCov">          0 :     ~Zoltan2_AlgMJ(){</span>
<span class="lineNum">    6121 </span>                :<span class="lineNoCov">          0 :       if (coordinate_ArrayRCP_holder != NULL){</span>
<span class="lineNum">    6122 </span>                :<span class="lineNoCov">          0 :         delete [] this-&gt;coordinate_ArrayRCP_holder;</span>
<span class="lineNum">    6123 </span>                :<span class="lineNoCov">          0 :         this-&gt;coordinate_ArrayRCP_holder = NULL;</span>
<span class="lineNum">    6124 </span>                :            :       }
<span class="lineNum">    6125 </span>                :<span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    6126 </span>                :            : 
<span class="lineNum">    6127 </span>                :            :     /*! \brief Multi Jagged  coordinate partitioning algorithm.
<span class="lineNum">    6128 </span>                :            :      *
<span class="lineNum">    6129 </span>                :            :      *  \param solution  a PartitioningSolution, on input it
<span class="lineNum">    6130 </span>                :            :      *      contains part information, on return it also contains
<span class="lineNum">    6131 </span>                :            :      *      the solution and quality metrics.
<span class="lineNum">    6132 </span>                :            :      */
<a name="6133"><span class="lineNum">    6133 </span>                :            :     void partition(const RCP&lt;PartitioningSolution&lt;Adapter&gt; &gt; &amp;solution);</a>
<span class="lineNum">    6134 </span>                :            : 
<span class="lineNum">    6135 </span>                :<span class="lineNoCov">          0 :     mj_partBoxVector_t &amp;getPartBoxesView() const</span>
<span class="lineNum">    6136 </span>                :            :     {
<span class="lineNum">    6137 </span>                :<span class="lineNoCov">          0 :       RCP&lt;mj_partBoxVector_t&gt; pBoxes = this-&gt;getGlobalBoxBoundaries();</span>
<span class="lineNum">    6138 </span>                :<span class="lineNoCov">          0 :       return *pBoxes;</span>
<span class="lineNum">    6139 </span>                :            :     }
<span class="lineNum">    6140 </span>                :            : 
<span class="lineNum">    6141 </span>                :            :     mj_part_t pointAssign(int dim, mj_scalar_t *point) const;
<span class="lineNum">    6142 </span>                :            : 
<span class="lineNum">    6143 </span>                :            :     void boxAssign(int dim, mj_scalar_t *lower, mj_scalar_t *upper,
<span class="lineNum">    6144 </span>                :            :                    size_t &amp;nPartsFound, mj_part_t **partsFound) const;
<span class="lineNum">    6145 </span>                :            : 
<span class="lineNum">    6146 </span>                :            : 
<span class="lineNum">    6147 </span>                :            :     /*! \brief returns communication graph resulting from MJ partitioning.
<span class="lineNum">    6148 </span>                :            :      */
<span class="lineNum">    6149 </span>                :            :     void getCommunicationGraph(
<span class="lineNum">    6150 </span>                :            :                          const PartitioningSolution&lt;Adapter&gt; *solution,
<span class="lineNum">    6151 </span>                :            :                          ArrayRCP&lt;mj_part_t&gt; &amp;comXAdj,
<span class="lineNum">    6152 </span>                :            :                          ArrayRCP&lt;mj_part_t&gt; &amp;comAdj);
<span class="lineNum">    6153 </span>                :            : };
<span class="lineNum">    6154 </span>                :            : 
<span class="lineNum">    6155 </span>                :            : 
<span class="lineNum">    6156 </span>                :            : /*! \brief Multi Jagged  coordinate partitioning algorithm.
<span class="lineNum">    6157 </span>                :            :  *
<span class="lineNum">    6158 </span>                :            :  *  \param env   library configuration and problem parameters
<span class="lineNum">    6159 </span>                :            :  *  \param problemComm the communicator for the problem
<span class="lineNum">    6160 </span>                :            :  *  \param coords    a CoordinateModel with user data
<span class="lineNum">    6161 </span>                :            :  *  \param solution  a PartitioningSolution, on input it
<span class="lineNum">    6162 </span>                :            :  *      contains part information, on return it also contains
<span class="lineNum">    6163 </span>                :            :  *      the solution and quality metrics.
<a name="6164"><span class="lineNum">    6164 </span>                :            :  */</a>
<span class="lineNum">    6165 </span>                :            : template &lt;typename Adapter&gt;
<span class="lineNum">    6166 </span>                :<span class="lineNoCov">          0 : void Zoltan2_AlgMJ&lt;Adapter&gt;::partition(</span>
<span class="lineNum">    6167 </span>                :            :   const RCP&lt;PartitioningSolution&lt;Adapter&gt; &gt; &amp;solution
<span class="lineNum">    6168 </span>                :            : )
<span class="lineNum">    6169 </span>                :            : {
<span class="lineNum">    6170 </span>                :<span class="lineNoCov">          0 :     this-&gt;set_up_partitioning_data(solution);</span>
<span class="lineNum">    6171 </span>                :<span class="lineNoCov">          0 :     this-&gt;set_input_parameters(this-&gt;mj_env-&gt;getParameters());</span>
<span class="lineNum">    6172 </span>                :<span class="lineNoCov">          0 :     if (this-&gt;mj_keep_part_boxes){</span>
<span class="lineNum">    6173 </span>                :<span class="lineNoCov">          0 :         this-&gt;mj_partitioner.set_to_keep_part_boxes();</span>
<span class="lineNum">    6174 </span>                :            :     }
<span class="lineNum">    6175 </span>                :<span class="lineNoCov">          0 :     this-&gt;mj_partitioner.set_partitioning_parameters(</span>
<span class="lineNum">    6176 </span>                :            :                 this-&gt;distribute_points_on_cut_lines,
<span class="lineNum">    6177 </span>                :            :                 this-&gt;max_concurrent_part_calculation,
<span class="lineNum">    6178 </span>                :            :                 this-&gt;check_migrate_avoid_migration_option,
<span class="lineNum">    6179 </span>                :            :                 this-&gt;minimum_migration_imbalance);
<span class="lineNum">    6180 </span>                :            : 
<span class="lineNum">    6181 </span>                :<span class="lineNoCov">          0 :     mj_part_t *result_assigned_part_ids = NULL;</span>
<span class="lineNum">    6182 </span>                :<span class="lineNoCov">          0 :     mj_gno_t *result_mj_gnos = NULL;</span>
<span class="lineNum">    6183 </span>                :<span class="lineNoCov">          0 :     this-&gt;mj_partitioner.multi_jagged_part(</span>
<span class="lineNum">    6184 </span>                :            :                 this-&gt;mj_env,
<span class="lineNum">    6185 </span>                :            :                 this-&gt;mj_problemComm,
<span class="lineNum">    6186 </span>                :            : 
<span class="lineNum">    6187 </span>                :            :                 this-&gt;imbalance_tolerance,
<span class="lineNum">    6188 </span>                :            :                 this-&gt;num_global_parts,
<span class="lineNum">    6189 </span>                :            :                 this-&gt;part_no_array,
<span class="lineNum">    6190 </span>                :            :                 this-&gt;recursion_depth,
<span class="lineNum">    6191 </span>                :            : 
<span class="lineNum">    6192 </span>                :            :                 this-&gt;coord_dim,
<span class="lineNum">    6193 </span>                :            :                 this-&gt;num_local_coords,
<span class="lineNum">    6194 </span>                :            :                 this-&gt;num_global_coords,
<span class="lineNum">    6195 </span>                :            :                 this-&gt;initial_mj_gnos,
<span class="lineNum">    6196 </span>                :            :                 this-&gt;mj_coordinates,
<span class="lineNum">    6197 </span>                :            : 
<span class="lineNum">    6198 </span>                :            :                 this-&gt;num_weights_per_coord,
<span class="lineNum">    6199 </span>                :            :                 this-&gt;mj_uniform_weights,
<span class="lineNum">    6200 </span>                :            :                 this-&gt;mj_weights,
<span class="lineNum">    6201 </span>                :            :                 this-&gt;mj_uniform_parts,
<span class="lineNum">    6202 </span>                :            :                 this-&gt;mj_part_sizes,
<span class="lineNum">    6203 </span>                :            : 
<span class="lineNum">    6204 </span>                :            :                 result_assigned_part_ids,
<span class="lineNum">    6205 </span>                :            :                 result_mj_gnos
<span class="lineNum">    6206 </span>                :            :                 );
<span class="lineNum">    6207 </span>                :            : 
<span class="lineNum">    6208 </span>                :            :     // Reorder results so that they match the order of the input
<span class="lineNum">    6209 </span>                :            : #if defined(__cplusplus) &amp;&amp; __cplusplus &gt;= 201103L
<span class="lineNum">    6210 </span>                :<span class="lineNoCov">          0 :     std::unordered_map&lt;mj_gno_t, mj_lno_t&gt; localGidToLid;</span>
<span class="lineNum">    6211 </span>                :<span class="lineNoCov">          0 :     localGidToLid.reserve(this-&gt;num_local_coords);</span>
<span class="lineNum">    6212 </span>                :<span class="lineNoCov">          0 :     for (mj_lno_t i = 0; i &lt; this-&gt;num_local_coords; i++)</span>
<span class="lineNum">    6213 </span>                :<span class="lineNoCov">          0 :       localGidToLid[this-&gt;initial_mj_gnos[i]] = i;</span>
<span class="lineNum">    6214 </span>                :            : 
<span class="lineNum">    6215 </span>                :<span class="lineNoCov">          0 :     ArrayRCP&lt;mj_part_t&gt; partId = arcp(new mj_part_t[this-&gt;num_local_coords],</span>
<span class="lineNum">    6216 </span>                :<span class="lineNoCov">          0 :                                       0, this-&gt;num_local_coords, true);</span>
<span class="lineNum">    6217 </span>                :            : 
<span class="lineNum">    6218 </span>                :<span class="lineNoCov">          0 :     for (mj_lno_t i = 0; i &lt; this-&gt;num_local_coords; i++) {</span>
<span class="lineNum">    6219 </span>                :<span class="lineNoCov">          0 :       mj_lno_t origLID = localGidToLid[result_mj_gnos[i]];</span>
<span class="lineNum">    6220 </span>                :<span class="lineNoCov">          0 :       partId[origLID] = result_assigned_part_ids[i];</span>
<span class="lineNum">    6221 </span>                :            :     }
<span class="lineNum">    6222 </span>                :            : 
<span class="lineNum">    6223 </span>                :            : #else
<span class="lineNum">    6224 </span>                :            :     Teuchos::Hashtable&lt;mj_gno_t, mj_lno_t&gt;
<span class="lineNum">    6225 </span>                :            :                        localGidToLid(this-&gt;num_local_coords);
<span class="lineNum">    6226 </span>                :            :     for (mj_lno_t i = 0; i &lt; this-&gt;num_local_coords; i++)
<span class="lineNum">    6227 </span>                :            :       localGidToLid.put(this-&gt;initial_mj_gnos[i], i);
<span class="lineNum">    6228 </span>                :            : 
<span class="lineNum">    6229 </span>                :            :     ArrayRCP&lt;mj_part_t&gt; partId = arcp(new mj_part_t[this-&gt;num_local_coords],
<span class="lineNum">    6230 </span>                :            :                                       0, this-&gt;num_local_coords, true);
<span class="lineNum">    6231 </span>                :            : 
<span class="lineNum">    6232 </span>                :            :     for (mj_lno_t i = 0; i &lt; this-&gt;num_local_coords; i++) {
<span class="lineNum">    6233 </span>                :            :       mj_lno_t origLID = localGidToLid.get(result_mj_gnos[i]);
<span class="lineNum">    6234 </span>                :            :       partId[origLID] = result_assigned_part_ids[i];
<span class="lineNum">    6235 </span>                :            :     }
<span class="lineNum">    6236 </span>                :            : 
<span class="lineNum">    6237 </span>                :            : #endif // C++11 is enabled
<span class="lineNum">    6238 </span>                :            : 
<span class="lineNum">    6239 </span>                :<span class="lineNoCov">          0 :     delete [] result_mj_gnos;</span>
<span class="lineNum">    6240 </span>                :<span class="lineNoCov">          0 :     delete [] result_assigned_part_ids;</span>
<span class="lineNum">    6241 </span>                :            : 
<span class="lineNum">    6242 </span>                :<span class="lineNoCov">          0 :     solution-&gt;setParts(partId);</span>
<span class="lineNum">    6243 </span>                :<span class="lineNoCov">          0 :     this-&gt;free_work_memory();</span>
<span class="lineNum">    6244 </span>                :<span class="lineNoCov">          0 : }</span>
<span class="lineNum">    6245 </span>                :            : 
<span class="lineNum">    6246 </span>                :            : /* \brief Freeing the memory allocated.
<a name="6247"><span class="lineNum">    6247 </span>                :            :  * */</a>
<span class="lineNum">    6248 </span>                :            : template &lt;typename Adapter&gt;
<span class="lineNum">    6249 </span>                :<span class="lineNoCov">          0 : void Zoltan2_AlgMJ&lt;Adapter&gt;::free_work_memory(){</span>
<span class="lineNum">    6250 </span>                :<span class="lineNoCov">          0 :         freeArray&lt;mj_scalar_t *&gt;(this-&gt;mj_coordinates);</span>
<span class="lineNum">    6251 </span>                :<span class="lineNoCov">          0 :         freeArray&lt;mj_scalar_t *&gt;(this-&gt;mj_weights);</span>
<span class="lineNum">    6252 </span>                :<span class="lineNoCov">          0 :         freeArray&lt;bool&gt;(this-&gt;mj_uniform_parts);</span>
<span class="lineNum">    6253 </span>                :<span class="lineNoCov">          0 :         freeArray&lt;mj_scalar_t *&gt;(this-&gt;mj_part_sizes);</span>
<span class="lineNum">    6254 </span>                :<span class="lineNoCov">          0 :         freeArray&lt;bool&gt;(this-&gt;mj_uniform_weights);</span>
<span class="lineNum">    6255 </span>                :            : 
<span class="lineNum">    6256 </span>                :<span class="lineNoCov">          0 : }</span>
<span class="lineNum">    6257 </span>                :            : 
<span class="lineNum">    6258 </span>                :            : /* \brief Sets the partitioning data for multijagged algorithm.
<a name="6259"><span class="lineNum">    6259 </span>                :            :  * */</a>
<span class="lineNum">    6260 </span>                :            : template &lt;typename Adapter&gt;
<span class="lineNum">    6261 </span>                :<span class="lineNoCov">          0 : void Zoltan2_AlgMJ&lt;Adapter&gt;::set_up_partitioning_data(</span>
<span class="lineNum">    6262 </span>                :            :   const RCP&lt;PartitioningSolution&lt;Adapter&gt; &gt; &amp;solution
<span class="lineNum">    6263 </span>                :            : )
<span class="lineNum">    6264 </span>                :            : {
<span class="lineNum">    6265 </span>                :<span class="lineNoCov">          0 :         this-&gt;coord_dim = this-&gt;mj_coords-&gt;getCoordinateDim();</span>
<span class="lineNum">    6266 </span>                :<span class="lineNoCov">          0 :         this-&gt;num_weights_per_coord = this-&gt;mj_coords-&gt;getNumWeightsPerCoordinate();</span>
<span class="lineNum">    6267 </span>                :<span class="lineNoCov">          0 :         this-&gt;num_local_coords = this-&gt;mj_coords-&gt;getLocalNumCoordinates();</span>
<span class="lineNum">    6268 </span>                :<span class="lineNoCov">          0 :         this-&gt;num_global_coords = this-&gt;mj_coords-&gt;getGlobalNumCoordinates();</span>
<span class="lineNum">    6269 </span>                :<span class="lineNoCov">          0 :         int criteria_dim = (this-&gt;num_weights_per_coord ? this-&gt;num_weights_per_coord : 1);</span>
<span class="lineNum">    6270 </span>                :            : 
<span class="lineNum">    6271 </span>                :            :         // From the Solution we get part information.
<span class="lineNum">    6272 </span>                :            :         // If the part sizes for a given criteria are not uniform,
<span class="lineNum">    6273 </span>                :            :         // then they are values that sum to 1.0.
<span class="lineNum">    6274 </span>                :<span class="lineNoCov">          0 :         this-&gt;num_global_parts = solution-&gt;getTargetGlobalNumberOfParts();</span>
<span class="lineNum">    6275 </span>                :            :         //allocate only two dimensional pointer.
<span class="lineNum">    6276 </span>                :            :         //raw pointer addresess will be obtained from multivector.
<span class="lineNum">    6277 </span>                :<span class="lineNoCov">          0 :         this-&gt;mj_coordinates = allocMemory&lt;mj_scalar_t *&gt;(this-&gt;coord_dim);</span>
<span class="lineNum">    6278 </span>                :<span class="lineNoCov">          0 :         this-&gt;mj_weights = allocMemory&lt;mj_scalar_t *&gt;(criteria_dim);</span>
<span class="lineNum">    6279 </span>                :            : 
<span class="lineNum">    6280 </span>                :            :         //if the partitioning results are to be uniform.
<span class="lineNum">    6281 </span>                :<span class="lineNoCov">          0 :         this-&gt;mj_uniform_parts = allocMemory&lt; bool &gt;(criteria_dim);</span>
<span class="lineNum">    6282 </span>                :            :         //if in a criteria dimension, uniform part is false this shows ratios of
<span class="lineNum">    6283 </span>                :            :         //the target part weights.
<span class="lineNum">    6284 </span>                :<span class="lineNoCov">          0 :         this-&gt;mj_part_sizes =  allocMemory&lt;mj_scalar_t *&gt;(criteria_dim);</span>
<span class="lineNum">    6285 </span>                :            :         //if the weights of coordinates are uniform in a criteria dimension.
<span class="lineNum">    6286 </span>                :<span class="lineNoCov">          0 :         this-&gt;mj_uniform_weights = allocMemory&lt; bool &gt;(criteria_dim);</span>
<span class="lineNum">    6287 </span>                :            : 
<span class="lineNum">    6288 </span>                :            :         typedef StridedData&lt;mj_lno_t, mj_scalar_t&gt; input_t;
<span class="lineNum">    6289 </span>                :<span class="lineNoCov">          0 :         ArrayView&lt;const mj_gno_t&gt; gnos;</span>
<span class="lineNum">    6290 </span>                :<span class="lineNoCov">          0 :         ArrayView&lt;input_t&gt; xyz;</span>
<span class="lineNum">    6291 </span>                :<span class="lineNoCov">          0 :         ArrayView&lt;input_t&gt; wgts;</span>
<span class="lineNum">    6292 </span>                :            : 
<span class="lineNum">    6293 </span>                :            : 
<span class="lineNum">    6294 </span>                :<span class="lineNoCov">          0 :         this-&gt;coordinate_ArrayRCP_holder = new ArrayRCP&lt;const mj_scalar_t&gt; [this-&gt;coord_dim + this-&gt;num_weights_per_coord];</span>
<span class="lineNum">    6295 </span>                :            : 
<span class="lineNum">    6296 </span>                :<span class="lineNoCov">          0 :         this-&gt;mj_coords-&gt;getCoordinates(gnos, xyz, wgts);</span>
<span class="lineNum">    6297 </span>                :            :         //obtain global ids.
<span class="lineNum">    6298 </span>                :<span class="lineNoCov">          0 :         ArrayView&lt;const mj_gno_t&gt; mj_gnos = gnos;</span>
<span class="lineNum">    6299 </span>                :<span class="lineNoCov">          0 :         this-&gt;initial_mj_gnos = mj_gnos.getRawPtr();</span>
<span class="lineNum">    6300 </span>                :            : 
<span class="lineNum">    6301 </span>                :            :         //extract coordinates from multivector.
<span class="lineNum">    6302 </span>                :<span class="lineNoCov">          0 :         for (int dim=0; dim &lt; this-&gt;coord_dim; dim++){</span>
<span class="lineNum">    6303 </span>                :<span class="lineNoCov">          0 :                 ArrayRCP&lt;const mj_scalar_t&gt; ar;</span>
<span class="lineNum">    6304 </span>                :<span class="lineNoCov">          0 :                 xyz[dim].getInputArray(ar);</span>
<span class="lineNum">    6305 </span>                :<span class="lineNoCov">          0 :                 this-&gt;coordinate_ArrayRCP_holder[dim] = ar;</span>
<span class="lineNum">    6306 </span>                :            : 
<span class="lineNum">    6307 </span>                :            :                 //multiJagged coordinate values assignment
<span class="lineNum">    6308 </span>                :<span class="lineNoCov">          0 :                 this-&gt;mj_coordinates[dim] =  (mj_scalar_t *)ar.getRawPtr();</span>
<span class="lineNum">    6309 </span>                :            :         }
<span class="lineNum">    6310 </span>                :            : 
<span class="lineNum">    6311 </span>                :            :         //if no weights are provided set uniform weight.
<span class="lineNum">    6312 </span>                :<span class="lineNoCov">          0 :         if (this-&gt;num_weights_per_coord == 0){</span>
<span class="lineNum">    6313 </span>                :<span class="lineNoCov">          0 :                 this-&gt;mj_uniform_weights[0] = true;</span>
<span class="lineNum">    6314 </span>                :<span class="lineNoCov">          0 :                 this-&gt;mj_weights[0] = NULL;</span>
<span class="lineNum">    6315 </span>                :            :         }
<span class="lineNum">    6316 </span>                :            :         else{
<span class="lineNum">    6317 </span>                :            :                 //if weights are provided get weights for all weight indices
<span class="lineNum">    6318 </span>                :<span class="lineNoCov">          0 :                 for (int wdim = 0; wdim &lt; this-&gt;num_weights_per_coord; wdim++){</span>
<span class="lineNum">    6319 </span>                :<span class="lineNoCov">          0 :                         ArrayRCP&lt;const mj_scalar_t&gt; ar;</span>
<span class="lineNum">    6320 </span>                :<span class="lineNoCov">          0 :                         wgts[wdim].getInputArray(ar);</span>
<span class="lineNum">    6321 </span>                :<span class="lineNoCov">          0 :                         this-&gt;coordinate_ArrayRCP_holder[this-&gt;coord_dim + wdim] = ar;</span>
<span class="lineNum">    6322 </span>                :<span class="lineNoCov">          0 :                         this-&gt;mj_uniform_weights[wdim] = false;</span>
<span class="lineNum">    6323 </span>                :<span class="lineNoCov">          0 :                         this-&gt;mj_weights[wdim] = (mj_scalar_t *) ar.getRawPtr();</span>
<span class="lineNum">    6324 </span>                :            :                 }
<span class="lineNum">    6325 </span>                :            :         }
<span class="lineNum">    6326 </span>                :            : 
<span class="lineNum">    6327 </span>                :<span class="lineNoCov">          0 :         for (int wdim = 0; wdim &lt; criteria_dim; wdim++){</span>
<span class="lineNum">    6328 </span>                :<span class="lineNoCov">          0 :                 if (solution-&gt;criteriaHasUniformPartSizes(wdim)){</span>
<span class="lineNum">    6329 </span>                :<span class="lineNoCov">          0 :                         this-&gt;mj_uniform_parts[wdim] = true;</span>
<span class="lineNum">    6330 </span>                :<span class="lineNoCov">          0 :                         this-&gt;mj_part_sizes[wdim] = NULL;</span>
<span class="lineNum">    6331 </span>                :            :                 }
<span class="lineNum">    6332 </span>                :            :                 else{
<span class="lineNum">    6333 </span>                :<span class="lineNoCov">          0 :                         std::cerr &lt;&lt; &quot;MJ does not support non uniform target part weights&quot; &lt;&lt; std::endl;</span>
<span class="lineNum">    6334 </span>                :<span class="lineNoCov">          0 :                         exit(1);</span>
<span class="lineNum">    6335 </span>                :            :                 }
<span class="lineNum">    6336 </span>                :            :         }
<span class="lineNum">    6337 </span>                :<span class="lineNoCov">          0 : }</span>
<span class="lineNum">    6338 </span>                :            : 
<span class="lineNum">    6339 </span>                :            : /* \brief Sets the partitioning parameters for multijagged algorithm.
<span class="lineNum">    6340 </span>                :            :  * \param pl: is the parameter list provided to zoltan2 call
<a name="6341"><span class="lineNum">    6341 </span>                :            :  * */</a>
<span class="lineNum">    6342 </span>                :            : template &lt;typename Adapter&gt;
<span class="lineNum">    6343 </span>                :<span class="lineNoCov">          0 : void Zoltan2_AlgMJ&lt;Adapter&gt;::set_input_parameters(const Teuchos::ParameterList &amp;pl){</span>
<span class="lineNum">    6344 </span>                :            : 
<span class="lineNum">    6345 </span>                :<span class="lineNoCov">          0 :         const Teuchos::ParameterEntry *pe = pl.getEntryPtr(&quot;imbalance_tolerance&quot;);</span>
<span class="lineNum">    6346 </span>                :<span class="lineNoCov">          0 :         if (pe){</span>
<span class="lineNum">    6347 </span>                :            :                 double tol;
<span class="lineNum">    6348 </span>                :<span class="lineNoCov">          0 :                 tol = pe-&gt;getValue(&amp;tol);</span>
<span class="lineNum">    6349 </span>                :<span class="lineNoCov">          0 :                 this-&gt;imbalance_tolerance = tol - 1.0;</span>
<span class="lineNum">    6350 </span>                :            :         }
<span class="lineNum">    6351 </span>                :            : 
<span class="lineNum">    6352 </span>                :            :     // TODO: May be a more relaxed tolerance is needed. RCB uses 10%
<span class="lineNum">    6353 </span>                :<span class="lineNoCov">          0 :         if (this-&gt;imbalance_tolerance &lt;= 0)</span>
<span class="lineNum">    6354 </span>                :<span class="lineNoCov">          0 :                 this-&gt;imbalance_tolerance= 10e-4;</span>
<span class="lineNum">    6355 </span>                :            : 
<span class="lineNum">    6356 </span>                :            :         //if an input partitioning array is provided.
<span class="lineNum">    6357 </span>                :<span class="lineNoCov">          0 :         this-&gt;part_no_array = NULL;</span>
<span class="lineNum">    6358 </span>                :            :         //the length of the input partitioning array.
<span class="lineNum">    6359 </span>                :<span class="lineNoCov">          0 :         this-&gt;recursion_depth = 0;</span>
<span class="lineNum">    6360 </span>                :            : 
<span class="lineNum">    6361 </span>                :<span class="lineNoCov">          0 :         if (pl.getPtr&lt;Array &lt;mj_part_t&gt; &gt;(&quot;mj_parts&quot;)){</span>
<span class="lineNum">    6362 </span>                :<span class="lineNoCov">          0 :                 this-&gt;part_no_array = (mj_part_t *) pl.getPtr&lt;Array &lt;mj_part_t&gt; &gt;(&quot;mj_parts&quot;)-&gt;getRawPtr();</span>
<span class="lineNum">    6363 </span>                :<span class="lineNoCov">          0 :                 this-&gt;recursion_depth = pl.getPtr&lt;Array &lt;mj_part_t&gt; &gt;(&quot;mj_parts&quot;)-&gt;size() - 1;</span>
<span class="lineNum">    6364 </span>                :<span class="lineNoCov">          0 :                 this-&gt;mj_env-&gt;debug(2, &quot;mj_parts provided by user&quot;);</span>
<span class="lineNum">    6365 </span>                :            :         }
<span class="lineNum">    6366 </span>                :            : 
<span class="lineNum">    6367 </span>                :            :         //get mj specific parameters.
<span class="lineNum">    6368 </span>                :<span class="lineNoCov">          0 :         this-&gt;distribute_points_on_cut_lines = true;</span>
<span class="lineNum">    6369 </span>                :<span class="lineNoCov">          0 :         this-&gt;max_concurrent_part_calculation = 1;</span>
<span class="lineNum">    6370 </span>                :            : 
<span class="lineNum">    6371 </span>                :<span class="lineNoCov">          0 :         this-&gt;mj_run_as_rcb = 0;</span>
<span class="lineNum">    6372 </span>                :<span class="lineNoCov">          0 :         int mj_user_recursion_depth = -1;</span>
<span class="lineNum">    6373 </span>                :<span class="lineNoCov">          0 :         this-&gt;mj_keep_part_boxes = 0;</span>
<span class="lineNum">    6374 </span>                :<span class="lineNoCov">          0 :         this-&gt;check_migrate_avoid_migration_option = 0;</span>
<span class="lineNum">    6375 </span>                :<span class="lineNoCov">          0 :         this-&gt;minimum_migration_imbalance = 0.35;</span>
<span class="lineNum">    6376 </span>                :            : 
<span class="lineNum">    6377 </span>                :<span class="lineNoCov">          0 :         pe = pl.getEntryPtr(&quot;mj_minimum_migration_imbalance&quot;);</span>
<span class="lineNum">    6378 </span>                :<span class="lineNoCov">          0 :         if (pe){</span>
<span class="lineNum">    6379 </span>                :            :                 double imb;
<span class="lineNum">    6380 </span>                :<span class="lineNoCov">          0 :                 imb = pe-&gt;getValue(&amp;imb);</span>
<span class="lineNum">    6381 </span>                :<span class="lineNoCov">          0 :                 this-&gt;minimum_migration_imbalance = imb - 1.0;</span>
<span class="lineNum">    6382 </span>                :            :         }
<span class="lineNum">    6383 </span>                :            : 
<span class="lineNum">    6384 </span>                :<span class="lineNoCov">          0 :         pe = pl.getEntryPtr(&quot;mj_migration_option&quot;);</span>
<span class="lineNum">    6385 </span>                :<span class="lineNoCov">          0 :         if (pe){</span>
<span class="lineNum">    6386 </span>                :<span class="lineNoCov">          0 :                 this-&gt;check_migrate_avoid_migration_option = pe-&gt;getValue(&amp;this-&gt;check_migrate_avoid_migration_option);</span>
<span class="lineNum">    6387 </span>                :            :         }else {
<span class="lineNum">    6388 </span>                :<span class="lineNoCov">          0 :                 this-&gt;check_migrate_avoid_migration_option = 0;</span>
<span class="lineNum">    6389 </span>                :            :         }
<span class="lineNum">    6390 </span>                :<span class="lineNoCov">          0 :         if (this-&gt;check_migrate_avoid_migration_option &gt; 1) this-&gt;check_migrate_avoid_migration_option = -1;</span>
<span class="lineNum">    6391 </span>                :            : 
<span class="lineNum">    6392 </span>                :            : 
<span class="lineNum">    6393 </span>                :<span class="lineNoCov">          0 :         pe = pl.getEntryPtr(&quot;mj_concurrent_part_count&quot;);</span>
<span class="lineNum">    6394 </span>                :<span class="lineNoCov">          0 :         if (pe){</span>
<span class="lineNum">    6395 </span>                :<span class="lineNoCov">          0 :                 this-&gt;max_concurrent_part_calculation = pe-&gt;getValue(&amp;this-&gt;max_concurrent_part_calculation);</span>
<span class="lineNum">    6396 </span>                :            :         }else {
<span class="lineNum">    6397 </span>                :<span class="lineNoCov">          0 :                 this-&gt;max_concurrent_part_calculation = 1; // Set to 1 if not provided.</span>
<span class="lineNum">    6398 </span>                :            :         }
<span class="lineNum">    6399 </span>                :            : 
<span class="lineNum">    6400 </span>                :<span class="lineNoCov">          0 :         pe = pl.getEntryPtr(&quot;mj_keep_part_boxes&quot;);</span>
<span class="lineNum">    6401 </span>                :<span class="lineNoCov">          0 :         if (pe){</span>
<span class="lineNum">    6402 </span>                :<span class="lineNoCov">          0 :                 this-&gt;mj_keep_part_boxes = pe-&gt;getValue(&amp;this-&gt;mj_keep_part_boxes);</span>
<span class="lineNum">    6403 </span>                :            :         }else {
<span class="lineNum">    6404 </span>                :<span class="lineNoCov">          0 :                 this-&gt;mj_keep_part_boxes = 0; // Set to invalid value</span>
<span class="lineNum">    6405 </span>                :            :         }
<span class="lineNum">    6406 </span>                :            : 
<span class="lineNum">    6407 </span>                :            :         // For now, need keep_part_boxes to do pointAssign and boxAssign.
<span class="lineNum">    6408 </span>                :            :         // pe = pl.getEntryPtr(&quot;keep_cuts&quot;);
<span class="lineNum">    6409 </span>                :            :         // if (pe){
<span class="lineNum">    6410 </span>                :            :         //      int tmp = pe-&gt;getValue(&amp;tmp);
<span class="lineNum">    6411 </span>                :            :         //      if (tmp) this-&gt;mj_keep_part_boxes = 1;
<span class="lineNum">    6412 </span>                :            :         // }
<span class="lineNum">    6413 </span>                :            : 
<span class="lineNum">    6414 </span>                :            :         //need to keep part boxes if mapping type is geometric.
<span class="lineNum">    6415 </span>                :<span class="lineNoCov">          0 :         if (this-&gt;mj_keep_part_boxes == 0){</span>
<span class="lineNum">    6416 </span>                :<span class="lineNoCov">          0 :                 pe = pl.getEntryPtr(&quot;mapping_type&quot;);</span>
<span class="lineNum">    6417 </span>                :<span class="lineNoCov">          0 :                 if (pe){</span>
<span class="lineNum">    6418 </span>                :<span class="lineNoCov">          0 :                         int mapping_type = -1;</span>
<span class="lineNum">    6419 </span>                :<span class="lineNoCov">          0 :                         mapping_type = pe-&gt;getValue(&amp;mapping_type);</span>
<span class="lineNum">    6420 </span>                :<span class="lineNoCov">          0 :                         if (mapping_type == 0){</span>
<span class="lineNum">    6421 </span>                :<span class="lineNoCov">          0 :                                 mj_keep_part_boxes  = 1;</span>
<span class="lineNum">    6422 </span>                :            :                         }
<span class="lineNum">    6423 </span>                :            :                 }
<span class="lineNum">    6424 </span>                :            :         }
<span class="lineNum">    6425 </span>                :            : 
<span class="lineNum">    6426 </span>                :            :         //need to keep part boxes if mapping type is geometric.
<span class="lineNum">    6427 </span>                :<span class="lineNoCov">          0 :         pe = pl.getEntryPtr(&quot;mj_enable_rcb&quot;);</span>
<span class="lineNum">    6428 </span>                :<span class="lineNoCov">          0 :         if (pe){</span>
<span class="lineNum">    6429 </span>                :<span class="lineNoCov">          0 :                 this-&gt;mj_run_as_rcb = pe-&gt;getValue(&amp;this-&gt;mj_run_as_rcb);</span>
<span class="lineNum">    6430 </span>                :            :         }else {
<span class="lineNum">    6431 </span>                :<span class="lineNoCov">          0 :                 this-&gt;mj_run_as_rcb = 0; // Set to invalid value</span>
<span class="lineNum">    6432 </span>                :            :         }
<span class="lineNum">    6433 </span>                :            : 
<span class="lineNum">    6434 </span>                :<span class="lineNoCov">          0 :         pe = pl.getEntryPtr(&quot;mj_recursion_depth&quot;);</span>
<span class="lineNum">    6435 </span>                :<span class="lineNoCov">          0 :         if (pe){</span>
<span class="lineNum">    6436 </span>                :<span class="lineNoCov">          0 :                 mj_user_recursion_depth = pe-&gt;getValue(&amp;mj_user_recursion_depth);</span>
<span class="lineNum">    6437 </span>                :            :         }else {
<span class="lineNum">    6438 </span>                :<span class="lineNoCov">          0 :                 mj_user_recursion_depth = -1; // Set to invalid value</span>
<span class="lineNum">    6439 </span>                :            :         }
<span class="lineNum">    6440 </span>                :            : 
<span class="lineNum">    6441 </span>                :<span class="lineNoCov">          0 :         int val = 0;</span>
<span class="lineNum">    6442 </span>                :<span class="lineNoCov">          0 :         pe = pl.getEntryPtr(&quot;rectilinear&quot;);</span>
<span class="lineNum">    6443 </span>                :<span class="lineNoCov">          0 :         if (pe) val = pe-&gt;getValue(&amp;val);</span>
<span class="lineNum">    6444 </span>                :<span class="lineNoCov">          0 :         if (val == 1){</span>
<span class="lineNum">    6445 </span>                :<span class="lineNoCov">          0 :                 this-&gt;distribute_points_on_cut_lines = false;</span>
<span class="lineNum">    6446 </span>                :            :         } else {
<span class="lineNum">    6447 </span>                :<span class="lineNoCov">          0 :                 this-&gt;distribute_points_on_cut_lines = true;</span>
<span class="lineNum">    6448 </span>                :            :         }
<span class="lineNum">    6449 </span>                :            : 
<span class="lineNum">    6450 </span>                :<span class="lineNoCov">          0 :         if (this-&gt;mj_run_as_rcb){</span>
<span class="lineNum">    6451 </span>                :<span class="lineNoCov">          0 :                 mj_user_recursion_depth = (int)(ceil(log ((this-&gt;num_global_parts)) / log (2.0)));</span>
<span class="lineNum">    6452 </span>                :            :         }
<span class="lineNum">    6453 </span>                :<span class="lineNoCov">          0 :         if (this-&gt;recursion_depth &lt; 1){</span>
<span class="lineNum">    6454 </span>                :<span class="lineNoCov">          0 :                 if (mj_user_recursion_depth &gt; 0){</span>
<span class="lineNum">    6455 </span>                :<span class="lineNoCov">          0 :                         this-&gt;recursion_depth = mj_user_recursion_depth;</span>
<span class="lineNum">    6456 </span>                :            :                 }
<span class="lineNum">    6457 </span>                :            :                 else {
<span class="lineNum">    6458 </span>                :<span class="lineNoCov">          0 :                         this-&gt;recursion_depth = this-&gt;coord_dim;</span>
<span class="lineNum">    6459 </span>                :            :                 }
<span class="lineNum">    6460 </span>                :            :         }
<span class="lineNum">    6461 </span>                :            : 
<span class="lineNum">    6462 </span>                :<span class="lineNoCov">          0 :         this-&gt;num_threads = 1;</span>
<span class="lineNum">    6463 </span>                :            : #ifdef HAVE_ZOLTAN2_OMP
<span class="lineNum">    6464 </span>                :            : #pragma omp parallel
<span class="lineNum">    6465 </span>                :            :         {
<span class="lineNum">    6466 </span>                :            :                 this-&gt;num_threads = omp_get_num_threads();
<span class="lineNum">    6467 </span>                :            :         }
<span class="lineNum">    6468 </span>                :            : #endif
<span class="lineNum">    6469 </span>                :            : 
<span class="lineNum">    6470 </span>                :<span class="lineNoCov">          0 : }</span>
<span class="lineNum">    6471 </span>                :            : 
<a name="6472"><span class="lineNum">    6472 </span>                :            : /////////////////////////////////////////////////////////////////////////////</a>
<span class="lineNum">    6473 </span>                :            : template &lt;typename Adapter&gt;
<span class="lineNum">    6474 </span>                :<span class="lineNoCov">          0 : void Zoltan2_AlgMJ&lt;Adapter&gt;::boxAssign(</span>
<span class="lineNum">    6475 </span>                :            :   int dim,
<span class="lineNum">    6476 </span>                :            :   typename Adapter::scalar_t *lower,
<span class="lineNum">    6477 </span>                :            :   typename Adapter::scalar_t *upper,
<span class="lineNum">    6478 </span>                :            :   size_t &amp;nPartsFound,
<span class="lineNum">    6479 </span>                :            :   typename Adapter::part_t **partsFound) const
<span class="lineNum">    6480 </span>                :            : {
<span class="lineNum">    6481 </span>                :            :   // TODO:  Implement with cuts rather than boxes to reduce algorithmic
<span class="lineNum">    6482 </span>                :            :   // TODO:  complexity.  Or at least do a search through the boxes, using
<span class="lineNum">    6483 </span>                :            :   // TODO:  p x q x r x ... if possible.
<span class="lineNum">    6484 </span>                :            : 
<span class="lineNum">    6485 </span>                :<span class="lineNoCov">          0 :   nPartsFound = 0;</span>
<span class="lineNum">    6486 </span>                :<span class="lineNoCov">          0 :   *partsFound = NULL;</span>
<span class="lineNum">    6487 </span>                :            : 
<span class="lineNum">    6488 </span>                :<span class="lineNoCov">          0 :   if (this-&gt;mj_keep_part_boxes) {</span>
<span class="lineNum">    6489 </span>                :            : 
<span class="lineNum">    6490 </span>                :            :     // Get vector of part boxes
<span class="lineNum">    6491 </span>                :<span class="lineNoCov">          0 :     RCP&lt;mj_partBoxVector_t&gt; partBoxes = this-&gt;getGlobalBoxBoundaries();</span>
<span class="lineNum">    6492 </span>                :            : 
<span class="lineNum">    6493 </span>                :<span class="lineNoCov">          0 :     size_t nBoxes = (*partBoxes).size();</span>
<span class="lineNum">    6494 </span>                :<span class="lineNoCov">          0 :     if (nBoxes == 0) {</span>
<span class="lineNum">    6495 </span>                :<span class="lineNoCov">          0 :       throw std::logic_error(&quot;no part boxes exist&quot;);</span>
<span class="lineNum">    6496 </span>                :            :     }
<span class="lineNum">    6497 </span>                :            : 
<span class="lineNum">    6498 </span>                :            :     // Determine whether the box overlaps the globalBox at all
<span class="lineNum">    6499 </span>                :<span class="lineNoCov">          0 :     RCP&lt;mj_partBox_t&gt; globalBox = this-&gt;mj_partitioner.get_global_box();</span>
<span class="lineNum">    6500 </span>                :            : 
<span class="lineNum">    6501 </span>                :<span class="lineNoCov">          0 :     if (globalBox-&gt;boxesOverlap(dim, lower, upper)) {</span>
<span class="lineNum">    6502 </span>                :            : 
<span class="lineNum">    6503 </span>                :<span class="lineNoCov">          0 :       std::vector&lt;typename Adapter::part_t&gt; partlist;</span>
<span class="lineNum">    6504 </span>                :            : 
<span class="lineNum">    6505 </span>                :            :       // box overlaps the global box; find specific overlapping boxes
<span class="lineNum">    6506 </span>                :<span class="lineNoCov">          0 :       for (size_t i = 0; i &lt; nBoxes; i++) {</span>
<span class="lineNum">    6507 </span>                :            :         try {
<span class="lineNum">    6508 </span>                :<span class="lineNoCov">          0 :           if ((*partBoxes)[i].boxesOverlap(dim, lower, upper)) {</span>
<span class="lineNum">    6509 </span>                :<span class="lineNoCov">          0 :             nPartsFound++;</span>
<span class="lineNum">    6510 </span>                :<span class="lineNoCov">          0 :             partlist.push_back((*partBoxes)[i].getpId());</span>
<span class="lineNum">    6511 </span>                :            : 
<span class="lineNum">    6512 </span>                :            : //            std::cout &lt;&lt; &quot;Given box (&quot;;
<span class="lineNum">    6513 </span>                :            : //            for (int j = 0; j &lt; dim; j++)
<span class="lineNum">    6514 </span>                :            : //              std::cout &lt;&lt; lower[j] &lt;&lt; &quot; &quot;;
<span class="lineNum">    6515 </span>                :            : //            std::cout &lt;&lt; &quot;) x (&quot;;
<span class="lineNum">    6516 </span>                :            : //            for (int j = 0; j &lt; dim; j++)
<span class="lineNum">    6517 </span>                :            : //              std::cout &lt;&lt; upper[j] &lt;&lt; &quot; &quot;;
<span class="lineNum">    6518 </span>                :            : //            std::cout &lt;&lt; &quot;) overlaps PartBox &quot;
<span class="lineNum">    6519 </span>                :            : //                      &lt;&lt; (*partBoxes)[i].getpId() &lt;&lt; &quot; (&quot;;
<span class="lineNum">    6520 </span>                :            : //            for (int j = 0; j &lt; dim; j++)
<span class="lineNum">    6521 </span>                :            : //              std::cout &lt;&lt; (*partBoxes)[i].getlmins()[j] &lt;&lt; &quot; &quot;;
<span class="lineNum">    6522 </span>                :            : //            std::cout &lt;&lt; &quot;) x (&quot;;
<span class="lineNum">    6523 </span>                :            : //            for (int j = 0; j &lt; dim; j++)
<span class="lineNum">    6524 </span>                :            : //              std::cout &lt;&lt; (*partBoxes)[i].getlmaxs()[j] &lt;&lt; &quot; &quot;;
<span class="lineNum">    6525 </span>                :            : //            std::cout &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
<span class="lineNum">    6526 </span>                :            :           }
<span class="lineNum">    6527 </span>                :            :         }
<span class="lineNum">    6528 </span>                :<span class="lineNoCov">          0 :         Z2_FORWARD_EXCEPTIONS;</span>
<span class="lineNum">    6529 </span>                :            :       }
<span class="lineNum">    6530 </span>                :<span class="lineNoCov">          0 :       if (nPartsFound) {</span>
<span class="lineNum">    6531 </span>                :<span class="lineNoCov">          0 :         *partsFound = new mj_part_t[nPartsFound];</span>
<span class="lineNum">    6532 </span>                :<span class="lineNoCov">          0 :         for (size_t i = 0; i &lt; nPartsFound; i++)</span>
<span class="lineNum">    6533 </span>                :<span class="lineNoCov">          0 :           (*partsFound)[i] = partlist[i];</span>
<span class="lineNum">    6534 </span>                :            :       }
<span class="lineNum">    6535 </span>                :            :     }
<span class="lineNum">    6536 </span>                :            :     else {
<span class="lineNum">    6537 </span>                :            :       // Box does not overlap the domain at all.  Find the closest part
<span class="lineNum">    6538 </span>                :            :       // Not sure how to perform this operation for MJ without having the
<span class="lineNum">    6539 </span>                :            :       // cuts.  With the RCB cuts, the concept of a part extending to
<span class="lineNum">    6540 </span>                :            :       // infinity was natural.  With the boxes, it is much more difficult.
<span class="lineNum">    6541 </span>                :            :       // TODO:  For now, return information indicating NO OVERLAP.
<span class="lineNum">    6542 </span>                :            : 
<span class="lineNum">    6543 </span>                :            :     }
<span class="lineNum">    6544 </span>                :            :   }
<span class="lineNum">    6545 </span>                :            :   else {
<span class="lineNum">    6546 </span>                :<span class="lineNoCov">          0 :     throw std::logic_error(&quot;need to use keep_cuts parameter for boxAssign&quot;);</span>
<span class="lineNum">    6547 </span>                :            :   }
<span class="lineNum">    6548 </span>                :<span class="lineNoCov">          0 : }</span>
<span class="lineNum">    6549 </span>                :            : 
<a name="6550"><span class="lineNum">    6550 </span>                :            : /////////////////////////////////////////////////////////////////////////////</a>
<span class="lineNum">    6551 </span>                :            : template &lt;typename Adapter&gt;
<span class="lineNum">    6552 </span>                :<span class="lineNoCov">          0 : typename Adapter::part_t Zoltan2_AlgMJ&lt;Adapter&gt;::pointAssign(</span>
<span class="lineNum">    6553 </span>                :            :   int dim,
<span class="lineNum">    6554 </span>                :            :   typename Adapter::scalar_t *point) const
<span class="lineNum">    6555 </span>                :            : {
<span class="lineNum">    6556 </span>                :            : 
<span class="lineNum">    6557 </span>                :            :   // TODO:  Implement with cuts rather than boxes to reduce algorithmic
<span class="lineNum">    6558 </span>                :            :   // TODO:  complexity.  Or at least do a search through the boxes, using
<span class="lineNum">    6559 </span>                :            :   // TODO:  p x q x r x ... if possible.
<span class="lineNum">    6560 </span>                :            : 
<span class="lineNum">    6561 </span>                :<span class="lineNoCov">          0 :   if (this-&gt;mj_keep_part_boxes) {</span>
<span class="lineNum">    6562 </span>                :<span class="lineNoCov">          0 :     typename Adapter::part_t foundPart = -1;</span>
<span class="lineNum">    6563 </span>                :            : 
<span class="lineNum">    6564 </span>                :            :     // Get vector of part boxes
<span class="lineNum">    6565 </span>                :<span class="lineNoCov">          0 :     RCP&lt;mj_partBoxVector_t&gt; partBoxes = this-&gt;getGlobalBoxBoundaries();</span>
<span class="lineNum">    6566 </span>                :            : 
<span class="lineNum">    6567 </span>                :<span class="lineNoCov">          0 :     size_t nBoxes = (*partBoxes).size();</span>
<span class="lineNum">    6568 </span>                :<span class="lineNoCov">          0 :     if (nBoxes == 0) {</span>
<span class="lineNum">    6569 </span>                :<span class="lineNoCov">          0 :       throw std::logic_error(&quot;no part boxes exist&quot;);</span>
<span class="lineNum">    6570 </span>                :            :     }
<span class="lineNum">    6571 </span>                :            : 
<span class="lineNum">    6572 </span>                :            :     // Determine whether the point is within the global domain
<span class="lineNum">    6573 </span>                :<span class="lineNoCov">          0 :     RCP&lt;mj_partBox_t&gt; globalBox = this-&gt;mj_partitioner.get_global_box();</span>
<span class="lineNum">    6574 </span>                :            : 
<span class="lineNum">    6575 </span>                :<span class="lineNoCov">          0 :     if (globalBox-&gt;pointInBox(dim, point)) {</span>
<span class="lineNum">    6576 </span>                :            : 
<span class="lineNum">    6577 </span>                :            :       // point is in the global domain; determine in which part it is.
<span class="lineNum">    6578 </span>                :            :       size_t i;
<span class="lineNum">    6579 </span>                :<span class="lineNoCov">          0 :       for (i = 0; i &lt; nBoxes; i++) {</span>
<span class="lineNum">    6580 </span>                :            :         try {
<span class="lineNum">    6581 </span>                :<span class="lineNoCov">          0 :           if ((*partBoxes)[i].pointInBox(dim, point)) {</span>
<span class="lineNum">    6582 </span>                :<span class="lineNoCov">          0 :             foundPart = (*partBoxes)[i].getpId();</span>
<span class="lineNum">    6583 </span>                :            : //            std::cout &lt;&lt; &quot;Point (&quot;;
<span class="lineNum">    6584 </span>                :            : //            for (int j = 0; j &lt; dim; j++) std::cout &lt;&lt; point[j] &lt;&lt; &quot; &quot;;
<span class="lineNum">    6585 </span>                :            : //            std::cout &lt;&lt; &quot;) found in box &quot; &lt;&lt; i &lt;&lt; &quot; part &quot; &lt;&lt; foundPart
<span class="lineNum">    6586 </span>                :            : //                      &lt;&lt; std::endl;
<span class="lineNum">    6587 </span>                :            : //            (*partBoxes)[i].print();
<span class="lineNum">    6588 </span>                :<span class="lineNoCov">          0 :             break;</span>
<span class="lineNum">    6589 </span>                :            :           }
<span class="lineNum">    6590 </span>                :            :         }
<span class="lineNum">    6591 </span>                :<span class="lineNoCov">          0 :         Z2_FORWARD_EXCEPTIONS;</span>
<span class="lineNum">    6592 </span>                :            :       }
<span class="lineNum">    6593 </span>                :            : 
<span class="lineNum">    6594 </span>                :<span class="lineNoCov">          0 :       if (i == nBoxes) {</span>
<span class="lineNum">    6595 </span>                :            :         // This error should never occur
<span class="lineNum">    6596 </span>                :<span class="lineNoCov">          0 :         std::ostringstream oss;</span>
<span class="lineNum">    6597 </span>                :<span class="lineNoCov">          0 :         oss &lt;&lt; &quot;Point (&quot;;</span>
<span class="lineNum">    6598 </span>                :<span class="lineNoCov">          0 :         for (int j = 0; j &lt; dim; j++) oss &lt;&lt; point[j] &lt;&lt; &quot; &quot;;</span>
<span class="lineNum">    6599 </span>                :<span class="lineNoCov">          0 :         oss &lt;&lt; &quot;) not found in domain&quot;;</span>
<span class="lineNum">    6600 </span>                :<span class="lineNoCov">          0 :         throw std::logic_error(oss.str());</span>
<span class="lineNum">    6601 </span>                :            :       }
<span class="lineNum">    6602 </span>                :            :     }
<span class="lineNum">    6603 </span>                :            : 
<span class="lineNum">    6604 </span>                :            :     else {
<span class="lineNum">    6605 </span>                :            :       // Point is outside the global domain.
<span class="lineNum">    6606 </span>                :            :       // Determine to which part it is closest.
<span class="lineNum">    6607 </span>                :            :       // TODO:  with cuts, would not need this special case
<span class="lineNum">    6608 </span>                :            : 
<span class="lineNum">    6609 </span>                :<span class="lineNoCov">          0 :       size_t closestBox = 0;</span>
<span class="lineNum">    6610 </span>                :<span class="lineNoCov">          0 :       mj_scalar_t minDistance = std::numeric_limits&lt;mj_scalar_t&gt;::max();</span>
<span class="lineNum">    6611 </span>                :<span class="lineNoCov">          0 :       mj_scalar_t *centroid = new mj_scalar_t[dim];</span>
<span class="lineNum">    6612 </span>                :<span class="lineNoCov">          0 :       for (size_t i = 0; i &lt; nBoxes; i++) {</span>
<span class="lineNum">    6613 </span>                :<span class="lineNoCov">          0 :         (*partBoxes)[i].computeCentroid(centroid);</span>
<span class="lineNum">    6614 </span>                :<span class="lineNoCov">          0 :         mj_scalar_t sum = 0.;</span>
<span class="lineNum">    6615 </span>                :            :         mj_scalar_t diff;
<span class="lineNum">    6616 </span>                :<span class="lineNoCov">          0 :         for (int j = 0; j &lt; dim; j++) {</span>
<span class="lineNum">    6617 </span>                :<span class="lineNoCov">          0 :           diff = centroid[j] - point[j];</span>
<span class="lineNum">    6618 </span>                :<span class="lineNoCov">          0 :           sum += diff * diff;</span>
<span class="lineNum">    6619 </span>                :            :         }
<span class="lineNum">    6620 </span>                :<span class="lineNoCov">          0 :         if (sum &lt; minDistance) {</span>
<span class="lineNum">    6621 </span>                :<span class="lineNoCov">          0 :           minDistance = sum;</span>
<span class="lineNum">    6622 </span>                :<span class="lineNoCov">          0 :           closestBox = i;</span>
<span class="lineNum">    6623 </span>                :            :         }
<span class="lineNum">    6624 </span>                :            :       }
<span class="lineNum">    6625 </span>                :<span class="lineNoCov">          0 :       foundPart = (*partBoxes)[closestBox].getpId();</span>
<span class="lineNum">    6626 </span>                :<span class="lineNoCov">          0 :       delete [] centroid;</span>
<span class="lineNum">    6627 </span>                :            :     }
<span class="lineNum">    6628 </span>                :            : 
<span class="lineNum">    6629 </span>                :<span class="lineNoCov">          0 :     return foundPart;</span>
<span class="lineNum">    6630 </span>                :            :   }
<span class="lineNum">    6631 </span>                :            :   else {
<span class="lineNum">    6632 </span>                :<span class="lineNoCov">          0 :     throw std::logic_error(&quot;need to use keep_cuts parameter for pointAssign&quot;);</span>
<span class="lineNum">    6633 </span>                :            :   }
<span class="lineNum">    6634 </span>                :            : }
<a name="6635"><span class="lineNum">    6635 </span>                :            : </a>
<span class="lineNum">    6636 </span>                :            : template &lt;typename Adapter&gt;
<span class="lineNum">    6637 </span>                :<span class="lineNoCov">          0 : void Zoltan2_AlgMJ&lt;Adapter&gt;::getCommunicationGraph(</span>
<span class="lineNum">    6638 </span>                :            :   const PartitioningSolution&lt;Adapter&gt; *solution,
<span class="lineNum">    6639 </span>                :            :   ArrayRCP&lt;typename Zoltan2_AlgMJ&lt;Adapter&gt;::mj_part_t&gt; &amp;comXAdj,
<span class="lineNum">    6640 </span>                :            :   ArrayRCP&lt;typename Zoltan2_AlgMJ&lt;Adapter&gt;::mj_part_t&gt; &amp;comAdj)
<span class="lineNum">    6641 </span>                :            : {
<span class="lineNum">    6642 </span>                :<span class="lineNoCov">          0 :   if(comXAdj_.getRawPtr() == NULL &amp;&amp; comAdj_.getRawPtr() == NULL){</span>
<span class="lineNum">    6643 </span>                :<span class="lineNoCov">          0 :     RCP&lt;mj_partBoxVector_t&gt; pBoxes = this-&gt;getGlobalBoxBoundaries();</span>
<span class="lineNum">    6644 </span>                :<span class="lineNoCov">          0 :     mj_part_t ntasks =  (*pBoxes).size();</span>
<span class="lineNum">    6645 </span>                :<span class="lineNoCov">          0 :     int dim = (*pBoxes)[0].getDim();</span>
<span class="lineNum">    6646 </span>                :<span class="lineNoCov">          0 :     GridHash&lt;mj_scalar_t, mj_part_t&gt; grid(pBoxes, ntasks, dim);</span>
<span class="lineNum">    6647 </span>                :<span class="lineNoCov">          0 :     grid.getAdjArrays(comXAdj_, comAdj_);</span>
<span class="lineNum">    6648 </span>                :            :   }
<span class="lineNum">    6649 </span>                :<span class="lineNoCov">          0 :   comAdj = comAdj_;</span>
<span class="lineNum">    6650 </span>                :<span class="lineNoCov">          0 :   comXAdj = comXAdj_;</span>
<span class="lineNum">    6651 </span>                :<span class="lineNoCov">          0 : }</span>
<span class="lineNum">    6652 </span>                :            : 
<span class="lineNum">    6653 </span>                :            : 
<a name="6654"><span class="lineNum">    6654 </span>                :            : template &lt;typename Adapter&gt;</a>
<span class="lineNum">    6655 </span>                :            : RCP&lt;typename Zoltan2_AlgMJ&lt;Adapter&gt;::mj_partBoxVector_t&gt;
<span class="lineNum">    6656 </span>                :<span class="lineNoCov">          0 : Zoltan2_AlgMJ&lt;Adapter&gt;::getGlobalBoxBoundaries() const</span>
<span class="lineNum">    6657 </span>                :            : {
<span class="lineNum">    6658 </span>                :<span class="lineNoCov">          0 :   return this-&gt;mj_partitioner.get_kept_boxes();</span>
<span class="lineNum">    6659 </span>                :            : }
<span class="lineNum">    6660 </span>                :            : 
<span class="lineNum">    6661 </span>                :            : 
<span class="lineNum">    6662 </span>                :            : template &lt;typename mj_scalar_t, typename mj_lno_t, typename mj_gno_t,
<a name="6663"><span class="lineNum">    6663 </span>                :            :           typename mj_part_t&gt;</a>
<span class="lineNum">    6664 </span>                :            : RCP&lt;typename AlgMJ&lt;mj_scalar_t,mj_lno_t,mj_gno_t,mj_part_t&gt;::mj_partBoxVector_t&gt;
<span class="lineNum">    6665 </span>                :<span class="lineNoCov">          0 : AlgMJ&lt;mj_scalar_t,mj_lno_t,mj_gno_t,mj_part_t&gt;::get_kept_boxes() const</span>
<span class="lineNum">    6666 </span>                :            : {
<span class="lineNum">    6667 </span>                :<span class="lineNoCov">          0 :   if (this-&gt;mj_keep_part_boxes)</span>
<span class="lineNum">    6668 </span>                :<span class="lineNoCov">          0 :     return this-&gt;kept_boxes;</span>
<span class="lineNum">    6669 </span>                :            :   else
<span class="lineNum">    6670 </span>                :<span class="lineNoCov">          0 :     throw std::logic_error(&quot;Error: part boxes are not stored.&quot;);</span>
<span class="lineNum">    6671 </span>                :            : }
<span class="lineNum">    6672 </span>                :            : 
<span class="lineNum">    6673 </span>                :            : template &lt;typename mj_scalar_t, typename mj_lno_t, typename mj_gno_t,
<a name="6674"><span class="lineNum">    6674 </span>                :            :           typename mj_part_t&gt;</a>
<span class="lineNum">    6675 </span>                :            : RCP&lt;typename AlgMJ&lt;mj_scalar_t,mj_lno_t,mj_gno_t,mj_part_t&gt;::mj_partBoxVector_t&gt;
<span class="lineNum">    6676 </span>                :<span class="lineNoCov">          0 : AlgMJ&lt;mj_scalar_t,mj_lno_t,mj_gno_t,mj_part_t&gt;::compute_global_box_boundaries(</span>
<span class="lineNum">    6677 </span>                :            :   RCP&lt;mj_partBoxVector_t&gt; &amp;localPartBoxes
<span class="lineNum">    6678 </span>                :            : ) const
<span class="lineNum">    6679 </span>                :            : {
<span class="lineNum">    6680 </span>                :<span class="lineNoCov">          0 :   mj_part_t ntasks = this-&gt;num_global_parts;</span>
<span class="lineNum">    6681 </span>                :<span class="lineNoCov">          0 :   int dim = (*localPartBoxes)[0].getDim();</span>
<span class="lineNum">    6682 </span>                :<span class="lineNoCov">          0 :   mj_scalar_t *localPartBoundaries = new mj_scalar_t[ntasks * 2 *dim];</span>
<span class="lineNum">    6683 </span>                :            : 
<span class="lineNum">    6684 </span>                :<span class="lineNoCov">          0 :   memset(localPartBoundaries, 0, sizeof(mj_scalar_t) * ntasks * 2 *dim);</span>
<span class="lineNum">    6685 </span>                :            : 
<span class="lineNum">    6686 </span>                :<span class="lineNoCov">          0 :   mj_scalar_t *globalPartBoundaries = new mj_scalar_t[ntasks * 2 *dim];</span>
<span class="lineNum">    6687 </span>                :<span class="lineNoCov">          0 :   memset(globalPartBoundaries, 0, sizeof(mj_scalar_t) * ntasks * 2 *dim);</span>
<span class="lineNum">    6688 </span>                :            : 
<span class="lineNum">    6689 </span>                :<span class="lineNoCov">          0 :   mj_scalar_t *localPartMins = localPartBoundaries;</span>
<span class="lineNum">    6690 </span>                :<span class="lineNoCov">          0 :   mj_scalar_t *localPartMaxs = localPartBoundaries + ntasks * dim;</span>
<span class="lineNum">    6691 </span>                :            : 
<span class="lineNum">    6692 </span>                :<span class="lineNoCov">          0 :   mj_scalar_t *globalPartMins = globalPartBoundaries;</span>
<span class="lineNum">    6693 </span>                :<span class="lineNoCov">          0 :   mj_scalar_t *globalPartMaxs = globalPartBoundaries + ntasks * dim;</span>
<span class="lineNum">    6694 </span>                :            : 
<span class="lineNum">    6695 </span>                :<span class="lineNoCov">          0 :   mj_part_t boxCount = localPartBoxes-&gt;size();</span>
<span class="lineNum">    6696 </span>                :<span class="lineNoCov">          0 :   for (mj_part_t i = 0; i &lt; boxCount; ++i){</span>
<span class="lineNum">    6697 </span>                :<span class="lineNoCov">          0 :     mj_part_t pId = (*localPartBoxes)[i].getpId();</span>
<span class="lineNum">    6698 </span>                :            :       //cout &lt;&lt; &quot;me:&quot; &lt;&lt; comm-&gt;getRank() &lt;&lt; &quot; has:&quot; &lt;&lt; pId &lt;&lt; endl;
<span class="lineNum">    6699 </span>                :            : 
<span class="lineNum">    6700 </span>                :<span class="lineNoCov">          0 :     mj_scalar_t *lmins = (*localPartBoxes)[i].getlmins();</span>
<span class="lineNum">    6701 </span>                :<span class="lineNoCov">          0 :     mj_scalar_t *lmaxs = (*localPartBoxes)[i].getlmaxs();</span>
<span class="lineNum">    6702 </span>                :            : 
<span class="lineNum">    6703 </span>                :<span class="lineNoCov">          0 :     for (int j = 0; j &lt; dim; ++j){</span>
<span class="lineNum">    6704 </span>                :<span class="lineNoCov">          0 :       localPartMins[dim * pId + j] = lmins[j];</span>
<span class="lineNum">    6705 </span>                :<span class="lineNoCov">          0 :       localPartMaxs[dim * pId + j] = lmaxs[j];</span>
<span class="lineNum">    6706 </span>                :            :       /*
<span class="lineNum">    6707 </span>                :            :       cout &lt;&lt; &quot;me:&quot; &lt;&lt; comm-&gt;getRank()  &lt;&lt;
<span class="lineNum">    6708 </span>                :            :               &quot; dim * pId + j:&quot;&lt;&lt; dim * pId + j &lt;&lt;
<span class="lineNum">    6709 </span>                :            :               &quot; localMin:&quot; &lt;&lt; localPartMins[dim * pId + j] &lt;&lt;
<span class="lineNum">    6710 </span>                :            :               &quot; localMax:&quot; &lt;&lt; localPartMaxs[dim * pId + j] &lt;&lt; endl;
<span class="lineNum">    6711 </span>                :            :       */
<span class="lineNum">    6712 </span>                :            :     }
<span class="lineNum">    6713 </span>                :            :   }
<span class="lineNum">    6714 </span>                :            : 
<span class="lineNum">    6715 </span>                :<span class="lineNoCov">          0 :   Teuchos::Zoltan2_BoxBoundaries&lt;int, mj_scalar_t&gt; reductionOp(ntasks * 2 *dim);</span>
<span class="lineNum">    6716 </span>                :            : 
<span class="lineNum">    6717 </span>                :<span class="lineNoCov">          0 :   reduceAll&lt;int, mj_scalar_t&gt;(*mj_problemComm, reductionOp,</span>
<span class="lineNum">    6718 </span>                :            :             ntasks * 2 *dim, localPartBoundaries, globalPartBoundaries);
<span class="lineNum">    6719 </span>                :<span class="lineNoCov">          0 :   RCP&lt;mj_partBoxVector_t&gt; pB(new mj_partBoxVector_t(),true);</span>
<span class="lineNum">    6720 </span>                :<span class="lineNoCov">          0 :   for (mj_part_t i = 0; i &lt; ntasks; ++i){</span>
<span class="lineNum">    6721 </span>                :            :     Zoltan2::coordinateModelPartBox &lt;mj_scalar_t, mj_part_t&gt; tpb(i, dim,
<span class="lineNum">    6722 </span>                :            :                                                globalPartMins + dim * i,
<span class="lineNum">    6723 </span>                :<span class="lineNoCov">          0 :                                                globalPartMaxs + dim * i);</span>
<span class="lineNum">    6724 </span>                :            : 
<span class="lineNum">    6725 </span>                :            :     /*
<span class="lineNum">    6726 </span>                :            :     for (int j = 0; j &lt; dim; ++j){
<span class="lineNum">    6727 </span>                :            :         cout &lt;&lt; &quot;me:&quot; &lt;&lt; comm-&gt;getRank()  &lt;&lt;
<span class="lineNum">    6728 </span>                :            :                 &quot; dim * pId + j:&quot;&lt;&lt; dim * i + j &lt;&lt;
<span class="lineNum">    6729 </span>                :            :                 &quot; globalMin:&quot; &lt;&lt; globalPartMins[dim * i + j] &lt;&lt;
<span class="lineNum">    6730 </span>                :            :                 &quot; globalMax:&quot; &lt;&lt; globalPartMaxs[dim * i + j] &lt;&lt; endl;
<span class="lineNum">    6731 </span>                :            :     }
<span class="lineNum">    6732 </span>                :            :     */
<span class="lineNum">    6733 </span>                :<span class="lineNoCov">          0 :     pB-&gt;push_back(tpb);</span>
<span class="lineNum">    6734 </span>                :            :   }
<span class="lineNum">    6735 </span>                :<span class="lineNoCov">          0 :   delete []localPartBoundaries;</span>
<span class="lineNum">    6736 </span>                :<span class="lineNoCov">          0 :   delete []globalPartBoundaries;</span>
<span class="lineNum">    6737 </span>                :            :   //RCP &lt;mj_partBoxVector_t&gt; tmpRCPBox(pB, true);
<span class="lineNum">    6738 </span>                :<span class="lineNoCov">          0 :   return pB;</span>
<span class="lineNum">    6739 </span>                :            : }
<span class="lineNum">    6740 </span>                :            : } // namespace Zoltan2
<span class="lineNum">    6741 </span>                :            : 
<span class="lineNum">    6742 </span>                :            : #endif
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.12</a></td></tr>
  </table>
  <br>

</body>
</html>
